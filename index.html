<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yiweiboi.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yiweiBoi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yiweiboi.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/31/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/31/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/" class="post-title-link" itemprop="url">LeetCode-20-有效的括号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-31 16:16:55 / 修改时间：16:44:29" itemprop="dateCreated datePublished" datetime="2024-01-31T16:16:55+08:00">2024-01-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2024/01/31/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/image-20240131161732458.png" class="" title="image-20240131161732458">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; stack;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isLeft</span>(s[i])) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> temp = stack.<span class="built_in">top</span>();</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isMatch</span>(temp, s[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLeft</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(<span class="type">char</span> c1, <span class="type">char</span> c2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c1 == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c2 == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c2 == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="string">&#x27;[&#x27;</span> &amp;&amp; c2 == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li><p>因为一对括号的匹配总是和最近的相邻括号进行，因此利用栈的先进后出的特点可以很方便的解决这个问题</p>
</li>
<li><p><strong>isLeft</strong> 方法检查是否是左括号</p>
</li>
<li><p><strong>isMatch</strong> 方法检查两个括号是否匹配</p>
</li>
<li><p>我们遍历字符串，如果是左括号的话入栈；如果是右括号的话，将栈顶元素 即 最近入栈的左括号 出栈与其进行匹配，如果不匹配，返回 false，如果全部匹配，返回 true</p>
</li>
<li><p>需要注意的是：</p>
<ul>
<li>出栈时，栈可能为空，因此要检查出栈时是否为空，如果为空，则返回 false</li>
<li>循环结束后，也需要检查栈是否为空，即左括号是否全部匹配，如果栈不为空，返回 false</li>
</ul>
</li>
<li><p>改进思路：</p>
<ul>
<li>我们完全可以换一种思路进行匹配，如果是左括号的话，将与其相匹配的右括号入栈；如果是右括号的话，将其和栈顶元素进行比较，如果不相等，则返回 false；这样我们就仅仅通过比较栈顶元素就可以了，会简单很多</li>
<li>当然，在比较右括号和栈顶元素时，栈也可能为空，如果为空，返回 false</li>
<li>全部比较完成后，也需要再次检查栈是否为空，如果不为空，返回 false</li>
<li>实现如下</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果是左括号，将对应的右括号入栈</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>); </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.<span class="built_in">empty</span>() || stack.<span class="built_in">top</span>() != s[i]) &#123; <span class="comment">// 如果是右括号，检查栈是否为空 或 是否和栈顶元素相等</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查栈是否为空</span></span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>Java 代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // 遍历字符串，两个字符两个字符遍历，如果两个字符匹配，则继续遍历</span></span><br><span class="line"><span class="comment">// // 如果两个字符不匹配，则看是否是同向，如果是同向超右的，入栈，如果是同向朝左的，和栈中元素继续匹配</span></span><br><span class="line"><span class="comment">// // 如果是不同向的，说明字符串不合法</span></span><br><span class="line"><span class="comment">// 思路错误...</span></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public boolean isValid(String s) &#123;</span></span><br><span class="line"><span class="comment">//         // 判断是否是奇数个</span></span><br><span class="line"><span class="comment">//         if (s.length() % 2 != 0) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         char[] ch = s.toCharArray();</span></span><br><span class="line"><span class="comment">//         Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         // 遍历字符串</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; ch.length; i += 2) &#123;</span></span><br><span class="line"><span class="comment">//             char c1 = ch[i];</span></span><br><span class="line"><span class="comment">//             char c2 = ch[i + 1];</span></span><br><span class="line"><span class="comment">//             // 如果是同向的</span></span><br><span class="line"><span class="comment">//             if (is_same(c1, c2)) &#123;</span></span><br><span class="line"><span class="comment">//                 // 如果都是向右的</span></span><br><span class="line"><span class="comment">//                 if (is_right(c1, c2)) &#123;</span></span><br><span class="line"><span class="comment">//                     stack.push(c1);</span></span><br><span class="line"><span class="comment">//                     stack.push(c2);</span></span><br><span class="line"><span class="comment">//                 &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                     // 都向左，但栈为空，没有可以匹配的元素</span></span><br><span class="line"><span class="comment">//                     if (stack.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//                         return false;</span></span><br><span class="line"><span class="comment">//                     &#125;</span></span><br><span class="line"><span class="comment">//                     // 都是向左的，判断是否和栈中元素匹配</span></span><br><span class="line"><span class="comment">//                     if (!is_match(stack.pop(), c1) || !is_match(stack.pop(), c2)) &#123;</span></span><br><span class="line"><span class="comment">//                         return false;</span></span><br><span class="line"><span class="comment">//                     &#125;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//             &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                 // 不同向，判断是否匹配</span></span><br><span class="line"><span class="comment">//                 if (!is_match(c1, c2)) &#123;</span></span><br><span class="line"><span class="comment">//                     return false;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         // 如果没有匹配完</span></span><br><span class="line"><span class="comment">//         if (!stack.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return true;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 判断是否都是向右的</span></span><br><span class="line"><span class="comment">//     public boolean is_right(char c1, char c2) &#123;</span></span><br><span class="line"><span class="comment">//         if ((c1 == &#x27;(&#x27; || c1 == &#x27;[&#x27; || c1 == &#x27;&#123;&#x27;) &amp;&amp; (c2 == &#x27;(&#x27; || c2 == &#x27;[&#x27; || c2 == &#x27;&#123;&#x27;)) &#123;</span></span><br><span class="line"><span class="comment">//             return true;</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 判断是否都是向左的</span></span><br><span class="line"><span class="comment">//     public boolean is_left(char c1, char c2) &#123;</span></span><br><span class="line"><span class="comment">//         if ((c1 == &#x27;)&#x27; || c1 == &#x27;]&#x27; || c1 == &#x27;&#125;&#x27;) &amp;&amp; (c2 == &#x27;)&#x27; || c2 == &#x27;]&#x27; || c2 == &#x27;&#125;&#x27;)) &#123;</span></span><br><span class="line"><span class="comment">//             return true;</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 判断是否是同向的</span></span><br><span class="line"><span class="comment">//     public boolean is_same(char c1, char c2) &#123;</span></span><br><span class="line"><span class="comment">//         if (is_left(c1, c2) || is_right(c1, c2)) &#123;</span></span><br><span class="line"><span class="comment">//             return true;</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 判断是否匹配</span></span><br><span class="line"><span class="comment">//     public boolean is_match(char c1, char c2) &#123;</span></span><br><span class="line"><span class="comment">//         if (c1 == &#x27;(&#x27; &amp;&amp; c2 != &#x27;)&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         if (c1 == &#x27;&#123;&#x27; &amp;&amp; c2 != &#x27;&#125;&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         if (c1 == &#x27;[&#x27; &amp;&amp; c2 != &#x27;]&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         if (c1 != &#x27;(&#x27; &amp;&amp; c1 != &#x27;[&#x27; &amp;&amp; c1 != &#x27;&#123;&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return true;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 感觉我是脑瘫</span></span><br><span class="line"><span class="comment">// // 遍历字符串，如果向右，入栈，如果向左，出栈元素进行匹配</span></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public boolean isValid(String s) &#123;</span></span><br><span class="line"><span class="comment">//         // 如果是奇数个</span></span><br><span class="line"><span class="comment">//         if (s.length() % 2 != 0) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         char[] ch = s.toCharArray();</span></span><br><span class="line"><span class="comment">//         Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         // 遍历字符串</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; ch.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//             char c = ch[i];</span></span><br><span class="line"><span class="comment">//             // 如果当前字符向右,入栈</span></span><br><span class="line"><span class="comment">//             if (is_right(c)) &#123;</span></span><br><span class="line"><span class="comment">//                 stack.push(c);</span></span><br><span class="line"><span class="comment">//                 // 如果当前字符向左</span></span><br><span class="line"><span class="comment">//             &#125; else if (is_left(c)) &#123;</span></span><br><span class="line"><span class="comment">//                 // 判断栈是否为空</span></span><br><span class="line"><span class="comment">//                 if (stack.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//                     return false;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 // 判断是否匹配和栈顶元素</span></span><br><span class="line"><span class="comment">//                 if (!is_match(stack.pop(), c)) &#123;</span></span><br><span class="line"><span class="comment">//                     return false;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         // 如果没有匹配完</span></span><br><span class="line"><span class="comment">//         if (!stack.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return true;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 判断是否是向右的</span></span><br><span class="line"><span class="comment">//     public boolean is_right(char c) &#123;</span></span><br><span class="line"><span class="comment">//         if (c == &#x27;(&#x27; || c == &#x27;[&#x27; || c == &#x27;&#123;&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//             return true;</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 判断是否是向左的</span></span><br><span class="line"><span class="comment">//     public boolean is_left(char c) &#123;</span></span><br><span class="line"><span class="comment">//         if (c == &#x27;)&#x27; || c == &#x27;]&#x27; || c == &#x27;&#125;&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//             return true;</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 判断是否匹配</span></span><br><span class="line"><span class="comment">//     public boolean is_match(char c1, char c2) &#123;</span></span><br><span class="line"><span class="comment">//         if (c1 == &#x27;(&#x27; &amp;&amp; c2 != &#x27;)&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         if (c1 == &#x27;&#123;&#x27; &amp;&amp; c2 != &#x27;&#125;&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         if (c1 == &#x27;[&#x27; &amp;&amp; c2 != &#x27;]&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         if (c1 != &#x27;(&#x27; &amp;&amp; c1 != &#x27;[&#x27; &amp;&amp; c1 != &#x27;&#123;&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return true;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更加简洁的写法:</span></span><br><span class="line"><span class="comment">// 遍历字符串，如果是左括号，就将相应的右括号压入栈</span></span><br><span class="line"><span class="comment">// 如果是右括号，弹出栈顶元素判断是否和右括号相等</span></span><br><span class="line"><span class="comment">// 遍历完成后，如果栈为空，说明全部匹配，不为空说明字符串不合法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是奇数个</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 如果是左括号，将相应的右括号压入栈</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是右括号</span></span><br><span class="line">                <span class="comment">// 如果栈不为空，和栈顶元素进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || c != stack.pop()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈为空，说明匹配完成</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/31/LeetCode-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/31/LeetCode-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/" class="post-title-link" itemprop="url">LeetCode-225-用队列实现栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-31 15:41:30 / 修改时间：16:05:05" itemprop="dateCreated datePublished" datetime="2024-01-31T15:41:30+08:00">2024-01-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2024/01/31/LeetCode-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/image-20240131154211821.png" class="" title="image-20240131154211821">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queue1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queue2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = queue1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = queue1.<span class="built_in">front</span>();</span><br><span class="line">            queue2.<span class="built_in">push</span>(temp);</span><br><span class="line">            queue1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> temp = queue1.<span class="built_in">front</span>();</span><br><span class="line">        queue1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        size = queue2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = queue2.<span class="built_in">front</span>();</span><br><span class="line">            queue1.<span class="built_in">push</span>(temp);</span><br><span class="line">            queue2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        queue1.<span class="built_in">push</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li><p>用队列模拟栈的思路和用栈模拟队列的思路很不一样，我们不能再通过什么 输入队列 和 输出队列 来实现栈了，这是因为即使使用两个不同的队列反复翻转，队列中的元素的入队、出队顺序还是一致的</p>
</li>
<li><p>因此，我们就考虑在 <strong>pop</strong> 时，通过一个备用队列，将队列中除去队尾元素全都 pop 到另一个备份队列中，此时，当前队列中就仅剩下队尾元素，而这个元素也正是我们所需要的元素；每次 pop 队尾元素后，再将备份队列中的元素重新 push 到 当前队列中</p>
</li>
<li><p>对于 <strong>push</strong>，我们只是将它简单的 push 到当前队列中即可</p>
</li>
<li><p>对于 <strong>top</strong>，我们还是采用 模拟栈 时的思路，利用 pop 来实现</p>
</li>
<li><p>改进思路：</p>
<ul>
<li><p>对于 push，我们还是简单的将元素 push 到当前队列中</p>
</li>
<li><p>对于 pop，我们在将 备份队列 中元素拷贝到 当前队列 中时，其实并不需要一个一个的 push，因为此时 当前队列 为空，而我们需要的是将 备份队列 中所有元素都拷贝到 当前队列，所以仅仅通过 赋值操作 即可简单实现</p>
<blockquote>
<p>而对于第一个循环，我们需要保留队尾元素，因此不能改变</p>
</blockquote>
</li>
<li><p>对于 top，因为 当前队列 的队尾即为我们模拟栈的栈顶，因此仅通过 back 即可简单实现</p>
</li>
<li><p>实现如下</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queue1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queue2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = queue1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = queue1.<span class="built_in">front</span>();</span><br><span class="line">            queue2.<span class="built_in">push</span>(temp);</span><br><span class="line">            queue1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> temp = queue1.<span class="built_in">front</span>();</span><br><span class="line">        queue1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        size = queue2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            queue2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>其实我们还可以仅仅通过一个队列来模拟栈！<ul>
<li>pop 时，我们将当前队列的 队尾元素 之前的所有元素重新 push 到当前队列中，那么此时的队首元素，即为我们需要的原来的队尾元素了！</li>
<li>实现如下</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = queue.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = queue.<span class="built_in">front</span>();</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">            queue.<span class="built_in">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> temp = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>Java 代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 难点在于如何在同一端进行入栈和出栈</span></span><br><span class="line"><span class="comment">// 当入栈时，先将元素入队列2，再将队列1的所有元素填充到队列2，即添加在新元素后边，再交换队列1，2</span></span><br><span class="line"><span class="comment">// 相当于队列2作为辅助队列，队列1队头就相当于栈顶，每次在对头做增加和删除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="comment">// 将队列一所有元素入队列二</span></span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/31/LeetCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/31/LeetCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">LeetCode-232-用栈实现队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-31 12:21:37 / 修改时间：15:20:18" itemprop="dateCreated datePublished" datetime="2024-01-31T12:21:37+08:00">2024-01-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2024/01/31/LeetCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/image-20240131122318814.png" class="" title="image-20240131122318814">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(stack2, stack1);</span><br><span class="line">        stack1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(stack1, stack2);</span><br><span class="line">        <span class="type">int</span> temp = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(stack1, stack2);</span><br><span class="line">        <span class="keyword">return</span> stack2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.<span class="built_in">empty</span>() &amp;&amp; stack2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(stack&lt;<span class="type">int</span>&gt; &amp;stack1, stack&lt;<span class="type">int</span>&gt; &amp;stack2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> temp = stack1.<span class="built_in">top</span>();</span><br><span class="line">            stack2.<span class="built_in">push</span>(temp);</span><br><span class="line">            stack1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li><p>使用栈模拟队列，至少需要两个栈来实现，一个栈表示 <strong>输出栈</strong>，该栈的 栈顶 表示 队列的 队首，用来 <strong>peek 和 pop</strong>；另一个栈表示 <strong>输入栈</strong>，该栈的栈顶 表示 队尾，用来 <strong>push</strong>；我们通过不断翻转两个栈来实现这样的效果</p>
</li>
<li><p>队列为空 则当且仅当 两个栈 同时为空时 为空</p>
</li>
<li><p>有一点需要注意的是：C++ 中的队列和栈都是 <strong>容器适配器</strong>，仅能使用适配器自己的操作，而不能使用底层容器的操作（stack 底层默认是 deque 实现）</p>
</li>
<li><p>改进思路：</p>
<ul>
<li>其实我们并不需要每次 push 时，都将 输出栈 中的元素翻转到 输入栈 中后，再 push，直接 push 到 输入栈 中即可</li>
<li>而对于 pop 和 peek 来说，因为采用了不同的 push 策略，因此只有当 输出栈 为空时，才需要将 输入栈 中的元素全部翻转到 输出栈中</li>
<li>特别的，对于 peek，采用了 pop 来实现，通过复用减少了重复的代码</li>
<li>实现如下</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1; <span class="comment">// 输入栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2; <span class="comment">// 输出栈</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> temp = stack1.<span class="built_in">top</span>();</span><br><span class="line">                stack2.<span class="built_in">push</span>(temp);</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        stack2.<span class="built_in">push</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.<span class="built_in">empty</span>() &amp;&amp; stack2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>Java 代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack1;</span><br><span class="line">    Deque&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        fillStack();</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        fillStack();</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 当stack1和stack2都为空时，队列才为空</span></span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fillStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果stack2为空</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 将stack1中所有元素放入stack2</span></span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">C++Primer-12-动态内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-29 15:22:21 / 修改时间：22:00:02" itemprop="dateCreated datePublished" datetime="2024-01-29T15:22:21+08:00">2024-01-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="12-动态内存"><a href="#12-动态内存" class="headerlink" title="12 动态内存"></a>12 动态内存</h1><blockquote>
<p>我们的程序之前使用的都是静态内存和栈内存，静态内存（static）和栈内存都是由编译器自动创建和销毁的</p>
<p>每个程序还拥有一个内存池，被称为 <strong>自由空间 或 堆</strong> ，程序用堆来存储 <strong>动态分配</strong> 的对象（程序运行时分配的对象）</p>
<p>动态对象不再使用时，必须显示的销毁它们</p>
</blockquote>
<h2 id="12-1-动态内存和智能指针"><a href="#12-1-动态内存和智能指针" class="headerlink" title="12.1 动态内存和智能指针"></a>12.1 动态内存和智能指针</h2><ul>
<li><p><strong>new</strong>：在冬天太内存中为对象分配空间并返回一个指向该对象的指针</p>
</li>
<li><p><strong>delete</strong>：接受一个动态对象指针，销毁该对象，释放与之关联的内存</p>
<blockquote>
<p>有时我们会忘记释放内存，造成内存泄漏</p>
<p>有时在尚有指针引用内存的情况下我们就释放它们，会产生引用非法内存的指针</p>
</blockquote>
</li>
<li><p>为了更容易、更安全的使用动态内存，标准库提供了 <strong>智能指针</strong></p>
<ul>
<li><strong>shared_ptr</strong>：允许多个指针同时指向同一个对象</li>
<li><strong>unique_ptr</strong>：独占所指向的对象</li>
<li><strong>weak_ptr</strong>：伴随类，是一种弱引用，指向 <strong>shared_ptr</strong> 所管理的对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>这两种智能指针的区别在于管理底层指针的方式不同，且这三种类型都定义在头文件 <strong>memory</strong> 种</p>
</blockquote>
<h3 id="12-1-1-shared-ptr-类"><a href="#12-1-1-shared-ptr-类" class="headerlink" title="12.1.1 shared_ptr 类"></a>12.1.1 shared_ptr 类</h3><ul>
<li>类似的，智能指针也是 <strong>模板</strong> ，因此创建一个智能指针时，必须提供指针可以指向的类型</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129153819459.png" class="" title="image-20240129153819459">

<blockquote>
<p>默认初始化的增长保存着一个空指针</p>
</blockquote>
<ul>
<li>与不同指针类似，解引用一个智能指针返回它指向的对象</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129153958953.png" class="" title="image-20240129153958953">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129154234812.png" class="" title="image-20240129154234812">

<h4 id="make-shared-函数"><a href="#make-shared-函数" class="headerlink" title="make_shared 函数"></a>make_shared 函数</h4><ul>
<li>最安全的分配和使用动态内存的方法是调用一个名为 <strong>make_shared</strong> 的标准库函数<ul>
<li>此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 <strong>shared_ptr</strong></li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129154439313.png" class="" title="image-20240129154439313">

<ul>
<li>make_shared 用其参数来构造给定类型的对象，如果不传递任何参数，对象就会进行值初始化</li>
<li>我们也可以用 <strong>auto</strong> 定义一个对象来保存 make_shared 的结果</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129154659474.png" class="" title="image-20240129154659474">

<h4 id="shared-ptr-的拷贝和赋值"><a href="#shared-ptr-的拷贝和赋值" class="headerlink" title="shared_ptr 的拷贝和赋值"></a>shared_ptr 的拷贝和赋值</h4><ul>
<li>当进项拷贝和赋值操作时，每个 shared_ptr 都会记录有多少个其他 shared_ptr 指向相同的对象<ul>
<li>即每个 shared_ptr 都有一个关联的计数器，通常称为 <strong>计数引用</strong></li>
<li>拷贝一个 shared_ptr（值传递、返回），计数器会增加</li>
<li>销毁一个 shared_ptr（局部对象离开作用域），计数器会递减</li>
<li>一旦一个 shared_ptr 的计数器变为 <strong>0</strong> ，它会自动释放自己所管理的对象</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129155212609.png" class="" title="image-20240129155212609">

<h4 id="shared-ptr-自动销毁所管理的对象"><a href="#shared-ptr-自动销毁所管理的对象" class="headerlink" title="shared_ptr 自动销毁所管理的对象"></a>shared_ptr 自动销毁所管理的对象</h4><ul>
<li>shared_ptr 类会自动销毁此对象，是通过 <strong>析构函数</strong> 所实现的，析构函数会递减它所指向的对象的引用计数，如果计数变为 0，就销毁对象，释放它占用的空间</li>
</ul>
<h4 id="shared-ptr-还会自动释放相关联的内存"><a href="#shared-ptr-还会自动释放相关联的内存" class="headerlink" title="shared_ptr 还会自动释放相关联的内存"></a>shared_ptr 还会自动释放相关联的内存</h4><ul>
<li>动态内对象不再被使用时，shared_ptr 类会自动释放动态对象，这一特性使得动态内存的使用变得容易</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129155818718.png" class="" title="image-20240129155818718">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129155826819.png" class="" title="image-20240129155826819">

<ul>
<li><p>保证 shared_ptr 在无用之后不再被保留非常重要，如果忘记销毁程序不再需要的 shared_ptr，程序仍然会正确执行，但会浪费空间</p>
<blockquote>
<p>比如在 vector 中，shared_ptr 被放在容器里，重排容器后，某些元素不再需要，我们应该确保使用 erase 删除那些不再需要的 shared_ptr 元素</p>
</blockquote>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129160237194.png" class="" title="image-20240129160237194">

<h4 id="使用了动态生存期的资源的类的原因"><a href="#使用了动态生存期的资源的类的原因" class="headerlink" title="使用了动态生存期的资源的类的原因"></a>使用了动态生存期的资源的类的原因</h4><ul>
<li>程序不知道自己需要使用多少对象（使用容器解决）</li>
<li>程序不知道所需对象的准确类型（使用模板解决）</li>
<li>程序需要在多个对象间共享数据（使用 shared_ptr 解决）</li>
</ul>
<blockquote>
<p>使用动态内存的一个常见原因是允许多个对象共享相同的状态</p>
</blockquote>
<h3 id="12-1-2-直接管理内存"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2 直接管理内存"></a>12.1.2 直接管理内存</h3><ul>
<li>相对于智能指针，直接管理内存的类不能依赖于对象的拷贝、赋值和销毁操作的任何默认定义</li>
</ul>
<h4 id="使用-new-动态分配和初始化对象"><a href="#使用-new-动态分配和初始化对象" class="headerlink" title="使用 new 动态分配和初始化对象"></a>使用 new 动态分配和初始化对象</h4><ul>
<li>在自由空间分配的内存都是无名的，因此 <strong>new</strong> 无法为其分配的对象命名，而是返回一个指向该对象的指针、</li>
<li>默认情况下，动态分配的对象都是默认初始化的，这意味着：<ul>
<li>内置类型或组合类型的对象的值将会是 <strong>未定义</strong> 的</li>
<li>类类型对象将用默认构造函数进行初始化</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129161515970.png" class="" title="image-20240129161515970">

<ul>
<li>我们也可以使用 <strong>直接初始化</strong> 的方式来初始化一个动态分配的对象（圆括号、初始化列表）</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129161654333.png" class="" title="image-20240129161654333">

<ul>
<li>也可以对动态分配的对象进行 <strong>值初始化</strong>（在类型名后加空括号即可）</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129161811465.png" class="" title="image-20240129161811465">

<blockquote>
<p>值初始化 和 默认初始化 对内置类型有很大差别，值初始化的内置类型有着良好定义的值</p>
<p>而对于类类型来说就没有意义了，它们总是通过默认构造函数来初始化，而对于类中的内置类型成员，如果未在类内被初始化，则它们的值也是未定义的</p>
</blockquote>
<ul>
<li>对于一个括号包围的初始化器，可以使用 <strong>auto</strong> 来从初始化器推断我们想要分配的对象的类型，但仅当括号中仅有 <strong>单一</strong> 的初始化器时才可以使用 auto</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129162456162.png" class="" title="image-20240129162456162">

<h4 id="动态分配的-const-对象"><a href="#动态分配的-const-对象" class="headerlink" title="动态分配的 const 对象"></a>动态分配的 const 对象</h4><ul>
<li>类似的，一个动态分配的 const 对象必须进行初始化，且由于分配的对象是 const 的，new 返回的指针是一个指向 const 的指针</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129162627102.png" class="" title="image-20240129162627102">

<h4 id="内存耗尽"><a href="#内存耗尽" class="headerlink" title="内存耗尽"></a>内存耗尽</h4><ul>
<li>当一个程序用光它所有可用的内存，new 表达式就会失败，默认情况下，会抛出一个类型为 <strong>bad_alloc</strong> 的异常，我们可以改变使用 new 的方式来阻止它抛出异常</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129162852836.png" class="" title="image-20240129162852836">

<ul>
<li>上方这种形式的 new 称为 <strong>定位 new</strong>，我们传递给它一个标准库定义的名为 <strong>nothrow</strong> 的对象，意图是告诉它不能抛出异常，如果这种形式的 new 不能分配所需内存，它会返回一个 <strong>空指针</strong></li>
</ul>
<h4 id="释放动态内存"><a href="#释放动态内存" class="headerlink" title="释放动态内存"></a>释放动态内存</h4><ul>
<li><strong>delete</strong> 表达式接受一个指针，指向我们想要释放的对象</li>
<li>和 new 类似，delete 表达式执行两个步骤：销毁给定对象，释放对应的内存</li>
</ul>
<h4 id="指针值和-delete"><a href="#指针值和-delete" class="headerlink" title="指针值和 delete"></a>指针值和 delete</h4><ul>
<li>传递给 delete 的指针必须指向 <strong>动态分配的内存</strong>，或者是一个 <strong>空指针</strong></li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129163806576.png" class="" title="image-20240129163806576">

<blockquote>
<p>通常情况下，编译器不能分辨一个真正指向的 静态 还是 动态 分配的对象</p>
<p>类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放</p>
<p>对于这些 delete 表达式，大多数编译器通过，尽管它们是错误的</p>
</blockquote>
<ul>
<li>一个 const 对象的值不能被改变，但它本身可以被销毁</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129164120773.png" class="" title="image-20240129164120773">

<h4 id="动态对象的生存期直到被释放时为止"><a href="#动态对象的生存期直到被释放时为止" class="headerlink" title="动态对象的生存期直到被释放时为止"></a>动态对象的生存期直到被释放时为止</h4><ul>
<li>由 shared_ptr 管理的内存在最后一个 shared_ptr 销毁时会被自动释放</li>
<li>而对于通过内置指针类型来管理的动态对象，直到被 <strong>显示释放</strong> 之前它都是存在的（因此调用者必须记得释放内存）</li>
</ul>
<h4 id="使用-new-和-delete-管理动态内存的三个常见问题"><a href="#使用-new-和-delete-管理动态内存的三个常见问题" class="headerlink" title="使用 new 和 delete 管理动态内存的三个常见问题"></a>使用 new 和 delete 管理动态内存的三个常见问题</h4><ul>
<li><p>忘记 delete 内存，导致 <strong>内存泄漏</strong> 问题， 查找困难</p>
</li>
<li><p>使用已经释放的对象</p>
</li>
<li><p>同一块内存释放两次</p>
<blockquote>
<p>坚持只使用智能指针，就可以避免所有这些问题</p>
</blockquote>
</li>
</ul>
<h4 id="delete-之后重置指针值"><a href="#delete-之后重置指针值" class="headerlink" title="delete 之后重置指针值"></a>delete 之后重置指针值</h4><ul>
<li>当我们 delete 一个指针后，指针值就变为无效了，即 <strong>空悬指针</strong>，指向一块曾经保存数据对象但现在已经无效的内存的指针</li>
<li>我们可以在 delete 之后将 <strong>nullptr</strong> 赋予指针来避免使用空悬指针</li>
</ul>
<h4 id="这只是提供了有限的保护"><a href="#这只是提供了有限的保护" class="headerlink" title="这只是提供了有限的保护"></a>这只是提供了有限的保护</h4><ul>
<li>delete 之后重置指针值的方法只是对这个指针有效，对于其他任何仍然指向（已释放）内存的指针是没有用的</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129165601535.png" class="" title="image-20240129165601535">

<h3 id="12-1-3-shared-ptr-和-new-结合使用"><a href="#12-1-3-shared-ptr-和-new-结合使用" class="headerlink" title="12.1.3 shared_ptr 和 new 结合使用"></a>12.1.3 shared_ptr 和 new 结合使用</h3><ul>
<li>我们还可以使用 new 返回的指针来初始化智能指针</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129165815575.png" class="" title="image-20240129165815575">

<ul>
<li>我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129165922694.png" class="" title="image-20240129165922694">

<blockquote>
<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用 delete 释放它所关联的对象</p>
<p>我们也可以智能指针绑定到一个指向其他资源的指针上，但必须提供自己的操作来替代 delete</p>
</blockquote>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170206001.png" class="" title="image-20240129170206001">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170216568.png" class="" title="image-20240129170216568">

<h4 id="不要混合使用普通指针和智能指针"><a href="#不要混合使用普通指针和智能指针" class="headerlink" title="不要混合使用普通指针和智能指针"></a>不要混合使用普通指针和智能指针</h4><img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170430745.png" class="" title="image-20240129170430745">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170440765.png" class="" title="image-20240129170440765">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170450208.png" class="" title="image-20240129170450208">

<ul>
<li>一旦我们将一个 shared_ptr 绑定到一个普通指针时，我们就将内存的管理责任交给这个 shared_ptr，我们就不应该再使用内置指针来访问 shared_ptr 所指向的内存了</li>
</ul>
<blockquote>
<p>使用内置指针来访问智能指针所负责的对象是很危险的，因为我们不知道对象何时被销毁</p>
</blockquote>
<h4 id="不要使用-get-初始化另一个智能指针或为智能指针赋值"><a href="#不要使用-get-初始化另一个智能指针或为智能指针赋值" class="headerlink" title="不要使用 get 初始化另一个智能指针或为智能指针赋值"></a>不要使用 get 初始化另一个智能指针或为智能指针赋值</h4><ul>
<li><p>智能指针类型的 get 函数，返回一个内置指针，指向智能指针管理的对象</p>
<ul>
<li>该函数是为 我们需要向不能使用智能指针的代码传递一个内置指针 而设计的</li>
<li>使用 get 返回的指针的代码不能 delete 此指针</li>
</ul>
</li>
<li><p>而将另一个智能指针也绑定到 get 返回的指针上是错误的（即使编译器不会给出错误信息）</p>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171136503.png" class="" title="image-20240129171136503">

<h4 id="其他-shared-ptr-操作"><a href="#其他-shared-ptr-操作" class="headerlink" title="其他 shared_ptr 操作"></a>其他 shared_ptr 操作</h4><ul>
<li>我们可以用 <strong>reset</strong> 将一个新的指针赋予一个 shared_ptr <ul>
<li>和赋值类似，reset 会更新引用计数，如果需要的话，会释放原来所指对象（计数为 0 时）</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171504149.png" class="" title="image-20240129171504149">

<ul>
<li>reset 常与 unique 一起使用，来控制多个 shared_ptr 共享的对象</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171514132.png" class="" title="image-20240129171514132">

<h3 id="12-1-4-智能指针和异常"><a href="#12-1-4-智能指针和异常" class="headerlink" title="12.1.4 智能指针和异常"></a>12.1.4 智能指针和异常</h3><ul>
<li>如果使用智能指针，即使程序块过早结束，智能指针类也能确保内存不再需要时将其释放</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171852797.png" class="" title="image-20240129171852797">

<ul>
<li>与之相对的，当发生异常时，我们直接管理的内存是不会自动释放的，即如果在 new 和 delete 之间发生异常，且异常未在当前函数中被捕获，则内存就永远不会被释放</li>
</ul>
<h4 id="智能指针和哑类"><a href="#智能指针和哑类" class="headerlink" title="智能指针和哑类"></a>智能指针和哑类</h4><ul>
<li>所有标准库在内的很多 C++ 类都定义了析构函数，但部署所有类都是这样良好定义的，特别是那些为 C 和 C++ 两种语言设计的类，通常要求用户显示的释放所有使用的任何资源</li>
<li>程序员忘记释放资源、在资源分配和释放之间发生了异常时，程序常常会发生资源泄漏</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129173708453.png" class="" title="image-20240129173708453">

<ul>
<li>可以使用 shared_ptr 来保证资源的正确释放</li>
</ul>
<h4 id="使用我们自己的释放操作"><a href="#使用我们自己的释放操作" class="headerlink" title="使用我们自己的释放操作"></a>使用我们自己的释放操作</h4><ul>
<li>默认情况下，shared_ptr 假定它指向的是动态内存，因此一个 shared_ptr 销毁时，默认对它管理的指针进行 delete 操作</li>
<li>我们可以定义一个 <strong>删除器（函数）</strong> 来代替 delete</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129174136618.png" class="" title="image-20240129174136618">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129174145963.png" class="" title="image-20240129174145963">

<ul>
<li>当指针被销毁时（即使发生异常也可会被销毁），调用的是我们自定义的函数，而不是 delete</li>
</ul>
<h4 id="智能指针陷阱"><a href="#智能指针陷阱" class="headerlink" title="智能指针陷阱"></a>智能指针陷阱</h4><img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129174350617.png" class="" title="image-20240129174350617">

<h3 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h3><ul>
<li>某个时刻一个 unique_ptr 只能指向一个给定对象，当 unique_ptr 被销毁时，它所指向的对象也被销毁</li>
<li>当我们定义一个 unique_ptr 时，需要将器绑定到一个 new 返回的指针上，初始化 unique_ptr 必须采用 <strong>直接初始化的形式</strong></li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180236825.png" class="" title="image-20240129180236825">

<ul>
<li>unique_ptr 不支持普通的拷贝和辅助操作</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180308421.png" class="" title="image-20240129180308421">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180334373.png" class="" title="image-20240129180334373">

<ul>
<li><p><strong>release</strong> 成员返回 unique_ptr 当前保存的指针并将其置为空</p>
<ul>
<li><p>release 会切断 unique_ptr 和它原来管理的对象间的联系，返回的指针常用来初始化另一个智能指针或给另一个智能指针赋值</p>
</li>
<li><p>如果我们不用另一个智能指针来保存 release 返回的指针，则我们的程序需要负责资源的释放</p>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180806421.png" class="" title="image-20240129180806421"></li>
</ul>
</li>
<li><p><strong>reset</strong> 成员接受一个可选的指针参数，令 unique_ptr 重新指向给定的指针，如果 unique_ptr 不为空，释放原来指向对象</p>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180840084.png" class="" title="image-20240129180840084">

<h4 id="传递-unique-ptr-参数和返回-unique-ptr"><a href="#传递-unique-ptr-参数和返回-unique-ptr" class="headerlink" title="传递 unique_ptr 参数和返回 unique_ptr"></a>传递 unique_ptr 参数和返回 unique_ptr</h4><ul>
<li>不能拷贝 unique_ptr 有一个例外：可以拷贝或赋值一个将要被销毁的 unique_ptr</li>
<li>编译器知道要返回的对象是将要被销毁的，编译器会执行一种特殊的 拷贝</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129181057275.png" class="" title="image-20240129181057275">

<blockquote>
<p>标准库较早的版本包含了一个名为 auto_ptr 的类，它有 unique_ptr 的部分功能</p>
<p>特别的，我们不能容器中保存 auto_ptr，也不能从函数中返回 auto_ptr</p>
<p>编写程序时应该使用 unique_ptr，而不是 auto_ptr</p>
</blockquote>
<h4 id="向-unique-ptr-传递删除器"><a href="#向-unique-ptr-传递删除器" class="headerlink" title="向 unique_ptr 传递删除器"></a>向 unique_ptr 传递删除器</h4><ul>
<li>类似的，默认情况下，unique_ptr 也使用 delete 释放它所指向的对象</li>
<li>和 shared_ptr 不同的是，重载一个 unique_ptr 的删除器时，我们必须在尖括号中提供删除器的类型，且在创建或 reset 一个这种 unique_ptr 类型的对象时，必须提供一个指定类型的可调用对象（删除器）</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129181610928.png" class="" title="image-20240129181610928">

<h3 id="12-1-6-weak-ptr"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr</h3><ul>
<li>weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向由一个 shared_ptr 管理的对象<ul>
<li>它不会改变所绑定的 shared_ptr 的引用计数</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129202140397.png" class="" title="image-20240129202140397">

<ul>
<li>当我们创建一个 weak_ptr 时，要用一个 shared_ptr 来初始化它</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129202226704.png" class="" title="image-20240129202226704">

<ul>
<li>由于对象可能不存在，我们不能使用 weak_ptr 直接访问对象，而必须使用 lock 函数<ul>
<li>如果对象存在，lock 返回一个指向共享对象的 shared_ptr</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129202355424.png" class="" title="image-20240129202355424">

<ul>
<li>通过使用 weak_ptr，不会影响一个给定的 shared_ptr 的生存周期，但可以阻止用户访问一个可能不再存在的对象</li>
</ul>
<h2 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h2><blockquote>
<p>为了支持这种需求，C++ 语言和标准库提供了两种一次分配一个对象数组的方法</p>
<p>C++ 语言定义了另一种 new 表达式语法，可以分配并初始化一个对象数组</p>
<p>标准库中包含一个名为 <strong>allocator</strong> 的类，允许我们将分配和初始化分离，使用 allocator 通常会提供更好的性能和更灵活的内存管理能力</p>
</blockquote>
<h3 id="12-2-1-new-和数组"><a href="#12-2-1-new-和数组" class="headerlink" title="12.2.1 new 和数组"></a>12.2.1 new 和数组</h3><ul>
<li>为了让 new 分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129205243652.png" class="" title="image-20240129205243652">

<blockquote>
<p>方括号中的大小必须是整型，但不必是常量</p>
</blockquote>
<ul>
<li>也可以使用一个表示数组类型的类型别名来分配一个数组</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129205359868.png" class="" title="image-20240129205359868">

<h4 id="分配一个数组会得到一个元素类型的指针"><a href="#分配一个数组会得到一个元素类型的指针" class="headerlink" title="分配一个数组会得到一个元素类型的指针"></a>分配一个数组会得到一个元素类型的指针</h4><blockquote>
<p>虽然我们通常称 new T[ ] 分配的内存为 <strong>动态数组</strong>，但这种叫法有一定的误导性</p>
</blockquote>
<ul>
<li>当用 new 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针<ul>
<li>由于得到的并不是一个数组类型，因此不能对动态数组调用 <strong>begin 和 end</strong>（这些函数使用数组的维度）</li>
<li>也不能使用 <strong>范围 for</strong> 语句来处理动态数组中的元素</li>
</ul>
</li>
</ul>
<h4 id="初始化动态分配对象的数组"><a href="#初始化动态分配对象的数组" class="headerlink" title="初始化动态分配对象的数组"></a>初始化动态分配对象的数组</h4><ul>
<li>默认情况下，new 分配的对象无论是单个分配还是数组中的，都是默认初始化</li>
<li>可以通过在大小后跟一对空括号来进行值初始化</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129205910027.png" class="" title="image-20240129205910027">

<ul>
<li>还可以提供一个元素初始化器的花括号列表进行初始化</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129210001004.png" class="" title="image-20240129210001004">

<blockquote>
<p>如果初始化器数目大于元素数目，则 new 表达式失败，不会分配任何内存，抛出一个类型为 bad_array_new_length 的异常</p>
</blockquote>
<h4 id="动态分配一个空数组是合法的"><a href="#动态分配一个空数组是合法的" class="headerlink" title="动态分配一个空数组是合法的"></a>动态分配一个空数组是合法的</h4><ul>
<li>当我们用 new 分配一个大小为 0 的数组时，new 返回一个合法的非空指针，此指针与 new 返回的其他任何指针都不同<ul>
<li>此指针就像尾后指针一样，我们可以像使用尾后指针一样使用它，不能解引用</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129210353845.png" class="" title="image-20240129210353845">

<h4 id="释放动态数组"><a href="#释放动态数组" class="headerlink" title="释放动态数组"></a>释放动态数组</h4><ul>
<li>为了释放动态数组，我们使用一种特殊形式的 delete，在指针前加上一个空方括号</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129210504615.png" class="" title="image-20240129210504615">

<ul>
<li>数组中的元素是按照逆序来进行销毁的</li>
<li>当释放一个指向数组的指针时，方括号是必须的，它指示编译器此指针指向一个对象数组的第一个元素</li>
</ul>
<blockquote>
<p>delete 一个数组忘记加方括号，或者 delete 一个单一对象的指针时使用了方括号，编译器可能不会给出警告</p>
</blockquote>
<h4 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h4><ul>
<li>为了用一个 <strong>unique_ptr</strong> 管理动态数组，我们必须在对象类型后面跟一对空方括号</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211032929.png" class="" title="image-20240129211032929">

<ul>
<li>当一个 unique_ptr 指向一个数组时，我们不能使用 <strong>点和箭头</strong> 成员运算符，我们可以使用 <strong>下标</strong> 运算符来访问数组中的元素</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211222606.png" class="" title="image-20240129211222606">

<ul>
<li>shared_ptr 并不直接支持管理动态数组，如果希望使用 shared_ptr 管理一个动态数组，必须提供自定义的删除器<ul>
<li>因为默认情况下使用 delete，会造成错误</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211336894.png" class="" title="image-20240129211336894">

<ul>
<li>且 shared_ptr 未定义下标运算符，且智能指针不支持指针算术运算，为了访问数组中的元素，必须通过 get 获取一个内置指针</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211608651.png" class="" title="image-20240129211608651">

<h3 id="12-2-2-allocator-类"><a href="#12-2-2-allocator-类" class="headerlink" title="12.2.2 allocator 类"></a>12.2.2 allocator 类</h3><ul>
<li>new 有一些灵活性上的局限，它将内存分配和对象构造组合在了一起<ul>
<li>一般情况下，将内存分配和对象构造组合在一起可能导致不必要的浪费</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214150987.png" class="" title="image-20240129214150987">

<blockquote>
<p>new 表达式分配并初始化了 n 个 string，但我们可能并不需要 n 个 string，且对于每个使用到的元素，都被赋值了两次，一次默认初始化，一次赋值</p>
<p>更重要的是，对于没有默认构造函数的类就不能动态分配数组</p>
</blockquote>
<h4 id="allocator-类"><a href="#allocator-类" class="headerlink" title="allocator 类"></a>allocator 类</h4><ul>
<li>它帮助我们将内存分配和对象构造分离开来，提供了一种类型感知的内存分配方法，<strong>它分配的内存是原始的、未构造的</strong></li>
<li>allocator 也是一个模板，定义时必须指明它可以分配的对象类型</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214125266.png" class="" title="image-20240129214125266">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214541210.png" class="" title="image-20240129214541210">

<h4 id="allocator-分配未构造的内存"><a href="#allocator-分配未构造的内存" class="headerlink" title="allocator 分配未构造的内存"></a>allocator 分配未构造的内存</h4><ul>
<li><strong>allocate</strong> 函数分配的内存是未构造的</li>
<li><strong>construct</strong> 函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素，额外参数用来初始化构造的对象</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214849723.png" class="" title="image-20240129214849723">

<ul>
<li>还未构造对象的情况下就使用原始内存是错误的、未定义的</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214932308.png" class="" title="image-20240129214932308">

<ul>
<li><p>当我们用完对象后，必须对每个构造的原始调用 <strong>destory</strong> 来销毁它们</p>
<ul>
<li><p>destory 函数接受一个真正，对指向的对象执行析构函数</p>
<blockquote>
<p>我们只能对真正构造了的元素进行 destory 操作</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129215107537.png" class="" title="image-20240129215107537">

<ul>
<li>一旦一个元素被销毁后，就可以重新使用这部分内存来保存其他对象，也可以将其归还给系统<ul>
<li>释放内存通过调用 <strong>deallocate</strong> 来完成</li>
<li>传递给 deallocate 的指针不能为空，且它必须指向由 allocate 分配的内存</li>
<li>且传递给 deallocate 的大小参数必须与调用 allocate 分配内存时提供的大小参数一样</li>
</ul>
</li>
</ul>
<h4 id="拷贝和填充未初始化内存的算法"><a href="#拷贝和填充未初始化内存的算法" class="headerlink" title="拷贝和填充未初始化内存的算法"></a>拷贝和填充未初始化内存的算法</h4><ul>
<li>标准库还为 allocator 类定义了两个伴随算法，可以在未初始化内存中创建对象</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129215620978.png" class="" title="image-20240129215620978">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129215643466.png" class="" title="image-20240129215643466">

<ul>
<li>类似 copy，uninitialized_copy 返回一个指针，指向最后一个构造的元素之后的位置</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">C++Primer-10-泛型算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-20 09:13:45 / 修改时间：17:46:24" itemprop="dateCreated datePublished" datetime="2024-01-20T09:13:45+08:00">2024-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="10-泛型算法"><a href="#10-泛型算法" class="headerlink" title="10 泛型算法"></a>10 泛型算法</h1><blockquote>
<p>顺序容器只定义了很少的操作，用户可能还做一些其他很有用的操作，标准库并未给每个容器都定义成员函数来实现它们，而是定义了一组 <strong>泛型算法</strong></p>
<p><strong>算法</strong> 是因为它们实现了一些经典算法的公共接口，<strong>泛型</strong> 是因为它们可以用于不同类型的元素和多种容器类型</p>
</blockquote>
<h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><blockquote>
<p>大多数算法都定义在头文件 <strong>algorithm</strong> 中，标准库还在头文件 <strong>numeric</strong> 中定义了一组数值泛型算法</p>
<p>一般情况下，算法并不直接操作容器，而是遍历由两个迭代器指定的一个容器范围来进行操作</p>
</blockquote>
<h4 id="迭代器令算法不依赖于容器"><a href="#迭代器令算法不依赖于容器" class="headerlink" title="迭代器令算法不依赖于容器"></a>迭代器令算法不依赖于容器</h4><ul>
<li><strong>find</strong> 算法的前两个参数表示元素范围的迭代器，第三个参数是一个值，返回第一个指向等于给定值的元素的迭代器<ul>
<li>如果没有匹配，则 find 返回第二个参数表示搜索失败，所以我们可以比较返回值和第二个参数判断是否成功</li>
<li>完成算法中的这些步骤都不依赖于容器所保存的元素类型</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095429785.png" class="" title="image-20240120095429785">

<h4 id="但算法依赖于元素类型的操作"><a href="#但算法依赖于元素类型的操作" class="headerlink" title="但算法依赖于元素类型的操作"></a>但算法依赖于元素类型的操作</h4><ul>
<li>虽然迭代器的使用令算法不依赖容器类型，但大多数算法都使用了一个或多个元素类型上的操作</li>
</ul>
<blockquote>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器上，执行迭代器的操作</p>
<p>这个特性带来了一个非常必要的编程假定：算法永远不会改变底层容器的大小</p>
</blockquote>
<h2 id="10-2-初始泛型算法"><a href="#10-2-初始泛型算法" class="headerlink" title="10.2 初始泛型算法"></a>10.2 初始泛型算法</h2><blockquote>
<p>除了少数例外，标准库算法都对一个范围内的元素进行操作，这个元素范围称为 <strong>输入范围</strong></p>
<p>虽然大多数算法遍历输入范围的方式类似，但它们使用范围中元素的方式不同</p>
</blockquote>
<h3 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法</h3><ul>
<li><p>只读取输入范围的元素，而不改变元素</p>
</li>
<li><p>find 就是一种只读算法，另一个只读算法是 <strong>accumulate</strong>，定义在头文件 numeric 中</p>
<ul>
<li><p>接受三个参数，前两个指出需要 <strong>求和</strong> 的范围，第三个参数是和的初始值</p>
<blockquote>
<p>accumulate 的第三个参数的类型决定了函数中使用哪个加法运算符及返回值的类型</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120094024649.png" class="" title="image-20240120094024649">

<blockquote>
<p>对于只读算法，通常最好使用 cbegin 和 cend</p>
</blockquote>
<h4 id="操作两个序列的算法"><a href="#操作两个序列的算法" class="headerlink" title="操作两个序列的算法"></a>操作两个序列的算法</h4><ul>
<li><p>另一个只读算法是 <strong>equal</strong>，用于确定两个序列算法保存相同的值</p>
<ul>
<li><p>接受三个迭代器，前两个表示输入范围，第三个表示第二个序列的首元素</p>
</li>
<li><p>它将第一个序列中每个元素于第二个序列中对应元素进行比较，都相等返回 true，否则返回 false</p>
<blockquote>
<p>equal 基于一个非常重要的 <strong>假设</strong>：第二个序列至少于第一个序列一样长</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095507828.png" class="" title="image-20240120095507828">

<blockquote>
<p>那些只接受一个单一迭代器表示第二个序列的算法，都假定第二个序列至少于第一个序列一样长</p>
</blockquote>
<h3 id="10-2-2-写容器元素的算法"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a>10.2.2 写容器元素的算法</h3><ul>
<li><p>这类算法要求原序列大小至少不小于我们要求算法写入的元素数目（因此它们最多写入和给定序列一样多的元素）</p>
</li>
<li><p><strong>fill</strong> 算法接受一对迭代器参数表示范围，还接受一个值作为第三个参数，将给定值赋予输入序列中的每个元素</p>
<blockquote>
<p>因此 fill 算法很安全，只要确保传递了一个有效的输入序列</p>
</blockquote>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095532562.png" class="" title="image-20240120095532562">

<h4 id="算法不检查写操作"><a href="#算法不检查写操作" class="headerlink" title="算法不检查写操作"></a>算法不检查写操作</h4><ul>
<li><p>一些算法只接受一个迭代器来指出一个单独的目的位置</p>
</li>
<li><p><strong>fill_n</strong> 函数接受一个单迭代器、一个计数器和一个值，它将给定值赋予迭代器指向的元素开始的指定个元素</p>
<blockquote>
<p>full_n 假定：dest 指向一个元素，而从 dest 开始的序列至少包含 n 个元素</p>
</blockquote>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095605020.png" class="" title="image-20240120095605020">

<blockquote>
<p>一个很容易犯的 <strong>错误</strong> 就是：在一个空容器上调用 fill_n</p>
<p>向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素</p>
</blockquote>
<h4 id="介绍-back-inserter"><a href="#介绍-back-inserter" class="headerlink" title="介绍 back_inserter"></a>介绍 back_inserter</h4><ul>
<li><p>一种保证算法有足够空间来容纳输入数据的方法是使用 <strong>插入迭代器</strong></p>
<ul>
<li>一般情况下，我们通过一个迭代器向容器赋值时，值被赋予迭代器指向的元素</li>
<li>而当我们通过一个插入迭代器赋值时，一个值相等的新元素被添加到容器中</li>
</ul>
</li>
<li><p><strong>back_inserter</strong> 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器</p>
<ul>
<li>当我们通过它赋值时，赋值运算符会调用 <strong>push_back</strong> 将一个给定值元素加入容器</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100204810.png" class="" title="image-20240120100204810">

<ul>
<li>我们通常将插入迭代器作为算法的 <strong>目的位置</strong> 来使用</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100247186.png" class="" title="image-20240120100247186">

<h4 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h4><ul>
<li>拷贝算法也是向 目的位置迭代器 指向的输入序列 中的元素 写入数据的算法<ul>
<li>接受三个迭代器，前两个表示输入范围，第三个表示目的序列的起始位置</li>
<li>将输入范围中的元素拷贝到目的序列中</li>
<li>因此，目的序列至少包含于输入序列一样多的元素</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100846520.png" class="" title="image-20240120100846520">

<ul>
<li><p>很多算法都提供了 <strong>拷贝版本</strong>，它们不会改变原序列，而是创建一个新的序列保存这些结果</p>
<ul>
<li><p><strong>replace</strong> 接受 4 个参数，前两个是输入序列，后两个一个是要搜索的值，一个是要替换的新值</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101225937.png" class="" title="image-20240120101225937">
</li>
<li><p><strong>replace_copy</strong> 接受额外的一个迭代器参数，指出调整后序列的保存位置</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101333789.png" class="" title="image-20240120101333789"></li>
</ul>
</li>
</ul>
<h3 id="10-2-3-重排容器元素的算法"><a href="#10-2-3-重排容器元素的算法" class="headerlink" title="10.2.3 重排容器元素的算法"></a>10.2.3 重排容器元素的算法</h3><ul>
<li><strong>sort</strong> 算法是利用元素类型的 <strong>&lt; 运算符</strong> 来实现排序的</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102044011.png" class="" title="image-20240120102044011">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102109934.png" class="" title="image-20240120102109934">

<blockquote>
<p>算法并不能执行容器操作，所以使用 vector 的 erase 来完成真正的删除操作</p>
</blockquote>
<h4 id="消除重复元素"><a href="#消除重复元素" class="headerlink" title="消除重复元素"></a>消除重复元素</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101657896.png" class="" title="image-20240120101657896">

<h4 id="使用-unique"><a href="#使用-unique" class="headerlink" title="使用 unique"></a>使用 unique</h4><ul>
<li><strong>unique</strong> 算法重排输入序列，将相邻的重复项 <strong>“消除”</strong>，并返回一个指向不重复范围末尾的迭代器</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102131214.png" class="" title="image-20240120102131214">

<h4 id="使用容器操作删除元素"><a href="#使用容器操作删除元素" class="headerlink" title="使用容器操作删除元素"></a>使用容器操作删除元素</h4><h2 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h2><blockquote>
<p>很多算法都会比较输入序列，默认情况下，这类算法使用元素类型的 <strong>&lt; 或 &#x3D;&#x3D; 运算符</strong> 完成比较</p>
<p>标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符</p>
</blockquote>
<h3 id="10-3-1-向算法传递函数"><a href="#10-3-1-向算法传递函数" class="headerlink" title="10.3.1 向算法传递函数"></a>10.3.1 向算法传递函数</h3><ul>
<li><strong>sort</strong> 的第二个版本，接受一个额外的参数，此参数是一个 <strong>谓词</strong></li>
</ul>
<h4 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h4><ul>
<li>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值，谓词又分为两类：<ul>
<li><strong>一元谓词</strong> 只能接受一个参数，<strong>二元谓词</strong> 有两个参数</li>
<li>接受谓词参数的算法，对输入序列中的元素调用谓词，因此元素类型必须能转换为谓词的参数类型</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103050597.png" class="" title="image-20240120103050597">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103100877.png" class="" title="image-20240120103100877">

<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><ul>
<li><strong>stable_sort</strong> 算法，这种 <strong>稳定</strong> 排序算法维持相等元素的原有顺序</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103241249.png" class="" title="image-20240120103241249">

<blockquote>
<p>通常情况下，我们不关心有序序列中相等元素的相对顺序，但在这个例子中，我们将 <strong>相等</strong> 定义为了 <strong>具有相同长度</strong></p>
</blockquote>
<h3 id="10-3-2-lambda-表达式"><a href="#10-3-2-lambda-表达式" class="headerlink" title="10.3.2 lambda 表达式"></a>10.3.2 lambda 表达式</h3><h4 id="介绍-lambda"><a href="#介绍-lambda" class="headerlink" title="介绍 lambda"></a>介绍 lambda</h4><ul>
<li><p>我们可以向一个算法传递任何类别的 <strong>可调用对象</strong>，对于一个对象或一个表达式，如果可以对其使用 <strong>（）调用运算符</strong>，则称它为可调用的</p>
</li>
<li><p>可调用对象有 4 种：函数、函数指针、重载了函数调用运算符的类、<strong>lambda 表达式</strong></p>
</li>
<li><p>一个 lambda 表达式表示一个可调用的代码单元</p>
<ul>
<li><p>具有一个返回类型，一个参数列表、一个函数体</p>
</li>
<li><p>与函数不同的是，lambda 可以定义在函数内部，形式如下：</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104014949.png" class="" title="image-20240120104014949">

<ul>
<li><strong>capture list（捕获列表）</strong>是一个 lambda 所在函数种定义的局部遍历的列表（通常为空）</li>
<li><strong>return type、parameter list 和 function body</strong> 分别表示返回类型、参数类别和函数体</li>
<li>不同的是，lambda 必须使用尾置返回来指定返回类型</li>
</ul>
</li>
</ul>
</li>
<li><p>我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104347020.png" class="" title="image-20240120104347020">

<blockquote>
<p>lambda 中忽略括号和参数列表等价于指定一个空参数列表</p>
<p>如果忽略返回类型，则 lambda 根据函数体中的代码推断出返回类型</p>
<p>如果函数体只是一个 return 语句，返回类型可以推测，否则忽略返回类型的话，返回类型为 void</p>
</blockquote>
<ul>
<li>lambda 的调用方式和普通函数一样，都使用调用运算符</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104423846.png" class="" title="image-20240120104423846">

<h4 id="向-lambda-传递参数"><a href="#向-lambda-传递参数" class="headerlink" title="向 lambda 传递参数"></a>向 lambda 传递参数</h4><ul>
<li>lambda 不能有默认参数，因此 lambda 的调用的实参数目永远与形参数目相等</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104841160.png" class="" title="image-20240120104841160">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104849527.png" class="" title="image-20240120104849527">

<h4 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h4><ul>
<li>lambda 通过将局部遍历包含在其捕获列表中来指出将会使用这些变量</li>
</ul>
<h4 id="调用-find-if"><a href="#调用-find-if" class="headerlink" title="调用 find_if"></a>调用 find_if</h4><ul>
<li><strong>find_if</strong> 算法可以查找第一个具有特定大小的元素<ul>
<li>接受三个参数，前两个参数表示输入范围，第三个参数是一个谓词，且是一个一元谓词</li>
<li>返回第一个使用谓词返回非 0 值的元素，如果不存在则返回尾迭代器</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105305781.png" class="" title="image-20240120105305781">

<h4 id="for-each-算法"><a href="#for-each-算法" class="headerlink" title="for_each 算法"></a>for_each 算法</h4><ul>
<li>接受三个参数，前两个为输入范围，第三个为一个可调用对象，对输入序列中的每个元素调用此对象</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105456109.png" class="" title="image-20240120105456109">

<blockquote>
<p>捕获列表只用于局部非 static 变量，lambda 可以直接使用局部 static 变量和它所在函数之外声明的名字</p>
</blockquote>
<h4 id="完整的-biggies"><a href="#完整的-biggies" class="headerlink" title="完整的 biggies"></a>完整的 biggies</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105640375.png" class="" title="image-20240120105640375">

<h3 id="10-3-3-lambda-捕获与返回"><a href="#10-3-3-lambda-捕获与返回" class="headerlink" title="10.3.3 lambda 捕获与返回"></a>10.3.3 lambda 捕获与返回</h3><ul>
<li>当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名的）类类型</li>
<li>当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象（未命名对象）<ul>
<li>默认情况下，从 lambda 生成的类都包含一个对应 lambda 所捕获的变量的数据成员</li>
</ul>
</li>
</ul>
<h4 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h4><ul>
<li>变量的捕获方式可以是值或引用<ul>
<li>采用值捕获的前提是变量可以拷贝，被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120110529067.png" class="" title="image-20240120110529067">

<h4 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120110557764.png" class="" title="image-20240120110557764">

<ul>
<li>如果我们采用引用的方式捕获变量，就必须保证被引用的对象在 lambda 这些的时候是存在的</li>
<li>lambda 捕获的是局部变量，这些变量在函数结束后就不复存在了</li>
<li>如果函数返回一个 lambda，则该 lambda 不能包含引用捕获</li>
</ul>
<blockquote>
<p>一般来说，我们应该尽量减少捕获的数据量，如果可能的话，应该避免捕获指针或引用</p>
</blockquote>
<h4 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h4><ul>
<li>可以让编译器根据 lambda 体中的代码来推断我们要使用那些变量<ul>
<li>在捕获列表中写 **&amp; 或 &#x3D;**，&amp; 告诉编译器采用捕获引用方式，&#x3D; 则表采用值捕获方式</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111417949.png" class="" title="image-20240120111417949">

<ul>
<li>也可以混合使用隐式捕获和显示捕获</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111540565.png" class="" title="image-20240120111540565">

<blockquote>
<p>混合使用隐式捕获和显示捕获时，捕获列表中的第一个元素必须是一个 &amp; 或 &#x3D;，且显示捕获的变量必须使用与隐式捕获不同的方式</p>
</blockquote>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111722099.png" class="" title="image-20240120111722099">

<h4 id="可变-lambda"><a href="#可变-lambda" class="headerlink" title="可变 lambda"></a>可变 lambda</h4><ul>
<li>默认情况下，一个值拷贝的变量，lambda 不会改变其值</li>
<li>如果我们希望改变一个捕获的变量的值，就必须在参数列表首加上关键字 <strong>mutable</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112046142.png" class="" title="image-20240120112046142">

<ul>
<li>一个引用捕获的变量算法可以修改则依赖于指向的是一个 const 还是 非 const</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112131621.png" class="" title="image-20240120112131621">

<h4 id="指定-lambda-返回类型"><a href="#指定-lambda-返回类型" class="headerlink" title="指定 lambda 返回类型"></a>指定 lambda 返回类型</h4><ul>
<li><p><strong>transform</strong> 函数接受三个迭代器和一个可调用对象，前两个迭代器表示输入序列，第三个迭代器表示目的位置</p>
<ul>
<li>算法对输入序列中每个元素调用可调用对象，结果写入到目的位置</li>
</ul>
</li>
<li><p>lambda 体只包含一个 return 语句时，可以隐式推断出返回类型</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112507534.png" class="" title="image-20240120112507534">

<ul>
<li>如果 lambda 体包含 return 之外的任何语句，则编译器假定此 lambda 返回 <strong>void</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112604726.png" class="" title="image-20240120112604726">

<ul>
<li>当我们需要为一个 lambda 定义返回类型时，必须使用 <strong>尾置返回类型</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112650976.png" class="" title="image-20240120112650976">

<h3 id="10-3-4-参数绑定"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a>10.3.4 参数绑定</h3><blockquote>
<p>在那种只有一两个地方使用的简单操作，lambda 表达式是最有用的</p>
<p>如果需要在很多地方使用，或一个操作需要很多语句才能完成，通常使用函数更好</p>
<p>对于捕获局部变量的 lambda，用函数替换它就不是那么容易了</p>
</blockquote>
<h4 id="标准库-bind-函数"><a href="#标准库-bind-函数" class="headerlink" title="标准库 bind 函数"></a>标准库 bind 函数</h4><ul>
<li><p>可以将 <strong>bind</strong> 看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来 <strong>“适应”</strong> 原对象的参数列表</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113047932.png" class="" title="image-20240120113047932">

<ul>
<li><strong>newCallable</strong> 是一个可调用对象，<strong>arg_list</strong> 是一个参数列表，对应给定的 <strong>callable（旧的可调用对象）</strong> 的参数</li>
<li><strong>arg_list</strong> 中的参数可能包含 <strong>_n</strong> 这样的名字，n 为一个整数，称为 <strong>占位符</strong>，表示 newCallable 的参数<ul>
<li><strong>_1</strong> 为 newCallable 的第一个参数，**_2** 为第二个参数……</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113624892.png" class="" title="image-20240120113624892">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113636991.png" class="" title="image-20240120113636991">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113749208.png" class="" title="image-20240120113749208">

<ul>
<li>对 find_if 使用</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113802747.png" class="" title="image-20240120113802747">

<h4 id="使用-placeholders-名字"><a href="#使用-placeholders-名字" class="headerlink" title="使用 placeholders 名字"></a>使用 placeholders 名字</h4><ul>
<li><p><strong>_n</strong> 这样的名字都定义在一个名为 <strong>placeholders</strong> 的命名空间中，这个命名空间本身就定义在 <strong>std</strong> 命名空间</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114153398.png" class="" title="image-20240120114153398">
</li>
<li><p>我们可以使用如下声明，说明希望所有来自 <strong>namespace_name</strong> 的名字都可以在我们的程序中直接使用</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114144721.png" class="" title="image-20240120114144721">

<h4 id="bind-的参数"><a href="#bind-的参数" class="headerlink" title="bind 的参数"></a>bind 的参数</h4><ul>
<li>可以用 bind 绑定给定可调用对象中的参数或重新安排其顺序</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114316937.png" class="" title="image-20240120114316937">

<ul>
<li>此时 g 的第一个参数被传递给 f 的最后一个参数，g 的第二个参数被传递给 f 的第三个参数</li>
</ul>
<h4 id="用-bind-重排参数顺序"><a href="#用-bind-重排参数顺序" class="headerlink" title="用 bind 重排参数顺序"></a>用 bind 重排参数顺序</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114514241.png" class="" title="image-20240120114514241">

<h4 id="绑定引用参数"><a href="#绑定引用参数" class="headerlink" title="绑定引用参数"></a>绑定引用参数</h4><ul>
<li>默认情况下，bind 的那些不是占位符的参数被拷贝到 bind 返回的可调用函数中</li>
<li>如果必须传递给 bind 一个对象而不是拷贝它，就必须使用 <strong>ref</strong> 函数（比如 ostream）</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114718943.png" class="" title="image-20240120114718943">

<ul>
<li><strong>cref</strong> 函数生成一个保存 const 引用的类</li>
</ul>
<h2 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器</h2><ul>
<li>除了在每个容器中定义的迭代器外，标志库在头文件 <strong>iterator</strong> 中还定义了额外几种迭代器</li>
<li><strong>插入迭代器</strong>：这些迭代器绑定到一个容器上，可以用来向容器中插入元素</li>
<li><strong>流迭代器</strong>：这些迭代器被绑定到输入或输出流上，可以用来遍历所关联的 IO 流</li>
<li><strong>反向迭代器</strong>：这些迭代器向后而不是向前移动（除了 forward_list 外的标准库都有反向迭代器）</li>
<li><strong>移动迭代器</strong>：这些专用的迭代器不是拷贝其中的元素，而是移动它们</li>
</ul>
<h3 id="10-4-1-插入迭代器"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a>10.4.1 插入迭代器</h3><ul>
<li>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，可以实现向给定容器添加元素</li>
<li>通过一个插入迭代器赋值时，该迭代器会调用容器操作来向给定容器的指定位置插入一个元素</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120130709219.png" class="" title="image-20240120130709219">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120130721421.png" class="" title="image-20240120130721421">

<h3 id="10-4-2-iostream-迭代器"><a href="#10-4-2-iostream-迭代器" class="headerlink" title="10.4.2 iostream 迭代器"></a>10.4.2 iostream 迭代器</h3><ul>
<li>虽然 iostream 类型不是容器，但标准库定义了可用于这些 IO 类型对象的迭代器</li>
<li><strong>istream_iterator</strong> 读取输入流，<strong>ostream_iterator</strong> 向一个输出流写数据</li>
<li>这些迭代器将给定的流当作一个特定类型的元素序列来处理</li>
</ul>
<h4 id="istream-iterator-操作"><a href="#istream-iterator-操作" class="headerlink" title="istream_iterator 操作"></a>istream_iterator 操作</h4><ul>
<li><p>创建一个流迭代器时，必须指定迭代器要读写的对象的类型</p>
<ul>
<li>一个 istream_iterator 使用 <strong>&gt;&gt;</strong> 来读取流，因此它读取的类型必须定义了 &gt;&gt; 输出运算符</li>
</ul>
</li>
<li><p>默认初始化迭代器时，会创建一个可以当作 <strong>尾后值</strong> 使用的迭代器</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131257862.png" class="" title="image-20240120131257862">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131310063.png" class="" title="image-20240120131310063">

<blockquote>
<p>对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到 IO 错误，迭代器的值就与尾后迭代器相等</p>
</blockquote>
<ul>
<li>我们以如下的方式构造 vector，从 cin 中读取数据，知道遇到文件尾或遇到一个不是 int 数据为止</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131627364.png" class="" title="image-20240120131627364">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131643099.png" class="" title="image-20240120131643099">

<h4 id="使用算法操作流迭代器"><a href="#使用算法操作流迭代器" class="headerlink" title="使用算法操作流迭代器"></a>使用算法操作流迭代器</h4><ul>
<li>通过一对 istream_iterator 来调用 accumulate：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131739797.png" class="" title="image-20240120131739797">

<h4 id="istream-iterator-允许使用懒惰求值"><a href="#istream-iterator-允许使用懒惰求值" class="headerlink" title="istream_iterator 允许使用懒惰求值"></a>istream_iterator 允许使用懒惰求值</h4><ul>
<li>当一个 istream_iterator 绑定到一个流时，标准库并不保证马上从流读取数据，可能直到我们使用迭代器时才真正读取</li>
</ul>
<h4 id="ostream-iterator-操作"><a href="#ostream-iterator-操作" class="headerlink" title="ostream_iterator 操作"></a>ostream_iterator 操作</h4><ul>
<li><p>我们可以对任何具有 <strong>&lt;&lt; 输出运算符</strong> 的类型定义 ostream_iterator</p>
<ul>
<li>创建时，我们也可以提供（可选的）第二参数，它是一个 C 风格的字符串，在输出每个元素后都会打印此字符串</li>
</ul>
</li>
<li><p>必须将 ostream_iterator 绑定到一个指定的流，不允许空的或表示尾后位置的 ostream_iterator</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132315074.png" class="" title="image-20240120132315074">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132346862.png" class="" title="image-20240120132346862">

<ul>
<li>当我们向 ostream_iterator 赋值时，可以忽略解引用和递增运算符，因为实际上它们什么也不做</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132509140.png" class="" title="image-20240120132509140">

<blockquote>
<p>但更推荐写上解引用和递增运算符，因为这样对读者来说更清晰，也更易修改</p>
</blockquote>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132700171.png" class="" title="image-20240120132700171">

<h4 id="使用流迭代器处理类类型"><a href="#使用流迭代器处理类类型" class="headerlink" title="使用流迭代器处理类类型"></a>使用流迭代器处理类类型</h4><ul>
<li>我们可以为任何定义了 <strong>&gt;&gt; 输入运算符</strong> 的类型创建 istream_iterator 对象，对定义有 <strong>&lt;&lt; 输出运算符</strong> 的类型创建 ostream_iterator 对象</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132900248.png" class="" title="image-20240120132900248">

<h3 id="10-4-3-反向迭代器"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a>10.4.3 反向迭代器</h3><ul>
<li>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器，递增及递减操作的含义颠倒过来</li>
<li>除了 **forward_list **之外的其他容器都支持反向迭代器，我们可以通过调用 rbegin、rend、crbegin、crend 函数来获得反向迭代器</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133138976.png" class="" title="image-20240120133138976">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133645835.png" class="" title="image-20240120133645835">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133654972.png" class="" title="image-20240120133654972">

<h4 id="反向迭代器需要递减运算符"><a href="#反向迭代器需要递减运算符" class="headerlink" title="反向迭代器需要递减运算符"></a>反向迭代器需要递减运算符</h4><ul>
<li>我们只能从既支持 ++ 也支持 - - 的迭代器来定义反向迭代器<ul>
<li><strong>流迭代器</strong> 不支持递减迭代器，而除了 forward_list 外，标准库容器上的其他迭代器都都既支持递增也支持递减运算符</li>
</ul>
</li>
</ul>
<h4 id="反向迭代器和其他迭代器之间的关系"><a href="#反向迭代器和其他迭代器之间的关系" class="headerlink" title="反向迭代器和其他迭代器之间的关系"></a>反向迭代器和其他迭代器之间的关系</h4><ul>
<li><p>调用反向迭代器（reverse_iterator）的 <strong>base</strong> 成员函数完成从一个反向迭代器转换为普通迭代器</p>
<blockquote>
<p>反向迭代器转换为普通迭代器后，指向不同的元素</p>
</blockquote>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120134322779.png" class="" title="image-20240120134322779">

<blockquote>
<p>反向迭代器和普通迭代器都反映了左闭合区间的特性，**[ line.crbegin( )，rcomma ），[ rcomma.base( )，line.cend( ) ）**</p>
</blockquote>
<h2 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构</h2><ul>
<li>算法所要求的迭代器操作可分为 5 个 <strong>迭代器类别</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120134619601.png" class="" title="image-20240120134619601">

<h3 id="10-5-1-5-类迭代器"><a href="#10-5-1-5-类迭代器" class="headerlink" title="10.5.1 5 类迭代器"></a>10.5.1 5 类迭代器</h3><ul>
<li>一个高层类别的迭代器支持低层类别迭代器的所有操作，而向算法传递一个哪里更差的迭代器会产生错误</li>
</ul>
<h4 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h4><ul>
<li>可以读取序列中的元素，一个输入迭代器必须支持：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120135823274.png" class="" title="image-20240120135823274">

<blockquote>
<p>输入迭代器只能用于单遍扫描算法</p>
</blockquote>
<h4 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h4><ul>
<li>只写而不读元素，输出迭代器必须支持：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120135944553.png" class="" title="image-20240120135944553">

<blockquote>
<p>我们只能向一个输出迭代器赋值一次，输出迭代器也只能用于单遍扫描算法</p>
<p>用作目的位置的迭代器通常是输出迭代器</p>
</blockquote>
<h4 id="向前迭代器"><a href="#向前迭代器" class="headerlink" title="向前迭代器"></a>向前迭代器</h4><ul>
<li>可以读写元素，这类迭代器只能在序列中沿一个方向移动</li>
<li>可以多次读写同一个元素，因此可以使用向前迭代器的算法对序列进行多次扫描</li>
</ul>
<h4 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h4><ul>
<li>提供在常量时间内访问序列中任意元素的哪里，支持双向迭代器的所有功能，还支持：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120140323390.png" class="" title="image-20240120140323390">

<blockquote>
<p>sort 就要求随机访问迭代器，array、deque、vector、string 的迭代器都是随机访问迭代器，用于访问内置数组的指针也是</p>
</blockquote>
<h3 id="10-5-2-算法形参模式"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a>10.5.2 算法形参模式</h3><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120140501206.png" class="" title="image-20240120140501206">

<ul>
<li><strong>alg</strong> 是算法的名字，<strong>beg 和 end</strong> 表示算法所操作的输入范围（几乎所有算法都接受一个输入范围）</li>
<li><strong>dest 和 beg2、end2</strong> 都是迭代器参数，分别表示目的位置和第二个范围的角色</li>
<li><strong>other args</strong> 表示其他额外的非迭代器参数，一些算法还接受它们</li>
</ul>
<h4 id="接受单个目标迭代器的算法"><a href="#接受单个目标迭代器的算法" class="headerlink" title="接受单个目标迭代器的算法"></a>接受单个目标迭代器的算法</h4><ul>
<li>蕴含一个编程假定，且通常 dest 被绑定到一个插入迭代器</li>
</ul>
<h4 id="接受第二个输入序列的算法"><a href="#接受第二个输入序列的算法" class="headerlink" title="接受第二个输入序列的算法"></a>接受第二个输入序列的算法</h4><ul>
<li>蕴含一个编程假定：从 beg2 开始的范围与 beg 和 end 所表示的范围至少一样大</li>
</ul>
<h3 id="10-5-3-算法命名规范"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a>10.5.3 算法命名规范</h3><h4 id="一些算法使用重载形式传递一个谓词"><a href="#一些算法使用重载形式传递一个谓词" class="headerlink" title="一些算法使用重载形式传递一个谓词"></a>一些算法使用重载形式传递一个谓词</h4><ul>
<li>接受谓词参数替换 &lt; 或 &#x3D;&#x3D; 运算符的算法，以及那些不接受额外参数的算法，通常是重载函数</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141052933.png" class="" title="image-20240120141052933">

<h4 id="if-版本的算法"><a href="#if-版本的算法" class="headerlink" title="_if 版本的算法"></a>_if 版本的算法</h4><ul>
<li>接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词替代元素值，都附加有 <strong>_if</strong> 前缀</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141402297.png" class="" title="image-20240120141402297">

<h4 id="区分拷贝元素的版本和不拷贝的版本"><a href="#区分拷贝元素的版本和不拷贝的版本" class="headerlink" title="区分拷贝元素的版本和不拷贝的版本"></a>区分拷贝元素的版本和不拷贝的版本</h4><ul>
<li>默认情况下，重排元素的算法将重排后的元素写到给定的输入序列中，它们还提供了一个拷贝版本，将元素写到一个指定的输出目的位置，都在名字后边附加一个 <strong>_copy</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141621469.png" class="" title="image-20240120141621469">

<ul>
<li>一些算法同时提供了 _copy 和 _if 版本</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141735652.png" class="" title="image-20240120141735652">

<h2 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法</h2><ul>
<li>特别的，<strong>链式类型 list 和 forward_list</strong> 定义了几个成员函数形式的算法，这些链表版本的算法的性能比对应的通用版本好得多</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141924398.png" class="" title="image-20240120141924398">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141934406.png" class="" title="image-20240120141934406">

<blockquote>
<p>对于 list 和 forward_list 应该优先使用成员函数版本的算法，而不是通用版本算法</p>
</blockquote>
<h4 id="spilce-成员"><a href="#spilce-成员" class="headerlink" title="spilce 成员"></a>spilce 成员</h4><ul>
<li>此算法是链表数据结构所特有的，不需要通用版本</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120142111787.png" class="" title="image-20240120142111787">

<h4 id="链表特有的操作会改变容器"><a href="#链表特有的操作会改变容器" class="headerlink" title="链表特有的操作会改变容器"></a>链表特有的操作会改变容器</h4><ul>
<li>多数链表特有的算法都与其通用版本相似，但不完全相同</li>
<li>链表特有的版本与通用版本的一个至关重要的的区别是 <strong>链表版本会改变底层的容器</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">C++Primer-9-顺序容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-19 11:18:05" itemprop="dateCreated datePublished" datetime="2024-01-19T11:18:05+08:00">2024-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-20 17:50:17" itemprop="dateModified" datetime="2024-01-20T17:50:17+08:00">2024-01-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="9-顺序容器"><a href="#9-顺序容器" class="headerlink" title="9 顺序容器"></a>9 顺序容器</h1><blockquote>
<p>一个容器就是一个特定类型的集合，顺序容器提供了控制元素存储和访问顺序的能力</p>
<p>这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应</p>
<p>标准库还定义了三种容器适配器来与容器类型适配</p>
</blockquote>
<h2 id="9-1-顺序容器概述"><a href="#9-1-顺序容器概述" class="headerlink" title="9.1 顺序容器概述"></a>9.1 顺序容器概述</h2><img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119112935811.png" class="" title="image-20240119112935811">

<ul>
<li><p><strong>string</strong> 和 <strong>vector</strong> 将元素保存在连续的内存空间中</p>
<ul>
<li>由于是 <strong>连续存储</strong> 的，由元素的下标来计算地址是非常快速的</li>
<li>但在中间位置添加或删除元素就很耗时，因为会移动其他元素来保持连续存储，且还有可能分配额外的存储空间</li>
</ul>
</li>
<li><p><strong>list</strong> 和 <strong>forward_list</strong> 的设计目的是在任何位置进行添加和删除都很快速</p>
<ul>
<li>不支持元素的随机访问，为了访问一个元素，只能遍历整个容器</li>
<li>额外内存开销也很大</li>
<li>特殊的，forward_list 没有 size 操作</li>
</ul>
</li>
<li><p><strong>deque</strong> 支持快速随机访问，同样在中间位置添加和删除元素很耗时，但在两端添加元素就很快速</p>
</li>
<li><p><strong>array</strong> 与内置数组类似，大小固定，不支持添加和删除元素以及改变容器大小的操作</p>
</li>
</ul>
<blockquote>
<p>现代 C++ 程序应该使用标准库容器，而不是更原始的数据结构，如内置数组</p>
<p>通常，使用 vector 是最好的选择，除非你有更好的理由选择其他容器</p>
</blockquote>
<ul>
<li>选择容器的基本原则：</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119113738503.png" class="" title="image-20240119113738503">

<ul>
<li>一般来说，占应用中主导地位的操作决定了容器类型的选择</li>
</ul>
<h2 id="9-2-容器库概览"><a href="#9-2-容器库概览" class="headerlink" title="9.2 容器库概览"></a>9.2 容器库概览</h2><blockquote>
<p>一般来说，每个容器都定义在了一个与文件名与类名同名的头文件中</p>
<p>容器均定义为模板类型</p>
</blockquote>
<h4 id="对容器可以保持的元素类型的限制"><a href="#对容器可以保持的元素类型的限制" class="headerlink" title="对容器可以保持的元素类型的限制"></a>对容器可以保持的元素类型的限制</h4><ul>
<li>顺序容器几乎可以保存任意类型的元素</li>
<li>但如果保存的是自定义数据类型，容器就只能使用那些没有特殊要求的容器操作了</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119114345994.png" class="" title="image-20240119114345994">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119114433741.png" class="" title="image-20240119114433741">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119114450674.png" class="" title="image-20240119114450674">

<h3 id="9-2-1-迭代器"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器</h3><blockquote>
<p>如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的</p>
<p>特殊的，forward_list 迭代器不支持递减运算符 - - </p>
</blockquote>
<h4 id="迭代器范围"><a href="#迭代器范围" class="headerlink" title="迭代器范围"></a>迭代器范围</h4><ul>
<li><p>一个 <strong>迭代器范围</strong> 由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置</p>
<blockquote>
<p>第二个迭代器从来不会指向范围中的最后一个元素，而是指向尾元素之后的位置</p>
<p>这种元素范围被称为 <strong>左闭合区间</strong>，即 <strong>[begin，end）</strong></p>
</blockquote>
</li>
</ul>
<h4 id="使用左闭合区间蕴含的编程假定"><a href="#使用左闭合区间蕴含的编程假定" class="headerlink" title="使用左闭合区间蕴含的编程假定"></a>使用左闭合区间蕴含的编程假定</h4><ul>
<li>如果 <strong>begin !&#x3D; end</strong>，范围内至少包含一个元素，且 begin 指向范围中的第一个元素</li>
<li>如果 <strong>begin &#x3D;&#x3D; end</strong>，范围为空</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119115237939.png" class="" title="image-20240119115237939">

<h3 id="9-2-2-容器类型成员"><a href="#9-2-2-容器类型成员" class="headerlink" title="9.2.2 容器类型成员"></a>9.2.2 容器类型成员</h3><ul>
<li>除了 iterator 和 const_iterator 类型，大多数容器还提供 <strong>反向迭代器</strong></li>
<li>反向迭代器是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒<ul>
<li>比如 ++ 操作会得到上一个元素</li>
</ul>
</li>
<li><strong>类型别名</strong>：通过类型别名我们可以在不了解容器中元素类型的情况下使用它<ul>
<li>比如使用 <strong>value_type</strong> 得到 <strong>元素类型</strong>，需要元素类型的一个引用，可以使用 <strong>reference</strong> 和 <strong>const_reference</strong></li>
<li>这些类型别名在泛型编程中非常有用</li>
</ul>
</li>
</ul>
<h3 id="9-2-3-begin-和-end-成员"><a href="#9-2-3-begin-和-end-成员" class="headerlink" title="9.2.3 begin 和 end 成员"></a>9.2.3 begin 和 end 成员</h3><ul>
<li><strong>begin</strong> 和 <strong>end</strong> 有多个版本：<strong>带 r</strong> 的版本返回反向迭代器，<strong>以 c 开头</strong> 的版本返回 const 迭代器</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119120530777.png" class="" title="image-20240119120530777">

<ul>
<li><p><strong>不以 c 开头</strong> 的函数都是被 <strong>重载</strong> 过的</p>
</li>
<li><p>因此实际上有两个 begin 成员，一个是 const 成员，返回 const_iterator 类型，另一个非常量成员返回 iterator 类型</p>
<ul>
<li>rbegin、rend 和 end 也是类似，如果我们用一个 const 对象调用它们时，得到 const 版本，反之亦然</li>
</ul>
</li>
<li><p>可以使用 auto 与 begin 和 end 结合使用</p>
</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119121258809.png" class="" title="image-20240119121258809">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119121320323.png" class="" title="image-20240119121320323">

<blockquote>
<p>当不需要写访问时，应该使用 cbegin 和 cend</p>
</blockquote>
<h3 id="9-2-4-容器定义和初始化"><a href="#9-2-4-容器定义和初始化" class="headerlink" title="9.2.4 容器定义和初始化"></a>9.2.4 容器定义和初始化</h3><ul>
<li>除了 array 之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119122320327.png" class="" title="image-20240119122320327">

<h4 id="将一个容器初始化为另一个容器的拷贝"><a href="#将一个容器初始化为另一个容器的拷贝" class="headerlink" title="将一个容器初始化为另一个容器的拷贝"></a>将一个容器初始化为另一个容器的拷贝</h4><ul>
<li>直接拷贝整个容器 或者 拷贝由一个迭代器对指定的元素范围（array 除外）</li>
<li>为了 <strong>创建一个容器为另一个容器的拷贝</strong>，两容器的类型及元素类型必须 <strong>匹配</strong></li>
<li>如果传递迭代器参数拷贝一个 <strong>范围</strong>，不要求容器和元素类型相同，只要求元素类型 <strong>可以转换</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119122638382.png" class="" title="image-20240119122638382">

<ul>
<li>也可以使用范围拷贝来拷贝一个容器的子序列：</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119122729707.png" class="" title="image-20240119122729707">

<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><ul>
<li>除了 array 之外的容器类型，列表初始化还隐含指定了容器的大小</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119122831449.png" class="" title="image-20240119122831449">

<h4 id="与顺序容器大小相关的构造函数"><a href="#与顺序容器大小相关的构造函数" class="headerlink" title="与顺序容器大小相关的构造函数"></a>与顺序容器大小相关的构造函数</h4><ul>
<li>接受一个容器大小和一个（可选的）元素初始值，如果没有接受元素初始值，则元素类型需要有默认构造函数</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119123013609.png" class="" title="image-20240119123013609">

<h4 id="标准库-array-具有固定大小"><a href="#标准库-array-具有固定大小" class="headerlink" title="标准库 array 具有固定大小"></a>标准库 array 具有固定大小</h4><ul>
<li>标准库 <strong>array 的大小</strong> 也是类型的一部分，因此定义一个 array 时，除了指定元素类型，还需要指定容器大小</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119123118897.png" class="" title="image-20240119123118897">

<ul>
<li>一个 <strong>默认构造的 array 是非空</strong> 的，它包含了与其大小一样多的元素，这些元素都被默认初始化，因此元素类型必须有一个默认构造函数</li>
<li>如果我们对 array 进行列表初始化，则初始值个数必须小于等于 array 大小，如果小于的话，后边的元素都会进行值初始化</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119123448208.png" class="" title="image-20240119123448208">

<ul>
<li>值得注意的是，虽然我们不能对内置数组进行拷贝或赋值，但 array 可以：</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119123538605.png" class="" title="image-20240119123538605">

<blockquote>
<p>当然，拷贝或赋值时元素类型和大小都需要匹配</p>
</blockquote>
<h3 id="9-2-5-赋值和-swap"><a href="#9-2-5-赋值和-swap" class="headerlink" title="9.2.5  赋值和 swap"></a>9.2.5  赋值和 swap</h3><ul>
<li>赋值运算符将其左边容器中所有元素替换为右边容器中元素的拷贝</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119141207073.png" class="" title="image-20240119141207073">

<ul>
<li>与内置数组不同，标准库 array 类型允许赋值，但左右两边运算对象必须有相同类型</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119141304928.png" class="" title="image-20240119141304928">

<blockquote>
<p>由于左右两边运算对象的大小可能不同，所以 array 不支持 assign 及花括号包围的值的列表进行赋值</p>
</blockquote>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119141539683.png" class="" title="image-20240119141539683">

<h4 id="使用-assign（仅顺序容器）"><a href="#使用-assign（仅顺序容器）" class="headerlink" title="使用 assign（仅顺序容器）"></a>使用 assign（仅顺序容器）</h4><ul>
<li><strong>assign</strong> 允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值</li>
<li>assign 用参数所指定的元素（的拷贝）<strong>替换</strong> 左边容器中所有元素</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119141755675.png" class="" title="image-20240119141755675">

<blockquote>
<p>由于旧元素被替换，因此传递给 assign 的迭代器不能指向调用 assign 的容器</p>
</blockquote>
<ul>
<li>assign 的第二个版本接受一个整型值和一个元素值</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119142008797.png" class="" title="image-20240119142008797">

<h4 id="使用-swap"><a href="#使用-swap" class="headerlink" title="使用 swap"></a>使用 swap</h4><ul>
<li>除了 array 之外，交换其他的两个容器会很快（元素本身并未交换，swap 只是交换了两个容器的内部数据结构）</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119142152075.png" class="" title="image-20240119142152075">

<blockquote>
<p>除 array 外，swap 不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成</p>
<p>而元素不会被移动表示，除 string 外，指向容器的迭代器、引用和指针在 swap 后仍然有效，只是已经属于不同容器了</p>
</blockquote>
<ul>
<li>与其他容器不同，<strong>swap 两个 array 会真的交换它们</strong>，因此所需时间与 array 中元素个数成正比</li>
</ul>
<blockquote>
<p>虽然有成员 swap 和非成员版本的 swap，但统一使用非成员版本的 swap 是一个好习惯</p>
</blockquote>
<h3 id="9-2-6-容器大小操作"><a href="#9-2-6-容器大小操作" class="headerlink" title="9.2.6 容器大小操作"></a>9.2.6 容器大小操作</h3><ul>
<li><strong>size</strong>：返回容器中元素数目</li>
<li><strong>empty</strong>：当 size 为 0 时返回 true，否则返回 false</li>
<li><strong>max_size</strong>：返回一个大于或等于该容器所能容纳的最大元素数的值</li>
</ul>
<blockquote>
<p>forward_list 支持 max_size、empty，但不支持 size</p>
</blockquote>
<h3 id="9-2-7-关系运算符"><a href="#9-2-7-关系运算符" class="headerlink" title="9.2.7 关系运算符"></a>9.2.7 关系运算符</h3><ul>
<li>每个容器都支持 <strong>相等运算符 &#x3D;&#x3D; 、!&#x3D;</strong></li>
<li>除了无序关联容器外，所有容器都支持 <strong>关系运算符 &gt;、 &gt;&#x3D;、 &lt;、 &lt;&#x3D;</strong>**<ul>
<li>关系运算符左右两边必须是相同类型的容器且元素类型也相同，比较策略是逐个比较</li>
</ul>
</li>
</ul>
<h4 id="容器的关系运算符使用元素的关系运算符完成比较"><a href="#容器的关系运算符使用元素的关系运算符完成比较" class="headerlink" title="容器的关系运算符使用元素的关系运算符完成比较"></a>容器的关系运算符使用元素的关系运算符完成比较</h4><ul>
<li>实际上，容器的相等运算符是使用 <strong>&#x3D;&#x3D; 运算符</strong> 实现比较的，而其他运算符是使用 <strong>&lt; 运算符</strong> 完成比较的</li>
<li>如果元素类型不支持所需的运算符，则容器就不能使用相应的运算符比较</li>
</ul>
<h2 id="9-3-顺序容器操作"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作</h2><blockquote>
<p>顺序容器个关联容器的不同之处在于两者组织元素的方式，这直接关系到了元素如何存储、访问、添加以及删除</p>
</blockquote>
<h3 id="9-3-1-向顺序容器添加元素"><a href="#9-3-1-向顺序容器添加元素" class="headerlink" title="9.3.1 向顺序容器添加元素"></a>9.3.1 向顺序容器添加元素</h3><ul>
<li>除了 array 之外，所有标准库都提供灵活的内存关联，在运行时可以动态的添加或删除元素改变容器的大小</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119143804807.png" class="" title="image-20240119143804807">

<blockquote>
<p>当我们使用这些操作时，必须记得不同容器使用不同策略来分配元素空间，这些策略会直接影响性能</p>
</blockquote>
<h4 id="使用-push-back"><a href="#使用-push-back" class="headerlink" title="使用 push_back"></a>使用 push_back</h4><ul>
<li><strong>除了 array 和 forward_list 外</strong>，其他容器都支持 push_back，push_back 将一个元素追加到一个容器的尾部</li>
</ul>
<blockquote>
<p>实际放入容器中的是对象值的一个拷贝，而不是对象本身</p>
</blockquote>
<h4 id="使用-push-front"><a href="#使用-push-front" class="headerlink" title="使用 push_front"></a>使用 push_front</h4><ul>
<li><strong>forward_list、list、deque 都支持 push_front</strong>，将元素插入到容器头部</li>
</ul>
<h4 id="在容器中的特定位置添加元素"><a href="#在容器中的特定位置添加元素" class="headerlink" title="在容器中的特定位置添加元素"></a>在容器中的特定位置添加元素</h4><ul>
<li><strong>vector、deque、list、string</strong> 都支持 insert，<strong>forward_list</strong> 提供了特殊版本的 insert</li>
<li><strong>insert</strong> 将元素插入到迭代器所指定的位置之前</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119144508718.png" class="" title="image-20240119144508718">

<h4 id="插入范围内元素"><a href="#插入范围内元素" class="headerlink" title="插入范围内元素"></a>插入范围内元素</h4><ul>
<li><p>除了第一个迭代器参数外，insert 函数还可以接受更多参数</p>
<ul>
<li><p>接受 <strong>一个元素数目和一个值</strong>，它将指定数量的元素添加到指定位置</p>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119144752618.png" class="" title="image-20240119144752618">
</li>
<li><p>接受 <strong>一对迭代器</strong> 或 <strong>一个初始化列表</strong>，将指定范围内的元素 <strong>插入指定位置之前</strong>，<strong>返回指向第一个新加入元素的迭代器</strong>，范围为空则返回第一个参数</p>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119144842479.png" class="" title="image-20240119144842479">

<blockquote>
<p>如果传递给 insert 一对迭代器，它们不能指向添加元素的目标容器</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="使用-insert-的返回值"><a href="#使用-insert-的返回值" class="headerlink" title="使用 insert 的返回值"></a>使用 insert 的返回值</h4><ul>
<li>通过使用 insert 的返回值，可以在容器中一个特定位置反复插入元素</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119145201837.png" class="" title="image-20240119145201837">

<h4 id="使用-emplace-操作"><a href="#使用-emplace-操作" class="headerlink" title="使用 emplace 操作"></a>使用 emplace 操作</h4><ul>
<li>这些操作 <strong>构造函数</strong>，而不是拷贝函数，它们将参数传递给元素类型的构造函数，参数必须与元素类型构造函数的参数相 <strong>匹配</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119145342291.png" class="" title="image-20240119145342291">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119145427328.png" class="" title="image-20240119145427328">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119145437306.png" class="" title="image-20240119145437306">

<blockquote>
<p>emplace 函数在容器中直接构造元素</p>
</blockquote>
<h3 id="9-3-2-访问元素"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素</h3><ul>
<li>包括 array 在内，每个容器都有一个 <strong>front</strong> 成员函数，而除了 forward_list 外，所有顺序容器都有一个 <strong>back</strong> 成员函数</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119145727854.png" class="" title="image-20240119145727854">

<h4 id="访问成员函数返回的是引用"><a href="#访问成员函数返回的是引用" class="headerlink" title="访问成员函数返回的是引用"></a>访问成员函数返回的是引用</h4><ul>
<li>在容器中访问元素的成员函数（<strong>front、back、下标、at</strong>）返回的都是 <strong>引用</strong>，如果容器是 const 对象，则返回 const 的引用</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119150226511.png" class="" title="image-20240119150226511">

<blockquote>
<p>使用 auto 保存返回值，希望用来改变元素的值，必须将变量定义为引用类型</p>
</blockquote>
<h4 id="下标操作和安全的随机访问"><a href="#下标操作和安全的随机访问" class="headerlink" title="下标操作和安全的随机访问"></a>下标操作和安全的随机访问</h4><ul>
<li>提供快速随机访问的容器（<strong>string、vector、deque、array</strong>）都提供下标运算符</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119150235629.png" class="" title="image-20240119150235629">

<blockquote>
<p>如果希望确保下标是合法的，可以使用 at 成员函数，越界时会抛出 out_of_range 异常</p>
</blockquote>
<h3 id="9-3-3-删除元素"><a href="#9-3-3-删除元素" class="headerlink" title="9.3.3 删除元素"></a>9.3.3 删除元素</h3><img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119150347885.png" class="" title="image-20240119150347885">

<blockquote>
<p>删除元素的函数并不检测其参数，所以删除前需要确保它们确实存在</p>
</blockquote>
<h4 id="pop-front-和-pop-back-成员函数"><a href="#pop-front-和-pop-back-成员函数" class="headerlink" title="pop_front 和 pop_back 成员函数"></a>pop_front 和 pop_back 成员函数</h4><ul>
<li>这些操作返回 <strong>void</strong>，如果你需要弹出的元素的值，必须在弹出前保存它</li>
</ul>
<h4 id="从容器内部删除一个元素"><a href="#从容器内部删除一个元素" class="headerlink" title="从容器内部删除一个元素"></a>从容器内部删除一个元素</h4><ul>
<li><strong>erase</strong> 从容器中指定位置删除元素<ul>
<li>可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的元素</li>
<li>都返回指向删除的（最后一个）元素之后位置的迭代器</li>
</ul>
</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119150822054.png" class="" title="image-20240119150822054">

<h4 id="删除多个元素"><a href="#删除多个元素" class="headerlink" title="删除多个元素"></a>删除多个元素</h4><ul>
<li>第一个迭代器指向要删除的第一个元素，第二个迭代器指向要删除的最后一个元素 <strong>之后</strong> 的位置</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119151031191.png" class="" title="image-20240119151031191">

<ul>
<li><strong>clear</strong> 删除容器中所有元素</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119151105553.png" class="" title="image-20240119151105553">

<h3 id="9-3-4-特殊的-forward-list-操作"><a href="#9-3-4-特殊的-forward-list-操作" class="headerlink" title="9.3.4 特殊的 forward_list 操作"></a>9.3.4 特殊的 forward_list 操作</h3><ul>
<li><p>由于 <strong>forward_list 是单向链表</strong>，当添加或删除一个元素时，我们需要访问它的 <strong>前驱</strong>，但在一个单向链表中我们并没有简单的方法获得前驱，因此 <strong>forward_list 提供了一些特殊版本的添加和删除操作</strong></p>
</li>
<li><p>forward_list 定义了 <strong>insert_after、emplace_after 和 erase_after</strong> 操作，都是向后操作</p>
<ul>
<li>为了支持这些操作，还定义了 <strong>before_begin</strong> 返回一个 <strong>首前</strong> 迭代器，指向首元素的前一个不存在的位置</li>
</ul>
</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119151706401.png" class="" title="image-20240119151706401">

<blockquote>
<p>因此，在 forward_list 中添加或删除元素时，我们需要关注两个迭代器：处理的元素及它的前驱</p>
</blockquote>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119151819772.png" class="" title="image-20240119151819772">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119151835982.png" class="" title="image-20240119151835982">

<h3 id="9-3-5-改变容器大小"><a href="#9-3-5-改变容器大小" class="headerlink" title="9.3.5 改变容器大小"></a>9.3.5 改变容器大小</h3><ul>
<li>我们可以使用 <strong>resize</strong> 来增加或缩小容器（array 不支持 resize）<ul>
<li>如果当前大小大于要求的大小，则后边的元素被删除</li>
<li>如果当前大小小于要求的大小，会将新元素添加到容器后（也可以接受一个可选的元素值来初始化新增的元素）</li>
</ul>
</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119152111835.png" class="" title="image-20240119152111835">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119152125794.png" class="" title="image-20240119152125794">

<h3 id="9-3-6-容器操作可能使迭代器失效"><a href="#9-3-6-容器操作可能使迭代器失效" class="headerlink" title="9.3.6 容器操作可能使迭代器失效"></a>9.3.6 容器操作可能使迭代器失效</h3><ul>
<li>向容器中 <strong>添加元素和从容器中删除元素</strong> 的操作可能使指向容器元素的 <strong>指针、引用或迭代器失效</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119152253466.png" class="" title="image-20240119152253466">

<blockquote>
<p>当我们添加或删除元素时，<strong>尾后迭代器总是会失效</strong></p>
<p>由于向迭代器添加或删除元素可能使迭代器失效，因此必须保证每次改变容器的操作之后都正确的 <strong>重新定位迭代器</strong></p>
</blockquote>
<h4 id="编写改变容器的循环程序"><a href="#编写改变容器的循环程序" class="headerlink" title="编写改变容器的循环程序"></a>编写改变容器的循环程序</h4><ul>
<li>必须保证每个循环步中都 <strong>更新</strong> 迭代器、引用和指针</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119152921542.png" class="" title="image-20240119152921542">

<h4 id="不要保存-end-返回的迭代器"><a href="#不要保存-end-返回的迭代器" class="headerlink" title="不要保存 end 返回的迭代器"></a>不要保存 end 返回的迭代器</h4><ul>
<li>原来 end 返回的迭代器总是会失效，因此需要在循环过程中返回调用</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119153038860.png" class="" title="image-20240119153038860">

<h2 id="9-4-vector-对象是如何增长的"><a href="#9-4-vector-对象是如何增长的" class="headerlink" title="9.4 vector 对象是如何增长的"></a>9.4 vector 对象是如何增长的</h2><blockquote>
<p>策略：<strong>当不得不获取新的内存空间时</strong>，vector 和 string 的实现通常会分配比新的空间需求更大的内存空间</p>
</blockquote>
<h4 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h4><ul>
<li><strong>capacity</strong> 操作告诉我们容器在不扩张内存的情况下可以容纳多少个元素</li>
<li><strong>reserve</strong> 操作允许我们通知容器应该准备保存多少个元素</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119153401527.png" class="" title="image-20240119153401527">

<blockquote>
<p>reserve 并不改变容器中元素的数量，仅影响容器预先分配多大的内存空间</p>
<p>只有需要的内存空间超过当前容量时，reserve 才会改变容器的容量，需求量小于当前容量时，什么也不做</p>
</blockquote>
<ul>
<li><strong>shrink_to_fit</strong> 仅仅是请求，不一定保证一定退回内存空间</li>
</ul>
<h4 id="capacity-和-size"><a href="#capacity-和-size" class="headerlink" title="capacity 和 size"></a>capacity 和 size</h4><ul>
<li><strong>size</strong> 是指它已经保存的元素数目，<strong>capacity</strong> 则是在不分配新的内存空间的前提下它最多可以保存多少元素</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119153949464.png" class="" title="image-20240119153949464">

<blockquote>
<p>一个空的 vector 的 size 为 0，显然它的 capacity 也为 0</p>
</blockquote>
<h2 id="9-5-额外的-stirng-操作"><a href="#9-5-额外的-stirng-操作" class="headerlink" title="9.5 额外的 stirng 操作"></a>9.5 额外的 stirng 操作</h2><blockquote>
<p>除了顺序容器共同的操作外，string 还提供了一些额外操作</p>
</blockquote>
<h3 id="9-5-1-构造-string-的其他方法"><a href="#9-5-1-构造-string-的其他方法" class="headerlink" title="9.5.1 构造 string 的其他方法"></a>9.5.1 构造 string 的其他方法</h3><img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119154505375.png" class="" title="image-20240119154505375">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119154607072.png" class="" title="image-20240119154607072">

<ul>
<li>当我们从一个 <strong>const char</strong>* 创建 string 时，指针指向的数组必须以空字符结尾，拷贝到空字符停止</li>
</ul>
<h4 id="substr-操作"><a href="#substr-操作" class="headerlink" title="substr 操作"></a>substr 操作</h4><ul>
<li>返回一个 string，它是原始 stirng 的一部分或全部的拷贝，可以传递一个可选的开始位置和计数值</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119154935662.png" class="" title="image-20240119154935662">

<ul>
<li>如果开始位置加上计数值大于 string 的大小，则 substr 只会拷贝到 string 的末尾（调整了计数值）</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119155050964.png" class="" title="image-20240119155050964">

<h3 id="9-5-2-改变-string-的其他方法"><a href="#9-5-2-改变-string-的其他方法" class="headerlink" title="9.5.2 改变 string 的其他方法"></a>9.5.2 改变 string 的其他方法</h3><ul>
<li>string 还提供了可以 <strong>接受下标的版本的 insert 和 erase</strong>，下标指出了开始删除的位置，或插入到给定值之前的位置</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119155719822.png" class="" title="image-20240119155719822">

<ul>
<li>string 还提供了 <strong>接受 C 风格字符数组的 insert 和 assign</strong> 版本</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160015197.png" class="" title="image-20240119160015197">

<blockquote>
<p>assign 中要求赋值的字符数必须小于等于 cp 指向数组中的字符数（不包括空字符）</p>
</blockquote>
<ul>
<li>也可以指定插入来自其他 string 或 子字符串</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160301990.png" class="" title="image-20240119160301990">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160310843.png" class="" title="image-20240119160310843">

<h4 id="append-和-replace-函数"><a href="#append-和-replace-函数" class="headerlink" title="append 和 replace 函数"></a>append 和 replace 函数</h4><ul>
<li><strong>append</strong> 操作是在 string <strong>末尾进行插入操作</strong> 的一种简写形式</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160416553.png" class="" title="image-20240119160416553">

<ul>
<li><strong>replace</strong> 操作是调用 <strong>erase 和 insert</strong> 的一种简写形式</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160456236.png" class="" title="image-20240119160456236">

<blockquote>
<p>replace 函数中插入的文本可以与删除的文本不一样长</p>
</blockquote>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160559461.png" class="" title="image-20240119160559461">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160609786.png" class="" title="image-20240119160609786">

<h4 id="改变-string-的多种重载函数"><a href="#改变-string-的多种重载函数" class="headerlink" title="改变 string 的多种重载函数"></a>改变 string 的多种重载函数</h4><ul>
<li><p><strong>assign</strong> 总是 <strong>替换</strong> string 中的 <strong>所有内容</strong></p>
</li>
<li><p><strong>append</strong> 总是将新字符 <strong>追加</strong> 到 string <strong>末尾</strong></p>
</li>
<li><p><strong>replace</strong> 提供了两种指定删除元素范围的方式</p>
<ul>
<li>通过一个位置和一个长度指定范围</li>
<li>通过一一个迭代器范围来指定</li>
</ul>
</li>
<li><p><strong>insert</strong> 允许我们用两种方式指定插入点</p>
<ul>
<li>用一个下标或一个迭代器，新元素总会插入到给定下标之前的位置</li>
</ul>
</li>
<li><p>添加到字符串中的字符</p>
<ul>
<li>可以来自一个 string，或来自一个字符指针，此时可以通过一个额外参数控制拷贝字符数目</li>
<li>也可以来自一个花括号包围的字符列表</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果我们希望用迭代器指定位置，就不能用字符指针指定新字符的来源</p>
</blockquote>
<h3 id="9-5-3-string-搜索操作"><a href="#9-5-3-string-搜索操作" class="headerlink" title="9.5.3 string 搜索操作"></a>9.5.3 string 搜索操作</h3><ul>
<li>每个搜索操作都返回一个 <strong>string: :size_type</strong> 值表示匹配发生位置的下标，如果搜索失败，则返回一个 <strong>string: :npos</strong> 的 static 成员，值为 <strong>-1</strong></li>
</ul>
<blockquote>
<p>string 搜索函数返回 string: :size_type 值，是一个 <strong>unsigned</strong> 类型，因此使用一个 int 或其他带符号类型来保存这些返回值不是一个好主意</p>
</blockquote>
<ul>
<li>搜索是大小写敏感的</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162323525.png" class="" title="image-20240119162323525">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162332714.png" class="" title="image-20240119162332714">

<h4 id="指定在哪里开始搜索"><a href="#指定在哪里开始搜索" class="headerlink" title="指定在哪里开始搜索"></a>指定在哪里开始搜索</h4><ul>
<li>传递给 <strong>find</strong> 操作一个可选的开始位置，指定从哪个位置开始进行搜索（默认情况下，该值为 0）</li>
</ul>
<h4 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h4><ul>
<li>find 是从左至右搜索，标准库还提供了从右至左的搜索，<strong>refind</strong> 搜索最后一个匹配</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162544412.png" class="" title="image-20240119162544412">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162558516.png" class="" title="image-20240119162558516">

<ul>
<li>每个操作都接受一个可选的第二参数，可用来指定从什么位置开始搜索</li>
</ul>
<h3 id="9-5-4-compare-函数"><a href="#9-5-4-compare-函数" class="headerlink" title="9.5.4 compare 函数"></a>9.5.4 compare 函数</h3><ul>
<li>根据 s 是等于、大于还是小于参数指定的字符串，<strong>compare 返回 0、正数或负数</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162813917.png" class="" title="image-20240119162813917">

<h3 id="9-5-5-数值转换"><a href="#9-5-5-数值转换" class="headerlink" title="9.5.5 数值转换"></a>9.5.5 数值转换</h3><ul>
<li>要转换为数值的 string 中 <strong>第一个非空白符必须是数值中可能出现的字符</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162935788.png" class="" title="image-20240119162935788">

<blockquote>
<p>string 参数中第一个非空白符必须是 <strong>符号（+ 或 -） 或数字</strong></p>
<p>也可以是 <strong>0x</strong> 开头表示 16 进制数</p>
<p>对于浮点数，可以以 <strong>小数点 .</strong> 开头，并且可以包含 <strong>e</strong> 表示指数部分</p>
<p>对于表示整型值的函数，也可以包含 <strong>字母字符</strong> 表示大于数字 9 的数</p>
</blockquote>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119163458474.png" class="" title="image-20240119163458474">

<h2 id="9-6-容器适配器"><a href="#9-6-容器适配器" class="headerlink" title="9.6 容器适配器"></a>9.6 容器适配器</h2><blockquote>
<p>除了顺序容器外，标准库还定义了三个顺序容器适配器：<strong>stack、queue 和 priority_queue</strong></p>
<p>适配器是一个通用概念，本质上是一种机制，能使某种事物的行为看起来像另一种事物一样</p>
</blockquote>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119163713519.png" class="" title="image-20240119163713519">

<h4 id="定义一个适配器"><a href="#定义一个适配器" class="headerlink" title="定义一个适配器"></a>定义一个适配器</h4><ul>
<li>每个适配器有两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器</li>
<li>默认情况下，<strong>stack 和 queue 是基于 deque 实现的</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119164921544.png" class="" title="image-20240119164921544">

<ul>
<li>我们也可以在创建一个适配器时将一个命名的顺序容器作为第二个参数来重载默认容器类型</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119165006260.png" class="" title="image-20240119165006260">

<ul>
<li><strong>stack</strong> 只要求 <strong>push_back、pop_back 和 back</strong> 操作，因此可以用除了 array 和 forward_list 之外所有容器构造</li>
<li><strong>queue</strong> 只要求 <strong>back、push_back、front 和 push_front</strong>，因此可以构造与 list 或 deque</li>
<li><strong>priority_queue</strong> 除了 <strong>front、push_back 和 pop_back</strong> 操作外，还要求随机访问哪里，因此可以构造与 vector 或 deque</li>
</ul>
<h4 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h4><img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119165354756.png" class="" title="image-20240119165354756">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119165406885.png" class="" title="image-20240119165406885">

<blockquote>
<p>我们只能使用适配器操作，而不能使用底层容器类型的操作</p>
</blockquote>
<h4 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h4><img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119165504986.png" class="" title="image-20240119165504986">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119165514487.png" class="" title="image-20240119165514487">

<ul>
<li><strong>queue</strong> 使用一种 <strong>先进先出（first-in，first-out，FIFO）</strong> 的存储和访问策略</li>
<li>进入队列的对象被放置在队尾，离开队列的对象则从队首删除</li>
<li><strong>priority_queue</strong> 允许我们为队列中的元素建立 <strong>优先级</strong>，新加入的元素会排在所有优先级比它低的已有元素之前</li>
<li>默认情况下，标准库在元素类型上使用 <strong>&lt; 运算符</strong> 来确定相对优先级</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/19/8-IO%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/19/8-IO%E5%BA%93/" class="post-title-link" itemprop="url">C++Primer-8-IO库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-19 10:00:08" itemprop="dateCreated datePublished" datetime="2024-01-19T10:00:08+08:00">2024-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-20 17:50:06" itemprop="dateModified" datetime="2024-01-20T17:50:06+08:00">2024-01-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-IO-库"><a href="#8-IO-库" class="headerlink" title="8 IO 库"></a>8 IO 库</h1><blockquote>
<p>我们之前已经使用过的 IO 类型和对象都是操作 char 数据的</p>
<p>默认情况下，这些对象都是关联到用户的控制台窗口的</p>
<p>当然，我们不能仅通过控制台窗口进行 IO 操作，应用程序常常需要读写文件</p>
<p>而且，使用 IO 操作处理 string 中的字符会很方便</p>
</blockquote>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119100804465.png" class="" title="image-20240119100804465">

<h2 id="8-1-IO-类"><a href="#8-1-IO-类" class="headerlink" title="8.1 IO 类"></a>8.1 IO 类</h2><blockquote>
<p><strong>iostream</strong> 定义了用于读写流的基本类型</p>
<p><strong>fstream</strong> 定义了读写命名文件的类型</p>
<p><strong>sstream</strong> 定义了读写内存 string 对象的类型</p>
</blockquote>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119100831652.png" class="" title="image-20240119100831652">

<ul>
<li>为了支持使用宽字符的语言，标准库也定义了一组类型和对象来操作 wchar_t 类型的数据</li>
</ul>
<h4 id="IO-类型间的关系"><a href="#IO-类型间的关系" class="headerlink" title="IO 类型间的关系"></a>IO 类型间的关系</h4><ul>
<li>标准库使我们能忽略不同类型之间的差异，是通过 <strong>继承机制</strong>，我们通常可以将一个派生类对象当作其基类对象来使用</li>
<li>而类型 ifstream 和 istringstream 都继承自 istream，因此可以像使用 istream 对象一样来使用它们</li>
</ul>
<h3 id="8-1-1-IO-对象无拷贝或赋值"><a href="#8-1-1-IO-对象无拷贝或赋值" class="headerlink" title="8.1.1 IO 对象无拷贝或赋值"></a>8.1.1 IO 对象无拷贝或赋值</h3><blockquote>
<p>我们不能对 IO 对象拷贝或赋值，进行 IO 操作的函数通常以 <strong>引用</strong> 方式传递和返回流</p>
</blockquote>
<h3 id="8-1-2-条件状态"><a href="#8-1-2-条件状态" class="headerlink" title="8.1.2 条件状态"></a>8.1.2 条件状态</h3><ul>
<li>IO 操作一个与生俱来的问题是可能发生错误，一些错误是可修复的，而其他错误已经超出应用程序可修正的范围</li>
<li>IO 类定义了一些函数和标志，可以帮助我们访问和操纵流的 <strong>条件状态</strong></li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119101713080.png" class="" title="image-20240119101713080">

<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119101721718.png" class="" title="image-20240119101721718">

<ul>
<li>由于流可能处于错误状态，因此代码通常应该 <strong>在使用一个流之前检查</strong> 它是否处于良好的状态</li>
<li>确定一个流对象的状态的最简单方法是将它当作一个条件使用：</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119101927320.png" class="" title="image-20240119101927320">

<h4 id="查询流的状态"><a href="#查询流的状态" class="headerlink" title="查询流的状态"></a>查询流的状态</h4><ul>
<li><p><strong>badbit</strong>：表示系统级错误，一旦被置位，流就无法再使用了</p>
</li>
<li><p><strong>failbit</strong>：发生可恢复错误后，failbit 被置位，比如期望读取一个 int 却读取了一个字符；修正后，流还可以继续使用</p>
</li>
<li><p><strong>eofbit</strong>：到达文件结束位置后被置位，failbit 此时也会被置位</p>
</li>
<li><p><strong>goodbit</strong>：值为 0 表示流未发生错误</p>
</li>
<li><p>使用 <strong>good</strong> 和 <strong>fail</strong> 是确定流的 <strong>总体状态</strong> 的正确方法</p>
</li>
</ul>
<h4 id="管理条件状态"><a href="#管理条件状态" class="headerlink" title="管理条件状态"></a>管理条件状态</h4><img src="/2024/01/19/8-IO%E5%BA%93/image-20240119102904908.png" class="" title="image-20240119102904908">

<ul>
<li>下面代码将 failbit 和 badbit 复位，但保持 eofbit 不变：</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119102952003.png" class="" title="image-20240119102952003">

<h3 id="8-1-3-管理输出缓冲"><a href="#8-1-3-管理输出缓冲" class="headerlink" title="8.1.3 管理输出缓冲"></a>8.1.3 管理输出缓冲</h3><ul>
<li><p>每个输入流都管理严格缓冲区，用来保存程序读写的数据，文本可能立即打印，也可能保存在缓冲区</p>
</li>
<li><p>由于设别的写操作可能很耗时，缓冲区允许操作系统将对各输出操作组合为单一的设备写操作，可以带来很大的性能提升</p>
</li>
<li><p>导致缓冲区刷新的原因：</p>
</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119103417735.png" class="" title="image-20240119103417735">

<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119103428573.png" class="" title="image-20240119103428573">

<h4 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h4><ul>
<li><strong>flush</strong>：刷新缓冲区，但不输出任何额外的字符</li>
<li><strong>ends</strong>：向缓冲区插入一个空字符，然后刷新缓冲区</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119103708247.png" class="" title="image-20240119103708247">

<h4 id="unitbuf-操纵符"><a href="#unitbuf-操纵符" class="headerlink" title="unitbuf 操纵符"></a>unitbuf 操纵符</h4><ul>
<li>使用 <strong>unitbuf</strong> 操作符告诉刘在接下来的每次写操作之后都进行一次 flush 操作</li>
<li>而 <strong>nounitbuf</strong> 操纵符则重置流，恢复正常的系统管理的缓冲区刷新机制</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119103922615.png" class="" title="image-20240119103922615">

<blockquote>
<p>如果程序异常终止，输出缓冲区是不会刷新的，当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印</p>
<p>所以当调试一个已经崩溃的程序时，你需要确认你认为已经输出的数据确实已经刷新了</p>
</blockquote>
<h4 id="关联输入和输出流"><a href="#关联输入和输出流" class="headerlink" title="关联输入和输出流"></a>关联输入和输出流</h4><ul>
<li><p>默认情况下，标准库将 cout 和 cin 关联在一起，所以 <code>cin &gt;&gt; val</code> 总是导致 cout 的缓冲区被刷新</p>
<blockquote>
<p>这在交互式系统中很有用，意味着所有输出总可以在读操作之前被打印出来</p>
</blockquote>
</li>
<li><p><strong>tie</strong> 有两个版本</p>
<ul>
<li>不带参数，返回指向的输出流的指针，如果没有关联，返回空指针，如果有，则返回本对象关联到的输出流的指针</li>
<li>带参数，接受一个 ostream 指针，将自己关联到 ostream</li>
</ul>
</li>
<li><p>我们可以通过 tie 将一个 istream 对象关联到另一个 ostream，也可以将一个 ostream 关联到另一个 ostream：</p>
</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119105058004.png" class="" title="image-20240119105058004">

<ul>
<li>每个流同时最多关联到一个流，但多个流可以同时关联到同一个 ostream</li>
</ul>
<h2 id="8-2-文件输入输出"><a href="#8-2-文件输入输出" class="headerlink" title="8.2 文件输入输出"></a>8.2 文件输入输出</h2><blockquote>
<p><strong>ifstream</strong>：从一个给定文件读取数据</p>
<p><strong>ostream</strong>：向一个给定文件写入数据</p>
</blockquote>
<ul>
<li>这些类型提供了和 cin、cout 一样的操作，还定义了一些新的成员来管理与流关联的文件：</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119105430658.png" class="" title="image-20240119105430658">

<h3 id="8-2-1-使用文件流对象"><a href="#8-2-1-使用文件流对象" class="headerlink" title="8.2.1 使用文件流对象"></a>8.2.1 使用文件流对象</h3><ul>
<li>创建文件流对象时，如果提供了一个文件名，则 <strong>open</strong> 会自动被调用</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119105603344.png" class="" title="image-20240119105603344">

<h4 id="成员函数-open-和-close"><a href="#成员函数-open-和-close" class="headerlink" title="成员函数 open 和 close"></a>成员函数 open 和 close</h4><ul>
<li>如果 open 调用失败，failit 会被置位，因此进行 open 是否成功的检测是一个好习惯</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119105807954.png" class="" title="image-20240119105807954">

<ul>
<li>实际上，对于一个已经打开的文件流调用 open 也会失败，导致 failbit 被置位</li>
</ul>
<h4 id="自动构造和析构"><a href="#自动构造和析构" class="headerlink" title="自动构造和析构"></a>自动构造和析构</h4><ul>
<li>当一个 fstream 对象离开其作用域时，与之关联的文件会自动关闭，即 <strong>当一个 fstream 对象被销毁时，close 会被自动调用</strong></li>
</ul>
<h3 id="8-2-2-文件模式"><a href="#8-2-2-文件模式" class="headerlink" title="8.2.2 文件模式"></a>8.2.2 文件模式</h3><ul>
<li>每个流都有一个与之关联的 <strong>文件模式</strong></li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119110130994.png" class="" title="image-20240119110130994">

<ul>
<li>指定文件模式的限制：</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119110245075.png" class="" title="image-20240119110245075">

<ul>
<li>每个文件流类型都有一个默认的文件模式，ifstream 为 in，ofstream 为 out，fstream 为 in 和 out</li>
</ul>
<h4 id="以-out-模式打开文件会丢弃已有数据"><a href="#以-out-模式打开文件会丢弃已有数据" class="headerlink" title="以 out 模式打开文件会丢弃已有数据"></a>以 out 模式打开文件会丢弃已有数据</h4><ul>
<li>默认情况下，以 out 打开的文件也会有 <strong>trunc 截断模式</strong>，阻止一个 ostream 清空给定文件内容的方法是指定 <strong>app 模式</strong></li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119110631551.png" class="" title="image-20240119110631551">

<h4 id="每次调用-open-时都会确定文件模式"><a href="#每次调用-open-时都会确定文件模式" class="headerlink" title="每次调用 open 时都会确定文件模式"></a>每次调用 open 时都会确定文件模式</h4><img src="/2024/01/19/8-IO%E5%BA%93/image-20240119110756988.png" class="" title="image-20240119110756988">

<h2 id="8-3-string-流"><a href="#8-3-string-流" class="headerlink" title="8.3 string 流"></a>8.3 string 流</h2><blockquote>
<p><strong>istringstream</strong>：从 string 读取数据</p>
<p><strong>ostringstream</strong>：向 string 写入数据</p>
<p><strong>stringstream</strong>：既可以从 string 读取数据也可以向 string 写入数据</p>
</blockquote>
<ul>
<li>除了继承自 iostream 的操作，还有一些特有的成员来关联与流相关联的 string：</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119111025023.png" class="" title="image-20240119111025023">

<h3 id="8-3-1-使用-istringstream"><a href="#8-3-1-使用-istringstream" class="headerlink" title="8.3.1 使用 istringstream"></a>8.3.1 使用 istringstream</h3><ul>
<li>当我们的某些工作是对整个文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用 istringstream</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119111407277.png" class="" title="image-20240119111407277">

<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119111420472.png" class="" title="image-20240119111420472">

<h3 id="8-3-2-使用-ostringstream"><a href="#8-3-2-使用-ostringstream" class="headerlink" title="8.3.2 使用 ostringstream"></a>8.3.2 使用 ostringstream</h3><ul>
<li>当我们希望逐步构造输出，对吼一起打印时，ostringstream 是很有用的</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119111545554.png" class="" title="image-20240119111545554">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">C++Primer-11-关联容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-18 10:58:12" itemprop="dateCreated datePublished" datetime="2024-01-18T10:58:12+08:00">2024-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-25 11:11:20" itemprop="dateModified" datetime="2024-01-25T11:11:20+08:00">2024-01-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="11-关联容器"><a href="#11-关联容器" class="headerlink" title="11 关联容器"></a>11 关联容器</h1><blockquote>
<p>关联容器支持高效的关键字查找和访问</p>
<p>两个主要的关联容器类型是 <strong>map</strong> 和 <strong>set</strong></p>
<p>map 中的元素是一些关键字 - 值（<strong>key - value</strong>）对：关键字起到索引作用，值则表示与索引相关联的数据</p>
<p>set 中每个元素只包含一个关键字：set 支持高效的关键字查询查找，检测一个给定关键字是否在 set 中</p>
</blockquote>
<h2 id="关联容器的分类"><a href="#关联容器的分类" class="headerlink" title="关联容器的分类"></a>关联容器的分类</h2><ul>
<li>或者是一个 <strong>set</strong>，或者是一个 <strong>map</strong></li>
<li>或者要求 <strong>不重复关键字</strong>，或者 <strong>允许重复关键字</strong>（<strong>允许重复关键字</strong> 的容器的名字中都包含单词 <strong>multi</strong>）</li>
<li>按 <strong>顺序</strong> 保存元素，或 <strong>无序</strong> 保存（<strong>无序保存</strong> 的容器的名字都以单词 <strong>unordered</strong> 开头）</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118122020151.png" class="" title="image-20240118122020151">

<h2 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h2><h3 id="使用map"><a href="#使用map" class="headerlink" title="使用map"></a>使用map</h3><img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118122100732.png" class="" title="image-20240118122100732">

<ul>
<li>**map **类型通常被称为 <strong>关联数组</strong>，和正常数组不同之处在于 <strong>我们通过一个关键字而不是位置来查找值</strong></li>
<li>**set **就是关键字的简单集合</li>
<li>类似的，关联容器也是模板，定义一个关联容器必须指定 key 和 value 的类型（set 仅仅指定 key 类型）</li>
<li>当对通过 key 对 map 进行 <strong>下标</strong> 操作时，如果还没有对应元素，则通过这个 key 创建并对 value 进行值初始化</li>
<li>当从 map 中提取一个元素时，会得到一个 <strong>pair 类型的对象</strong><ul>
<li>pair 是一个模板类型，保存两个 <strong>public</strong> 成员 <strong>first 和 second</strong>，first 保存 key，second 保存 对应的 value</li>
</ul>
</li>
</ul>
<h3 id="使用set"><a href="#使用set" class="headerlink" title="使用set"></a>使用set</h3><img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118122148226.png" class="" title="image-20240118122148226">

<ul>
<li><p>set 也是模板，定义是必须指定其元素（key）类型	</p>
</li>
<li><p>可以对一个关联容器的元素进行列表初始化</p>
</li>
<li><p>**find **调用返回一个迭代器，指向该关键字，否则返回尾后迭代器</p>
</li>
</ul>
<h2 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h2><blockquote>
<p>关联容器不存在顺序容器的位置相关操作，原因是关联容器中的元素是根据关键字顺序存储的</p>
<p>关联容器也不支持接受一个元素值和一个数量值的构造函数或插入操作</p>
<p>无序容器还提供了一些调整哈希性能的操作</p>
</blockquote>
<h3 id="11-2-1-定义关联容器"><a href="#11-2-1-定义关联容器" class="headerlink" title="11.2.1 定义关联容器"></a>11.2.1 定义关联容器</h3><ul>
<li>定义一个关联容器时，需要指定 <strong>key 和 value</strong> 或 <strong>key</strong> 的类型</li>
<li>每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器<ul>
<li>我们可以将关联容器初始化为 <strong>另一个同类型关联容器的拷贝</strong></li>
<li>或者通过一个 <strong>值范围来初始化关联容器</strong>（前提是这些值可以转换为容器指定类型）</li>
<li>我们也可以对关联容器进行 <strong>值表初始化</strong></li>
</ul>
</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118122235417.png" class="" title="image-20240118122235417">

<h4 id="初始化-multimap-或-multiset"><a href="#初始化-multimap-或-multiset" class="headerlink" title="初始化 multimap 或 multiset"></a>初始化 multimap 或 multiset</h4><ul>
<li>map 和 set 中的关键字必须唯一，multimap 和 multiset 没有这个限制，允许多个元素有相同的 key</li>
</ul>
<h3 id="11-2-2-关键字类型的要求"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a>11.2.2 关键字类型的要求</h3><ul>
<li>关联容器的 key <strong>必须定义元素比较的方法</strong>，默认情况下，<strong>标准库使用 key 类型的 &lt; 运算符比较两个 key</strong></li>
</ul>
<h4 id="有序容器的关键字类型"><a href="#有序容器的关键字类型" class="headerlink" title="有序容器的关键字类型"></a>有序容器的关键字类型</h4><ul>
<li>我们也可以提供一个自定义的比较操作来代替 key 上的 &lt; 运算符，所提供的操作必须在 key 类型上定义一个 <strong>严格弱序</strong>，可以将严格弱序看作 <strong>小于等于</strong></li>
</ul>
<h4 id="使用关键字类型的比较函数"><a href="#使用关键字类型的比较函数" class="headerlink" title="使用关键字类型的比较函数"></a>使用关键字类型的比较函数</h4><ul>
<li>如果我们想自定义关联容器的比较操作，则自定义操作的类型必须在定义关联容器类型时提供（在 &lt;&gt; 内紧跟元素类型给出）</li>
<li>比较操作的类型应该是一种 <strong>函数指针类型</strong><ul>
<li>当使用 <strong>decltype</strong> 来获得严格函数指针类型时，必须加上 * 来指出函数类型的指针</li>
<li>使用函数名时，需要的情况下它会自动转换为一个指针（有例外，比如 decltype）</li>
</ul>
</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118122343840.png" class="" title="image-20240118122343840">

<h3 id="11-2-3-pair类型"><a href="#11-2-3-pair类型" class="headerlink" title="11.2.3 pair类型"></a>11.2.3 pair类型</h3><ul>
<li>类似容器，pair 是一个模板，一个 pair 保存两个数据成员，都是 public 的</li>
<li>创建一个 pair 时，必须提供两个类型，即 pair 的数据成员将具有的类型，两个类型不要求一样</li>
<li>pair 的默认构造函数对数据成员进行值初始化</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118122827320.png" class="" title="image-20240118122827320">

<h4 id="创建-pair-对象的函数"><a href="#创建-pair-对象的函数" class="headerlink" title="创建 pair 对象的函数"></a>创建 pair 对象的函数</h4><ul>
<li>我们可以使用 <strong>初始化列表、隐式构造返回值</strong> 进行初始化</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118123210870.png" class="" title="image-20240118123210870">

<ul>
<li>也可以 <strong>显示构造返回值</strong></li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118123225069.png" class="" title="image-20240118123225069">

<ul>
<li>还可以使用 <strong>make_pair</strong> 来生成 pair 对象</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118123233531.png" class="" title="image-20240118123233531">

<h2 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h2><ul>
<li>关联容器中表示 key 和 value 的类型</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118134643464.png" class="" title="image-20240118134643464">

<ul>
<li>我们可以通过作用域运算符来提取一个类型的成员 <code>map&lt;string, int&gt;::key_type</code></li>
</ul>
<h3 id="11-3-1-关联容器迭代器"><a href="#11-3-1-关联容器迭代器" class="headerlink" title="11.3.1 关联容器迭代器"></a>11.3.1 关联容器迭代器</h3><ul>
<li>当解引用一个关联容器迭代器时，会得到一个类型为容器的 value_type 的值的引用<ul>
<li>对 map 而言，**value_type ** 是一个 **pair **类型，first保存 key，second 保存 value（我们可以改变 pair 的值，但不能改变 key 成员的值）</li>
<li>对 set 而言，value_type 和 key_type 都是 key</li>
</ul>
</li>
</ul>
<h4 id="set-的迭代器是-const-的"><a href="#set-的迭代器是-const-的" class="headerlink" title="set 的迭代器是 const 的"></a>set 的迭代器是 const 的</h4><ul>
<li>set 虽然同时定义了 iterator 和 const_iterator 类型，但都只允许只读访问 set 中的元素</li>
<li>一个 set 中的关键字也是 const 的，不能修改</li>
</ul>
<h4 id="遍历关联容器"><a href="#遍历关联容器" class="headerlink" title="遍历关联容器"></a>遍历关联容器</h4><ul>
<li>map 和 set 类型都支持 begin 和 end 操作</li>
<li>遍历 map、multimap、set、multiset 时，迭代器按照关键字升序遍历元素</li>
</ul>
<h4 id="关联容器和算法"><a href="#关联容器和算法" class="headerlink" title="关联容器和算法"></a>关联容器和算法</h4><ul>
<li>我们通常不对关联容器使用泛型算法，因为关键字是 <strong>const</strong> 的这一属性意味着我们不能将关联容器传给修改或排序的算法</li>
<li>我们通常也不会对关联容器使用只读元素的算法（即使可以使用），使用关联容器定义的 find 会比泛型 find <strong>快得多</strong></li>
<li>如果真的要对关联容器使用算法，通常是把它当作一个 <strong>源序列</strong> 或 <strong>目的位置</strong></li>
</ul>
<h3 id="11-3-2-添加元素"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a>11.3.2 添加元素</h3><ul>
<li>使用 insert 操作对关联容器插入一个已存在的元素没有任何影响</li>
</ul>
<h4 id="向-map-添加元素"><a href="#向-map-添加元素" class="headerlink" title="向 map 添加元素"></a>向 map 添加元素</h4><ul>
<li>对 map 进行 insert 操作时，必须记住元素类型是 pair，可以在 insert 的参数列表中创建一个 pair</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118140723915.png" class="" title="image-20240118140723915">

<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118140745901.png" class="" title="image-20240118140745901">

<h4 id="检测-insert-的返回值"><a href="#检测-insert-的返回值" class="headerlink" title="检测 insert 的返回值"></a>检测 insert 的返回值</h4><ul>
<li>insert 的返回值依赖于容器类型和参数，对于不包含重复关键字的容器，insert 返回一个pair<ul>
<li>pair 的 first 成员是一个迭代器，指向给定关键字的元素</li>
<li>second 成员是一个 bool 值，指出元素是插入成功还是失败（已经存在）</li>
</ul>
</li>
</ul>
<h4 id="向-multiset-或-multimap-添加元素"><a href="#向-multiset-或-multimap-添加元素" class="headerlink" title="向 multiset 或 multimap 添加元素"></a>向 multiset 或 multimap 添加元素</h4><ul>
<li>由于关键字不必唯一，所以总是会插入一个元素</li>
<li>insert 操作返回一个指向新元素的迭代器</li>
</ul>
<h3 id="11-3-3-删除元素"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a>11.3.3 删除元素</h3><ul>
<li>通过传递给 erase 一个 迭代器 或一个 迭代器对 来删除 一个元素 或 一个元素范围，都返回 void</li>
<li>关联容器还提供一个额外的 erase 操作，接受一个 key_type 参数，删除所有匹配给定关键字的元素，返回实际删除的元素的数量</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118141614325.png" class="" title="image-20240118141614325">

<h3 id="11-3-4-map-的下标操作"><a href="#11-3-4-map-的下标操作" class="headerlink" title="11.3.4 map 的下标操作"></a>11.3.4 map 的下标操作</h3><ul>
<li>map 和 unordered_map 容器提供了下标运算符和 对应的 at 函数</li>
<li>set 类型不支持下标，因为 set 中没有与关键字对应的值</li>
<li>我们不能对一个 multimap 或一个 unordered_multimap 进行下标操作，因为它们有多个值与一个关键字相关联</li>
<li>进行下标操作时，如果关键字不在 map 中，会为它创建一个元素并插入到 map 中，关联值进行值初始化</li>
<li>由于下标运算符可能会插入一个新的元素，因此只可以对非 const 的 map 使用下标操作</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118142048699.png" class="" title="image-20240118142048699">

<h4 id="使用下标操作的返回值"><a href="#使用下标操作的返回值" class="headerlink" title="使用下标操作的返回值"></a>使用下标操作的返回值</h4><ul>
<li>当对一个 map 进行下标操作时，会得到一个 mapped_type 对象，但当解引用一个 map 迭代器时，会的得到一个 value_type 对象</li>
<li>map 的下标运算符返回一个 <strong>左值</strong></li>
</ul>
<h3 id="11-3-5-访问元素"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素</h3><img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118142412315.png" class="" title="image-20240118142412315">

<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118142426165.png" class="" title="image-20240118142426165">

<h4 id="对-map-使用-find-代替下标操作"><a href="#对-map-使用-find-代替下标操作" class="headerlink" title="对 map 使用 find 代替下标操作"></a>对 map 使用 find 代替下标操作</h4><ul>
<li>如果我们只是想知道一个给定关键字是否早 map 中，而不想改变 map，使用 find 是最合适的</li>
</ul>
<h4 id="在-multimap-或-multiset-中查找元素"><a href="#在-multimap-或-multiset-中查找元素" class="headerlink" title="在 multimap 或 multiset 中查找元素"></a>在 multimap 或 multiset 中查找元素</h4><ul>
<li>使用 **find **和 <strong>count</strong>：</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118142712195.png" class="" title="image-20240118142712195">

<ul>
<li>使用 **lower_bound **和 <strong>upper_bound</strong>：<ul>
<li>lower_bound 返回迭代器指向第一个具有给定关键字的元素，upper_bound 则返回指向最后一个匹配的元素之后的位置</li>
<li>如果没有找到，则它们都指向一个不影响排序的关键字插入位置</li>
</ul>
</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118142756475.png" class="" title="image-20240118142756475">

<ul>
<li>使用 <strong>equal_range</strong>：<ul>
<li>接受一个关键字，返回一个 pair 对象</li>
<li>pair 的 first 成员和 lower_bound 一样，second 成员和 upper_bound 一样</li>
</ul>
</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118143238859.png" class="" title="image-20240118143238859">

<h3 id="11-3-6-一个单词转换的-map"><a href="#11-3-6-一个单词转换的-map" class="headerlink" title="11.3.6 一个单词转换的 map"></a>11.3.6 一个单词转换的 map</h3><h4 id="单词转换程序"><a href="#单词转换程序" class="headerlink" title="单词转换程序"></a>单词转换程序</h4><img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118143347356.png" class="" title="image-20240118143347356">

<h4 id="建立转换映射"><a href="#建立转换映射" class="headerlink" title="建立转换映射"></a>建立转换映射</h4><img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118143409269.png" class="" title="image-20240118143409269">

<h4 id="生成转换文本"><a href="#生成转换文本" class="headerlink" title="生成转换文本"></a>生成转换文本</h4><img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118143432773.png" class="" title="image-20240118143432773">

<h2 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h2><blockquote>
<p>定义了 4 个无序关联容器</p>
<p>这些容器不是使用比较运算符来组织元素，而是使用一个 <strong>哈希函数</strong> 和关键字类型的 <strong>&#x3D;&#x3D; 运算符</strong></p>
</blockquote>
<h3 id="使用无序容器"><a href="#使用无序容器" class="headerlink" title="使用无序容器"></a>使用无序容器</h3><ul>
<li>无序容器还提供了与有序容器相同的操作，因此常常可以用一个无序容器替换对应的有序容器（但元素未按顺序存储），反之亦然</li>
</ul>
<h3 id="管理桶"><a href="#管理桶" class="headerlink" title="管理桶"></a>管理桶</h3><ul>
<li>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素</li>
<li>无序容器使用一个哈希函数将元素映射到桶，因此无序容器的性能依赖于哈希函数的质量和桶的数量和大小</li>
<li>无序容器还提供了允许我们查询容器状态及在必要时强制容器进行重组的操作：</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118144117524.png" class="" title="image-20240118144117524">

<h3 id="无序容器对关键字类型的要求"><a href="#无序容器对关键字类型的要求" class="headerlink" title="无序容器对关键字类型的要求"></a>无序容器对关键字类型的要求</h3><ul>
<li>默认情况下，无序容器使用关键字类型的 &#x3D;&#x3D; 运算符来比较元素，还使用一个 hash<key_type> 类型的对象来生成每个元素的哈希值</li>
<li>标准库为内置类型（包括指针）、标准库类型（包括 string 和智能指针类型）定义了 hash，因此我们可以直接定义这些类型的无序容器</li>
<li>但我们不能直接定义关键字类型为自定义类类型的无序容器<ul>
<li>我们需要提供函数来替代 &#x3D;&#x3D; 运算符和哈希值计算函数（如果我们的类已经定义了 &#x3D;&#x3D; 运算符，则可以只重载哈希函数）</li>
</ul>
</li>
</ul>
<img src="/2024/01/18/11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/image-20240118144743581.png" class="" title="image-20240118144743581">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/17/CSAPP-Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/17/CSAPP-Lab1/" class="post-title-link" itemprop="url">CSAPP-Lab1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-17 19:45:22" itemprop="dateCreated datePublished" datetime="2024-01-17T19:45:22+08:00">2024-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-01 22:51:26" itemprop="dateModified" datetime="2024-02-01T22:51:26+08:00">2024-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><strong>bits.c</strong> 文件是我们需要进行修改和编写的文件</li>
<li><strong>btest.c</strong> 是编译并检测我们代码（<strong>bits.c</strong> 文件）</li>
<li>每次修改 <strong>bits.c</strong> 文件后，我们都需要保存 <strong>CTRL + S</strong>，然后在命令行终端输入 <strong>make btest</strong> 重新进行编译生成新的可执行文件</li>
<li>通过 <strong>.&#x2F;btest -f function</strong> 来检测某个函数的正确性（<strong>function</strong> 为函数名）</li>
<li>通过 <strong>.&#x2F;btest</strong> 测试所有函数的正确性</li>
<li>通过 <strong>.&#x2F;dlc -e bits.c</strong> 打印每个函数使用的运算符数目</li>
</ul>
<h1 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要求：<strong>^</strong> 表示与非，仅使用 <strong>~ 取反</strong> 和 <strong>&amp; 与</strong> 来实现 <strong>^ 与非</strong></li>
<li><strong>^</strong> 的特性为：x 和 y 只有一个为 1 时才为 1，否则为 0，即可以表示为 <code>x^y = (~x &amp; y) | (x &amp; ~y)</code></li>
<li>因为仅可以使用 ~ 和 &amp;，我们通过公式法可以转换为：<ul>
<li><code>(~x &amp; y) | (x &amp; ~y)</code> &#x3D; <code>~(~(~x &amp; y) &amp; ~(x &amp; ~y))</code></li>
<li>也可以这样想，<code>(~x &amp; y) | (x &amp; ~y)</code> &#x3D; <code>(~x | ~y) &amp; (x | y)</code> &#x3D; <code>~(x &amp; y) &amp; ~(~x &amp; ~y)</code></li>
<li>原理：<strong>与非 &#x3D; 非 的 或 | 或非 &#x3D; 非 的 与</strong>（当然，也可以扩展为 <strong>或 &#x3D; 非 的 与非 | 与 &#x3D; 非 的 或非</strong>）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(x &amp; ~y) &amp; ~(~x &amp; y));</span><br><span class="line">  <span class="comment">// return ~(x &amp; y) &amp; ~(~x &amp; ~y);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要求：返回 <strong>32 位二进制中的最小数</strong>，仅可以使用 <strong>! 逻辑非、~ 取反、&amp; 与、^ 异或、| 或、+ 加法、&lt;&lt; 左移、&gt;&gt; 右移</strong> 来实现</li>
<li><strong>32 位二进制中的最小数</strong> 的位模式为 <strong>100……00</strong>，即符号位为 1 表示负数，其他位全为 0</li>
<li>1 的位模式为 <strong>00……01</strong>，我们可以通过将 1 <strong>左移 31</strong> 位来得到最小数 <strong>100……00</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="isTMax"><a href="#isTMax" class="headerlink" title="isTMax"></a>isTMax</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：如果 x 是 32 位二进制中最大数，返回 1，否则返回 0，仅可以使用 <strong>!  ~  &amp;  ^  +</strong> 来实现</p>
</li>
<li><p>32 位二进制中的最大数的位模式为 <strong>011……11</strong>，我们可以发现它有一些特殊特性：</p>
<ul>
<li><strong>011……11</strong> 加 1 得到 <strong>100……00</strong>，我们将这两个数相加又得到 <strong>11……11</strong></li>
<li>我们将 <strong>11……11</strong> 取反得到 <strong>00……00</strong>，这好像是其他数所没有的！</li>
</ul>
</li>
<li><p>然而，<strong>11……11</strong> 也有这样的特性</p>
<ul>
<li><strong>11……11</strong> 加 1 得到 <strong>00……00</strong>，这两个数相加也会得到 <strong>11……11</strong></li>
</ul>
</li>
<li><p>通过分析，我们又发现 <strong>11……11</strong> 有一些真正的且唯一的特殊特性：</p>
<ul>
<li>我们将 <strong>11……11</strong> 取反得到 <strong>00……00</strong>，在进行逻辑非 <strong>!</strong> ，就会得到 0，而其他数经过这样的操作都会得到 1</li>
<li>注：逻辑非 <strong>!</strong> 的作用为 <strong>将不为 0 的数转为 0，将 0 转为 1</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = x + <span class="number">1</span>; 	<span class="comment">// 得到 10……0 | 00……0 | 其他情况下的非零值</span></span><br><span class="line">  x = ~(x + y); 	<span class="comment">// 得到 00……0 | 其他情况下的非零值</span></span><br><span class="line">  y = !y; 			<span class="comment">// 排除 x = 11……1 的情况，如果是，则此时 y = !0 = 1 ，其他情况下 y = !非零值 = 0</span></span><br><span class="line">  x = x + y; 		<span class="comment">// 排村 x = 11……1 的情况，如果是，则此时 x = 0 + 1 = 1，</span></span><br><span class="line">    				<span class="comment">// 而对于 x = 0……11，此时 x = 0 + 0 = 0，当然其他情况为 x = 非零值 + 0 = 非零值</span></span><br><span class="line">  <span class="keyword">return</span> !x; 		<span class="comment">// 返回，x = 01……1 时，返回 !x = !0 = 1，x = 11……1 时，返回 !x = !1 = 0，</span></span><br><span class="line">    				<span class="comment">// 而其他情况，返回 x = !非零值 = 0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 另一种写法，好像更容易理解一些</span></span><br><span class="line">  <span class="comment">// !(~(x + x + 1) 筛选得到 x = 01……11 和 x = 11……11 的情况，!!(~x) 排除 x = 11……1 的情况</span></span><br><span class="line">  <span class="comment">// return !(~(x + x + 1)) &amp; !!(~x);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一种方法，真值表：</li>
</ul>
<table>
<thead>
<tr>
<th>x</th>
<th>011……11</th>
<th>11……11</th>
<th>其他情况</th>
</tr>
</thead>
<tbody><tr>
<td>y &#x3D; x + 1</td>
<td>100……00</td>
<td>00……00</td>
<td>未知值</td>
</tr>
<tr>
<td>x &#x3D; ~(x + y)</td>
<td>00……00</td>
<td>00……00</td>
<td>非零值</td>
</tr>
<tr>
<td>y &#x3D; ! y</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>x &#x3D; x + y</td>
<td>0</td>
<td>1</td>
<td>非零值</td>
</tr>
<tr>
<td>! x</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<ul>
<li>第二种方法，真值表：</li>
</ul>
<table>
<thead>
<tr>
<th>x</th>
<th>011……11</th>
<th>11……11</th>
<th>其他情况</th>
</tr>
</thead>
<tbody><tr>
<td>! (~x + x + 1)</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>! ! (~x)</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>&amp;</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：如果 32 位二进制数的奇数位全为 1，返回 1，否则返回 0，仅通过 <strong>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</p>
</li>
<li><p>如果一个数的奇数位全为 1，那么如果我们把它的偶数位也全变为 1，那么就得到了 <strong>11……11</strong>，我们再将它取反再取非，就得到了1，这是奇数位全为 1 的数的特殊特性！其他情况下都会得到 0！</p>
<ul>
<li>那么我们将它的偶数位全部置为 1 呢？我们可以通过与掩码 <strong>0101……0101（16 进制为 0X55……55）</strong> 进行 <strong>或</strong> 操作来实现</li>
<li>那么如何得到 <strong>0X55……55</strong> 呢？我们可以先将 0X55 左移 8 位，再加上 0X55 得到 0X5555，再将 0X5555 左移 16 位加上 0X5555 就得到了 0X55555555 了</li>
</ul>
</li>
<li><p>还有一种思路，我们将这个数的偶数位全都置为 0，再检测它的奇数位是否都为 1</p>
<ul>
<li>如何将它的偶数位全置为 0 呢？通过与掩码 <strong>1010……1010（16进制为 0XAA……AA）</strong> 进行 <strong>与</strong> 操作来实现<ul>
<li>0XAAAAAAAA 通过 0X55555555 的类似操作得到</li>
</ul>
</li>
<li>如何检测它是否所有奇数位全为 1 呢？通过与掩码 <strong>0XAA……AA</strong> 进行 <strong>异或</strong> 操作来实现<ul>
<li>如果奇数位全为 1 的话，异或得到 0，取非得到 1，其他情况下，得到非零值取非得到 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// int y = 0x55&lt;&lt;8; </span></span><br><span class="line">  <span class="comment">// y = y + 0x55;</span></span><br><span class="line">  <span class="comment">// y = y &lt;&lt; 16;</span></span><br><span class="line">  <span class="comment">// y = y + 0x5555;</span></span><br><span class="line">  <span class="comment">// x = x | y;</span></span><br><span class="line">  <span class="comment">// return !~x;</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> y = <span class="number">0xAA</span>&lt;&lt;<span class="number">8</span>;</span><br><span class="line">  y = y + <span class="number">0xAA</span>;</span><br><span class="line">  y = y &lt;&lt; <span class="number">16</span>;</span><br><span class="line">  y = y + <span class="number">0xAAAA</span>;</span><br><span class="line">  x = x &amp; y;</span><br><span class="line">  <span class="keyword">return</span> !(x^y); <span class="comment">// 括号是必须加的...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要求：返回 -x，仅通过 <strong>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</li>
<li>通过书上的公式 <code>-x = ~x + 1</code> 可以很容易实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：如果 <strong>0x30 &lt;&#x3D; x &lt;&#x3D; 0x39**，返回 1，否则返回 0，仅通过 **! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</p>
</li>
<li><p>我们可以通过两个特殊的数来判断 x 是否处于这个范围，一个数加上大于 0x39 的数后，由正数变为负数，另一个数加上大于 0x30 的数后，由负数变为正数</p>
<ul>
<li>因此我们需要设法得到这两个特殊的数，通过加上 x 来判断他们的符号位，如果都为正数，则 x 位于这个范围，如果至少一个为负数，则 x 不属于这个范围</li>
<li>对于第一个特殊的数，我们可以先得到 10……00，将它和 0x39 进行 或 操作，再进行取反得到</li>
<li>对于第二个特殊的数，我们可以通过将 0x30 取反 加 1 得到，也可以直接对 0x2F 取反得到</li>
</ul>
</li>
<li><p>还有一种更简单直观的思路，利用 negate 函数的技巧</p>
<ul>
<li>如果 <strong>x - 0X3A 小于 0 且 x - 0x30 大于等于 0</strong>，x 位于这个返回（x - 0X3A 而不是 0x39，是因为要判断是否是负数，即符号位是否为 1，x - 0X39 可能得到 0 使结果混淆）</li>
<li>-0X3A 和 -0X30 通过 ~x + 1 得到</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> y1 = ~(y | <span class="number">0x39</span>); 	<span class="comment">// 得到第一个特殊的数</span></span><br><span class="line">  <span class="type">int</span> y2 = ~<span class="number">0x30</span> + <span class="number">1</span>; 		<span class="comment">// 得到第二个特殊的数</span></span><br><span class="line">  <span class="type">int</span> sign1 = (y1 + x)&gt;&gt;<span class="number">31</span>; <span class="comment">// 判断 x 是否大于 0x39</span></span><br><span class="line">  <span class="type">int</span> sign2 = (y2 + x)&gt;&gt;<span class="number">31</span>; <span class="comment">// 判断 x 是否小于 0x30</span></span><br><span class="line">  <span class="keyword">return</span> !(sign1 | sign2);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// return (x + ~0x3A+1)&gt;&gt;31 &amp; !(x + ~0x30+1)&gt;&gt;31;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：实现 <strong>x ? y : z</strong>，即如果 x !&#x3D; 0，返回 y，x &#x3D;&#x3D; 0，返回 z，仅通过 <strong>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</p>
</li>
<li><p>首先我们应该想一个方法将 x &#x3D; 0 和 x &#x3D; 非零值 这两种情况分开，然后我们需要想办法如何根据 x 的值区分 y 和 z</p>
</li>
<li><p>我们可以通过 <strong>! 运算 将 x &#x3D; 0 和 x !&#x3D; 0 两种情况分开</strong>，<strong>如果 x &#x3D; 0，x &#x3D; ! x &#x3D; 1，如果 x !&#x3D; 0，x &#x3D; ! x &#x3D; 0</strong></p>
</li>
<li><p>我们如何通过此时的 x 值区分 y 和 z 呢？我们知道 <strong>t &amp; 11……11 &#x3D; t，t &amp; 00……00 &#x3D; 0</strong>，我们是否可以根据当前的 x 值来得到 11……11 和 00……00呢？</p>
<ul>
<li>通过 <code>x = ~x + 1</code> 就可以实现，x &#x3D; 0 时，x &#x3D; 00……00，x &#x3D; 1 时，x &#x3D; 11……11</li>
</ul>
</li>
<li><p>这样我们就可以区分 y 和 z 了，通过 <strong>(y &amp; ~x) + (z &amp; x)</strong> 来实现</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  x = !x;  </span><br><span class="line">  x = ~x + <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> (y &amp; ~x) + (z &amp; x); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：如果 x &lt;&#x3D; y，返回 1，否则返回 0，仅通过 <strong>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</p>
</li>
<li><p>注意：不要轻易对范围不确定的 int 使用 + ，两个正数相加很容易溢出得到一个负数</p>
<blockquote>
<p>之前还想着用 y + ~x + 1 ，再判断符号位得到结果……</p>
</blockquote>
</li>
<li><p>我们需要记住一个原则：符号位不同，正数为大，符号位相同，作差判断符号位</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> signX = x&gt;&gt;<span class="number">31</span>; <span class="comment">// 得到 x 的符号位</span></span><br><span class="line">  <span class="type">int</span> signY = y&gt;&gt;<span class="number">31</span>; <span class="comment">// 得到 y 的符号位</span></span><br><span class="line">  <span class="type">int</span> sign = signX^signY; <span class="comment">// 判断 x 和 y 是否有相同的符号</span></span><br><span class="line">  <span class="comment">// !sign &amp; !((y+~x+1)&gt;&gt;31) 符号相同，作差判断符号，!!sign &amp; !signY 符号位不同，检查 y 的符号位</span></span><br><span class="line">  <span class="keyword">return</span> (!sign &amp; !((y+~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>)) | (!!sign &amp; !signY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>! sign &amp; ! ((y ~x + 1)&gt;&gt;31))</strong> 检查符号位相同的情况，此时 sign 为 00……00，取非得到 00……01，如果 y - x 为正，则 <strong>((y ~x + 1)&gt;&gt;31))</strong> 得到 11……11 ，取非同样得到 00……01</p>
</li>
<li><p><strong>! ! sign &amp; ! signY</strong> 检查符号位不同的情况，此时 ! ! sigh 为 00……01，**! signY** 判断 y 的符号位，如果 y 为正，则 ! sighY 为 00……01</p>
<blockquote>
<p>记住，千万别 x &#x3D; x&gt;&gt;31，y &#x3D; y&gt;&gt;31，这样会改变 x、y 的值，后边还要作差呢……</p>
</blockquote>
</li>
</ul>
<h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要求：实现 <strong>逻辑非 !</strong> 运算符，仅通过 <strong>~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</li>
<li>我们需要想一个方法将 0 和其他非零情况分开进行处理，我们可以利用补码的非这个特性来实现<ul>
<li>0 的非还是 0，特殊的 TMin 的非也还是 TMin，其他数的非为 -x</li>
<li>然而，我们发现除了 0，其他数（包括 TMin）和它的非的 <strong>或</strong> 的值的符号位总为 1，而只有 0 和它的非的 或 的值的符号位为 0</li>
<li>我们可以利用这个特点分开处理 0 和其他情况</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// x = 0 时，00……00 + 1 = 1，x = 其他情况时，11……11 + 1 = 0</span></span><br><span class="line">  <span class="keyword">return</span> ((x | (~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们不确定不同运算符的优先级，加上括号让他符合你的逻辑总是没错的</p>
</blockquote>
<h1 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：返回表示 x 的二进制补码所需要的最小位数，即x的二进制补码至少需要几位表示</p>
</li>
<li><p>思路：</p>
<ul>
<li><p>对于正数来说，我们需要找到它最大位为 1 的位数，那么他所需要的最小位数为 n（最大位为1的数） + 1（符号位）</p>
</li>
<li><p>如果是负数的话，我们需要找到他最大位为 0 的位数，则此时他所需要的最小位数为 n（最大位为 0 的位数）+ 1</p>
<ul>
<li>比如 1101 表示 -3，而 101 也表示 -3，那么所需要的最小位数为：最大位为 0 的位数 n &#x3D; 2，n + 1 &#x3D; 3</li>
<li>而对于 1001，其最大位为 0 的位数 n &#x3D; 3，n + 1 &#x3D; 4</li>
</ul>
</li>
<li><p>因此，我们需要将负数和正数的情况统一起来，对于负数，我们可以将其取反，这样的话，无论是正数还是负数，我们都寻找 最大位 为 1 的 位数，再 + 1 得到答案所需要的最小位数</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sign = x&gt;&gt;<span class="number">31</span>; <span class="comment">// 得到符号位</span></span><br><span class="line">  x = (sign &amp; ~x) | (~sign &amp; x); <span class="comment">// 如果 x 为负数，则取反，如果 x 为正数，则不变</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0; <span class="comment">// 分别表示是否至少需要相应的位数</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 由于进行了上述处理，此时 x 的符号位已经全部为 0 </span></span><br><span class="line">  </span><br><span class="line">  b16 = !!(x&gt;&gt;<span class="number">16</span>)&lt;&lt;<span class="number">4</span>; 	<span class="comment">// 目的：检查其高 16 位中是否有 1</span></span><br><span class="line">    					<span class="comment">// 先 &gt;&gt;16 是为了去除低 16 位的影响，!! 用来检查是否有 1，</span></span><br><span class="line">    					<span class="comment">// &lt;&lt;4 是为后续步骤做铺垫，如果有 1，则 b16 = 16，如果没有 1，则 b16 = 0</span></span><br><span class="line">    					<span class="comment">// b16 不仅用于后续的右移操作，还表示此时至少需要 16 位 或 0 位</span></span><br><span class="line">  x = x&gt;&gt;b16; 			<span class="comment">// 如果高 16 位有 1 的话，则至少需要 16 位，将 x 右移 16 位，去除低 16 位的影响</span></span><br><span class="line">    					<span class="comment">// 便于后续检查高 16 位的情况</span></span><br><span class="line">    					<span class="comment">// 如果高 16 位没有 1 的话，右移 0 位，则后续检查低 16 位的情况</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 逐渐缩小检查范围</span></span><br><span class="line">  </span><br><span class="line">  b8 = !!(x&gt;&gt;<span class="number">8</span>)&lt;&lt;<span class="number">3</span>; <span class="comment">// 和上述思路一样，检查高 8 位是否有 1</span></span><br><span class="line">    				<span class="comment">// 这里隐含了上边操作的影响，如果高 16 位有 1 的话，则此时检查的是 高 16 位中的高 8 位</span></span><br><span class="line">    				<span class="comment">// 如果高 16 位中没有 1 的话，则此时检查的是低 16 位中的高 8 位</span></span><br><span class="line">  x = x&gt;&gt;b8; 		<span class="comment">// 同样的思路，缩小范围，</span></span><br><span class="line">  </span><br><span class="line">  b4 = !!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>; </span><br><span class="line">  x = x&gt;&gt;b4;</span><br><span class="line">  </span><br><span class="line">  b2 = !!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x = x&gt;&gt;b2;</span><br><span class="line">  </span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  x = x&gt;&gt;b1;</span><br><span class="line">  </span><br><span class="line">  b0 = x;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述的查找最大位为 1 的位数的操作，很像一个 <strong>二分查找</strong>，通过检查高 n 位中是否含有 1 来代替通常的比较操作，通过 x 右移 bn 位的操作来缩小查找（比较）的范围</li>
</ul>
<h1 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：使用无符号整数模拟单精度浮点数 float，返回 2 * f 的结果，可以使用任何整数或无符号数的运算，包括 ||、&amp;&amp;、if、while，对于 NaN（Not a Number），直接返回参数即可</p>
</li>
<li><p>首先我们需要了解浮点数的组成，<strong>V &#x3D; （-1）^s^ * M * 2^E^</strong></p>
<ul>
<li><p>其中，s 表示符号位，M 表示尾数，由二进制小数位进行编码，E 表示阶码，由二进制整数位进行编码</p>
</li>
<li><p>而浮点数又根据阶码的不同，分为了三种情况：</p>
</li>
<li><p>如果编码阶码 E 的二进制整数位有 0 有 1，则称为 <strong>规格化的值</strong>，因为 V &#x3D; …… * 2^E^ 的原因，因此对于规格化的值，仅仅让编码阶码部分的二进制整数部分加 <strong>+ 1</strong> 即可实现 2 * f 的效果</p>
</li>
<li><p>如果编码阶码 E 的二进制整数部分全为 0，则称为 <strong>无规格化的值</strong>，此时仅有小数位，因为 V &#x3D; ……* M 的原因， 仅仅让二进制小数位 <strong>左移一位</strong>，即可达到 2 * f 的效果</p>
</li>
<li><p>如果编码阶码 E 的二进制整数部分全为 1，则称为 <strong>特殊值</strong>，比如 NaN，此时直接返回参数即可</p>
</li>
<li><p>除了上述分类外，我们还需要了解对于单精度浮点数 float 来说，一共 32 位，1 位表示符号位，阶码E （整数部分）的有效位数为 8 位，小数位数为 23 位</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> ((uf &amp; <span class="number">0x7f800000</span>) == <span class="number">0</span>) &#123; <span class="comment">// 通过和 0 111 1111 1 000 0……0 &amp; 检查是否阶码部分全为 0</span></span><br><span class="line">  	uf = (uf &lt;&lt; <span class="number">1</span>) | (uf &amp; <span class="number">0x80000000</span>); <span class="comment">// 将二进制小数部分左移 1 位实现 2 * f</span></span><br><span class="line">      									<span class="comment">// | (uf &amp; 0x80000000) 的目的是保留符号位不变 </span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((uf &amp; <span class="number">0x7f800000</span>) != <span class="number">0x7f800000</span>) &#123; <span class="comment">// 通过和 0x7f800000 &amp; 检查是否阶码部分不全为 1</span></span><br><span class="line">  	uf += <span class="number">0x00800000</span>; 	<span class="comment">// 如果不全为 1，则此时有 1 有 0，通过将阶码部分 + 1，实现 2 * f</span></span><br><span class="line">      				  	<span class="comment">// + 1 即 + 0 000 0000 1 000 0……0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：返回等效于表达式 （int）f 的位级，参数作为无符号整数传递，但被解释为单精度浮点数 float，任何超出返回的内容，都应返回 0x80000000，可以使用任何整数或无符号运算，包括 ||、&amp;&amp;、if、while</p>
</li>
<li><p>首先，我们还是需要明白二进制浮点数的解释方式：<strong>V &#x3D; (-1)^s^ * M * 2^E^</strong>，根据浮点数的解释方式寻求解决方法</p>
<ul>
<li>我们可以发现：因为 *M 的原因，所以如果将二进制浮点数解释为 int 的话， M 尾数部分是可以不动的</li>
<li>由于 * 2^E^ 的原因，因此 解释为 int 的话，相当于右移阶码 E 位</li>
<li>因此，我们可以通过将浮点数的各个部分得到，根据阶码 E 的取值情况，来以不同的方式处理 M 尾数部分，最后再根据符号位的情况来处理符号位</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="type">int</span> sign = uf&gt;&gt;<span class="number">31</span>; 					<span class="comment">// 得到符号位</span></span><br><span class="line">  <span class="type">int</span> E = ((uf &amp; <span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>) - <span class="number">127</span>; <span class="comment">// 得到阶码部分，阶码部分有 8 位</span></span><br><span class="line">    									<span class="comment">// 阶码部分解释为 E = e - Basic，Basic 为偏置值，对于 float 来说为 127</span></span><br><span class="line">  <span class="type">int</span> M = (uf &amp; <span class="number">0x00700000</span>) | <span class="number">0x00800000</span>; 	<span class="comment">// 得到尾数部分，尾数部分有 23 位</span></span><br><span class="line">    										<span class="comment">// 在规格化的值的情况下时，M = 1 + f ，所以需要 | 0x00800000</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!(uf &amp; <span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果浮点数原来就是 0，则直接返回 0</span></span><br><span class="line">  <span class="keyword">if</span> (E &gt;= <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;  	<span class="comment">// 如果阶码部分大于等于 31，即超出解释为 int 后的取值范围，则返 0x80000000</span></span><br><span class="line">  <span class="keyword">if</span> (E &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; 				<span class="comment">// 如果阶码部分小于 0，则仅有小数部分，因此解释为 int 时，小数被省略，返回 0</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (E &gt; <span class="number">23</span>) M = M &lt;&lt; (E - <span class="number">23</span>); 	<span class="comment">// 如果阶码 E 大于 23 小于 31，因为解释为浮点数时，M 尾数部分被解释为小数，</span></span><br><span class="line">    								<span class="comment">// 且有 23 位，因此当 * 2^E^ 时，在解释为 int 时，仅需要左移 E -23 位即可</span></span><br><span class="line">  <span class="keyword">else</span> M = M &gt;&gt; (<span class="number">23</span> - E); 			<span class="comment">// 如果阶码 E 小于 23 大于 0 的时，此时解释 为 int 时，</span></span><br><span class="line">    								<span class="comment">// 因为 M 尾数部分有 23 位，因此需要缩小 （舍弃）E - 23 位 （小数部分）</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!(M &gt;&gt; <span class="number">31</span>) ^ sign) <span class="keyword">return</span> M; 	<span class="comment">// 如果 M 尾数部分的符号位与解释为浮点数时的符号位相同，直接返回 M，</span></span><br><span class="line">    								<span class="comment">// 且这里提供了一个技巧，在使用位运算比较两个数是否相等时，</span></span><br><span class="line">    								<span class="comment">// 可以通过 ! 配合 ^ 异或进行比较</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ~M + <span class="number">1</span>;   			<span class="comment">// 如果相反，则返回 -M ，即 ~M + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：返回表达式 <strong>2.0^x^</strong> 的等效位级表示，通过无符号值返回，且应具有相同的位表示单精度浮点数 2.0^x^ ，如果结果太小而无法表示，返回 0，如果结果太大而无法表示，返回 +INF，任何整数或无符号运算都可以使用，包括 ||、&amp;&amp;、if、while</p>
</li>
<li><p>首先，我们知道二进制浮点数的解释为 V &#x3D; (-1)^s^ * M * 2^E^， 且又分为 规格化的值，非规格化的值，特殊值</p>
<ul>
<li><p>对于非规格化的值来说：</p>
<ul>
<li><p><strong>V 的最小精度为 -149</strong>，为什么呢？因为此时对于 M 尾数来说，<strong>M 被解释为 M &#x3D; f</strong>，因此小数部分只有最后一位为1 ，其余位全为 0，因为小数部分有 23 位，则 M &#x3D; 2^-23^ ，对于阶码 E 来说，非规格化的值的解释为 <strong>E &#x3D; 1 - Basic</strong> &#x3D; -126，因此，此时 V 的最小精度 min &#x3D; 2^-23-126^ &#x3D;      2^-149^，即 -149</p>
</li>
<li><p>而非规格化的值的最大精度，因为 IEEE 浮点数的设计，非规格化的值的最大精度可以与规格化的值的最小精度无缝衔接，因此，我们可以通过规格化的值的最小精度得到，即 <strong>-127</strong></p>
<blockquote>
<p>当然我们也可以估算，此时小数部分全为 1，M &#x3D; 0.??? &#x3D; 2^-0.???^，那么此时最大精度为 2^-126.???^ ，精确到整数为 -127）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>对于规格化的值来说：</p>
<ul>
<li><p><strong>V 的最小精度为 -126</strong>，因为对于非规格化的值来说，<strong>M 被解释为 M &#x3D; 1 + f</strong>，即此时 M 尾数的小数部分的所有位全都为0，M &#x3D; 1， 而阶码 E 整数部分仅有第一个位为 1，<strong>E 被解释为 E &#x3D; exp - Basic</strong>，因此 E &#x3D; 1 - Basic &#x3D; -126，则此时规格化的值的最小精度为 min &#x3D; 2^-126^</p>
</li>
<li><p><strong>最大精度为 127</strong> ，为什么呢？最大精度可以根据特殊值的情况得到的，特殊值的无穷大时，阶码 E 全为 1，小数部分全为 0，则此时阶码 E 至少为 128（1111 1111 - 127 &#x3D; 128），因此对于规格化的值来说，最大精度为 127</p>
</li>
</ul>
<blockquote>
<p>当然我们也可以再次估算，此时阶码 E 的最低位为 0，其余位全为 1，即 E &#x3D; 1111 1110 - 127 &#x3D; 127，M 尾数部分全为 1，即 M &#x3D; 1 + 0.??? &#x3D; 1.??? &#x3D; 2^0.???^，那么此时最大精度 max &#x3D; 2^127.???^ ，精确到整数为 127）</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>在求精度时，对于规格化的值来说，因为小数很小，完全可以忽略小数部分的影响，此时精度完全由阶码 E 决定</p>
</blockquote>
<ul>
<li>因此， 如果 <strong>x 属于 [-149, -126) 时</strong>，为非规格化的值，此时仅有小数部分，则我们可以仅仅将 <strong>1 左移 x + 149 位</strong> ，即左移 [0，23）位，即可得到 2.0^x^ 的二进制浮点数解释</li>
<li>如果 **x 属于 [-126, 127]**，为规格化的值，需要求出整数部分 exp ，因为 E &#x3D; exp - Basic，所以 exp &#x3D; E + Basic，而此时阶码 E 即为 x，可以很简单的得到 exp，我们在将 <strong>exp 左移 23 位</strong> ,即可得到得到 2.0^x^ 的二进制浮点数解释（此时小数部分影响太小）</li>
<li>如果 <strong>x  &gt;&#x3D; 128</strong>，即 exp 大于等于 255，此时为特殊值 ，因为太大而无法表示，<strong>返回 +INF，即 0x7f800000</strong></li>
<li>如果 <strong>x &lt; -149</strong> ，因为太小而无法表示，<strong>返回 0</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-149</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 太小而无法表示 </span></span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">128</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>; <span class="comment">// 太大而无法表示</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">-149</span> &amp;&amp; x &lt; <span class="number">-126</span>) <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (x + <span class="number">149</span>); <span class="comment">// 非规格化的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>;  <span class="comment">// 规格化的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><img src="/2024/01/17/CSAPP-Lab1/image-20240201225023110.png" class="" title="image-20240201225023110">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>虚拟机下载相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45912291/article/details/108901106">虚拟机VMware安装ubuntu教程（ubuntu-20.04.1-desktop-amd64.iso）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45912291/article/details/108894737">虚拟机VMware下载与安装教程（详细）</a></p>
<ul>
<li>换源相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bryan_QAQ/article/details/89951443">ubuntu 更改浏览器搜索引擎</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11Drlzij">ubuntu镜像_阿里巴巴开源镜像站 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45912291/article/details/108900602">Ubuntu系统下载（清华大学开源软件镜像站）（ubuntu-20.04.1-desktop-amd64.iso）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39514906/article/details/119703781">ubuntu sudo password 无法输入解决方法-CSDN博客</a></p>
<ul>
<li>中文设置相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gymaisyl/article/details/100981982">ubuntu 设置中文环境</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45965432/article/details/115446648">Ubuntu设置中文界面_ubuntu怎么设置中文</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43431593/article/details/106444769">Ubuntu设置中文输入法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/meyungle/article/details/98808528">Ubuntu中文语言包下载失败解决方法</a></p>
<ul>
<li>实验相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45703010/article/details/120897185">【CSAPP】lab0 环境的配置_虚拟机安.&#x2F;dlc是什么意思-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45698833/article/details/118689278">CSAPP实验记录（一）：环境配置&amp;datalab_unix make btest-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45677541/article/details/123955438">CSAPP Lab1：Data Lab （虚拟机安装+Lab环境配置+函数实现）-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7199280265914023997">CSAPP: Data Lab - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59534845">CSAPP 之 DataLab详解，没有比这更详细的了 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Yuan_Cl/article/details/83960550">CS:APP Data Lab_cs:app data lab 中文翻译-CSDN博客</a></p>
<ul>
<li>About me</li>
</ul>
<p><strong>虚拟机全名</strong>：YiweiBoi</p>
<p><strong>用户名</strong>：yiweiboi</p>
<p><strong>密码</strong>：woainimen1314</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">CSAPP-2-信息的表示与处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-16 09:19:56 / 修改时间：12:12:20" itemprop="dateCreated datePublished" datetime="2024-01-16T09:19:56+08:00">2024-01-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2-信息的表示与处理"><a href="#2-信息的表示与处理" class="headerlink" title="2. 信息的表示与处理"></a>2. 信息的表示与处理</h1><blockquote>
<p>现代计算机存储和处理数据以 <strong>位（bit）</strong> 为基础，二进制值工作的更好，能够被更好的表示、存储和传输</p>
<p>孤立的来说，单个位并不是非常有用，当把位组合在一起，再加上某种 <strong>解释</strong> ，那就赋予了位模式以含义，可以表示任何有限集合</p>
<p>我们研究的三种最重要的数字：<strong>无符号编码、补码、浮点数</strong></p>
</blockquote>
<h2 id="2-1-信息的存储"><a href="#2-1-信息的存储" class="headerlink" title="2.1 信息的存储"></a>2.1 信息的存储</h2><blockquote>
<p>大多数计算机都是以 <strong>8个位的块（字节）</strong> 作为最小的可寻址的内存单位</p>
<p>虚拟内存：机器程序将内存是为一个 <strong>非常大的字节数组</strong> ，所有可能的集合即为 <strong>虚拟地址空间</strong> ，但它只是一个 <strong>被展示给机器级程序的概念性映像</strong> </p>
<p>编译器将指针和类型信息联合起来，便于生成不同的机器级代码来访问存储在指针所指地址空间的值，但其生成的机器级程序并不包含关于数据类型的信息</p>
</blockquote>
<h3 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h3><ul>
<li>二进制表示法太冗长，十进制表示法与位模式相互转换很麻烦</li>
</ul>
<h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><ul>
<li>字长：决定了虚拟地址空间的最大大小，字长为 <strong>w</strong> 位的机器，虚拟地址的范围位 <strong>0 ~ 2^w^-1</strong> ，即程序最多访问 <strong>2^w^</strong> 个字节</li>
<li>32位程序和64位程序的区别在于 <strong>程序是如何编译的，而不是其运行的机器的类型</strong></li>
<li>为了避免依赖 <strong>典型</strong> 大小和不同编译器设置带来的奇怪行为，设计了一些固定大小的数据类型</li>
</ul>
<style>.uvjdyipthxzh{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.1.2.png" class="uvjdyipthxzh" alt="image-20240113161658749">

<h3 id="2-1-3寻址和字节顺序"><a href="#2-1-3寻址和字节顺序" class="headerlink" title="2.1.3寻址和字节顺序"></a>2.1.3寻址和字节顺序</h3><ul>
<li>多字节对象都被存储在 <strong>连续的字节序列</strong>，对象的 <strong>地址</strong> 为所使用字节中最小地址</li>
<li>表示一个对象的字节有两种通用的规则<ul>
<li><strong>小端法</strong>：最低有效字节在最左边</li>
<li><strong>大端法</strong>：最高有效字节在最左边</li>
<li>注意，<strong>我们一般书写的顺序为大端法</strong></li>
</ul>
</li>
</ul>
<style>.pelmmduhsdxl{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.1.3.png" class="pelmmduhsdxl" alt="image-20240113162025395">

<ul>
<li>由于不同字节顺序所引发的问题：网络传输二进制数据、阅读整数数据的字节序列、编写规避正常的类型系统的程序</li>
<li>整数和浮点数编码不同的原因是：两种格式使用不同的编码方法</li>
<li>指针值编码完全不同的原因：不同机器 &#x2F; 操作系统配置使用不同的存储分配规则</li>
</ul>
<style>.ywqxbristixi{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.1.3.1.png" class="ywqxbristixi" alt="image-20240113162214103">

<h3 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h3><ul>
<li>字符编码与字节顺序和字大小规则无关，与使用编码规则有关，如ASCLL字符码，使用相同字符编码规则在任何系统上都会得到相同的结果，因此文本数据比二进制数据有更好的平台独立性</li>
</ul>
<h3 id="2-1-5-表示代码"><a href="#2-1-5-表示代码" class="headerlink" title="2.1.5 表示代码"></a>2.1.5 表示代码</h3><ul>
<li>不同机器类型使用不同的且不兼容的指令和编码方式，二进制代码是不兼容的，很少可以移植</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.1.5.png" class="" title="image-20240113162325035">

<h3 id="2-1-6-布尔代数简介"><a href="#2-1-6-布尔代数简介" class="headerlink" title="2.1.6 布尔代数简介"></a>2.1.6 布尔代数简介</h3><h3 id="2-1-7-C语言中的位级运算"><a href="#2-1-7-C语言中的位级运算" class="headerlink" title="2.1.7 C语言中的位级运算"></a>2.1.7 C语言中的位级运算</h3><ul>
<li>位级运算的一个常用方法是 <strong>掩码运算</strong> ，这里的掩码是一个位模式，表示从一个字中选出位的集合</li>
</ul>
<h3 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h3><ul>
<li>千万不要把逻辑运算和位级运算混淆，它们是完全不同的两种功能</li>
<li>一个重要区别就是，逻辑运算如果对第一个参数求值结果就能确定的话，那么就不会对第二个参数求值</li>
</ul>
<h3 id="2-1-9-C语言中的移位运算"><a href="#2-1-9-C语言中的移位运算" class="headerlink" title="2.1.9 C语言中的移位运算"></a>2.1.9 C语言中的移位运算</h3><ul>
<li><strong>左移</strong>：&gt;&gt;</li>
<li><strong>逻辑右移</strong>：用于 <strong>无符号数</strong></li>
<li><strong>算术右移</strong>：几乎所有编译器 &#x2F; 机器组合都对<strong>有符号数</strong> 使用算术右移，且我们也假设机器使用算术右移</li>
<li>在很多机器中，当移动一个 <strong>w</strong> 位的值时，如果要移动 <strong>k &gt;&#x3D; w 位</strong> ，实际上的移动量为 <strong>k mod w</strong>，但一些程序并不能保证</li>
</ul>
<h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><blockquote>
<p>主要描述用位来编码整数的两种不同的方式：无符号数、有符号数</p>
</blockquote>
<h3 id="2-2-1-整数数据类型"><a href="#2-2-1-整数数据类型" class="headerlink" title="2.2.1 整数数据类型"></a>2.2.1 整数数据类型</h3><style>.tthpyepsclju{zoom: 67%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.1.png" class="tthpyepsclju" alt="image-20240113165907711"><style>.kelighdjdszi{zoom: 67%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.1.1.png" class="kelighdjdszi" alt="image-20240113165956780">

<ul>
<li>这里给出的唯一一个取值范围与机器相关的类型位 long</li>
<li>并且我们可以注意到，取整范围不是对称的，负数的取整范围比整数的范围大 1</li>
</ul>
<h3 id="2-2-2-无符号数的编码"><a href="#2-2-2-无符号数的编码" class="headerlink" title="2.2.2 无符号数的编码"></a>2.2.2 无符号数的编码</h3><ul>
<li>无符号编码的基本原理：</li>
</ul>
<style>.xtxzxodfoypl{zoom: 80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.2.png" class="xtxzxodfoypl" alt="image-20240113170435788"><style>.wxfyfvfqjwfa{zoom:67%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.2.1.png" class="wxfyfvfqjwfa" alt="image-20240113170602003">

<ul>
<li>无符号编码具有唯一性，即每个介于 <strong>0 ~ 2^w^-1</strong> 之间的数都有唯一一个 <strong>w</strong> 位的值编码</li>
</ul>
<h3 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h3><ul>
<li>最常见的有符号数的计算机表示方式就是 <strong>补码</strong>，在补码的定义中，字的最高有效位解释位 <strong>负权</strong></li>
</ul>
<style>.mgrbjpxdidbp{zoom:67%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.2.2.png" class="mgrbjpxdidbp" alt="image-20240113170936379"><style>.bbnwgsfbzudg{zoom:67%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.2.3.png" class="bbnwgsfbzudg" alt="image-20240113171032126">

<ul>
<li>同无符号表示一样，在可表示的取值范围内的每个数字都有一个唯一的 <strong>w</strong> 位的补码编码</li>
<li>补码的范围是不对称的：**|TMin| &#x3D; |TMax| + 1**，这是因为 TMin &#x3D; [1000……0]，TMax &#x3D; [0111……1]，0为非负数，从而导致的 TMax 比 TMin 少 1</li>
<li>最大的无符号数 UMax 比补码的最大值 TMax 的 2 倍还大 1，即 <strong>UMax &#x3D; 2TMax + 1</strong></li>
</ul>
<h3 id="2-2-4-有符号数和无符号数之间的转换"><a href="#2-2-4-有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 有符号数和无符号数之间的转换"></a>2.2.4 有符号数和无符号数之间的转换</h3><ul>
<li>需要明确的是：<strong>类型转换的结果保持位不变，只是改变了解释这些位的方式</strong>，即数值可能改变，但位模式不变</li>
<li>有符号数转无符号数：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.4.png" class="" title="image-20240113172139014">

<ul>
<li>所以，当一个有符号数映射位它相应的无符号数时，负数就转换为大的正数，而非负数保持不变</li>
<li>无符号数转有符号数：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.4.1.png" class="" title="image-20240113172405854">

<h3 id="2-2-5-C语言中的有符号数和无符号数"><a href="#2-2-5-C语言中的有符号数和无符号数" class="headerlink" title="2.2.5 C语言中的有符号数和无符号数"></a>2.2.5 C语言中的有符号数和无符号数</h3><ul>
<li>当执行一个运算时，C 语言会隐式的将有符号参数强制转换为无符号数，并假设这两个数都是非负的</li>
</ul>
<h3 id="2-2-6-扩展一个数字的位表示"><a href="#2-2-6-扩展一个数字的位表示" class="headerlink" title="2.2.6 扩展一个数字的位表示"></a>2.2.6 扩展一个数字的位表示</h3><ul>
<li>无符号数的零扩展：</li>
</ul>
<style>.yimpzhrkhqpd{}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.6.png" class="yimpzhrkhqpd" alt="image-20240113173032471">

<ul>
<li>有符号数的符合扩展</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.6.1.png" class="" title="image-20240113173130459">

<ul>
<li>这两种扩展都不会改变数值</li>
<li>对于 <code>short sx = -12345; unsigned uy = sx;</code> ，首先改变大小，之后再完成从有符号到无符号的转换，即等价于 <code>(unsigned) (int) sx</code></li>
</ul>
<h3 id="2-2-7-截断数字"><a href="#2-2-7-截断数字" class="headerlink" title="2.2.7 截断数字"></a>2.2.7 截断数字</h3><ul>
<li>截断一个数字可能会改变它的值，这是 <strong>溢出</strong> 的一种形式</li>
<li>截断无符号数：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.7.png" class="" title="image-20240113174106480">

<ul>
<li>截断有符号数：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.7.1.png" class="" title="image-20240113174144727">

<ul>
<li>即先将其看作无符号数，截断以后再转为有符号数</li>
</ul>
<h2 id="2-3-整数运算"><a href="#2-3-整数运算" class="headerlink" title="2.3 整数运算"></a>2.3 整数运算</h2><blockquote>
<p>我们有时会惊奇地发现，两个正数相加会得到一个负数，而表达式 x &lt; y 和 x - y &lt; 0 会产生不同的结果</p>
<p>这些属性是由计算机运算的有限性造成的</p>
</blockquote>
<h3 id="2-3-1-无符号加法"><a href="#2-3-1-无符号加法" class="headerlink" title="2.3.1 无符号加法"></a>2.3.1 无符号加法</h3><ul>
<li>我们总是将 x + y 截断为 w 位 得到的结果，再把它看作一个无符号数：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.1.png" class="" title="image-20240114120057057">

<ul>
<li>算术运算的溢出，是指完整的整数结果不能放到数据类型的字长限制中去</li>
<li>无符号加法是否溢出的检测：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.1.1.png" class="" title="image-20240114120303899">

<ul>
<li>无符号数求反：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.1.2.png" class="" title="image-20240114120355251">

<h3 id="2-3-2-补码加法"><a href="#2-3-2-补码加法" class="headerlink" title="2.3.2 补码加法"></a>2.3.2 补码加法</h3><ul>
<li>我们同样通过表示截断到 w 位，来避免数据大小的不断扩张：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.2.png" class="" title="image-20240114120610165">

<ul>
<li><p>我们可以观察到：<strong>两个数的 w 位补码之和与无符号之和有完全相同的位级表示，只是解释方式不同</strong></p>
</li>
<li><p>补码加法是否溢出的检测：</p>
</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.2.1.png" class="" title="image-20240114120841612">

<h3 id="2-3-3-补码的非"><a href="#2-3-3-补码的非" class="headerlink" title="2.3.3 补码的非"></a>2.3.3 补码的非</h3><ul>
<li>补码的加法逆元即补码的非：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.3.png" class="" title="image-20240114121013371">

<ul>
<li>补码的非的位级表示的几种方法：<ul>
<li>对每一位求补，再对结果加 1</li>
<li>假设 k 是最右边的 1 的位置，则我们对位 k 左边的所有位取反</li>
<li>注意：上述方法，都不考虑符合位，全都取反</li>
</ul>
</li>
</ul>
<h3 id="2-3-4-无符号乘法"><a href="#2-3-4-无符号乘法" class="headerlink" title="2.3.4 无符号乘法"></a>2.3.4 无符号乘法</h3><ul>
<li>无符号数乘法：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.4.png" class="" title="image-20240114121627890">

<h3 id="2-3-5-补码乘法"><a href="#2-3-5-补码乘法" class="headerlink" title="2.3.5 补码乘法"></a>2.3.5 补码乘法</h3><ul>
<li>相当于计算 x 和 y 的无符号乘法，再将无符号数转换位补码得到：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.5.png" class="" title="image-20240114121923127">

<ul>
<li>我们认为对于无符号和补码乘法来说，乘法运算的位级表示都是一样的</li>
</ul>
<style>.xjccsakykvjq{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.5.1.png" class="xjccsakykvjq" alt="image-20240114122632606">

<h3 id="2-3-6-乘以常数"><a href="#2-3-6-乘以常数" class="headerlink" title="2.3.6 乘以常数"></a>2.3.6 乘以常数</h3><ul>
<li>首先考虑乘以 2 的幂的情况：</li>
</ul>
<style>.xmfkngxtcevs{}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.6.png" class="xmfkngxtcevs" alt="image-20240114123451331">

<ul>
<li>我们可以看出左移一个数值等价于执行一个与 2 的幂相乘的无符号乘法</li>
<li>需要注意的是：无论是无符号运算还是补码运算，乘以 2 的幂都可能导致溢出，但即使溢出的时候，我们通过移位得到的结果也是一样的，即位模式还是一样的</li>
<li>由于<strong>整数乘法比移位和加法的代价要大得多</strong>，编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况<ul>
<li>如表达式 <strong>x * 14</strong>，利用 <strong>14 &#x3D; 2^3^ + 2^2^ + 2^1^</strong> ，编译器会将乘法重写为 <strong>(x&lt;&lt;3) + (x&lt;&lt;2) + (x&lt;&lt;1)</strong></li>
<li>编译器还可以利属性 <strong>14 &#x3D; 2^4^ - 2^1^</strong>，将乘法重写为 <strong>(x&lt;&lt;4) - (x&lt;&lt;1)</strong></li>
<li>大多数编译器只在需要少量移位、加法和减法就足够的时候才使用这种优化</li>
</ul>
</li>
</ul>
<h3 id="2-3-7-除以-2-的幂"><a href="#2-3-7-除以-2-的幂" class="headerlink" title="2.3.7 除以 2 的幂"></a>2.3.7 除以 2 的幂</h3><ul>
<li>在大多数机器上，整数除法要比整数乘法更慢</li>
<li>除以 2 的幂也可以用移位运算来实现，只不过是右移</li>
<li>无符号数的右移一定是 <strong>逻辑右移</strong></li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.png" class="" title="image-20240114135657324">

<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.1.png" class="" title="image-20240114135806413">

<ul>
<li><p>有符号数为了保证负数仍然为负，移位要执行的是 <strong>算术右移</strong></p>
<ul>
<li>但我们如果只是执行算术右移，有时会与整数除法的规则不符</li>
</ul>
</li>
<li><p>如果只是简单的算术右移：</p>
</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.2.png" class="" title="image-20240114140311743">

<style>.gsymqydbcpvl{}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.3.png" class="gsymqydbcpvl" alt="image-20240114140339504">

<ul>
<li>我们可以通过在移位之前 <strong>偏置</strong> 这个值，来修正这种不合适的舍入：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.4.png" class="" title="image-20240114140508967">

<blockquote>
<p>修正：产生数值$\lceil x&#x2F;2^k \rceil$</p>
</blockquote>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.5.png" class="" title="image-20240114140548404">

<ul>
<li>C 表达式为：<code>(x&lt;0 ? x+(1&lt;&lt;k)-1 : x) &gt;&gt; k</code></li>
<li>同乘法不同，我们不能用除以 2 的幂的除法来表示除以任意常数 K 的除法</li>
</ul>
<h3 id="2-3-8-关于整数运算的最后思考"><a href="#2-3-8-关于整数运算的最后思考" class="headerlink" title="2.3.8 关于整数运算的最后思考"></a>2.3.8 关于整数运算的最后思考</h3><ul>
<li>计算机执行 <strong>“整数”</strong> 运算实际上是一种 <strong>模运算</strong> 的形式</li>
<li>表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出</li>
<li>无符号数和补码实行了相同的运算包括加法、减法、乘法，甚至除法，都有完全一样或非常类似的位级行为</li>
</ul>
<h2 id="2-4-浮点数"><a href="#2-4-浮点数" class="headerlink" title="2.4 浮点数"></a>2.4 浮点数</h2><blockquote>
<p>浮点表示形如 <strong>V &#x3D; x * 2^y^</strong> 的有理数进行编码</p>
<p>它对于执行涉及非常大的数字 |V| &gt;&gt; 0，非常接近于 0 的数字 |V| &lt;&lt; 1，以及更普遍地作为实数运算的近似值的计算，是很有用的</p>
<p>目前，实际上所有的计算机都支持 <strong>IEEE 浮点</strong> 标准，大大提高了科学应用程序在不同机器上的可移植性</p>
<p>IEEE 格式是定义在一组小而非一致的原则上的</p>
</blockquote>
<h3 id="2-4-1-二进制小数"><a href="#2-4-1-二进制小数" class="headerlink" title="2.4.1 二进制小数"></a>2.4.1 二进制小数</h3><ul>
<li>二进制数 <strong>101.11</strong> 表示数字 **1 * 2^2^ + 0 * 2^1^ + 1 * 2^0^ + 1 * 2^-1^ + 1 * 2^-2^ **</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.1.png" class="" title="image-20240114150353692">

<ul>
<li><p>二进制小数点向左移一位相当于这个数被 2 除，右移一位相当于这个数乘 2</p>
</li>
<li><p>形如 <strong>0.1111……1</strong> 这样的二进制数表示刚好小于 1 的数，简单表示为 <strong>1.0-ε</strong></p>
</li>
<li><p>小数的二进制表示法只能表示那些能够被写成 x * 2^y^ 的数，其他值只能近似的表示</p>
</li>
</ul>
<h3 id="2-4-2-IEEE-浮点表示"><a href="#2-4-2-IEEE-浮点表示" class="headerlink" title="2.4.2 IEEE 浮点表示"></a>2.4.2 IEEE 浮点表示</h3><ul>
<li><p>IEEE 浮点标准用 <strong>V &#x3D; (-1)^s^ * M * 2^E^</strong>  的形式来表示一个数</p>
<ul>
<li><strong>符号 s</strong>：决定这个数的符合，负数（s &#x3D; -1）还是正数（s &#x3D; 0），由一个单独的符号位直接编码</li>
<li><strong>尾数 M</strong>：是一个二进制小数，由 n 位的小数字段编码</li>
<li><strong>阶码 E</strong>：作用为给浮点数加权，权重位 2 的 E 次幂，由 k 位的阶码字段（整数部分）编码</li>
</ul>
</li>
<li><p>单精度浮点格式 float，1 个符号位，k &#x3D; 8，n &#x3D; 23，得到一个 32 位的表示</p>
</li>
<li><p>双精度浮点格式 double，1 个符号位，k &#x3D; 11，n &#x3D; 52，得到一个 64 位的表示</p>
</li>
</ul>
<style>.aossnrljgqbe{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.2.png" class="aossnrljgqbe" alt="image-20240114152534113">

<ul>
<li><p>根据 exp（阶码字段）的值，被编码的值可以分成三中不同的情况</p>
<ul>
<li><p><strong>规格化的值</strong>：最普遍的情况，exp 的位模式有 0 有 1</p>
<ul>
<li><p>阶码字段被解释为以 <strong>偏置</strong> 的形式表示有符号整数，阶码的值 <strong>E &#x3D; e - Bias</strong></p>
<ul>
<li>e 为无符号数 exp，Bias 为 2^k-1^ - 1（float 为 127，double 为 1023）</li>
</ul>
</li>
<li><p>此时单精度是 -126 ~ 127</p>
<blockquote>
<p>对于单精度来说，因为有 0 有 1，所以取值范围为 [00……01，11……10]</p>
<p>单精度为 [1 - 127，254 - 127] &#x3D; [-126，127]</p>
</blockquote>
</li>
<li><p>尾数定义为 <strong>M &#x3D; 1 + f</strong></p>
<ul>
<li>f 为小数字段，这是一种<strong>隐含的以1开头的</strong> 表示</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>非规格化的值</strong>：当阶码域（整数部分）全为 0 时</p>
<ul>
<li><p>阶码值是 <strong>E &#x3D; 1 - Bias</strong>，尾数的值是 <strong>M &#x3D; f</strong></p>
<blockquote>
<p>E &#x3D; 1 - Bias 而不是 E &#x3D; -Bias，是为了让最大非规格化的值 [0.11……1] 和最小规格化的值 [1.00……0] 无缝衔接</p>
</blockquote>
</li>
<li><p>非规格化的值为我们提供了一种表示 0 的方法，因为根据 IEEE 浮点格式，在一些方面 +0.0 和 -0.0 被认为是不同的，而规格化的数，我们总是必须让 M &gt;&#x3D; 1，即整数部分总是不能全为 0，非规格化的数很好的表示了 +0.0</p>
</li>
</ul>
</li>
<li><p><strong>特殊值</strong>：阶码全为 1 时</p>
<ul>
<li>小数域全为 0 时，得到的值表示无穷，s &#x3D; 0 时表示正无穷，s &#x3D; 1 时表示负无穷</li>
<li>小数域为非零时，结果值被称为 <strong>NAN</strong>，即 <strong>Not a Number</strong> 的缩写</li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.bshbmqdollin{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.2.1.png" class="bshbmqdollin" alt="image-20240114154957055">

<h3 id="2-4-3-数字示例"><a href="#2-4-3-数字示例" class="headerlink" title="2.4.3 数字示例"></a>2.4.3 数字示例</h3><ul>
<li>越靠近原点 0，可表示的数越稠密</li>
</ul>
<style>.yhhcoirddieo{}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.3.png" class="yhhcoirddieo" alt="image-20240114155045884">

<ul>
<li>最大非规格化数和最小规格化数之间的平滑转变，归功于将 E 定义为 1 - Bias，可以补充非规格化数的尾数没有隐含的开头的 1</li>
</ul>
<style>.otefnctmcbtw{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.3.1.png" class="otefnctmcbtw" alt="image-20240114155308630">

<ul>
<li>如果按照无符号解释，它们就是按照升序排列的，这样设计是为了浮点数能够使用整数排序函数来进行排序</li>
</ul>
<h3 id="2-4-4-舍入"><a href="#2-4-4-舍入" class="headerlink" title="2.4.4 舍入"></a>2.4.4 舍入</h3><ul>
<li><p>表示方法限制了浮点数的范围和精度，只能近似表示实数运算，舍入运算的任务就是能够找到 <strong>最近接的</strong> 匹配值</p>
</li>
<li><p>IEEE 浮点格式定义了死者不同的舍入方式，默认方法是找到最接近的匹配</p>
<ul>
<li><p><strong>向偶舍入</strong> 也被称为 <strong>最接近的值舍入</strong>，<strong>是默认方式</strong></p>
<ul>
<li>对于 1.4 舍入到 1，对于 1.6 舍入到 2，得到最接近的整数，而对于 1.5 和 2.5，都舍入到 2，使结果的最低有效数字是偶数</li>
<li>相似的，也可以运用在二进制小数上，我们将最低有效位 0 认为是偶数，1 认为是奇数</li>
<li>向偶舍入在大多数现实情况中避免了统计的偏差</li>
</ul>
</li>
<li><p><strong>向零舍入</strong> 方式把正数向下舍入，把负数向上舍入</p>
</li>
<li><p><strong>向下舍入</strong> 方式把正数和负数都向下舍入</p>
</li>
<li><p><strong>向上舍入</strong> 方式把正数和负数都向上舍入</p>
</li>
</ul>
</li>
</ul>
<style>.brolteevhgqb{}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.4.png" class="brolteevhgqb" alt="image-20240114161650259">

<h3 id="2-4-5-浮点运算"><a href="#2-4-5-浮点运算" class="headerlink" title="2.4.5 浮点运算"></a>2.4.5 浮点运算</h3><ul>
<li><p>对于实数 x、y，计算将产生 **Round(x * y)**，这是对实数运算的精确结果进行舍入后的结果，但在实际中，通常会避免执行这些精确的运算，因为计算只要精确到能够保证得到一个正确的舍入结果就可以了</p>
</li>
<li><p>浮点运算的一些特性</p>
<ul>
<li><p>浮点加法：可交换的、不可结合的，都不是 NaN 的话，是单调的（无符号和补码加法没有单调性）</p>
</li>
<li><p>浮点乘法：可交换的、不可分配的，都不是 NaN的话，满足如下单调性（当然，无符号和补码乘法没有这些单调性）</p>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.5.png" class="" title="image-20240114163833483">		<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.5.1.png" class="" title="image-20240114163904931"></li>
</ul>
</li>
</ul>
<h3 id="2-4-6-C-语言中的浮点数"><a href="#2-4-6-C-语言中的浮点数" class="headerlink" title="2.4.6 C 语言中的浮点数"></a>2.4.6 C 语言中的浮点数</h3><ul>
<li><p>int 转为 float 不会溢出，但可能会被舍入</p>
</li>
<li><p>double 转为 float，可能溢出，也可能舍入</p>
</li>
<li><p>double、float 转为 int，值会向零舍入，且值可能溢出</p>
<blockquote>
<p>与 Intel 兼容的微处理器指定位模式 [10……00] (TMin) 为正数不确定值，如果一个浮点数到正数的转换不能找到一个合理的整数近似值，将会得到这样的一个结果</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
