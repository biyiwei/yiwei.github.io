<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yiweiboi.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yiweiBoi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yiweiboi.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/07/01/6-S081-Lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/01/6-S081-Lab6/" class="post-title-link" itemprop="url">Lab Multithreading</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-01 17:29:10" itemprop="dateCreated datePublished" datetime="2024-07-01T17:29:10+08:00">2024-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-03 17:12:06" itemprop="dateModified" datetime="2024-07-03T17:12:06+08:00">2024-07-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>Lab Guidance：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/labs/thread.html">Lab: Multithreading (mit.edu)</a></p>
</li>
<li><p>这个实验让你熟悉多线程，你将在用户级线程包中实现线程之间的切换，使用多个线程来加快程序速度，并实现 barrier</p>
</li>
<li><p>你应该确保你已经阅读了 xv6 book 的第 7 章：<code>&quot;Scheduling&quot;</code>，并研究了相关代码（<code>kernel/proc.c</code>，<code>kernel/swtch.S</code>）</p>
</li>
<li><p>在开始前，请键入：<code>git stash &amp;&amp; git fetch &amp;&amp; git checkout thread &amp;&amp; make clean</code></p>
</li>
</ul>
<h1 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h1><ul>
<li><p>在本次任务中，你将为用户级线程系统设计上下文切换机制，然后实现它</p>
</li>
<li><p>你的 xv6 中有两个文件 <code>user/uthread.c</code> 和 <code>user/uthread_switch.S</code>，以及 Makefile 中构建 uthread 程序的规则</p>
</li>
<li><p><code>user/uthread.c</code> 中包含大部分用户及线程包和三个简单测试线程的代码，线程包缺少一些创建线程和在线程之间切换的代码</p>
</li>
<li><p>你的工作是想出一个方法来创建线程，保存&#x2F;恢复寄存器，以便在线程之间切换。当你完成后，你可以通过 <code>uthread</code> 进行测试</p>
</li>
<li><p>一些提示</p>
<ul>
<li>你需要将代码添加到 <code>user/uthread.c</code> 中的 <code>thread_create()</code> 和 <code>thread_schedule()</code>，以及 <code>user/thread_switch.S</code> 中的 <code>thread_switch()</code></li>
<li><code>thread_schedule()</code> 调度一个线程后，这个线程在自己的线程栈上执行传递给 <code>thread_create()</code> 的函数</li>
<li><code>thread_switch()</code> 的目的是保存&#x2F;恢复寄存器，实现切换线程</li>
<li>你必须决定保存&#x2F;恢复哪些寄存器（调用者寄存器）；在哪里保存寄存器（修改 <code>struct thread</code> 可能是一个好的方法）</li>
<li>你可以将需要的任何参数传递给 <code>thread_switch()</code>，以便从线程 t 切换到 nexthread</li>
</ul>
</li>
<li><p>为了保存相关寄存器，模仿 <code>kernel/proc.h</code> 中的 <code>struct context</code>，在 <code>user/uthread.c</code> 中添加一个上下文结构体，并将它添加到 <code>struct thread</code> 中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack  线程栈*/</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE 线程状态*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span> <span class="comment">// 线程上下文</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>uthread_create()</code> 中添加代码<ul>
<li><code>thread_create()</code> 遍历线程组，找到一个 <code>FREE</code> 线程，将设置为 <code>RUNNABLE</code> 线程。我们的任务是在之后调度到这个线程时，在这个线程的线程栈上运行传递的函数 <code>func</code></li>
<li>为了在这个线程的线程栈上运行传递的函数，令线程上下文中的栈指针 <code>sp</code> 指向线程栈的栈顶，<code>+ STACK_SIZE</code> 是因为栈由上向下增长</li>
<li>为了在通过 <code>thread_switch()</code> 切换到这个线程后，可以返回到函数 <code>func</code> 被中断的位置继续运行，令线程上下文中的 <code>ra</code> 寄存器存储 <code>func</code> 函数指针的值（函数地址），<code>ra</code> 寄存器存储的是返回的地址</li>
<li>所以 <code>uthread_create()</code> 只是将传递的函数绑定到一个 <code>FREE</code> 线程上，并将这个线程设为 <code>RUNNABLE</code>，函数并没有真正的运行</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在 <code>user/thread_switch.S</code> 中添加代码</p>
<ul>
<li><code>thread_switch()</code> 由于需要保存&#x2F;恢复寄存器，所以需要汇编实现</li>
<li>它的作用是保存一个线程的上下文，恢复另一个线程的上下文，从而实现切换线程</li>
<li>它的实现和 <code>kernel/swtch.S</code> 中内核线程的上下文切换一样</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">	.text</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">         * save the old thread&#x27;s registers,</span><br><span class="line">         * restore the new thread&#x27;s registers.</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">	.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">	/* YOUR CODE HERE */</span><br><span class="line">	sd ra, 0(a0)</span><br><span class="line">	sd sp, 8(a0)</span><br><span class="line">	sd s0, 16(a0)</span><br><span class="line">	sd s1, 24(a0)</span><br><span class="line">	sd s2, 32(a0)</span><br><span class="line">	sd s3, 40(a0)</span><br><span class="line">	sd s4, 48(a0)</span><br><span class="line">	sd s5, 56(a0)</span><br><span class="line">	sd s6, 64(a0)</span><br><span class="line">	sd s7, 72(a0)</span><br><span class="line">	sd s8, 80(a0)</span><br><span class="line">	sd s9, 88(a0)</span><br><span class="line">	sd s10, 96(a0)</span><br><span class="line">	sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">	ld ra, 0(a1)</span><br><span class="line">	ld sp, 8(a1)</span><br><span class="line">	ld s0, 16(a1)</span><br><span class="line">	ld s1, 24(a1)</span><br><span class="line">	ld s2, 32(a1)</span><br><span class="line">	ld s3, 40(a1)</span><br><span class="line">	ld s4, 48(a1)</span><br><span class="line">	ld s5, 56(a1)</span><br><span class="line">	ld s6, 64(a1)</span><br><span class="line">	ld s7, 72(a1)</span><br><span class="line">	ld s8, 80(a1)</span><br><span class="line">	ld s9, 88(a1)</span><br><span class="line">	ld s10, 96(a1)</span><br><span class="line">	ld s11, 104(a1)</span><br><span class="line"></span><br><span class="line">	ret    /* return to ra */</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在 <code>uthread_schedule()</code> 中添加代码</p>
<ul>
<li><code>uthread_schedule()</code> 遍历线程组，找到一个 <code>RUNNABLE</code> 线程，进行切换。我们的任务就仅仅是调用 <code>thread_switch()</code> 来进行线程切换</li>
<li><code>uthread_schedule()</code> 和 <code>kernel/proc.c</code> 中的 <code>scheduler()</code> 的作用很像</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>, *<span class="title">next_thread</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find another runnable thread. */</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br><span class="line">  t = current_thread + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_THREAD; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt;= all_thread + MAX_THREAD)</span><br><span class="line">      t = all_thread;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;state == RUNNABLE) &#123;</span><br><span class="line">      next_thread = t;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next_thread == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread_schedule: no runnable threads\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    thread_switch((uint64)&amp;t-&gt;context, (uint64)&amp;current_thread-&gt;context);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在测试之前，让我们来看一下 <code>main()</code> 的实现流程<ul>
<li>首先调用 <code>thread_init()</code> 初始化线程组中的第一个线程</li>
<li>之后通过 <code>thread_create()</code> 创建三个分别和测试函数 <code>thread_a/b/c</code> 绑定的 <code>RUNNABLE</code> 线程</li>
<li>将当前线程，也就是第一个线程设置为 <code>FREE</code>，防止之后被调度</li>
<li>通过 <code>thread_schedule()</code> 遍历线程组，找到一个 <code>RUNNABLE</code> 线程进行切换<ul>
<li>通过 <code>thread_schedule()</code> 中的 <code>thread_switch()</code> 切换线程返回后，第一次回返回到 <code>thread_a</code></li>
<li>在 <code>thread_a</code> 中，输出 <code>start</code>，如果还有没有输出 <code>start</code> 的测试函数线程，通过 <code>thread_yield()</code> 进行调度</li>
<li>由于 <code>thread_schedule()</code> 总是从当前线程之后开始遍历线程组，所以之后依次调度到 <code>thread_b</code>，<code>thread_c</code>，待它们都输出过 <code>start</code> 后，又调度到了 <code>thread_a</code></li>
<li><code>thread_a</code> 继续输出累计值，每输出一次就通过 <code>thread_yield()</code> 进行调度，直到输出到 99，其他测试函数线程也是一样</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">  a_started = b_started = c_started = <span class="number">0</span>;</span><br><span class="line">  a_n = b_n = c_n = <span class="number">0</span>;</span><br><span class="line">  thread_init();</span><br><span class="line">  thread_create(thread_a);</span><br><span class="line">  thread_create(thread_b);</span><br><span class="line">  thread_create(thread_c);</span><br><span class="line">  current_thread-&gt;state = FREE;</span><br><span class="line">  thread_schedule();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// main() is thread 0, which will make the first invocation to</span></span><br><span class="line">  <span class="comment">// thread_schedule(). It needs a stack so that the first thread_switch() can</span></span><br><span class="line">  <span class="comment">// save thread 0&#x27;s state.</span></span><br><span class="line">  current_thread = &amp;all_thread[<span class="number">0</span>];</span><br><span class="line">  current_thread-&gt;state = RUNNING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_a</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;thread_a started\n&quot;</span>);</span><br><span class="line">  a_started = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b_started == <span class="number">0</span> || c_started == <span class="number">0</span>)</span><br><span class="line">    thread_yield();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread_a %d\n&quot;</span>, i);</span><br><span class="line">    a_n += <span class="number">1</span>;</span><br><span class="line">    thread_yield();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;thread_a: exit after %d\n&quot;</span>, a_n);</span><br><span class="line"></span><br><span class="line">  current_thread-&gt;state = FREE;</span><br><span class="line">  thread_schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  current_thread-&gt;state = RUNNABLE;</span><br><span class="line">  thread_schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; uthread</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240701211537718.png" class="" title="image-20240701211537718">

<ul>
<li><strong>.&#x2F;grade-lab-thread uthread</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240701211829481.png" class="" title="image-20240701211829481">

<h1 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h1><ul>
<li><p>在本次任务中，你将要使用散列表探索线程和锁的并行编程。你应该在具有多个内核的真实 Linux 计算机上执行此任务（不是 xv6 和 qemu）</p>
</li>
<li><p>此任务使用 UNIX pthread 线程库，你可以通过 <code>man pthreads</code> 查看相关信息</p>
</li>
<li><p>文件 <code>notxv6/ph.c</code> 中包含一个简单的哈希表，如果从单个线程使用，该哈希表是正确的，但从多个线程使用时不正确</p>
</li>
<li><p>你可以在主 xv6 目录下键入 <code>make ph &amp;&amp; ./ph 1</code>（1 表示指定在哈希表上执行 put 和 get 操作的线程数），运行一段时间后，它将输出以下结果</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100000 puts, 3.991 seconds, 25056 puts/second</span><br><span class="line">0: 0 keys missing</span><br><span class="line">100000 gets, 3.981 seconds, 25118 gets/second</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你尝试 <code>./ph 2</code>，虽然输出显示它获得了并行加速，但本应该在哈希表中的 keys 却大量消失</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100000 puts, 1.885 seconds, 53044 puts/second</span><br><span class="line">1: 16579 keys missing</span><br><span class="line">0: 16579 keys missing</span><br><span class="line">200000 gets, 4.322 seconds, 46274 gets/second</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一些提示</p>
<ul>
<li><p>你应该看看 <code>notxv6/ph.c</code> 中的 <code>put()</code> 和 <code>insert()</code></p>
</li>
<li><p>为了避免这种情况，请在 <code>put</code> 中加入锁定和解锁语句，相关的 phtread 调用如下。当你的代码通过了 <code>ph_safe</code> 测试时，你就完成了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;            <span class="comment">// declare a lock</span></span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>); <span class="comment">// initialize the lock</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);       <span class="comment">// acquire lock</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);     <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在某些情况下，并发 <code>put()</code> 在散列表中读取或写入的内存没有重叠，因此不需要锁来保护，修改 <code>ph.c</code> 以利用这种情况来获得并行加速（每个哈希桶一个锁是一个好方法）。当你的代码通过了 <code>ph_fast</code> 测试时，你就完成了</p>
</li>
</ul>
</li>
<li><p>在开始前，我们先来仔细看一下 <code>ph.c</code> 代码的执行过程，分析为什么会发生在多线程环境下 keys 大量 “消失”</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> *tha;</span><br><span class="line">  <span class="type">void</span> *value;</span><br><span class="line">  <span class="type">double</span> t1, t0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s nthreads\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nthread = atoi(argv[<span class="number">1</span>]);  <span class="comment">// 线程数</span></span><br><span class="line">  tha = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * nthread);</span><br><span class="line">  srandom(<span class="number">0</span>);</span><br><span class="line">  assert(NKEYS % nthread == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NKEYS; i++) &#123;</span><br><span class="line">    keys[i] = random();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// first the puts</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  t0 = now();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_create(&amp;tha[i], <span class="literal">NULL</span>, put_thread, (<span class="type">void</span> *) (<span class="type">long</span>) i) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_join(tha[i], &amp;value) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  t1 = now();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d puts, %.3f seconds, %.0f puts/second\n&quot;</span>,</span><br><span class="line">         NKEYS, t1 - t0, NKEYS / (t1 - t0));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// now the gets</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  t0 = now();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_create(&amp;tha[i], <span class="literal">NULL</span>, get_thread, (<span class="type">void</span> *) (<span class="type">long</span>) i) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_join(tha[i], &amp;value) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  t1 = now();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d gets, %.3f seconds, %.0f gets/second\n&quot;</span>,</span><br><span class="line">         NKEYS*nthread, t1 - t0, (NKEYS*nthread) / (t1 - t0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>main()</code> 首先根据传入的参数来创建线程，并且保证 <code>NKEYS % nthread == 0</code></p>
<ul>
<li>这是因为在之后我们会发现，<code>NKEYS</code> 是我们需要处理的 keys 数组的大小，如果 <code>NKEYS</code> 可以整除线程数，那么就可以保证每个线程处理的 keys 数组的范围大小相同，且每个线程只处理自己范围内的 keys 数组的值，而不越界影响其他线程</li>
<li>将需要处理的 keys 数组中的 key 值初始化为随机数，这说明 keys 数组中的 key 值可能相等，也可能不相等，这就为之后的 <strong>竞争</strong> 埋下了伏笔</li>
</ul>
</li>
<li><p>调用 <code>now()</code> 获得当前时间，这是为了之后计算 <code>put()</code> 的运行速度做准备，计算 <code>get()</code> 时也是如此</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span></span><br><span class="line"><span class="title function_">now</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"> gettimeofday(&amp;tv, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">return</span> tv.tv_sec + tv.tv_usec / <span class="number">1000000.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在循环中调用 <code>phtread_create()</code> 创建 nthread 个线程执行 <code>put_thread()</code></p>
<ul>
<li><code>phtread_create()</code> 中的最后一个参数是传递给 <code>put_thread()</code> 的参数，表示 thread number（第几个线程）</li>
</ul>
</li>
<li><p><code>put_thread()</code> 通过传入的参数 thread number 来确定当前线程处理的 keys 数组的范围（<code>b*n + i</code>），调用 <code>put()</code> 将键值对 <code>[keys[b*n + i], n]</code> 插入到哈希表中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">put_thread</span><span class="params">(<span class="type">void</span> *xa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>) (<span class="type">long</span>) xa; <span class="comment">// thread number</span></span><br><span class="line">  <span class="type">int</span> b = NKEYS/nthread;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">    put(keys[b*n + i], n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>put()</code> 根据传入的 key 确定是哪个哈希桶，遍历这个哈希桶找到是否有对应的 key，如果有就更新 value，否则就调用 <code>insert()</code> 将一个新的键值对插入这个哈希桶中<ul>
<li>发现了吗，这里存在一个数据竞争，因为 keys 数组中的 key 都是随机数，如果两个线程处理的 key 值相同，但由于它们的 thread number（需要插入的 value 值）是一定不同的，当他们同时来到 <code>put()</code> 且同时找到相同的 <code>e</code> 时，<code>e-&gt;value = value</code> 的行为是不可预测的，但这并不会导致 key 的消失，所以真正的罪魁祸首是 <code>insert()</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET; <span class="comment">// 根据key确定哈希桶</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(e)&#123;  </span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>insert()</code> 采用头插法的方式将一个新的键值对插入到哈希桶的顶部<ul>
<li>由于 keys 数组中的 key 值都是随机数，所以两个不同的线程可能正在处理同一个 key，如果两个线程同时来到这里，那么此时哈希桶的头部键值对（<code>table[i]</code>，这里是 <code>*p</code>）是相同的，<code>e-&gt;next = n; *p = e;</code> 的行为是无法预测的</li>
<li>如果两个线程先后执行 <code>e-&gt;next = n;</code>，之后又先后执行 <code>*p = e</code>，那么先执行 <code>*p = e</code> 的线程插入的键值对就会丢失。这就是为什么在多线程环境下大量 key 消失的原因</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">insert</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="keyword">struct</span> entry **p, <span class="keyword">struct</span> entry *n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry));</span><br><span class="line">  e-&gt;key = key;</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  e-&gt;next = n;</span><br><span class="line">  *p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>回到 <code>main()</code>，在循环中调用 <code>pthread_join()</code> 等待所有创建的线程结束，最后输出 <code>put</code> 的运行速率</p>
</li>
<li><p>之后测试 <code>get</code> 的运行速率也是大同小异</p>
</li>
<li><p>同样是在循环中调用 <code>phtread_create()</code> 创建 nthread 个线程执行 <code>get_thread()</code>，传入参数 thread number</p>
</li>
<li><p><code>get_phtread()</code> 的作用就是统计哈希表中有多少个键值对消失，由于 <code>get_thread</code> 和 <code>get</code> 都有没有涉及对临界值（也就是共享变量哈希表）的修改操作，所以不会造成竞争，也就不需要锁的保护</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">get_thread</span><span class="params">(<span class="type">void</span> *xa)</span>  <span class="comment">// get_thread的作用就是检测哈希表中有多少缺失的键值对</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>) (<span class="type">long</span>) xa; <span class="comment">// thread number</span></span><br><span class="line">  <span class="type">int</span> missing = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NKEYS; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> get(keys[i]);</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="number">0</span>) missing++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: %d keys missing\n&quot;</span>, n, missing);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> entry*</span><br><span class="line"><span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;  <span class="comment">// 确定哈希桶</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>notxv6/ph.c</code>，让它可以在多线程环境中安全且快速的运行的方法就很明显了，我们只需要在 <code>put()</code> 中加锁就可以了</li>
<li>根据提示，不同线程在操作不同的哈希桶时，每个线程写入的内存并不会重叠，所以就不会造成竞争。每个哈希桶一个锁是个很好的解决方案</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock[NBUCKET];</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>main()</code> 中初始化所有的锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> *tha;</span><br><span class="line">  <span class="type">void</span> *value;</span><br><span class="line">  <span class="type">double</span> t1, t0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s nthreads\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nthread = atoi(argv[<span class="number">1</span>]);  <span class="comment">// 线程数</span></span><br><span class="line">  tha = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * nthread);</span><br><span class="line">  srandom(<span class="number">0</span>);</span><br><span class="line">  assert(NKEYS % nthread == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NKEYS; i++) &#123;</span><br><span class="line">    keys[i] = random();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;lock[i], <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>put()</code>，在调用 <code>insert()</code> 时加上对应哈希桶的锁，<code>insert()</code> 返回后解锁<ul>
<li>这里不是在 <code>if(e) &#123;...&#125;</code> 之前之后加锁解锁是很有必要的，<code>e-&gt;value = value</code> 并不会使键值对丢失，缩小加锁的范围也可以一定程度上提高并行速度</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123; </span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(e)&#123;  </span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    pthread_mutex_lock(&amp;lock[i]);</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    pthread_mutex_unlock(&amp;lock[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.&#x2F;grade-lab-thread ph_safe</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240703152158708.png" class="" title="image-20240703152158708">

<ul>
<li><strong>.&#x2F;grade-lab-thread ph_fast</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240703152327038.png" class="" title="image-20240703152327038">

<h1 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h1><ul>
<li>在本次任务中，你将要实现一个 barrier：应用程序中的一个点，所有参与的线程必须等待，直到所有其它参与的线程也达到该点</li>
<li>你将要使用 pthread 条件变量。你应该在真正的计算机上完成此任务（不是 xv6 和 qemu）</li>
<li>文件 <code>notxv6/barrier.c</code> 包含一个 broken barrier。在主 xv6 目录中键入 <code>make barrier &amp;&amp; ./barrier 2</code>（2 指定了在 barrier 上同步的线程数），它会产生如下输出</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make barrier</span><br><span class="line">./barrier 2</span><br><span class="line">barrier: notxv6/barrier.c:42: thread: Assertion `i == t&#x27; failed.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>断言触发的原因是：一个线程在另一个线程到达 barrier 之前离开了 barrier。我们期望的行为是：每个线程在 barrier 中被阻塞，直到所有线程都到达 barrier（调用 barrier）</p>
</li>
<li><p>你的目标是实现所需要的 barrier 行为，除了在上一个任务中看到的锁原语外，你还需要以下新的 pthread 原语</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  <span class="comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span></span><br><span class="line">pthread_cond_broadcast(&amp;cond);     <span class="comment">// wake up every thread sleeping on cond</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们已经给你提供了 <code>barrier_init()</code> 及 <code>struct barrier</code>，你的工作是实现 <code>barrier()</code>。确保你的解决方案通过 <code>barrier</code> 测试</p>
</li>
<li><p>有一些问题使得问题复杂化</p>
<ul>
<li>你需要处理我们每一轮都会调用的一连串的 <code>barrier</code> 调用。<code>barrier.round</code> 记录当前是哪一轮，每次所有线程都达到 <code>barrier</code> 时，你都应该增加 <code>barrier.round</code></li>
<li>你必须处理一个线程在其他线程还未达到 <code>barrier</code> 之前 “循环赛跑” 的情况。<code>barrier.nthread</code> 记录了当前一轮已经达到 <code>barrier</code> 的线程数。确保当前一轮所有线程还未达到 <code>barrier</code> 时，已经达到的线程 “在一个循环中赛跑” 时并不会增加 <code>barrier.nthread</code></li>
</ul>
</li>
<li><p>在开始之前，我们看一下 <code>notxv6/barrier.c</code> 的运行流程</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> *tha;</span><br><span class="line">  <span class="type">void</span> *value;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">double</span> t1, t0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s nthread\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  nthread = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  tha = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * nthread);</span><br><span class="line">  srandom(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  barrier_init();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_create(&amp;tha[i], <span class="literal">NULL</span>, thread, (<span class="type">void</span> *) i) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_join(tha[i], &amp;value) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;OK; passed\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>main()</code> 根据传入参数初始化 <code>nthread</code> 以记录需要同步的线程数，分配 nthread 个线程的空间</li>
<li>调用 <code>barrier_init()</code> 初始化共享变量 <code>bstate</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">barrier</span> &#123;</span></span><br><span class="line">  <span class="type">pthread_mutex_t</span> barrier_mutex;</span><br><span class="line">  <span class="type">pthread_cond_t</span> barrier_cond;</span><br><span class="line">  <span class="type">int</span> nthread;      <span class="comment">// Number of threads that have reached this round of the barrier</span></span><br><span class="line">  <span class="type">int</span> round;     <span class="comment">// Barrier round</span></span><br><span class="line">&#125; bstate;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">barrier_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(pthread_mutex_init(&amp;bstate.barrier_mutex, <span class="literal">NULL</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(pthread_cond_init(&amp;bstate.barrier_cond, <span class="literal">NULL</span>) == <span class="number">0</span>);</span><br><span class="line">  bstate.nthread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在循环中调用 <code>pthread_create()</code> 创建 nthread 个线程执行 <code>thread()</code>，传入参数 thread number（第几个线程）</li>
<li><code>thread()</code> 在每次循环中，检查当前记录的轮数 <code>bstate.round</code> 是否和循环的轮数 <code>i</code> 匹配，不相等就会触发断言<ul>
<li>由于可能有多个线程，所以我们对 <code>barrier()</code> 期望是：一个线程调用 <code>barrier()</code> 后会被阻塞，只有其他所有可能的线程都调用 <code>barrier()</code> 后，递增 <code>bstate.round</code> 以记录轮数，所有线程才可以离开 <code>barrier()</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">thread</span><span class="params">(<span class="type">void</span> *xa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> n = (<span class="type">long</span>) xa;</span><br><span class="line">  <span class="type">long</span> delay;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> t = bstate.round;</span><br><span class="line">    assert (i == t);</span><br><span class="line">    barrier();</span><br><span class="line">    usleep(random() % <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>barrier()</code> 就是本次任务中我们需要实现的方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>回到 <code>main()</code>，在循环中调用 <code>pthread_join()</code> 等待所有创建的线程结束。最后输出 <code>OK; passed</code></li>
<li>在实现 <code>barrier()</code> 时，我的第一次实现如下所示<ul>
<li>之后觉得这样的写法不仅 “臃肿”，而且 <code>while</code> 的作用也不能说是没有，只能说是毫无用处，好像仅仅是为了应和提示中的 “在循环中赛跑”</li>
<li>然而真实情况就是它根本就没有循环，一个线程调用 <code>pthread_cond_wait()</code> 后就陷入了睡眠，当所有线程达到时被 <code>pthread_cond_broadcast()</code> 唤醒后，它会和其他线程争抢锁，没有抢到锁时确实可能会陷入 “循环赛跑”，但这也持续不了多久，毕竟其他线程很快就会释放锁并退出 <code>barrier</code>，“循环赛跑” 会严重浪费 CPU 时间，远不如睡眠来的实在</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  ++bstate.nthread;</span><br><span class="line">  <span class="keyword">while</span> (bstate.nthread != nthread) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">    pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ++bstate.round;</span><br><span class="line">  bstate.nthread = <span class="number">0</span>;</span><br><span class="line">  pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为了实现的更加 “优雅”，<code>barrier()</code> 最终的实现版本如下<ul>
<li>在修改临界区 <code>bstate</code> 之前获得锁，如果递增 <code>bstate.nthread</code> 时发现所有的线程还未到达 <code>barrier</code>，那就释放锁并陷入睡眠</li>
<li>如果递增 <code>bstate.round</code> 时发现所有线程均已达到 <code>barrier</code>，那就重置 <code>bstate.nthread</code> 且递增 <code>bstate.round</code> 以记录轮数，唤醒所有线程，释放锁</li>
<li>其他被唤醒的线程争抢锁，抢到锁的线程释放锁后退出 <code>barrier</code>，其他线程也是如此</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  <span class="keyword">if</span> (++bstate.nthread != nthread) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    ++bstate.round;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.&#x2F;barrier 2</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240703165743645.png" class="" title="image-20240703165743645">

<ul>
<li><strong>.&#x2F;grade-lab-thread barrier</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240703170504808.png" class="" title="image-20240703170504808">

<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make grade</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240703171141481.png" class="" title="image-20240703171141481">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/121430791">MIT 6.S081] Lab 7: Multithreading_lab7: multithreading-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16222393.html">MIT6.S081-Lab6 Lab Multithreading 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/23/xv6-book-chapter-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/23/xv6-book-chapter-7/" class="post-title-link" itemprop="url">xv6 book chapter 7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-06-23 17:43:02 / 修改时间：17:43:29" itemprop="dateCreated datePublished" datetime="2024-06-23T17:43:02+08:00">2024-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/22/xv6-book-chapter-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/22/xv6-book-chapter-6/" class="post-title-link" itemprop="url">xv6 book chapter 6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-06-22 19:43:55 / 修改时间：19:44:53" itemprop="dateCreated datePublished" datetime="2024-06-22T19:43:55+08:00">2024-06-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><ul>
<li><p>大多数内核，包括 xv6，都会交错执行多个任务。一种实现交错执行任务的方式是多处理器架构：硬件系统具有多个 CPU 独立执行，如 xv6 的 RISC-V</p>
<ul>
<li>这些 CPU 共享物理 RAM，xv6 利用共享来维护所有 CPU 读写的数据结构。这种共享带来了一种可能性，即一个 CPU 读取一个数据结构，而另一个 CPU 正在中途更新它，甚至多个 CPU 同时更新同一个数据</li>
<li>如果不仔细设计，这种并行访问很可能产生不正确的结果或破坏数据结构。即使在单处理器上，内核也可能在多个线程之间切换 CPU，导致它们的执行交错</li>
<li>最后，如果中断发生的时间不对，一个设备中断处理程序可能会修改与一些可中断代码相同的数据，从而破坏数据</li>
<li>并发一词指的是由于多处理器并行、线程切换或中断而导致多个指令流交错的情况</li>
</ul>
</li>
<li><p>内核中充满了并发访问的数据。例如，两个 CPU 可以同时调用 <code>kalloc</code>，从而并发地从空闲内存链表的头部 push。内核设计者喜欢允许大量的并发，因为它可以通过并行来提高性能，提高响应速度。然而，结果是内核设计者花了很多精力来让自己确认这些存在的并发是正确的</p>
<ul>
<li>有很多方法可以写出正确的代码，有些方法比其他方法更简单。以并发下的正确性为目标的策略，以及支持这些策略的抽象，被称为并发控制技术</li>
</ul>
</li>
<li><p>根据不同的情况，xv6 使用了很多并发控制技术，且还有更多的可能尚未被实现。本章重点介绍一种广泛使用的技术:锁（lock）</p>
<ul>
<li>锁提供了互斥的功能，确保一次只有一个 CPU 可以持有一个特定的锁。如果程序员为每个共享数据项关联一个锁，并且代码在使用某项时总是持有关联的锁，那么该项每次只能由一个 CPU 使用。在这种情况下，我们说锁保护了数据项</li>
<li>虽然锁是一种简单易懂的并发控制机制，但其也带来了性能降低的缺点，因为锁将并发操作串行化了</li>
</ul>
</li>
<li><p>本章的其余部分解释了为什么 xv6 需要锁、xv6 如何实现它们以及如何使用它们</p>
</li>
</ul>
<h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><img src="/2024/06/22/xv6-book-chapter-6/Figure-6.1.png" class="" title="Figure-6.1">

<ul>
<li><p>作为我们为什么需要锁的一个例子，考虑两个进程在两个不同的 CPU 上调用 <code>wait</code>，<code>wait</code> 释放子进程的内存。因此，在每个 CPU上，内核都会调用 <code>kfree</code> 来释放子进程的内存页</p>
<ul>
<li><p>内核分配器维护了一个链表: <code>kalloc()</code> (kernel&#x2F;kalloc.c:69) 从空闲页链表中 pop 一页内存，<code>kfree()</code> (kernel&#x2F;kalloc.c:47) 将一页 push 空闲链表中</p>
</li>
<li><p>为了达到最好的性能，我们可能希望两个父进程的 <code>kfree</code> 能够并行执行，而不需要任何一个进程等待另一个进程，但是考虑到 xv6 的 <code>kfree</code> 实现，这是不正确的</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>图 6.1 更详细地说明了这种设置：链表在两个 CPU 共享的内存中，CPU 使用加载和存储指令操作链表。(在现实中，处理器有缓存，但在概念上，多处理器系统的行为就像有一个单一的共享内存一样)。如果没有并发请求，你可能会实现如下的链表 push 操作:</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span> =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">	l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">list</span> = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/06/22/xv6-book-chapter-6/Figure-6.2.png" class="" title="Figure-6.2">

<ul>
<li><p>如果单独执行，这个实现是正确的。但是，如果多个副本同时执行，代码就不正确。如果两个 CPU 同时执行 <code>push</code>，那么两个 CPU 可能都会执行图 6.1 所示的第 15 行，然后其中一个才执行第 16 行，这就会产生一个不正确的结果，如图 6.2 所示</p>
<ul>
<li>这样就会出现两个 list 元素，将 next 设为 list 的前值。当对 list 的两次赋值发生在第 16 行时，第二次赋值将覆盖第一次赋值;第一次赋值中涉及的元素将丢失</li>
</ul>
</li>
<li><p>第 16 行的丢失更新是竞争条件 (race condition) 的一个例子。竞争条件是指同时访问一个内存位置，并且至少有一次访问是写的情况</p>
<ul>
<li>竞争通常是一个错误的标志，要么是丢失更新 (如果访问是写)，要么是读取一个不完全更新的数据结构。竞争的结果取决于所涉及的两个 CPU 的确切时间，以及它们的内存操作如何被内存系统排序，这可能会使竞争引起的错误难以重现和调试</li>
<li>例如，在调试 <code>push</code> 时加入 <code>print</code> 语句可能会改变执行的时机，足以使竞争消失</li>
</ul>
</li>
<li><p>避免竞争的通常方法是使用锁。锁确保了相互排斥，因此一次只能有一个 CPU 执行 <code>push</code> 的哪一行;这就使得上面的情况不可能发生。上面代码的正确 <code>lock</code> 版本只增加了几行代码</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span>=</span><span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locklist</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push</span> <span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">	l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">	acquire(&amp;listlock);</span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">list</span> = l;</span><br><span class="line">    release(&amp;listlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>acquire</code> 和 <code>release</code> 之间的指令序列通常被称为临界区。这里的锁保护 <code>list</code></p>
</li>
<li><p>当我们说锁保护数据时，我们真正的意思是 <strong>锁保护了一些适用于数据的不变量(invariant)的集合</strong>。不变量是数据结构的属性，这些属性在不同的操作中得到维护</p>
<ul>
<li>通常情况下，一个操作的正确行为取决于操作开始时的不变量是否为真。操作可能会暂时违反不变量，但在结束前必须重新建立不变量</li>
<li>例如，在链表中，不变性是：“ list 指向列表中的第一个元素，并且每个元素的下一个字段指向下一个元素”。push 的实现暂时违反了这一不变性：在第 17 行，l 指向下一个链表元素 list，但 list 还没有指向 l（在第 18 行重新建立）</li>
<li>我们上面所研究的竞争条件之所以会发生，是因为第二个 CPU 执行了依赖于列表不变式的代码，而它们被（暂时）违反了</li>
<li>正确使用锁可以确保每次只有一个 CPU 可以对关键部分的数据结构进行操作，因此当数据结构的不变式不成立时，没有 CPU 会执行数据结构操作</li>
</ul>
</li>
<li><p>你可以把锁看成是把并发的关键部分序列化，使它们一次只运行一个，从而保存不变性（假设关键部分孤立地正确）。你也可以认为由同一个锁保护的关键部分是相互原子的 (atomic)，因此每个关键部分只看到来自更早的关键部分的完整变化，而永远不会看到部分完成的更新</p>
</li>
<li><p>虽然正确使用锁可以使不正确的代码变得正确，但锁限制了性能。例如，如果两个进程同时调用 kfree，锁会将两个调用序列化，我们在不同的 CPU 上运行它们不会获得任何好处</p>
<ul>
<li>我们说，如果多个进程同时想要同一个锁，就会发生冲突，或者说锁经历了争夺。内核设计的一个主要挑战是避免锁的争夺。</li>
<li>xv6 在这方面做得很少，但是复杂的内核会专门组织数据结构和算法来避免锁争用</li>
<li>在列表的例子中，一个内核可能会维护每个CPU 的空闲列表，只有当 CPU 的列表是空的，并且它必须从另一个 CPU 偷取内存时，才会接触另一个 CPU 的空闲列表。其他用例可能需要更复杂的设计</li>
</ul>
</li>
<li><p>锁的位置对性能也很重要。例如，在 <code>push</code> 中把 <code>acquisition</code> 移动到较早的位置也是正确的：将 <code>acquisition</code> 的调用移动到第 13 行之前是可以的。然而，这可能会降低性能，因为这样的话，对 <code>malloc</code> 的调用也会被序列化</p>
<ul>
<li>下面的 “使用锁” 一节提供了一些关于在哪里插入 <code>acquisition</code> 和 <code>release</code> 调用的指南</li>
</ul>
</li>
</ul>
<h2 id="代码：锁"><a href="#代码：锁" class="headerlink" title="代码：锁"></a>代码：锁</h2><ul>
<li>xv6 有两种类型的锁: 自旋锁 (spinlock) 和睡眠锁 (sleeplock)。我们先说说自旋锁<ul>
<li>xv6 将自旋锁表示为一个结构体 <code>spinlock</code> (kernel&#x2F;spinlock.h:2)。该结构中重要的字段是 <code>locked</code>，当锁可获得时，<code>locked</code> 为零，当锁被持有时，<code>locked</code> 为非零。从逻辑上讲，xv6 获取锁的的代码类似于:</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span><span class="comment">//doesnotwork!</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		<span class="keyword">if</span>(lk-&gt;locked == <span class="number">0</span>)&#123;</span><br><span class="line">			lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>不幸的是，这种实现并不能保证多处理器上的相互排斥。可能会出现这样的情况: 两个 CPU 同时到达 if 语句，看到 <code>lk-&gt;locked</code> 为零，然后都通过设置 <code>lk-&gt;locked=1</code> 来抢夺锁</p>
<ul>
<li>此时，两个不同的 CPU 持有锁，这就违反了互斥属性。我们需要的是让第 25 行和第 26 行作为一个原子 (即不可分割) 步骤来执行</li>
</ul>
</li>
<li><p>由于锁被广泛使用，多核处理器通常提供了一些原子版的指令</p>
<ul>
<li>在 RISC-V 上，这条指令是 <code>amoswapr,a</code>。<code>amoswap</code> 读取内存地址 <code>a</code> 处的值，将寄存器 <code>r</code> 的内容写入该地址，并将其读取的值放入 <code>r</code> 中，也就是说，它将寄存器的内容和内存地址进行了交换。它原子地执行这个序列，使用特殊的硬件来防止任何其他 CPU 使用读和写之间的内存地址</li>
</ul>
</li>
<li><p>xv6 的 <code>acquire</code> (kernel&#x2F;spinlock.c:22) 使用了可移植的 C 库调用 <code>__sync_lock_test_and_set</code>，它本质上为 <code>amoswap</code> 指令;返回值是 <code>lk-&gt;locked</code> 的旧 (被交换出来的) 内容</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock. 禁用中断避免死锁</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))	<span class="comment">// 检查当前CPU是否已经持有了这个锁，中断必须是关闭的</span></span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">// 在RISC-V中，sync_lock_test_and_set转换为一个原子的交换</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">  <span class="comment">// 告诉C编译器和处理器不要移动（重新排序）加载（loads）或存储（stores）操作在这一点之后</span></span><br><span class="line">  <span class="comment">// 以确保关键部分的内存引用严格地在获取锁之后发生</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，这会发出一个fence指令</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  <span class="comment">// 记录关于锁获取的信息，以便进行holding()和调试</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether this cpu is holding the lock. 检查当前CPU是否已经持有了这个锁，中断必须是关闭的</span></span><br><span class="line"><span class="comment">// Interrupts must be off.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">holding</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span></span><br><span class="line"><span class="comment">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span></span><br><span class="line"><span class="comment">// push_off/pop_off与intr_off()/intr_on()类似</span></span><br><span class="line"><span class="comment">// 但它们是配对的：需要两次pop_off()才能撤销两次push_off()的效果</span></span><br><span class="line"><span class="comment">// are initially off, then push_off, pop_off leaves them off.</span></span><br><span class="line"><span class="comment">// 另外，如果中断最初是关闭的，那么执行 push_off 和 pop_off 后，它们仍然保持关闭状态</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> old = intr_get();</span><br><span class="line"></span><br><span class="line">  intr_off();</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting. push_off()的嵌套深度</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>acquire</code> 函数循环交换，重试 (旋转) 直到获取了锁。每一次迭代都会将 1 交换到 <code>lk-&gt;locked</code> 中，并检查之前的值;如果之前的值为 0，那么我们已经获得了锁，并且交换将 <code>lk-&gt;locked</code> 设置为 1。如果之前的值是 1，那么其他 CPU 持有该锁，而我们原子地将 1 换成 <code>lk-&gt;locked</code> 并没有改变它的值</li>
</ul>
</li>
<li><p>一旦锁被获取，<code>acquire</code> 就会记录获取该锁的 CPU，这方便调试。<code>lk-&gt;cpu</code> 字段受到锁的保护，只有在持有锁的时候才能改变</p>
</li>
<li><p>函数 <code>release</code> (kernel&#x2F;spinlock.c:47) 与 <code>acquire</code> 相反:它清除 <code>lk-&gt;cpu</code> 字段，然后释放锁</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))	<span class="comment">// 检查当前CPU是否没有持有锁，中断必须是关闭的</span></span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// 告诉C编译器和CPU不要将加载或存储操作移动到这一点之后</span></span><br><span class="line">  <span class="comment">// 以确保在临界区内的所有存储操作在释放锁之前对其他CPU可见</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// 并且临界区内的加载操作严格在释放锁之前发生</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，这会生成一个fence指令</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0. 释放锁，等价于 lk-&gt;locked = 0 </span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard </span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// 这段代码不使用C语言的赋值操作，因为C标准暗示赋值操作可能会用多个存储指令来实现</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，sync_lock_release会转化为一个原子交换操作:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pop_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="keyword">if</span>(intr_get()) <span class="comment">// 中断必须是关闭的，否则就panic</span></span><br><span class="line">    panic(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena) <span class="comment">// 0层嵌套的pop_off()及在调用push_off()之前，中断是开启的</span></span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>从概念上讲，释放只需要给 <code>lk-&gt;locked</code> 赋值为 0</li>
<li>C 标准允许编译器用多条存储指令来实现赋值，所以 C 赋值对于并发代码来说可能是非原子性的</li>
<li>相反，<code>release</code> 使用 C 库函数 <code>__sync_lock_release</code> 执行原子赋值。这个函数也是使用了 RISC-V 的 <code>amoswap</code> 指令</li>
</ul>
</li>
</ul>
<h2 id="代码：使用锁"><a href="#代码：使用锁" class="headerlink" title="代码：使用锁"></a>代码：使用锁</h2><ul>
<li><p>xv6 在很多地方使用锁来避免竞赛条件。如上所述，<code>kalloc</code> (kernel&#x2F;kalloc.c:69) 和 <code>kfree</code> (kernel&#x2F;kalloc.c:47) 就是一个很好的例子</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>试着练习 1 和 2 看看如果这些函数省略了锁会发生什么事情。你可能会发现，很难触发不正确的行为，这说明很难可靠地测试代码是否没有锁定错误和竞争。xv6 有一些竞争也不是不可能的</li>
</ul>
</li>
<li><p>使用锁的一个难点是决定使用多少个锁，以及每个锁应该保护哪些数据和不变量。有几个基本原则</p>
<ul>
<li>首先，任何时候，当一个 CPU 可以在另一个 CPU 读或写变量的同时写入变量时，都应该使用锁来防止这两个操作重叠</li>
<li>第二，记住锁保护不变量：如果一个不变量涉及多个内存位置，通常需要用一个锁保护所有的位置，以确保不变式得到维护</li>
</ul>
</li>
<li><p>上面的规则说了什么时候需要锁，但没有说什么时候不需要锁，为了效率，不要锁太多，因为锁会降低并行性。如果并行性不重要，那么可以安排只有一个进程，而不用担心锁的问题</p>
<ul>
<li>一个简单的内核可以在多处理器上做到这一点，它有一个单一的锁，这个锁必须在进入内核时获得，并在退出内核时释放（尽管系统调用，如管道读取或等待会带来一个问题）。许多单处理器操作系统已经被改造成使用这种方法在多处理器上运行，有时被称为 “大内核锁”，但这种方法牺牲了并行性：内核中一次只能执行一个 CPU</li>
<li>如果内核做任何繁重的计算，那么使用一组更大的更细粒度的锁，这样内核可以同时在多个 CPU 上执行，效率会更高</li>
</ul>
</li>
<li><p>作为粗粒度锁的一个例子，xv6 的 kalloc.c 分配器有一个单一的空闲列表，由一个单一的锁构成。如果不同 CPU 上的多个进程试图同时分配页面，那么每个进程都必须通过在 <code>acquire</code> 中旋转来等待轮到自己。旋转会降低性能，因为这不是有用的工作</p>
<ul>
<li>如果争夺锁浪费了相当一部分 CPU 时间，也许可以通过改变分配器的设计来提高性能，使其拥有多个空闲列表，每个列表都有自己的锁，从而实现真正的并行分配（该分配器在 lockinglab 中会被重写——译者注）</li>
</ul>
</li>
<li><p>作为细粒度锁的一个例子，xv6 为每个文件都有一个单独的锁，这样操作不同文件的进程往往可以不用等待对方的锁就可以进行</p>
<ul>
<li>如果想让进程模拟写入同一文件的不同区域，文件锁方案可以做得更细。最终，锁的粒度决定需要由性能测量以及复杂性考虑来驱动</li>
<li>在后续的章节解释 xv6 的每个部分时，会提到 xv6 使用锁来处理并发性的例子。作为预览，图 6.3 列出了 xv6 中所有的锁。</li>
</ul>
</li>
</ul>
<img src="/2024/06/22/xv6-book-chapter-6/Figure-6.3.png" class="" title="Figure-6.3">

<h2 id="死锁和锁的顺序"><a href="#死锁和锁的顺序" class="headerlink" title="死锁和锁的顺序"></a>死锁和锁的顺序</h2><ul>
<li><p>如果一个穿过内核的代码路径必须同时持有多个锁，那么所有的代码路径以相同的顺序获取这些锁是很重要的。如果他们不这样做，就会有死锁的风险</p>
<ul>
<li>假设线程 T1 执行代码 path1 并获取锁 A，线程 T2 执行代码 path2 并获取锁 B，接下来 T1 会尝试获取锁 B，T2 会尝试获取锁 A，这两次获取都会无限期地阻塞，因为在这两种情况下，另一个线程都持有所需的锁，并且不会释放它，直到它的获取返回</li>
<li>为了避免这样的死锁，所有的代码路径必须以相同的顺序获取锁。对全局锁获取顺序的需求意味着锁实际上是每个函数规范的一部分: 调用者调用函数的方式必须使锁按照约定的顺序被获取</li>
</ul>
</li>
<li><p>由于 sleep 的工作方式 (见第 7 章)，xv6 有许多长度为 2 的锁序链，涉及到进程锁 ( <code>structproc</code> 中的锁)</p>
<ul>
<li><p>例如，<code>consoleintr</code> (kernel&#x2F;console.c:138) 是处理格式化字符的中断流程。当一个新数据到达时，任何正在等待控制台（终端，即 cmd）输入的进程都应该被唤醒。为此，<code>consoleintr</code> 在调用 <code>wakeup</code> 时持有 <code>cons.lock</code>，以获取进程锁来唤醒它。因此，全局避免死锁的锁顺序包括了 <code>cons.lock</code> 必须在任何进程锁之前获取的规则</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the console input interrupt handler. 控制台输入中断处理程序</span></span><br><span class="line"><span class="comment">// uartintr() calls this for input character. 输入一个字符时uartintr()调用它</span></span><br><span class="line"><span class="comment">// do erase/kill processing, append to cons.buf, 处理退格/删除操作，追加字符到cons.buf</span></span><br><span class="line"><span class="comment">// wake up consoleread() if a whole line has arrived. 唤醒consoleread()如果一整行到达</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;P&#x27;</span>)</span>:  <span class="comment">// Print process list.</span></span><br><span class="line">    <span class="title function_">procdump</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;U&#x27;</span>)</span>:  <span class="comment">// Kill line.</span></span><br><span class="line">    <span class="title function_">while</span><span class="params">(cons.e != cons.w &amp;&amp;</span></span><br><span class="line"><span class="params">          cons.buf[(cons.e<span class="number">-1</span>) % INPUT_BUF_SIZE] != <span class="string">&#x27;\n&#x27;</span>)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;H&#x27;</span>)</span>: <span class="comment">// Backspace</span></span><br><span class="line">  <span class="keyword">case</span> &#x27;\x7f&#x27;: <span class="comment">// Delete key</span></span><br><span class="line">    <span class="title function_">if</span><span class="params">(cons.e != cons.w)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)&#123;</span><br><span class="line">      c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// echo back to the user.</span></span><br><span class="line">      consputc(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;</span><br><span class="line">        <span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line">        <span class="comment">// has arrived.</span></span><br><span class="line">        cons.w = cons.e;</span><br><span class="line">        wakeup(&amp;cons.r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>文件系统代码包含 xv6 最长的锁链。例如，创建一个文件需要同时持有目录的锁、新文件的 inode 的锁、磁盘块缓冲区的锁、磁盘驱动器的 <code>vdisk_lock</code> 和调用进程的 <code>p-&gt;lock</code>。为了避免死锁，文件系统代码总是按照上一句提到的顺序获取锁</p>
</li>
</ul>
</li>
<li><p>遵守全局避免死锁的顺序可能会非常困难。有时锁的顺序与逻辑程序结构相冲突，例如，也许代码模块 M1 调用模块 M2，但锁的顺序要求 M2 中的锁在 M1 中的锁之前被获取</p>
<ul>
<li>有时锁的身份并不是事先知道的，也许是因为必须持有一个锁才能发现接下来要获取的锁的身份。这种情况出现在文件系统中，因为它在路径名中查找连续的组件，也出现在 <code>wait</code> 和 <code>exit</code> 的代码中，因为它们搜索进程表寻找子进程</li>
<li>最后，死锁的危险往往制约着人们对锁方案的细化程度，因为更多的锁往往意味着更多的死锁机会。避免死锁是内核实现的重要需求</li>
</ul>
</li>
</ul>
<h2 id="锁与中断处理"><a href="#锁与中断处理" class="headerlink" title="锁与中断处理"></a>锁与中断处理</h2><ul>
<li><p>一些 xv6 自旋锁保护的数据会被线程和中断处理程序两者使用。例如，<code>clockintr</code> 定时器中断处理程序可能会在内核线程读取<code>sys_sleep</code> (kernel&#x2F;sysproc.c:64) 中的 <code>ticks</code> 的同时，递增 <code>ticks</code> (kernel&#x2F;trap.c:163)。锁 <code>tickslock</code> 将保护两次临界区</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;n);</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>自旋锁和中断的相互作用带来了一个潜在的危险。假设 <code>sys_sleep</code> 持有 <code>tickslock</code>，而它的 CPU 接收到一个时钟中断。<code>clockintr</code> 会尝试获取 <code>tickslock</code>，看到它被持有，并等待它被释放。在这种情况下，<code>tickslock</code> 永远不会被释放：只有<code>sys_sleep</code> 可以释放它，但 <code>sys_sleep</code> 不会继续运行，直到 <code>clockintr</code> 返回。所以 CPU 会死锁，任何需要其他锁的代码也会冻结</p>
</li>
<li><p>为了避免这种情况，如果一个中断处理程序使用了自旋锁，CPU 决不能在启用中断的情况下持有该锁。xv6 则采用了更加保守的策略：当一个 CPU 获取任何锁时，xv6 总是禁用该 CPU 上的中断。中断仍然可能发生在其他 CPU 上，所以一个中断程序获取锁会等待一个线程释放自旋锁，但它们不在同一个 CPU 上</p>
</li>
<li><p>xv6 在 CPU 没有持有自旋锁时重新启用中断;它必须做一点记录来应对嵌套的临界区</p>
<ul>
<li><p><code>acquire</code> 调用 <code>push_off</code> (kernel&#x2F;spinlock.c:89) 和 <code>release</code> 调用 <code>pop_off</code> (kernel&#x2F;spinlock.c:100) 来跟踪当前 CPU 上锁的嵌套级别。当该计数达到零时，<code>pop_off</code> 会恢复最外层临界区开始时的中断启用状态</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting. push_off()的嵌套深度</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span></span><br><span class="line"><span class="comment">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span></span><br><span class="line"><span class="comment">// push_off/pop_off与intr_off()/intr_on()类似</span></span><br><span class="line"><span class="comment">// 但它们是配对的：需要两次pop_off()才能撤销两次push_off()的效果</span></span><br><span class="line"><span class="comment">// are initially off, then push_off, pop_off leaves them off.</span></span><br><span class="line"><span class="comment">// 另外，如果中断最初是关闭的，那么执行 push_off 和 pop_off 后，它们仍然保持关闭状态</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> old = intr_get();</span><br><span class="line"></span><br><span class="line">  intr_off();</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pop_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="keyword">if</span>(intr_get()) <span class="comment">// 中断必须是关闭的，否则就panic</span></span><br><span class="line">    panic(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena) <span class="comment">// 0层嵌套的pop_off()及在调用push_off()之前，中断是开启的</span></span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>intr_off</code> 和 <code>intr_on</code> 函数分别执行 RISC-V 指令来禁用和启用中断</p>
</li>
</ul>
</li>
<li><p>在设置 <code>lk-&gt;locked</code> 之前，严格调用 <code>push_off</code> 是很重要的 (kernel&#x2F;spinlock.c:28)。如果两者反过来，那么在启用中断的情况下，锁会有一个窗口 (未锁到的位置)，在未禁止中断时持有锁。在这种情况下，一个时机恰到好处的时钟中断会使系统死锁</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>同样，释放锁后才调用 <code>pop_off</code> 也很重要 (kernel&#x2F;spinlock.c:66)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="指令与存储的顺序"><a href="#指令与存储的顺序" class="headerlink" title="指令与存储的顺序"></a>指令与存储的顺序</h2><ul>
<li><p>人们很自然地认为程序是按照源代码语句出现的顺序来执行的。然而，许多编译器和 CPU 为了获得更高的性能，会不按顺序执行代码</p>
<ul>
<li>如果一条指令需要很多周期才能完成，CPU 可能会提前发出该指令，以便与其他指令重叠，避免 CPU 停顿。例如，CPU 可能会注意到在一个串行序列中，指令 A 和 B 互不依赖。CPU 可能先启动指令 B，这是因为它的输入在 A 的输入之前已经准备好了，或者是为了使 A 和 B 的执行重叠</li>
<li>编译器可以执行类似的重新排序，在一条语句的指令之前发出另一条语句的指令，由于它们原来的顺序</li>
</ul>
</li>
<li><p>编译器和 CPU 在对指令重新排序时遵循相应规则，以确保它们不会改变正确编写的串行代码的结果。然而，这些规则确实允许重排，从而改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU 的指令排序规则规则称为内存模型 (memory model)</p>
</li>
<li><p>例如，在这段 <code>push</code> 的代码中，如果编译器或 CPU 将第 4 行对应的存储移到第 6 行释放后的某个点，那将是一场灾难</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">l-&gt;data = data;</span><br><span class="line">acquire(&amp;listlock);</span><br><span class="line">l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">release(&amp;listlock);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果发生这样的重排，就会有一个指令执行的窗口。在这个窗口中，另一个 CPU 可以获取锁并观察更新的链表，但看到的是一个未初始化的 <code>list-&gt;next</code></p>
</li>
<li><p>为了告诉硬件和编译器不要执行这样的 re-ordering，xv6 在 <code>acquire</code> (kernel&#x2F;spinlock.c:22) 和 <code>release</code> (kernel&#x2F;spinlock.c:47) 中都使用了 <code>__sync_synchronize()</code>。<code>__sync_synchronize()</code> 是一个内存屏障 (memory barrier): 它告诉编译器和 CPU 不要在越过屏障重新排列任何的内存读写操作。<code>acquire</code> 和 <code>release</code> 中的屏障几乎在所有重要的情况下都会强制锁定顺序，因为 xv6 在访问共享数据的周围使用锁。第 9 章讨论了一些例外情况</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock. 禁用中断避免死锁</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))	<span class="comment">// 检查当前CPU是否已经持有了这个锁，中断必须是关闭的</span></span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">// 在RISC-V中，sync_lock_test_and_set转换为一个原子的交换</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">  <span class="comment">// 告诉C编译器和处理器不要将（重新排序）加载（loads）或存储（stores）操作移动到这一点之后</span></span><br><span class="line">  <span class="comment">// 以确保关键部分的内存引用严格地在获取锁之后发生</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，这会发出一个fence指令</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  <span class="comment">// 记录关于锁获取的信息，以便进行holding()和调试</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))	<span class="comment">// 检查当前CPU是否没有持有锁，中断必须是关闭的</span></span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// 告诉C编译器和CPU不要将加载或存储操作移动到这一点之后</span></span><br><span class="line">  <span class="comment">// 以确保在临界区内的所有存储操作在释放锁之前对其他CPU可见</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// 并且临界区内的加载操作严格在释放锁之前发生</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，这会生成一个fence指令</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0. 释放锁，等价于 lk-&gt;locked = 0 </span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard </span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// 这段代码不使用C语言的赋值操作，因为C标准暗示赋值操作可能会用多个存储指令来实现</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，sync_lock_release会转化为一个原子交换操作:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="睡眠锁"><a href="#睡眠锁" class="headerlink" title="睡眠锁"></a>睡眠锁</h2><ul>
<li><p>有时 xv6 需要长时间保持一个锁。例如，文件系统（第 8 章）在磁盘上读写文件内容时，会保持一个文件的锁定，这些磁盘操作可能需要几十毫秒。如果另一个进程想获取一个自旋锁，那么保持那么长的时间会导致浪费，因为第二个进程在等待锁的同时会浪费 CPU 很长时间</p>
<ul>
<li>自旋锁的另一个缺点是，一个进程在保留自旋锁的同时不能释放 CPU 并将自身转变为就绪态；我们希望做到这一点，以便在拥有自旋锁的进程等待磁盘时，其他进程可以使用 CPU</li>
<li>在持有自旋锁时释放 CPU 是非法的，因为如果第二个线程再试图获取自旋锁，可能会导致死锁；由于 <code>acquire</code> 并不能释放 CPU，第二个进程的等待可能会阻止第一个进程运行和释放锁。在持有锁的同时释放 CPU 也会违反在持有自旋锁时中断必须关闭的要求</li>
<li>因此，我们希望有一种锁，在等待获取的同时让 CPU 可以进行别的工作，并在锁被持有时允许释放 CPU，同时开放中断</li>
</ul>
</li>
<li><p>xv6 以睡眠锁 (sleeplock) 的形式提供了这样的锁。<code>acquiresleep</code> (kernel&#x2F;sleeplock.c:22) 在等待时产生 CPU，使用的技术将在第 7 章解释</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">  lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user read()s from the console go here.</span></span><br><span class="line"><span class="comment">// copy (up to) a whole input line to dst.</span></span><br><span class="line"><span class="comment">// user_dist indicates whether dst is a user</span></span><br><span class="line"><span class="comment">// or kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint target;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">  target = n;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// wait until interrupt handler has put some</span></span><br><span class="line">    <span class="comment">// input into cons.buffer.</span></span><br><span class="line">    <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">      <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">        release(&amp;cons.lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c = cons.buf[cons.r++ % INPUT_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == C(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file</span></span><br><span class="line">      <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">        <span class="comment">// Save ^D for next time, to make sure</span></span><br><span class="line">        <span class="comment">// caller gets a 0-byte result.</span></span><br><span class="line">        cons.r--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line">    cbuf = c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    dst++;</span><br><span class="line">    --n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">      <span class="comment">// the user-level read().</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>在高层次上，睡眠锁有一个由 <code>spinlock</code> 保护的锁定字段，<code>acquiresleep</code> 调用 <code>sleep</code> 原子性地让渡 CPU 并释放 <code>spinlock</code>。结果就是，在 <code>acquireleep</code> 等待的时候，其他线程可以执行</li>
</ul>
</li>
<li><p>因为睡眠锁使中断处于启用状态，所以它们不能用于中断处理程序中。由于 <code>acquiresleep</code> 可能会释放 CPU，所以睡眠锁不能在自旋锁的核心代码中使用（尽管自旋锁可以在睡眠锁的核心代码中使用）</p>
</li>
<li><p>自旋锁最适合于短的关键部分，因为等待它们会浪费 CPU 时间；睡眠锁对长的操作很有效</p>
</li>
</ul>
<h2 id="现实世界"><a href="#现实世界" class="headerlink" title="现实世界"></a>现实世界</h2><ul>
<li><p>尽管对并发基元和并行进行了多年的研究，但使用锁进行编程仍然具有挑战性。通常最好是将锁隐藏在更高级别的构造中，比如同步队列，尽管 xv6 没有这样做</p>
<ul>
<li>如果您使用锁编程，明智的做法是使用一个试图识别竞争条件的工具，因为很容易错过一个需要锁的不变式</li>
</ul>
</li>
<li><p>大多数操作系统都支持 POSIX 线程（Pthreads），它允许一个用户进程在不同的 CPU 上有多个线程同时运行。Pthreads 对用户级锁、屏障等都有支持</p>
<ul>
<li>支持 Pthreads 需要操作系统的支持。例如，应该是如果一个 pthread 在系统调用中阻塞，同一进程的另一个 pthread 应该可以在该 CPU 上运行。又比如，如果一个 pthread 改变了它的进程的地址空间（比如映射或取消映射内存），内核必须安排运行同一进程线程的其他 CPU 更新它们的硬件页表以反映地址空间的变化</li>
</ul>
</li>
<li><p>可以在没有原子指令的情况下实现锁，但成本很高，大多数操作系统都使用原子指令</p>
</li>
<li><p>如果许多 CPU 试图同时获取同一个锁，那么锁的成本会很高。如果一个 CPU 的本地缓存中有一个锁，而另一个 CPU 必须获取该锁，那么更新持有该锁的缓存行的原子指令必须将该行从一个 CPU 的缓存中移到另一个 CPU 的缓存中，并且可能使缓存行的任何其他副本无效。从另一个 CPU 的缓存中获取缓存单元的代价可能比从本地缓存中获取行的代价高出一个数量级</p>
</li>
<li><p>为了避免与锁相关的代价，许多操作系统使用无锁数据结构和算法。例如，可以实现像本章开头那样的链接列表，在列表搜索过程中不需要锁，只需要一条原子指令就可以在列表中插入一个项目</p>
<ul>
<li>不过，无锁编程比有锁编程更复杂，例如，必须担心指令和内存的重新排序问题。用锁编程已经很难了，所以 xv6 避免了无锁编程的额外复杂性</li>
</ul>
</li>
</ul>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li>删去 <code>kalloc</code> (kernel&#x2F;kalloc.c:69) 中对 acquire 和 release 的调用。这似乎会给调用 kalloc 的内核代码带来问题。你觉得会发生什么？当你运行 xv6 时，和你想的一样吗？运行 <code>usertests</code> 的时候呢？如果你没有看到问题，为什么没有呢？看看你是否可以通过在 kalloc 的关键部分插入 dummy loops 来引发问题</li>
<li>假设你在 <code>kfree</code> 中注释了锁 (在恢复 <code>kalloc</code> 的锁之后)。现在可能出了什么问题？<code>kfree</code> 中缺少锁是否比 kalloc 中缺少锁的危害小？</li>
<li>如果两个 CPU 同时调用 <code>kalloc</code>，其中一个就要等待另一个，这对性能不利。修改 <code>kalloc.c</code>，使其具有更多的并行性，这样不同 CPU 对 <code>kalloc</code> 的同时调用就可以进行，而不需要等待对方</li>
<li>使用大多数操作系统都支持的 POSIX 线程 (Pthreads) 编写一个并行程序。例如，实现一个并行哈希表，并测量 put&#x2F;get 操作的数量是否随着核心数的增加而增加</li>
<li>在 xv6 中实现 Pthreads 的一个子集。即实现用户级线程库，使一个用户进程可以有 1 个以上的线程，并安排这些线程可以在不同的 CPU 上并行运行。提出一个设计，正确处理线程进行阻塞系统调用和改变其共享地址空间的问题</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/20/6-S081-Lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/20/6-S081-Lab5/" class="post-title-link" itemprop="url">Lab Copy on-write</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-20 16:39:25" itemprop="dateCreated datePublished" datetime="2024-06-20T16:39:25+08:00">2024-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-22 23:13:11" itemprop="dateModified" datetime="2024-06-22T23:13:11+08:00">2024-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>Lab Guidance：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/labs/cow.html">Lab: Copy-on-Write Fork for xv6 (mit.edu)</a></p>
</li>
<li><p>虚拟内存提供了一种程度的间接性：内核可以通过将 PTE 标记为无效或只读来拦截内存引用，从而导致页面错误，并且可以通过修改 PTE 来更改地址的含义</p>
</li>
<li><p>计算机系统中有句谚语：任何系统问题都可以通过间接层来解决</p>
</li>
<li><p>在开始前，输入：<code>git fetch &amp;&amp; git checkout cow &amp;&amp; make clean</code> 来切换到 cow 分支</p>
</li>
</ul>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ul>
<li>xv6 中的 <code>fork()</code> 系统调用将父进程的所有用户空间内存复制到子进程中，如果父进程很大，复制可以需要很长时间，更糟糕的是：子进程中，<code>fork()</code> 后面通常是 <code>exec()</code>，它丢弃了复制的内存，通常不使用大部分内存</li>
<li>另一方面，如果父进程和子进程使用一个复制页面，并且他们中的一个或两个都写它，复制确实是需要的</li>
</ul>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li>你实现写时复制（COW）<code>fork()</code> 的目标是推迟分配和复制物理内存页面，直到真正需要副本</li>
<li>COW <code>fork()</code> 仅为子进程创建一个页表，用户内存的 PTE 指向父级物理页面。COW <code>fork()</code> 将父进程和子进程中的所有用户 PTE 标记为只读。当任一进程尝试写这些 COW 页面之一时，CPU 将强制出现页面错误。内核页面错误处理程序检测此情况，为发生错误的进程分配一个物理内存页面，将原始页面复制到新页面，并修改发生错误进程中的相关 PTE 以引用新页面，PTE 标记为可写。当页面错误处理程序返回时，用户进程将能够写页面的副本了。</li>
<li>COW <code>fork()</code> 使释放实现用户内存的物理页面变得有些棘手。给定的物理页面可以被多个进程的页表引用，并且只有在最后一个引用消失时才应释放。在像 xv6 这样的简单内核中，这种记录相当简单明了，但在真正的内核中，这可能很难正确</li>
</ul>
<h1 id="Implement-copy-on-write-fork"><a href="#Implement-copy-on-write-fork" class="headerlink" title="Implement copy-on-write fork"></a>Implement copy-on-write fork</h1><ul>
<li><p>你的任务是在 xv6 内核中实现写时复制 <code>fork()</code>。如果你修改后的内核成功执行了 <code>cowtest</code> 和 <code>usertests</code>，则通过</p>
</li>
<li><p>这是一个合理的 attack 计划</p>
<ul>
<li>修改 <code>uvmcopy()</code> 以将父进程的物理页面映射到子进程，而不是分配的新的页面。对于设置了 PTE_W 的页面，在子进程和父进程的 PTE 中清除 PTE_W</li>
<li>修改 <code>usertrap()</code> 以识别页面错误。当最初的可写入 COW 页面上发生页面错误时，使用 <code>kalloc()</code> 分配一个新页面，将旧页面复制到新页面，并在设置 PTE_W 的 PTE 中设置新页面。最初只读的页面（没有 PTE_W，如文本段中的页面）应保持只读状态，并在父进程和子进程之间共享；试图写此类页面的进程应该被终止</li>
<li>确保每个物理页面在最后一次 PTE 引用消失时释放——但不是之前。做到这一点的一个好方法是为每个物理页面保留引用该页面的 “引用计数”。当 <code>kalloc()</code> 分配页面时，将页面的引用计数设置为 1。当 <code>fork()</code> 导致共享页面时，增加页面的引用计数，每次任何进程将页面从其页面表中删除时，都会减少页面的引用计数。<code>kfree()</code> 仅当其引用计数为零时，才将页面放回到空闲链表中。将这些计数保留在固定大小的整数数组中是可以的。你必须制定一个如何索引数组以及如何选择其大小的方案。例如，你可以将页面的物理地址除以 4096 对数组进行索引，并通过 <code>kalloc.c</code> 中的 <code>kinit()</code> 为数组提供等于空闲链表中页面的最高物理地址的大小。随意修改 <code>kalloc.c</code>（例如，<code>kalloc()</code> 和 <code>kfree()</code>）以保持引用计数</li>
<li>修改 <code>copyout()</code>，以便在遇到 COW 页面时使用与页面错误系统的方案</li>
</ul>
</li>
<li><p>一些提示</p>
<ul>
<li>对于每个 PTE，有一种记录它是否是 COW 映射的方法可能是有用的。你可以使用 RISC-V 中的 RSW（保留给软件）位</li>
<li><code>usertests</code> 探索了 <code>cowtest</code> 不测试的场景，所以不要忘记检查所有的测试是否通过</li>
<li>对页表标志有用的一些宏定义在 <code>kernel/riscv.h</code> 的末尾</li>
<li>如果发生 COW 页面错误，并且没有可用的内存，则应该终止进程</li>
</ul>
</li>
</ul>
<img src="/2024/06/20/6-S081-Lab5/image-20240622211042467.png" class="" title="image-20240622211042467">

<ul>
<li>在 <code>kernel/riscv.h</code> 中添加 <code>PTE_COW</code> 来标记这是一个 COW 页面</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L &lt;&lt; 4) <span class="comment">// user can access</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8) <span class="comment">// COW</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/vm.c</code> 中，修改 <code>uvmcopy()</code> 将父进程的物理内存映射到子进程的页表中，需要注意的是：<ul>
<li>只有 PTE 拥有 PTE_W 时才消除 PTE_W，添加 PTE_COW。PTE 没有 PTE_W 时有两种情况，第一种是已经是 COW 页面了，第二种是只读页面</li>
<li>在将可写页面设置为 COW 页面时有一个逻辑上的细节。当一个 PTE 拥有 PTE_W 时，将父进程的 PTE  消除 PTE_W，添加 PTE_COW，之后子进程 <code>(mappages(new, i, PGSIZE, pa, flags)</code> 映射时，由于父进程 PTE 的 <code>flags</code> 已经更新，所以子进程的相关页面也是 COW 页面了。不仅更新了父进程的可写页面为 COW 页面，之后子进程的相关也是 COW 页面了</li>
<li>映射成功后，通过 <code>add_refcount(pa)</code> （之后讨论方法的具体实现及细节）增加对应页面的引用计数</li>
<li>发生错误 <code>goto err</code> 时，调用了 <code>uvmunmap(new, 0, i / PGSIZE, 1)</code>，第四个参数为 1 表示取消映射且 <code>kfree()</code> 映射的物理内存，这也是与引用计数相关的细节，之后再讨论</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given a parent process&#x27;s page table, copy 给定一个父进程的页表，复制其内存到子进程的页表中</span></span><br><span class="line"><span class="comment">// its memory into a child&#x27;s page table.</span></span><br><span class="line"><span class="comment">// Copies both the page table and the 复制页表和物理内存</span></span><br><span class="line"><span class="comment">// physical memory.</span></span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure. 成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="comment">// frees any allocated pages on failure. 如果失败，释放任何已分配的页面</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_W) != <span class="number">0</span>) &#123;</span><br><span class="line">      *pte |= PTE_COW;</span><br><span class="line">      *pte &amp;= (~PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span> (mappages(new, i, PGSIZE, pa, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: mappages error&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    add_refcount(pa);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err:</span><br><span class="line">    uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 <code>copyout()</code> 和发生页面错误时 <code>usertrap()</code> 的处理方案相同，所以创建一个方法来解决，需要注意的是：<ul>
<li><code>va &gt; MAXVA</code> 中的 <code>MAXVA</code> 真的值得注意，不要写成 <code>MAXARG</code>（因为它，我重新写了整个实验！）</li>
<li>如果 PTE 没有 PTE_W，也没有 PTE_COW 时，说明它是一个最初的只读页面，不能写。此时 <code>usertrap()</code> 会终止写一个只读页面而造成 page fault 的进程；<code>copyout()</code> 也是一样（<code>usertests</code> 的 <code>copyout</code> 测试了它，由于这个条件没写，Debug 很久，又重新写了一次实验！！）</li>
<li>如果 PTE 没有 PTE_W，或者没有 PTE_COW，此时 PTE 是一个最初的可写页面。最后 PTE 就只能是 COW 页面了</li>
<li>如果 COW 页面的引用计数为 1，那么添加 PTE_W，消除 PTE_COW，重新变为最初的可写页面</li>
<li><code>(mappages(pagetable, PGROUNDDOWN(va), PGSIZE, pa1, flags)</code> 失败时需要 <code>kfree()</code>，当然也和引用计数有关</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">handler_COW</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa0, pa1, flags;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pte == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_U) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pa0 = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_COW) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_W) != <span class="number">0</span> || (*pte &amp; PTE_COW) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> pa0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_refcount(pa0) == <span class="number">1</span>) &#123;</span><br><span class="line">    *pte &amp;= (~PTE_COW);</span><br><span class="line">    *pte |= PTE_W;</span><br><span class="line">    <span class="keyword">return</span> pa0;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (get_refcount(pa0) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    panic(<span class="string">&quot;handle_COW: refcount &lt;= 0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((pa1 = (uint64)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  flags = PTE_FLAGS(*pte);</span><br><span class="line">  flags |= PTE_W;</span><br><span class="line">  flags &amp;= (~PTE_COW);</span><br><span class="line">  memmove((<span class="type">void</span> *)pa1, (<span class="type">void</span> *)pa0, PGSIZE);</span><br><span class="line">  uvmunmap(pagetable, PGROUNDDOWN(va), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, PGROUNDDOWN(va), PGSIZE, pa1, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *)pa1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pa1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/vm.c</code> 中，修改 <code>copyout()</code>，在遇到 COW 页面时采用上述方案</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user. 从内核复制到用户空间</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table. 复制len字节从src到给定的页表中的虚拟地址dstva</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.  返回0表示成功，-1表示失败</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="comment">// printf(&quot;here &quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    </span><br><span class="line">    pa0 = handler_COW(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/defs.h</code> 中添加 <code>handler_COW</code> 以便在 <code>usertrap()</code> 中调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm.c</span></span><br><span class="line">uint64          <span class="title function_">handler_COW</span><span class="params">(<span class="type">pagetable_t</span> pagatable, uint64 va)</span>;</span><br></pre></td></tr></table></figure>

<style>.itxikektdkdy{zoom: 67%;}</style><img src="/2024/06/20/6-S081-Lab5/image-20240622221123530.png" class="itxikektdkdy" alt="image-20240622221123530">

<ul>
<li><code>kernel/trap.c</code> 中，修改 <code>usertrap()</code> 处理由于写 COW 页面而造成的 page fault。如果写一个只读页面，立即终止这个进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">    <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span>(handler_COW(p-&gt;pagetable, va) == <span class="number">0</span>)&#123;  </span><br><span class="line">      setkilled(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">      setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/kalloc.c</code> 中创建相关结构体和方法，实现引用计数，需要注意的是：<ul>
<li>由于记录引用计数的数组属于临界资源，所以需要锁来实现互斥访问</li>
<li>由于 <code>refcount</code> 结构体变量是全局变量，所以引用计数数组中所有元素初始值为 0</li>
<li><code>PHYSTOP</code> 是物理内存地址的最大值，<code>KERNBASE</code> 是物理内存地址的最小值，在 <code>kernel/memlayout.h</code> 中定义</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[(PHYSTOP - KERNBASE) / PGSIZE];</span><br><span class="line">&#125; refcount;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_refcount</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || pa &gt;= PHYSTOP) &#123;</span><br><span class="line">    panic(<span class="string">&quot;add_refcount: index error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint64 ret;</span><br><span class="line">  pa = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  ret = ++refcount.<span class="built_in">array</span>[pa];</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_refcount</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || pa &gt;= PHYSTOP) &#123;</span><br><span class="line">    panic(<span class="string">&quot;sub_refcount: index error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pa = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  ret = --refcount.<span class="built_in">array</span>[pa];</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_refcount</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || pa &gt;= PHYSTOP) &#123;</span><br><span class="line">    panic(<span class="string">&quot;get_refcount: index error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pa = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  ret = refcount.<span class="built_in">array</span>[pa];</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kinit()</code> 初始化锁（好像并不需要，因为锁的初始值就是 0）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;refcount.lock, <span class="string">&quot;refcount&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kfree()</code>，每次调用 <code>kfree()</code> 时都会减少引用计数，只有引用计数为 0 时才真正释放物理内存，需要注意的是：<ul>
<li>经过之前的修改，每个进程在将页面从页表中删除时，都会调用 <code>kfree()</code> 释放映射的物理内存，因此最终在 <code>kfree()</code> 中减少引用计数是合理的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sub_refcount((uint64)pa) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kalloc()</code> 在分配页面时，将引用计数设置为 1，需要注意的是：<ul>
<li>只有分配成功时才设置引用计数，由于引用计数初始值为 0，加一后为 1</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r) &#123;</span><br><span class="line">    add_refcount((uint64)r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>freerange()</code>，一个回马枪，需要注意的是：<ul>
<li><code>kinit()</code> 调用了 <code>freerange()</code>，<code>freerange()</code> 对每个物理页面调用了 <code>kfree()</code> 将其添加到空闲链表</li>
<li>由于引用计数初始值都为 0，减一后不等于 0 会导致无法添加，加一保证了页面可以添加到空闲链表</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE) &#123;</span><br><span class="line">    add_refcount((uint64)p);</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/defs.h</code> 中添加相关函数原型，以便在其他文件中调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="type">int</span>             <span class="title function_">add_refcount</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">sub_refcount</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">get_refcount</span><span class="params">(uint64 pa)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; cowtest &amp;&amp; usertests</strong></li>
</ul>
<img src="/2024/06/20/6-S081-Lab5/image-20240622230114645.png" class="" title="image-20240622230114645">

<img src="/2024/06/20/6-S081-Lab5/image-20240622230857574.png" class="" title="image-20240622230857574">

<ul>
<li><strong>make grade</strong></li>
</ul>
<img src="/2024/06/20/6-S081-Lab5/image-20240622231107743.png" class="" title="image-20240622231107743">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/121418548">MIT 6.S081] Lab 6: Copy-on-Write Fork for xv6_xv6 lab cow-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16170379.html">MIT6.S081-Lab5 COW 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://ttzytt.com/2022/07/xv6_lab6_record/index.html">MIT 6.s081] Xv6 Lab6 COW 实验记录 | tzyt的博客 (ttzytt.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.expoli.tech/articles/2023/07/25/[MIT-6.s081]-Lab:-Copy-on-Write-Fork-for-xv6-experiment-record#d40c70a00c7e45e59250f5f9d4c99297">MIT 6.s081] Lab: Copy-on-Write Fork for xv6 实验记录 | 糖醋鱼的小破站 (expoli.tech)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/644779152">MIT 6.828 LAB 5 COW 代码与debug - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cstardust.github.io/2022/11/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab6-cow/">操作系统-xv6-lab6-cow | 不落辰 (cstardust.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/traver/p/15778370.html">MIT 6.S081 操作系统 LAB6:Copy-on-Write - traver - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/19/xv6-book-chapter-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/19/xv6-book-chapter-5/" class="post-title-link" itemprop="url">xv6 book chapter 5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-19 14:54:58" itemprop="dateCreated datePublished" datetime="2024-06-19T14:54:58+08:00">2024-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-22 18:37:07" itemprop="dateModified" datetime="2024-06-22T18:37:07+08:00">2024-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="中断和设备驱动"><a href="#中断和设备驱动" class="headerlink" title="中断和设备驱动"></a>中断和设备驱动</h1><ul>
<li><p><strong>驱动</strong> 是操作系统中管理特定设备的代码，它有如下功能：1、配置设备相关的硬件，2、告诉设备需要怎样执行，3、处理设备产生的中断，4、与等待设备 I&#x2F;O 的进程进行交互</p>
<ul>
<li>驱动程序的代码写起来可能很棘手，因为驱动程序与它所管理的设备会并发</li>
<li>此外，驱动必须了解设备的硬件接口，但硬件接口可能是很复杂的，而且文档不够完善</li>
</ul>
</li>
<li><p>需要操作系统关注的设备通常可以被配置为产生中断，这是 trap 的一种类型</p>
<ul>
<li>内核 trap 处理代码可以知道设备何时引发了中断，并调用驱动的中断处理程序</li>
<li>在 xv6 中，这个处理发生在 <strong>devintr</strong> (kernel&#x2F;trap.c:177) 中</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt, 检查它是一个外部中断还是软件中断，并处理它</span></span><br><span class="line"><span class="comment">// and handle it.</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt, 	如果是定时器中断，返回 2</span></span><br><span class="line"><span class="comment">// 1 if other device, 				如果是其他设备的中断，返回 1</span></span><br><span class="line"><span class="comment">// 0 if not recognized. 			如果未识别，返回 0</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// irq indicates which device interrupted.</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the PLIC allows each device to raise at most one</span></span><br><span class="line">    <span class="comment">// interrupt at a time; tell the PLIC the device is</span></span><br><span class="line">    <span class="comment">// now allowed to interrupt again.</span></span><br><span class="line">    <span class="keyword">if</span>(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">    <span class="comment">// forwarded by timervec in kernelvec.S.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>许多设备驱动程序在两个 context 中执行代码：上半部分（<strong>top half</strong>）在进程的内核线程中运行，下半部分（<strong>bottom half</strong>）在中断时执行<ul>
<li>上半部分是通过系统调用，如希望执行 I&#x2F;O 的 read 和 write。这段代码可能会要求硬件开始一个操作（比如要求磁盘读取一个块）；然后代码等待操作完成。最终设备完成操作并引发一个中断</li>
<li>驱动程序的中断处理程序，作为 <strong>下半部分</strong>，找出什么操作已经完成，如果合适的话，唤醒一个等待该操作的进程，并告诉硬件执行下一个操作</li>
</ul>
</li>
</ul>
<h2 id="Code-Console-input-控制台输入"><a href="#Code-Console-input-控制台输入" class="headerlink" title="Code: Console input 控制台输入"></a>Code: Console input 控制台输入</h2><ul>
<li><p>控制台驱动 (console.c) 是驱动结构的一个简单说明</p>
<ul>
<li>控制台驱动通过连接到 RISC-V 上的 UART 串行端口硬件，接受输入的字符。控制台驱动程序每次累计一行输入，处理特殊的输入字符，如退格键和 control-u</li>
<li>用户进程，如 shell，使用 <strong>read</strong> 系统调用从控制台获取输入行</li>
<li>当你在 QEMU 中向 xv6 输入时，你的按键会通过 QEMU 的模拟 UART 硬件传递给 xv6</li>
</ul>
</li>
<li><p>与驱动交互的 UART 硬件是由 QEMU 仿真的 16550芯片[11]</p>
<ul>
<li>在真实的计算机上，16550 将管理一个连接到终端或其他计算机的 RS232 串行链接。当运行 QEMU 时，它连接到你的键盘和显示器上</li>
</ul>
</li>
<li><p>UART 硬件在软件看来是一组 <strong>内存映射</strong> 的控制寄存器。也就是说，有一些 RISC-V 硬件的物理内存地址会关联到 UART 设备，因此加载和存储与设备硬件而不是 RAM 交互</p>
<ul>
<li><p>UART 的内存映射地址从 0x10000000 开始，即 <strong>UART0</strong>（kernel&#x2F;memlayout.h:21）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这里有一些 UART 控制寄存器，每个寄存器的宽度是一个字节。它们与 UART0 的偏移量定义在 (kernel&#x2F;uart.c:22)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the UART control registers. UART控制寄存器</span></span><br><span class="line"><span class="comment">// some have different meanings for 某些寄存器在读取和写入时具有不同的含义</span></span><br><span class="line"><span class="comment">// read vs write.</span></span><br><span class="line"><span class="comment">// see http://byterunner.com/16550.html</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RHR 0                 <span class="comment">// receive holding register (for input bytes) </span></span></span><br><span class="line">         					  <span class="comment">// 接收保持寄存器（用于输入字节）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THR 0                 <span class="comment">// transmit holding register (for output bytes) </span></span></span><br><span class="line">							  <span class="comment">// 发送保持寄存器（用于输出字节）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER 1                 <span class="comment">// interrupt enable register 中断使能寄存器 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_RX_ENABLE (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_TX_ENABLE (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR 2                 <span class="comment">// FIFO control register FIFO控制寄存器 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_ENABLE (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_CLEAR (3&lt;&lt;1) <span class="comment">// clear the content of the two FIFOs 清除两个FIFO的内容</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR 2                 <span class="comment">// interrupt status register 中断状态寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR 3                 <span class="comment">// line control register 行控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR_EIGHT_BITS (3&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR_BAUD_LATCH (1&lt;&lt;7) <span class="comment">// special mode to set baud rate 特殊模式以设置波特率 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5                 <span class="comment">// line status register 行状态寄存器 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="comment">// input is waiting to be read from RHR </span></span></span><br><span class="line">							  <span class="comment">// 接收就绪（表示RHR中有输入等待读取）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="comment">// THR can accept another character to send </span></span></span><br><span class="line">							  <span class="comment">// 发送空闲（表示THR可以接受另一个字符进行发送）</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>例如，<strong>LSR</strong> 寄存器中一些位表示是否有输入字符在等待软件读取。这些字符（如果有的话）可以从 <strong>RHR</strong> 寄存器中读取。每次读取一个字符，UART 硬件就会将其从内部等待字符的 FIFO 中删除，并在 FIFO 为空时清除 <strong>LSR</strong> 中的就绪位</p>
</li>
<li><p>UART 传输硬件在很大程度上是独立于接收硬件的，如果软件向 <strong>THR</strong> 写入一个字节，UART 就会发送该字节</p>
</li>
</ul>
</li>
<li><p>xv6 的 <strong>main</strong> 调用 <strong>consoleinit</strong>（kernel&#x2F;console.c:184）来初始化 UART 硬件</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller	</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode table</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用consoleinit()后，UART可以产生中断了，但还没有什么用，还没有对PLIC编程，无法路由设备产生的中断</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">initlock(&amp;cons.lock, <span class="string">&quot;cons&quot;</span>);</span><br><span class="line"></span><br><span class="line">uartinit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect read and write system calls</span></span><br><span class="line"><span class="comment">// to consoleread and consolewrite.</span></span><br><span class="line">devsw[CONSOLE].read = consoleread;</span><br><span class="line">devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置PLIC，可以路由来自UART、VIRTI产生的中断</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">plicinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set desired IRQ priorities non-zero (otherwise disabled).</span></span><br><span class="line">  *(uint32*)(PLIC + UART0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">  *(uint32*)(PLIC + VIRTIO0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后每个核心都会调用它来向PLIC表明该核心对UART、VIRTI产生的中断感兴趣</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">plicinithart</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set enable bits for this hart&#x27;s S-mode</span></span><br><span class="line">  <span class="comment">// for the uart and virtio disk.</span></span><br><span class="line">  *(uint32*)PLIC_SENABLE(hart) = (<span class="number">1</span> &lt;&lt; UART0_IRQ) | (<span class="number">1</span> &lt;&lt; VIRTIO0_IRQ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set this hart&#x27;s S-mode priority threshold to 0.</span></span><br><span class="line">  *(uint32*)PLIC_SPRIORITY(hart) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// The most recent process to run may have had interrupts</span></span><br><span class="line">    <span class="comment">// turned off; enable them to avoid a deadlock if all</span></span><br><span class="line">    <span class="comment">// processes are waiting.</span></span><br><span class="line">    intr_on();	<span class="comment">// 此时CPU才真正启用中断，可以接收来自外部设备的中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>这段代码配置了 UART，当 UART 接收到一个字节的输入时，就产生一个接收中断，当 UART 每次完成发送一个字节的输出时，产生一个 <strong>传输完成 (transmit complete)</strong> 中断 (kernel&#x2F;uart.c:53)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// disable interrupts. 禁用中断</span></span><br><span class="line">  WriteReg(IER, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// special mode to set baud rate. 特殊模式以设置波特率</span></span><br><span class="line">  WriteReg(LCR, LCR_BAUD_LATCH);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// LSB for baud rate of 38.4K.</span></span><br><span class="line">  WriteReg(<span class="number">0</span>, <span class="number">0x03</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MSB for baud rate of 38.4K.</span></span><br><span class="line">  WriteReg(<span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// leave set-baud mode, 离开设置波特率模式，设置字长为8bit，没有奇偶校验位</span></span><br><span class="line">  <span class="comment">// and set word length to 8 bits, no parity.</span></span><br><span class="line">  WriteReg(LCR, LCR_EIGHT_BITS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset and enable FIFOs. 重置并启用FIFOs</span></span><br><span class="line">  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable transmit and receive interrupts. 启用发送和接收中断</span></span><br><span class="line">  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;uart_tx_lock, <span class="string">&quot;uart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>xv6 shell 通过 <strong>init.c</strong> (user&#x2F;init.c:19) 打开的文件描述符从控制台读取</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid, wpid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stdout</span></span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stderr</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">      <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">      wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">        <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>对 <strong>read</strong> 的系统调用通过内核到达 <strong>consoleread</strong>（kernel&#x2F;console.c:82）。<strong>consoleread</strong> 等待输入的到来 (通过中断)，输入会被缓冲在 <strong>cons.buf</strong>，然后将输入复制到用户空间，再然后 (在一整行到达后) 返回到用户进程</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read()系统调用会调用到fileread()</span></span><br><span class="line"><span class="comment">// fileread()查看文件描述符类型发现是来自console设备，那就调用consoleread()</span></span><br><span class="line"><span class="comment">// Read from file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>((r = readi(f-&gt;ip, <span class="number">1</span>, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">      f-&gt;off += r;</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    panic(<span class="string">&quot;fileread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user read()s from the console go here. 用户从控制台读取输入的操作在这里进行</span></span><br><span class="line"><span class="comment">// copy (up to) a whole input line to dst. 将（最多）一整行输入复制到目标位置dst</span></span><br><span class="line"><span class="comment">// user_dist indicates whether dst is a user user_dist 指示dst是一个用户地址还是一个内核地址</span></span><br><span class="line"><span class="comment">// or kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">uint target;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">target = n;</span><br><span class="line">acquire(&amp;cons.lock);</span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> <span class="comment">// wait until interrupt handler has put some 等待直到中断处理程序将一些输入放入cons.buffer中</span></span><br><span class="line"> <span class="comment">// input into cons.buffer.</span></span><br><span class="line"> <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">   <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">     release(&amp;cons.lock);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> c = cons.buf[cons.r++ % INPUT_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(c == C(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file</span></span><br><span class="line">   <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">     <span class="comment">// Save ^D for next time, to make sure 保存^D以便下次使用，以确保调用者得到一个0字节的结果</span></span><br><span class="line">     <span class="comment">// caller gets a 0-byte result. Uinx中^D通常是用于表示文件结束（EOF, End Of File）的控制字符</span></span><br><span class="line">     cons.r--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// copy the input byte to the user-space buffer. 将输入字节复制到用户空间缓冲区</span></span><br><span class="line"> cbuf = c;</span><br><span class="line"> <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> dst++;</span><br><span class="line"> --n;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">   <span class="comment">// a whole line has arrived, return to 一整行已经到达，返回到用户级的read()</span></span><br><span class="line">   <span class="comment">// the user-level read().</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">release(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> target - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果用户还没有输入完整的行，任何调用了 <strong>read</strong> 进程将在 <strong>sleep</strong> 中等待 (kernel&#x2F;console.c:98) (第 7 章解释了 sleep 的细节)</p>
</li>
</ul>
</li>
<li><p>当用户键入一个字符时，UART 硬件向 RISC-V 抛出一个中断，从而激活 xv6 的 <strong>trap</strong> 处理程序</p>
<ul>
<li><p>trap 处理程序调用 devintr (kernel&#x2F;trap.c:177)，它查看 RISC-V 的 <strong>scause</strong> 寄存器，发现中断来自一个外部设备。然后它向一个叫做 PLIC[1] 的硬件单元询问哪个设备中断了 (kernel&#x2F;trap.c:186)</p>
</li>
<li><p>如果是 UART，<strong>devintr</strong> 调用 <strong>uartintr</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt, 检查它是一个外部中断还是软件中断</span></span><br><span class="line"><span class="comment">// and handle it. 并处理它</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt, 	如果是定时器中断，返回 2</span></span><br><span class="line"><span class="comment">// 1 if other device, 				如果是其他设备的中断，返回 1</span></span><br><span class="line"><span class="comment">// 0 if not recognized. 			如果未识别，返回 0</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// this is a supervisor external interrupt, via PLIC. </span></span><br><span class="line">    <span class="comment">// 这是一个通过PLIC（Platform-Level Interrupt Controller，平台级中断控制器）产生的监管者外部中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// irq indicates which device interrupted. irq指示了哪个设备产生了中断</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the PLIC allows each device to raise at most one PLIC允许在一个时刻</span></span><br><span class="line">    <span class="comment">// interrupt at a time; tell the PLIC the device is 每个设备一次最多产生一个中断</span></span><br><span class="line">    <span class="comment">// now allowed to interrupt again. 告诉PLIC该设备现在允许再次产生中断</span></span><br><span class="line">    <span class="keyword">if</span>(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// software interrupt from a machine-mode timer interrupt, 来自机器模式定时器的软件中断</span></span><br><span class="line">    <span class="comment">// forwarded by timervec in kernelvec.S. 通过kernelvec.S中的timervec转发</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing 通过清除sip中的SSIP位来确认软件中断</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p><strong>uartintr</strong> (kernel&#x2F;uart.c:180) 从 <strong>UART</strong> 硬件中读取在等待的输入字符，并将它们交给 <strong>consoleintr</strong> (kernel&#x2F;console.c:138)；它不会等待输入字符，因为以后的输入会引发一个新的中断</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle a uart interrupt, raised because input has 处理UART中断，这个中断是由于有输入数据到达</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or 或者UART准备好接收更多输出数据，或者两者都有而触发的</span></span><br><span class="line"><span class="comment">// both. called from devintr(). 这个函数从devintr()中被调用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters. 读取并处理传入的字符</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters. 发送缓冲字符</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>consoleintr</strong> 的工作是将中输入字符积累 <strong>cons.buf</strong> 中，直到有一行字符。<strong>consoleintr</strong> 会特别处理退格键和其他一些字符。当一个新行到达时，<strong>consoleintr</strong> 会唤醒一个等待的 <strong>consoleread</strong>（如果有的话）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the console input interrupt handler. 控制台输入中断处理程序</span></span><br><span class="line"><span class="comment">// uartintr() calls this for input character. uartintr() 在接收到输入字符时调用此函数</span></span><br><span class="line"><span class="comment">// do erase/kill processing, append to cons.buf, 执行删除/终止处理，将字符追加到 cons.buf</span></span><br><span class="line"><span class="comment">// wake up consoleread() if a whole line has arrived. 如果一整行已经到达，则唤醒 consoleread()</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;P&#x27;</span>)</span>:  <span class="comment">// Print process list.</span></span><br><span class="line">    <span class="title function_">procdump</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;U&#x27;</span>)</span>:  <span class="comment">// Kill line.</span></span><br><span class="line">    <span class="title function_">while</span><span class="params">(cons.e != cons.w &amp;&amp;</span></span><br><span class="line"><span class="params">          cons.buf[(cons.e<span class="number">-1</span>) % INPUT_BUF_SIZE] != <span class="string">&#x27;\n&#x27;</span>)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;H&#x27;</span>)</span>: <span class="comment">// Backspace</span></span><br><span class="line">  <span class="keyword">case</span> &#x27;\x7f&#x27;: <span class="comment">// Delete key</span></span><br><span class="line">    <span class="title function_">if</span><span class="params">(cons.e != cons.w)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)&#123;</span><br><span class="line">      c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// echo back to the user.	回显给用户</span></span><br><span class="line">      consputc(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// store for consumption by consoleread(). 将（字符）存储起来供 consoleread() 读取使用</span></span><br><span class="line">      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;</span><br><span class="line">        <span class="comment">// wake up consoleread() if a whole line (or end-of-file) 如果一整行(或文件末尾)已经到达</span></span><br><span class="line">        <span class="comment">// has arrived. 则唤醒 consoleread()</span></span><br><span class="line">        cons.w = cons.e;</span><br><span class="line">        wakeup(&amp;cons.r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>一旦被唤醒，<strong>consoleread</strong> 将会注意到 <strong>cons.buf</strong> 中的完整行，并将其将其复制到用户空间，并返回（通过系统调用机制）到用户空间</p>
</li>
</ul>
</li>
</ul>
<h2 id="Code-Console-output-控制台输出"><a href="#Code-Console-output-控制台输出" class="headerlink" title="Code: Console output 控制台输出"></a>Code: Console output 控制台输出</h2><ul>
<li><p>向控制台写数据的 <strong>write</strong> 系统调用最终会到达 <strong>uartputc</strong> (kernel&#x2F;uart.c:87)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a character to the output buffer and tell the 将一个字符添加到输出缓冲区，</span></span><br><span class="line"><span class="comment">// UART to start sending if it isn&#x27;t already. 并告诉UART（如果尚未开始）开始发送</span></span><br><span class="line"><span class="comment">// blocks if the output buffer is full. 如果输出缓冲区已满，则会阻塞</span></span><br><span class="line"><span class="comment">// because it may block, it can&#x27;t be called  由于它可能会阻塞，因此不能从中断中调用</span></span><br><span class="line"><span class="comment">// from interrupts; it&#x27;s only suitable for use 它仅适合在write()函数中使用</span></span><br><span class="line"><span class="comment">// by write().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE)&#123;</span><br><span class="line">    <span class="comment">// buffer is full. 缓冲区满了</span></span><br><span class="line">    <span class="comment">// wait for uartstart() to open up space in the buffer. 等待 uartstart() 打开缓冲区中的空间</span></span><br><span class="line">    sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;</span><br><span class="line">  uart_tx_w += <span class="number">1</span>;</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>设备驱动维护了一个输出缓冲区 (<strong>uart_tx_buf</strong>)，这样写进程就不需要等待 UART 完成发送；相反，<strong>uartputc</strong> 将每个字符追加到缓冲区，调用 <strong>uartstart</strong> 来启动设备发送 (如果还没有的话)，然后返回。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if the UART is idle, and a character is waiting 如果UART处于空闲状态</span></span><br><span class="line"><span class="comment">// in the transmit buffer, send it. 并且传输缓冲区中有一个字符等待发送，则发送该字符</span></span><br><span class="line"><span class="comment">// caller must hold uart_tx_lock. 调用者必须持有uart_tx_lock锁</span></span><br><span class="line"><span class="comment">// called from both the top- and bottom-half. 该函数从顶层和底层都被调用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartstart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      <span class="comment">// transmit buffer is empty. 传输缓冲区为空</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the UART transmit holding register is full, UART发送保持寄存器已满</span></span><br><span class="line">      <span class="comment">// so we cannot give it another byte. 因此我们不能再给它一个字节</span></span><br><span class="line">      <span class="comment">// it will interrupt when it&#x27;s ready for a new byte. 当它准备好接收新字节时，它会产生中断</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];</span><br><span class="line">    uart_tx_r += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maybe uartputc() is waiting for space in the buffer. 可能uartputc()函数在等待缓冲区中有空间</span></span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    </span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>uartputc</strong> 只有在缓冲区满的时候才会等待</p>
</li>
</ul>
</li>
<li><p>每次 UART 发送完成一个字节，它都会产生一个中断</p>
<ul>
<li><p><strong>uartintr</strong> 调用 <strong>uartstart</strong>，<strong>uartintr</strong> 检查设备是否真的发送完毕，并将下一个缓冲输出字符交给设备，每当 UART 发送完一个字节，就会产生一个中断</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle a uart interrupt, raised because input has 处理UART中断，这个中断是由于有输入数据到达</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or 或者UART准备好接收更多输出数据</span></span><br><span class="line"><span class="comment">// both. called from devintr(). 或者两者都有而触发的，这个函数从devintr()中被调用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters. 读取并处理传入的字符</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters. 发送缓冲字符</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>因此，如果一个进程向控制台写入多个字节，通常第一个字节将由 uartputc 调用 uartstart 发送，其余的缓冲字节将由 uartintr 调用 uartstart 发送，因为发送完成中断到来</p>
</li>
</ul>
</li>
<li><p><strong>uartintr</strong> 调用 <strong>uartstart</strong>，<strong>uartintr</strong> 查看设备是否真的发送完成，并将下一个缓冲输出字符交给设备，每当 UART 发送完一个字节，就会产生一个中断</p>
<ul>
<li>因此，如果一个进程向控制台写入多个字节，通常第一个字节将由 <strong>uartputc</strong> 对 <strong>uartstart</strong> 的调用发送，其余的缓冲字节将随着发送完成中断的到来由 <strong>uartintr</strong> 的 <strong>uartstart</strong> 调用发送</li>
</ul>
</li>
<li><p>有一个通用模式需要注意，设备活动和进程活动需要解耦，这将通过缓冲和中断来实现</p>
<ul>
<li>控制台驱动程序可以处理输入，即使没有进程等待读取它；随后的读取将看到输入</li>
<li>同样，进程可以发送输出字节，而不必等待设备</li>
<li>这种解耦可以通过允许进程与设备 I&#x2F;O 并发执行来提高性能，当设备速度很慢（如 UART）或需要立即关注（如回显键入的字节）时，这种解耦尤为重要。这个 idea 有时被称为 <strong>I&#x2F;O并发</strong></li>
</ul>
</li>
</ul>
<h3 id="shell-如何输出"><a href="#shell-如何输出" class="headerlink" title="shell 如何输出 $"></a>shell 如何输出 $</h3><ul>
<li><code>user/init.c</code> 创建 <code>console</code> 设备并分配初始的 3 个文件描述符</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid, wpid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stdout</span></span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stderr</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">      <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">      wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">        <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>user/sh.c</code> 中 shell 通过 <code>write</code> 系统调用写入 <code>$</code> 到 <code>console</code> 设备对应的文件描述符 2</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getcmd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> nbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;$ &quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  gets(buf, nbuf);</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>user/printf.c</code> 中 <code>printf</code> 也是通过 <code>write</code> 系统调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">putc</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用户空间中对 <code>write</code> 的系统调用会找到 <code>kernel/sysfile.c</code> 中的 <code>sys_write</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint64 p;</span><br><span class="line">  </span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;p);</span><br><span class="line">  argint(<span class="number">2</span>, &amp;n);</span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> filewrite(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/file.c</code> 中的 <code>filewrite()</code>，查看文件描述符类型，来自 <code>console</code> 设备会调用 <code>consolewrite()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write to file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    ret = pipewrite(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ret = devsw[f-&gt;major].write(<span class="number">1</span>, addr, n);	<span class="comment">// 走到了这里</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    <span class="comment">// write a few blocks at a time to avoid exceeding</span></span><br><span class="line">    <span class="comment">// the maximum log transaction size, including</span></span><br><span class="line">    <span class="comment">// i-node, indirect block, allocation blocks,</span></span><br><span class="line">    <span class="comment">// and 2 blocks of slop for non-aligned writes.</span></span><br><span class="line">    <span class="comment">// this really belongs lower down, since writei()</span></span><br><span class="line">    <span class="comment">// might be writing a device like the console.</span></span><br><span class="line">    <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">      <span class="type">int</span> n1 = n - i;</span><br><span class="line">      <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">        n1 = max;</span><br><span class="line"></span><br><span class="line">      begin_op();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(r != n1)&#123;</span><br><span class="line">        <span class="comment">// error from writei</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i += r;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    panic(<span class="string">&quot;filewrite&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/console.c</code> 中的 <code>consolewrite()</code> 通过 <code>either_copyin()</code> 复制一个字符后调用了 <code>uartputc()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user write()s to the console go here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consolewrite</span><span class="params">(<span class="type">int</span> user_src, uint64 src, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(&amp;c, user_src, src+i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    uartputc(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/uart.c</code> 中的 <code>uartputc()</code> 将一个字符添加到缓冲区，调用了 <code>uartstart()</code> 将缓冲区中的字符写入相关输出寄存器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a character to the output buffer and tell the 将一个字符添加到输出缓冲区，并告诉UART（如果尚未开始）开始发送</span></span><br><span class="line"><span class="comment">// UART to start sending if it isn&#x27;t already.</span></span><br><span class="line"><span class="comment">// blocks if the output buffer is full. 如果输出缓冲区已满，则会阻塞</span></span><br><span class="line"><span class="comment">// because it may block, it can&#x27;t be called  由于它可能会阻塞，因此不能从中断中调用</span></span><br><span class="line"><span class="comment">// from interrupts; it&#x27;s only suitable for use 它仅适合在write()函数中使用</span></span><br><span class="line"><span class="comment">// by write().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE)&#123;</span><br><span class="line">    <span class="comment">// buffer is full. 缓冲区满了</span></span><br><span class="line">    <span class="comment">// wait for uartstart() to open up space in the buffer. 等待 uartstart() 打开缓冲区中的空间</span></span><br><span class="line">    sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;</span><br><span class="line">  uart_tx_w += <span class="number">1</span>;</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if the UART is idle, and a character is waiting 如果UART处于空闲状态，并且传输缓冲区中有一个字符等待发送</span></span><br><span class="line"><span class="comment">// in the transmit buffer, send it. 则发送该字符</span></span><br><span class="line"><span class="comment">// caller must hold uart_tx_lock. 调用者必须持有uart_tx_lock锁</span></span><br><span class="line"><span class="comment">// called from both the top- and bottom-half. 该函数从顶层和底层都被调用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartstart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      <span class="comment">// transmit buffer is empty. 传输缓冲区为空</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the UART transmit holding register is full, UART发送保持寄存器已满</span></span><br><span class="line">      <span class="comment">// so we cannot give it another byte. 因此我们不能再给它一个字节</span></span><br><span class="line">      <span class="comment">// it will interrupt when it&#x27;s ready for a new byte. 当它准备好接收新字节时，它会产生中断</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];</span><br><span class="line">    uart_tx_r += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maybe uartputc() is waiting for space in the buffer. 可能有uartputc()函数在等待缓冲区中有空间</span></span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    </span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之后可能通过 <code>userret</code> 等机制返回到用户空间，但 shell 写入的是 <code>&quot;$ &quot; </code>，另一个空格字符会通过设备中断，调用 <code>devintr()</code>、 <code>uartintr()</code>、<code>uartstart()</code> 写入输出寄存器</li>
</ul>
<h2 id="Concurrency-in-drivers-驱动程序中的并发"><a href="#Concurrency-in-drivers-驱动程序中的并发" class="headerlink" title="Concurrency in drivers 驱动程序中的并发"></a>Concurrency in drivers 驱动程序中的并发</h2><ul>
<li><p>你可能已经注意到在 <strong>consoleread</strong> 和 <strong>consoleintr</strong> 中会调用 <strong>acquire</strong>。</p>
<ul>
<li><strong>acquire</strong> 调用会获取一个锁，保护控制台驱动的数据结构不被并发访问。</li>
<li>这里有三个并发风险：不同 CPU 上的两个进程可能会同时调用 <strong>consoleread</strong>；硬件可能会在一个 CPU 正在执行 consoleread 时，向该 CPU 抛出一个控制台（实际上是 UART）中断；硬件可能会在 consoleread 执行时向另一个 CPU 抛出一个控制台中断</li>
<li>第 6 章探讨锁如何在这些情况下提供帮助</li>
</ul>
</li>
<li><p>需要关注驱动并发安全的另一个原因是，一个进程可能正在等待来自设备的输入，但是当表明输入到来的中断发生时该进程已经没有在运行（被切换）</p>
<ul>
<li>因此，中断处理程序不允许知道被中断的进程或代码。例如，一个中断处理程序不能安全地用当前进程的页表调用 <strong>copyout</strong></li>
<li>中断处理程序通常只做相对较少的工作（例如，只是将输入数据复制到缓冲区），并唤醒 <strong>上半部分</strong> 代码来做剩下的工作</li>
</ul>
</li>
</ul>
<h2 id="Timer-interrupts-定时器中断"><a href="#Timer-interrupts-定时器中断" class="headerlink" title="Timer interrupts 定时器中断"></a>Timer interrupts 定时器中断</h2><ul>
<li><p>xv6 使用定时器中断来维护它的时钟，并使它能够切换计算密集型进程；<strong>usertrap</strong> 和 <strong>kerneltrap</strong> 中的 <strong>yield</strong> 调用会导致这种切换</p>
<ul>
<li>每个 RISC-V CPU 的时钟硬件都会抛出时钟中断。xv6 对这个时钟硬件进行编程，使其定期周期性地中断相应的 CPU</li>
</ul>
</li>
<li><p>RISC-V 要求在机器模式下处理定时器中断，而不是监督者模式</p>
<ul>
<li>RISC-V 机器模式执行时没有分页，并且有一套单独的控制寄存器，因此在机器模式下运行普通的 xv6 内核代码是不实用的</li>
<li>因此，xv6 对定时器中断的处理与上面谈到的 trap 机制完全分离了</li>
</ul>
</li>
<li><p>在 main 执行之前的 <strong>start.c</strong>，是在机器模式下执行的。它设置了接收定时器中断 (kernel&#x2F;start.c:57)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrange to receive timer interrupts. 安排接收定时器中断</span></span><br><span class="line"><span class="comment">// they will arrive in machine mode at 这些中断将在机器模式下到达kernelvec.S中的timervec</span></span><br><span class="line"><span class="comment">// at timervec in kernelvec.S, </span></span><br><span class="line"><span class="comment">// which turns them into software interrupts for 它将它们转换为trap.c中的devintr()的软件中断</span></span><br><span class="line"><span class="comment">// devintr() in trap.c.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">timerinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// each CPU has a separate source of timer interrupts. 每个CPU都有一个独立的定时器中断源</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask the CLINT for a timer interrupt. 向CLINT请求定时器中断</span></span><br><span class="line">  <span class="type">int</span> interval = <span class="number">1000000</span>; <span class="comment">// cycles; about 1/10th second in qemu. 时钟周期数；在qemu中大约是1/10秒</span></span><br><span class="line">  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare information in scratch[] for timervec. 在scratch[]中准备timervec需要的信息</span></span><br><span class="line">  <span class="comment">// scratch[0..2] : space for timervec to save registers. timervec用于保存寄存器的空间</span></span><br><span class="line">  <span class="comment">// scratch[3] : address of CLINT MTIMECMP register. CLINT MTIMECMP寄存器的地址</span></span><br><span class="line">  <span class="comment">// scratch[4] : desired interval (in cycles) between timer interrupts. 定时器中断之间的期望周期数（以时钟周期为单位）</span></span><br><span class="line">  uint64 *scratch = &amp;timer_scratch[id][<span class="number">0</span>];</span><br><span class="line">  scratch[<span class="number">3</span>] = CLINT_MTIMECMP(id);</span><br><span class="line">  scratch[<span class="number">4</span>] = interval;</span><br><span class="line">  w_mscratch((uint64)scratch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the machine-mode trap handler. 设置机器模式的陷阱处理程序</span></span><br><span class="line">  w_mtvec((uint64)timervec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode interrupts. 启用机器模式中断</span></span><br><span class="line">  w_mstatus(r_mstatus() | MSTATUS_MIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode timer interrupts. 启用机器模式定时器中断</span></span><br><span class="line">  w_mie(r_mie() | MIE_MTIE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>一部分工作是对 <strong>CLINT</strong> 硬件（<strong>core-local interruptor</strong>）进行编程，使其每隔一定时间产生一次中断</li>
<li>另一部分是设置一个类似于 <strong>trapframe</strong> 的暂存区，帮助定时器中断处理程序保存寄存器和 <strong>CLINT</strong> 寄存器的地址</li>
<li>最后，<strong>start</strong> 将 <strong>mtvec</strong> 设置为 <strong>timervec</strong>，启用定时器中断</li>
</ul>
</li>
<li><p>定时器中断可能发生在用户或内核代码执行的任何时候；内核没有办法在关键操作中禁用定时器中断</p>
<ul>
<li><p>因此，定时器中断处理程序必须以保证不干扰被中断的内核代码的方式进行工作</p>
</li>
<li><p>基本策略是处理程序要求 RISC-V 引发一个软件中断并立即返回。RISC-V 用普通的 trap 机制将软件中断传递给内核，并允许内核禁用它们</p>
</li>
<li><p>处理定时器中断产生的软件中断的代码可以在 <strong>devintr</strong>（kernel&#x2F;trap.c:204）中看到</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt, 检查它是一个外部中断还是软件中断</span></span><br><span class="line"><span class="comment">// and handle it. 并处理它</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt, 	如果是定时器中断，返回 2</span></span><br><span class="line"><span class="comment">// 1 if other device, 				如果是其他设备的中断，返回 1</span></span><br><span class="line"><span class="comment">// 0 if not recognized. 			如果未识别，返回 0</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// this is a supervisor external interrupt, via PLIC. </span></span><br><span class="line">    <span class="comment">// 这是一个通过PLIC（Platform-Level Interrupt Controller，平台级中断控制器）产生的监管者外部中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// irq indicates which device interrupted. irq指示了哪个设备产生了中断</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the PLIC allows each device to raise at most one PLIC允许在一个时刻</span></span><br><span class="line">    <span class="comment">// interrupt at a time; tell the PLIC the device is 每个设备一次最多产生一个中断</span></span><br><span class="line">    <span class="comment">// now allowed to interrupt again. 告诉PLIC该设备现在允许再次产生中断</span></span><br><span class="line">    <span class="keyword">if</span>(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// software interrupt from a machine-mode timer interrupt, 来自机器模式定时器的软件中断</span></span><br><span class="line">    <span class="comment">// forwarded by timervec in kernelvec.S. 通过kernelvec.S中的timervec转发</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing 通过清除sip中的SSIP位来确认软件中断</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>机器模式的定时器中断向量是 <strong>timervec</strong> (kernel&#x2F;kernelvec.S:93)</p>
<blockquote>
<p>中断向量也就是中断处理程序的入口</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">timervec:</span><br><span class="line">        # start.c has set up the memory that mscratch points to: start.c已经设置了mscratch指向的内存</span><br><span class="line">        # scratch[0,8,16] : register save area.  寄存器保存区域</span><br><span class="line">        # scratch[24] : address of CLINT&#x27;s MTIMECMP register. CLINT的MTIMECMP寄存器的地址</span><br><span class="line">        # scratch[32] : desired interval between interrupts. 期望的中断间隔</span><br><span class="line">        </span><br><span class="line">        csrrw a0, mscratch, a0</span><br><span class="line">        sd a1, 0(a0)</span><br><span class="line">        sd a2, 8(a0)</span><br><span class="line">        sd a3, 16(a0)</span><br><span class="line"></span><br><span class="line">        # schedule the next timer interrupt 安排下一个定时器中断</span><br><span class="line">        # by adding interval to mtimecmp. 通过将间隔加到mtimecmp上</span><br><span class="line">        ld a1, 24(a0) # CLINT_MTIMECMP(hart) CLINT的MTIMECMP寄存器的地址</span><br><span class="line">        ld a2, 32(a0) # interval 间隔</span><br><span class="line">        ld a3, 0(a1)</span><br><span class="line">        add a3, a3, a2</span><br><span class="line">        sd a3, 0(a1)</span><br><span class="line"></span><br><span class="line">        # arrange for a supervisor software interrupt 安排一个监督者(内核)软件中断</span><br><span class="line">        # after this handler returns. 在这个处理程序返回之后</span><br><span class="line">        li a1, 2</span><br><span class="line">        csrw sip, a1</span><br><span class="line"></span><br><span class="line">        ld a3, 16(a0)</span><br><span class="line">        ld a2, 8(a0)</span><br><span class="line">        ld a1, 0(a0)</span><br><span class="line">        csrrw a0, mscratch, a0</span><br><span class="line"></span><br><span class="line">        mret</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>它在 <strong>start</strong> 准备的暂存区保存一些寄存器，告诉 <strong>CLINT</strong> 何时产生下一个定时器中断，使 RISC-V 产生一个软件中断，恢复寄存器，然后返回。在定时器中断处理程序中没有 C 代码</li>
</ul>
</li>
</ul>
<h2 id="Real-world-现实情况"><a href="#Real-world-现实情况" class="headerlink" title="Real world 现实情况"></a>Real world 现实情况</h2><ul>
<li><p>xv6 允许在内核和用户程序执行时使用设备和定时器中断</p>
<ul>
<li>定时器中断可以强制从定时器中断处理程序进行线程切换（调用 <strong>yield</strong>），即使是在内核中执行</li>
<li>如果内核线程有时会花费大量的时间进行计算，而不返回用户空间，那么在内核线程之间公平地对 CPU 进行时间划分的能力是很有用的</li>
<li>然而，内核代码需要注意它可能会被暂停（由于定时器中断），然后在不同的 CPU 上恢复，这是 xv6 中一些复杂的根源</li>
<li>如果设备和定时器中断只发生在执行用户代码时，内核可以变得更简单一些</li>
</ul>
</li>
<li><p>在一台典型的计算机上支持所有设备的全貌是一件很辛苦的事情，因为设备很多，设备有很多功能，设备和驱动程序之间的协议可能很复杂，而且文档也不完善。在许多操作系统中，驱动程序所占的代码比核心内核还多</p>
</li>
<li><p>UART 驱动器通过读取 UART 控制寄存器，一次读取一个字节的数据；这种模式被称为编程 I&#x2F;O，因为软件在控制数据移动。程序化 I&#x2F;O 简单，但速度太慢，无法在高数据速率下使用</p>
<ul>
<li>需要高速移动大量数据的设备通常使用 **直接内存访问(direct memory access, DMA)**。DMA 设备硬件直接将传入数据写入 RAM，并从 RAM 中读取传出数据。现代磁盘和网络设备都使用 DMA</li>
<li>DMA 设备的驱动程序会在 RAM 中准备数据，然后使用对控制寄存器的一次写入来告诉设备处理准备好的数据</li>
</ul>
</li>
<li><p>当设备在不可预知的时间需要关注，且不那么频繁时，中断是很有用的。但中断对 CPU 的开销很大</p>
<blockquote>
<p>这里的关注指的是：CPU 需要立即停止当前的工作，并转而处理这个中断事件</p>
</blockquote>
<ul>
<li>因此，高速设备，如网络和磁盘控制器，使用了减少对中断需求的技巧。其中一个技巧是对整批传入或传出的请求提出一个单一的中断</li>
<li>另一个技巧是让驱动程序完全禁用中断，并定期检查设备是否需要关注。这种技术称为 <strong>轮询（polling）</strong>。如果设备执行操作的速度非常快，轮询是有意义的，但如果设备大部分时间处于空闲状态，则会浪费 CPU 时间</li>
<li>一些驱动程序会根据当前设备的负载情况，在轮询和中断之间动态切换</li>
</ul>
</li>
<li><p>UART 驱动首先将输入的数据复制到内核的缓冲区，然后再复制到用户空间。这在低数据速率下是有意义的，但对于那些快速生成或消耗数据的设备来说，这样的双重拷贝会大大降低性能</p>
<ul>
<li>一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常使用 DMA</li>
</ul>
</li>
</ul>
<h2 id="Exercises-练习"><a href="#Exercises-练习" class="headerlink" title="Exercises 练习"></a>Exercises 练习</h2><ol>
<li><p>修改 <code>uart.c</code>，使其完全不使用中断。你可能还需要修改 <code>console.c</code>。</p>
</li>
<li><p>添加一个网卡驱动。</p>
</li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19k4y1C7kA/?p=8&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=4bc88d483dc220df9aabd792fd12f134">Lecture 9 - Interrupts_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/17/6-S081-Lab0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/17/6-S081-Lab0/" class="post-title-link" itemprop="url">Lab Tools and Guidance</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-17 21:46:11" itemprop="dateCreated datePublished" datetime="2024-06-17T21:46:11+08:00">2024-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-19 13:13:15" itemprop="dateModified" datetime="2024-06-19T13:13:15+08:00">2024-06-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>实验讲义：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/labs/guidance.html">Lab guidance (mit.edu)</a>、<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/tools.html">6.1810 &#x2F; Fall 2023 (mit.edu)</a></li>
<li>迟来的 <code>Lab 0</code> ……</li>
</ul>
<h1 id="Install-riscv64-unknown-elf-gdb"><a href="#Install-riscv64-unknown-elf-gdb" class="headerlink" title="Install riscv64-unknown-elf-gdb"></a>Install riscv64-unknown-elf-gdb</h1><ul>
<li><p><strong>References</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zjp-cn.github.io/posts/rcore-gdb/#%E5%AE%89%E8%A3%85-gdb">【笔记】rCore (RISC-V)：GDB 使用记录 | 苦瓜小仔 (zjp-cn.github.io)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/120397168">MIT 6.S081] Lab 0: 实验配置, 调试及测试_6.s081 tools-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://rcore-os.cn/rCore-Tutorial-deploy/docs/pre-lab/gdb.html">GDB 调试方法* · GitBook (rcore-os.cn)</a></li>
</ul>
</li>
<li><p>需要注意的是：</p>
<ul>
<li><code>--prefix</code> 指定了安装路径，以下指令会安装到 <code>/usr/local/bin/</code> </li>
<li><code>--with-python</code> 指定 <code>python</code> 解释器的地址</li>
<li>可以通过 <code>which python | which python3</code> 了解自己的 <code>python</code> 安装在哪里</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/usr/local --with-python=/usr/bin/python --target=riscv64-unknown-elf --enable-tui=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>一般 <code>user/bin/python</code> 是 <code>python2</code> 的地址，而 <code>python2</code> 已经过时了，所以最好指定 <code>python3</code> 的地址</p>
</li>
<li><p><code>make -j$(nproc)</code> 编译完成后，别忘记 <code>sudo make install</code> 进行安装</p>
</li>
</ul>
</li>
<li><p>在编译过程中，你可能会遇到：需要安装或更新 GMP 和 MPFR 库的问题，输入以下指令进行安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install python3-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>你可能还会遇到 <code>configure: error: no usable python found at /usr/bin/python</code> 这样的问题</p>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://rcore-os.cn/rCore-Tutorial-deploy/docs/pre-lab/gdb.html"><a target="_blank" rel="noopener" href="https://www.coder.work/article/357511">交叉编译 GDB 时出现 Python 丢失或不可用错误</a></a></li>
<li>对于 <code>python3</code>，输入以下指令安装 <code>python3-dev</code> 包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install python3-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>riscv64-unknown-elf-gdb</code> 第一次运行 gdb 时，它可能提醒你：需要在 <code>.config/gdb/gdbinit</code> 中写入一些内容</p>
<ul>
<li>如果 <code>.config/gdb/gdbinit</code> 文件还未创建，你需要自己创建后写入提示的内容</li>
<li>内容格式应该是 <code>add-auto-load-safe-path your_usage_path/.gdbinit</code></li>
</ul>
</li>
</ul>
<h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><ul>
<li><p><strong>References</strong>：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1526675">可能是东半球最全面易懂的 Tmux 使用教程！( 强烈建议收藏 )-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSSDCC/article/details/121231906">Tmux教程 （一文就够）-CSDN博客</a></p>
</li>
</ul>
</li>
<li><p>用户打开终端窗口输入命令与计算机进行交互，这种 <strong>用户与计算机的临时交互，称为会话（session）</strong></p>
<ul>
<li>会话的一个特点是：窗口和与之启动进程是连在一起的，窗口关闭则进程终止，无论进程有没有执行完</li>
<li>tmux 解决了这个问题，它允许会话与当前窗口 “解绑”，会话继续在后台运行，需要时再与当前窗口 “绑定”</li>
<li>一个 session 可以创建好几个 window，对于每一个窗口，都可以将其分解为几个 pane 窗格</li>
</ul>
</li>
</ul>
<h2 id="tmux-的作用"><a href="#tmux-的作用" class="headerlink" title="tmux 的作用"></a>tmux 的作用</h2><ul>
<li>它允许在单个窗口中，同时访问多个会话，这对于同时运行多个命令行程序很有用</li>
<li>它可以让新窗口 “接入” 已经存在的会话</li>
<li>它允许每个会话有多个连接窗口，因此可以多人实时共享会话</li>
<li>它还支持窗口任意的垂直和水平拆分</li>
</ul>
<h2 id="tmux-的使用"><a href="#tmux-的使用" class="headerlink" title="tmux 的使用"></a>tmux 的使用</h2><ul>
<li><p>启动 tmux：创建一个 session 及其 tmux 窗口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>只能在 shell 窗口中使用</p>
<p>由于这个窗口总是 session 的第一个 window，所以它的编号总是为 0</p>
<p>按照顺序，<code>tmux</code> 指令创建的每个 session 的默认编号依次为 0、1、2 ……</p>
<p>这里的编号其实就是下文的 <code>session-name</code>，只不过由于是默认的，为了区分就叫编号了</p>
</blockquote>
<ul>
<li><p>退出 tmux：退出当前 tmux 窗口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>只能在 tmux 窗口中使用</p>
<p>与 session 绑定的 tmux 窗口不一定只有一个，所以 session 不一定终止</p>
<p>所以当然可以 <code>exit</code> 一个 session 的所有 window 来杀死这个 session</p>
</blockquote>
<ul>
<li><p><strong>会话管理</strong></p>
<ul>
<li><p>新建会话</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s &lt;session-name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只能在 tmux 窗口中使用</p>
<p>创建会话时指定 <code>session-name</code> 更便于管理，<code>tmux</code> 指令给予的默认 session-name 就是编号了</p>
</blockquote>
</li>
<li><p>分离会话：将当前 tmux 窗口及其 session 放入后台运行，返回 shell 窗口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux detach</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只能在 tmux 窗口中使用，也可以通过快捷键：<code>CTRL + B D</code></p>
</blockquote>
</li>
<li><p>显示当前所有的会议</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 tmux 窗口和 shell 窗口中都能使用</p>
</blockquote>
</li>
<li><p>接入会话</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux attach -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只能在 shell 窗口中使用</p>
</blockquote>
</li>
<li><p>切换会话</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux switch -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只能在 tmux 窗口中使用，也可以通过快捷键：<code>CTRL + B S</code></p>
</blockquote>
</li>
<li><p>杀死会话：杀死指定 session 及其 tmux 窗口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux kill-session -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只能在 shell 窗口中使用</p>
</blockquote>
</li>
<li><p>重命名会话</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux rename-session -t &lt;old-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 tmux 窗口和 shell 窗口中都能使用</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>窗口管理</strong></p>
<ul>
<li><p>新建窗口：第一种方式新建的窗口没有 window-name，第二中方式指定 window-name 新建窗口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmux new-window</span><br><span class="line"></span><br><span class="line">tmux new-window -n &lt;window-name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>按道理只能在 tmux 窗口中使用，但我发现也可以在 shell 窗口中使用，在 shell 窗口中使用会为刚刚放入后台的 session 新建窗口</p>
<p>窗口的编号及 name 的管理方式和 session 并不一样</p>
<p>每个窗口都有自己的编号，这是新建窗口时系统自动给予的，而它们的名字需要用户额外给予，比如在新建窗口时给予，也可以通过下文提到的指令为当前窗口命名</p>
<p>也可以使用快捷键：<code>CTRL + B C</code> 新建一个没有名称的 tmux 窗口</p>
</blockquote>
</li>
<li><p>切换窗口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmux select-window -t &lt;window-name&gt;</span><br><span class="line"></span><br><span class="line">tmux select-window -t &lt;window-number&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只能在 tmux 窗口中使用，使用快捷键更方便</p>
<p><code>CTRL + B P</code>：切换到上一个窗口（按照底部状态栏上的顺序，<code>*</code> 表示当前所在窗口，<code>-</code> 表示上一个访问过的窗口）</p>
<p><code>CTRL + B N</code>：切换到下一个窗口</p>
<p><code>CTRL + B &lt;number&gt;</code>：切换到指定编号的窗口</p>
<p><code>CTRL + B W</code>：从列表中选择窗口（很方便）</p>
</blockquote>
</li>
<li><p>命名或重命名窗口：第一种方式是命名或重命名当前窗口，第二种方式通过 name 或 number 确定要命名的 window</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmux rename-window &lt;new-name&gt;</span><br><span class="line"></span><br><span class="line">tmux rename-window -t &lt;old-name|number&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只能在 tmux 窗口中使用</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>窗格管理</strong></p>
<blockquote>
<p>窗格管理的相关指令只能在 tmux 窗口中使用</p>
</blockquote>
<ul>
<li><p>划分窗格：将当前 tmux 窗口划分为多个窗格</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">划分为上下两个窗格</span></span><br><span class="line">tmux split-window</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">划分为左右两个窗格</span></span><br><span class="line">tmux split-window -h</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用快捷键更方便</p>
<p><code>CTRL + B &quot;</code>：划分上下两个窗格</p>
<p><code>CTRL + B %</code>：划分左右两个窗格</p>
</blockquote>
</li>
<li><p>移动光标</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光标切换到上方窗格</span></span><br><span class="line">tmux select-pane -U</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光标切换到下方窗格</span></span><br><span class="line">tmux select-pane -D</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光标切换到左边窗格</span></span><br><span class="line">tmux select-pane -L</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光标切换到右边窗格</span></span><br><span class="line">tmux select-pane -R</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用快捷键更方便</p>
<p><code>CTRL + B o</code>：切换到下一个窗格</p>
<p><code>CTRL + B ;</code>：切换到上一个窗格</p>
<p><code>CTRL + B &lt;arrow key&gt;</code>：通过方向键将光标切换到指定窗格（很方便）</p>
</blockquote>
</li>
<li><p>交换窗格位置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前窗格上移</span></span><br><span class="line">tmux swap-pane -U</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前窗格下移</span></span><br><span class="line">tmux swap-pane -D</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前窗格左移</span></span><br><span class="line">tmux swap-pane -L</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前窗格左移</span></span><br><span class="line">tmux swap-pane -R</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭当前窗格</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以使用快捷键：<code>CTRL + B X</code> 或 <code>CTRL + D</code></p>
</blockquote>
</li>
<li><p>其他关于窗格操作的快捷键</p>
<blockquote>
<p><code>CTRL + B CTRL + &lt;arrow key&gt;</code>：通过方向键调整当前窗格大小</p>
<p><code>CTRL + B Q</code>：显示窗格编号</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="Use-riscv64-unknown-elf-gdb"><a href="#Use-riscv64-unknown-elf-gdb" class="headerlink" title="Use riscv64-unknown-elf-gdb"></a>Use riscv64-unknown-elf-gdb</h1><ul>
<li><p><strong>References</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45031801/article/details/134399664">【Linux】GDB保姆级调试指南（什么是GDB？GDB如何使用？）_linux gdb标准输入-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/120397168">MIT 6.S081] Lab 0: 实验配置, 调试及测试_6.s081 tools-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://darksharpness.github.io/gdb/#%E5%90%AF%E5%8A%A8%E6%8C%87%E4%BB%A4">GDB 使用笔记 | DarkSharpness’s Dougen</a></li>
</ul>
</li>
<li><p>启动 GDB</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-gdb</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在一个窗口中通过 <code>make CPUS=1 qemu-gdb</code> 启动 qemu 后，在另一个窗口中启动 GDB 进行调试</p>
</blockquote>
</li>
<li><p>退出 GDB</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line"></span><br><span class="line">q</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以使用快捷键：<code>CTRL D</code></p>
</blockquote>
</li>
<li><p><strong>断点相关</strong></p>
<ul>
<li><p>设置断点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">break &lt;function name&gt;</span><br><span class="line"></span><br><span class="line">break *&lt;address&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看断点信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info break</span><br><span class="line"></span><br><span class="line">i b</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用指定断点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable &lt;number&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用指定断点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable &lt;numebr&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定断点或删除所有断点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d &lt;break-number&gt;</span><br><span class="line"></span><br><span class="line">delete</span><br><span class="line"></span><br><span class="line">d</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>执行相关</strong></p>
<ul>
<li><p>加载一个可执行文件或目标文件以供调试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;file-path&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于 <code>user</code> 目录下的文件，我们可以加载可执行文件的符号表 <code>_xxx</code> 以供调试</p>
</blockquote>
</li>
<li><p>开始程序的运行，遇到断点就停下来</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line"></span><br><span class="line">r</span><br></pre></td></tr></table></figure>
</li>
<li><p>从一个断点处运行至下一个断点处</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">continue</span><br><span class="line"></span><br><span class="line">c</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行完当前函数并返回</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finish</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行下一行代码，进入函数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">step</span><br><span class="line"></span><br><span class="line">s</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ENTER</code> 键会执行刚刚执行过的指令</p>
</blockquote>
</li>
<li><p>执行下一条指令，包括跳转指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stepi</span><br><span class="line"></span><br><span class="line">si</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行下一行代码，不进入函数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next</span><br><span class="line"></span><br><span class="line">n</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行下一条指令，如果是跳转指令则执行至返回</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nexti</span><br><span class="line"></span><br><span class="line">ni</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>查看相关</strong></p>
<ul>
<li><p>查看变量：打印变量的值，以十六进制格式打印变量的值，以字符串的形式打印变量的值，以字符的形式打印变量的值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print &lt;var&gt;</span><br><span class="line"></span><br><span class="line">print/x &lt;var&gt;</span><br><span class="line"></span><br><span class="line">print/s &lt;var&gt;</span><br><span class="line"></span><br><span class="line">print/c &lt;var&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看内存地址的内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/&lt;n/f/u&gt; &lt;addr&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&lt;n&gt;</code>：可选参数，表示要显示的内存单元的个数。如果未指定，GDB 默认显示一个单元</p>
<p><code>&lt;f&gt;</code>：可选参数，表示显示的格式。常用的格式有：</p>
<p>​	<code>x</code>：十六进制</p>
<p>​	<code>t</code>：二进制</p>
<p>​	<code>d</code>：十进制</p>
<p>​	<code>c</code>：字符</p>
<p>​	<code>f</code>：浮点数</p>
<p>​	<code>s</code>：字符串（直到遇到 null 字符）</p>
<p>​	<code>i</code>：指令</p>
<p><code>&lt;u&gt;</code>：可选参数，表示每个单元的大小。常用的单位有：（如果不指定 <code>&lt;u&gt;</code>，GDB 默认使用 4 字节（word））</p>
<p>​	<code>b</code>：单字节（byte）</p>
<p>​	<code>h</code>：双字节（halfword，通常为 2 字节）</p>
<p>​	<code>w</code>：四字节（word，通常为 4 字节）</p>
<p>​	<code>g</code>：八字节（giant，通常为 8 字节）</p>
<p><code>&lt;addr&gt;</code>：必选参数，表示要查看的内存地址</p>
</blockquote>
</li>
<li><p>查看当前函数的参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info args</span><br><span class="line"></span><br><span class="line">i args</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看局部变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info locals</span><br><span class="line"></span><br><span class="line">i locals</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看寄存器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info reg</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置监视变量：该变量发生变化时会提示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch &lt;var&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>栈帧相关</strong></p>
<ul>
<li><p>查看当前栈帧</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info frame</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有栈帧</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">backtrace</span><br><span class="line"></span><br><span class="line">bt</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看指定栈帧</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame &lt;number&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="tui"><a href="#tui" class="headerlink" title="tui"></a>tui</h1><ul>
<li>启动 tui：tui 界面只能在 GDB 中使用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tui enable</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>常用指令</strong></p>
<ul>
<li><p>查看汇编代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout asm</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看源码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout src</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看寄存器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout reg</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时查看源码和汇编代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout split</span><br></pre></td></tr></table></figure>
</li>
<li><p>聚焦到某一窗口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">focus asm</span><br><span class="line"></span><br><span class="line">focus src</span><br><span class="line"></span><br><span class="line">focus reg</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示与 tui 相关的指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apropos tui</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://zjp-cn.github.io/posts/rcore-gdb/#%E5%AE%89%E8%A3%85-gdb">【笔记】rCore (RISC-V)：GDB 使用记录 | 苦瓜小仔 (zjp-cn.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/120397168">MIT 6.S081] Lab 0: 实验配置, 调试及测试_6.s081 tools-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://rcore-os.cn/rCore-Tutorial-deploy/docs/pre-lab/gdb.html">GDB 调试方法* · GitBook (rcore-os.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/gnu/gdb/?C=M&O=D">Index of &#x2F;gnu&#x2F;gdb&#x2F; | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<p><a target="_blank" rel="noopener" href="https://www.coder.work/article/357511">交叉编译 GDB 时出现 Python 丢失或不可用错误</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSSDCC/article/details/121231906">Tmux教程 （一文就够）-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1526675">可能是东半球最全面易懂的 Tmux 使用教程！( 强烈建议收藏 )-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45031801/article/details/134399664">【Linux】GDB保姆级调试指南（什么是GDB？GDB如何使用？）_linux gdb标准输入-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://darksharpness.github.io/gdb/#%E5%90%AF%E5%8A%A8%E6%8C%87%E4%BB%A4">GDB 使用笔记 | DarkSharpness’s Dougen</a></p>
<h1 id="待更新（使用-zhs）"><a href="#待更新（使用-zhs）" class="headerlink" title="待更新（使用 zhs）"></a>待更新（使用 zhs）</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19k4y1C7kA/?p=4&spm_id_from=pageDriver&vd_source=4bc88d483dc220df9aabd792fd12f134">Lecture 5 - RISC-V Calling Convention and Stack Frames_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/13/6-S081-Lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/13/6-S081-Lab4/" class="post-title-link" itemprop="url">Lab Traps</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-13 11:03:39" itemprop="dateCreated datePublished" datetime="2024-06-13T11:03:39+08:00">2024-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-16 15:57:19" itemprop="dateModified" datetime="2024-06-16T15:57:19+08:00">2024-06-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>实验讲义：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/labs/traps.html">Lab: Traps (mit.edu)</a></p>
</li>
<li><p>本次实验探索如何使用陷阱实现系统调用。你将首先用堆栈进行热身练习，然后实现用户级陷阱处理的示例</p>
</li>
<li><p>在开始编码之前，请阅读 xv6 book 的第 4 章，及相关源文件：</p>
<ul>
<li><code>kernel/trampoline.S</code>：涉及从用户空间到内核空间和返回的组件</li>
<li><code>kernel/trap.c</code>：处理所有中断的代码</li>
</ul>
</li>
<li><p>要开始这次实验，请输入：<code>git fetch &amp;&amp; git checkout traps &amp;&amp; make clean</code></p>
<blockquote>
<p>当然可以输入 <code>git stash</code> 贮藏之前的修改</p>
</blockquote>
</li>
</ul>
<h1 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h1><ul>
<li><p>了解一些 RISC-V 组件很重要。有一个文件 <code>user/call.c</code>，通过 <code>make fs.img</code> 编译它，这会在 <code>user/call.asm</code> 中生成程序的可读汇编版本</p>
</li>
<li><p>阅读 <code>user/call.asm</code> 中的函数 g、f 和 main 的代码，回答以下问题（将答案存储在文件 <code>answers-traps.txt</code>）</p>
</li>
<li><p>在开始之前，我们可以在 <a target="_blank" rel="noopener" href="http://staff.ustc.edu.cn/~llxx/cod/reference_books/RISC-V-Reader-Chinese-v2p12017.pdf">RISC-V手册 (ustc.edu.cn)</a> 了解 RISC-V 的一些基本指令</p>
<blockquote>
<p>附录 A 部分有每个 RISC-V 指令的详尽描述</p>
</blockquote>
</li>
</ul>
<style>.gmwpvfebbtrv{zoom:67%;}</style><img src="/2024/06/13/6-S081-Lab4/image-20240613112329423.png" class="gmwpvfebbtrv" alt="image-20240613112329423">

<blockquote>
<p>Temporary：临时的，frame pointer：帧指针</p>
</blockquote>
<ul>
<li>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</li>
<li>哪些寄存器包含函数的参数？例如，在 main 对 printf 中哪个寄存器持有 13 <ul>
<li>Function argument 总是存放在寄存器 a0-a7，在 main:24 不难发现 a2 持有 13</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">000000000000001c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">void main(void) &#123;</span><br><span class="line">  1c:	1141                	addi	sp,sp,-16</span><br><span class="line">  1e:	e406                	sd	ra,8(sp)</span><br><span class="line">  20:	e022                	sd	s0,0(sp)</span><br><span class="line">  22:	0800                	addi	s0,sp,16</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:	4635                	li	a2,13</span><br><span class="line">  26:	45b1                	li	a1,12</span><br><span class="line">  28:	00000517          	auipc	a0,0x0</span><br><span class="line">  2c:	7c850513          	addi	a0,a0,1992 # 7f0 &lt;malloc+0xe8&gt;</span><br><span class="line">  30:	00000097          	auipc	ra,0x0</span><br><span class="line">  34:	61a080e7          	jalr	1562(ra) # 64a &lt;printf&gt;</span><br><span class="line">  exit(0);</span><br><span class="line">  38:	4501                	li	a0,0</span><br><span class="line">  3a:	00000097          	auipc	ra,0x0</span><br><span class="line">  3e:	298080e7          	jalr	664(ra) # 2d2 &lt;exit&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</li>
<li>在 mian 的汇编代码中，对函数 f 的调用在哪里？对 g 的调用在哪里？（提示：编译器可能内联函数）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int g(int x) &#123;</span><br><span class="line">   0:	1141                	addi	sp,sp,-16</span><br><span class="line">   2:	e422                	sd	s0,8(sp)</span><br><span class="line">   4:	0800                	addi	s0,sp,16</span><br><span class="line">  return x+3;</span><br><span class="line">&#125;</span><br><span class="line">   6:	250d                	addiw	a0,a0,3</span><br><span class="line">   8:	6422                	ld	s0,8(sp)</span><br><span class="line">   a:	0141                	addi	sp,sp,16</span><br><span class="line">   c:	8082                	ret</span><br><span class="line"></span><br><span class="line">000000000000000e &lt;f&gt;:</span><br><span class="line"></span><br><span class="line">int f(int x) &#123;</span><br><span class="line">   e:	1141                	addi	sp,sp,-16</span><br><span class="line">  10:	e422                	sd	s0,8(sp)</span><br><span class="line">  12:	0800                	addi	s0,sp,16</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br><span class="line">  14:	250d                	addiw	a0,a0,3</span><br><span class="line">  16:	6422                	ld	s0,8(sp)</span><br><span class="line">  18:	0141                	addi	sp,sp,16</span><br><span class="line">  1a:	8082                	ret</span><br></pre></td></tr></table></figure>

<ul>
<li><p>main 调用了 <code>printf(&quot;%d %d\n&quot;, f(8)+1, 13)</code>，f 调用了 <code>return g(x)</code>，g 的作用是 <code>return x + 3</code></p>
<ul>
<li>所以在 main:26，对 f 的调用被内联为了 <code>li a1 12</code>；在 f:14，对 g 的调用也被内联为了 <code>addiw a0,a0,3</code></li>
</ul>
</li>
<li><p>At what address is the function <code>printf</code> located?</p>
</li>
<li><p>printf 函数位于哪个地址？</p>
</li>
<li><p>在 main:30，<code>30:00000097  auipc ra,0x0</code>。<code>auipc rd,immediate</code> 令 <code>rd = pc + immediate &lt;&lt; 12</code></p>
</li>
<li><p>因为 <code>immediate = 0,pc = 0x30</code>，所以 <code>ra = 0x30</code></p>
</li>
</ul>
<img src="/2024/06/13/6-S081-Lab4/image-20240613125823682.png" class="" title="image-20240613125823682">

<ul>
<li><p>在 main:34，<code>34:61a080e7  jalr 1562(ra)</code> 。<code>jalr rd offset(rs1)</code> 令 <code>rd = pc + 4</code>， <code>pc = offset(rs1)</code> 即跳转到 <code>offset(rs1)</code></p>
</li>
<li><p>因为 <code>rd = rs1 = ra,pc = 0x34,1562 = 0x600</code>，所以跳转到 <code>0x600 + ra = 0x630</code> 且 <code>ra = 0x34 + 0x4 = 0x38</code> </p>
<img src="/2024/06/13/6-S081-Lab4/image-20240613115004256.png" class="" title="image-20240613115004256">

<ul>
<li>因此 printf 函数位于 <strong>0x630</strong></li>
</ul>
</li>
<li><p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p>
</li>
<li><p>main 中 jalr 跳转到 printf 之后寄存器 ra 中有什么值？</p>
<ul>
<li>根据上述的分析可以知道，<code>ra = 0x38</code></li>
</ul>
</li>
<li><p>Run the following code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i); </span><br></pre></td></tr></table></figure>
</li>
<li><p>What is the output?</p>
</li>
<li><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
</li>
<li><p>运行一下代码。输出是什么？输出取决于 RISC-V 是小端的事实。如果 RISC-V 是大端，你会设置什么来产生相同的输出？你需要将 57616 更改为不同的值吗？</p>
</li>
<li><p><code>%x</code> 用于打印无符号整数的十六进制形式，<code>57616 = 0xE110</code>；<code>%s</code> 接收一个指向字符的指针，逐个打印字符直到遇到 <code>\0</code>，由于小端 <code>0x00646c72 = 72-6c-64-00</code>，根据 ASCLL 表得 <code>r-l-d</code>，最后的 <code>00</code> 充当 <code>\0</code></p>
<ul>
<li>因此输出是 <code>HE110 World</code>。如果是大端，<code>i = 0x726c6400</code>，57616 不需要改变</li>
</ul>
</li>
<li><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在下面的代码中，在 <code>y=</code> 之后将打印什么？（注：答案不是特定值）为什么会发生这种情况？</p>
<ul>
<li>只传入了一个参数，第二个参数取决于寄存器 <code>a2</code> 之前存的是什么值</li>
</ul>
</li>
</ul>
<h1 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h1><ul>
<li>对于调试，回溯通常是有用的：一个在发送错误点上方的堆栈上的函数调用列表</li>
<li>在 <code>kernel/printf.c</code> 中实现 <code>backtrace()</code> 函数，在 <code>sys_sleep()</code> 中插入对此函数的调用，运行 <code>bttest</code>，它会调用 <code>sys_sleep</code></li>
<li>你的输出应该如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">backtrace:</span><br><span class="line"><span class="number">0x0000000080002cda</span></span><br><span class="line"><span class="number">0x0000000080002bb6</span></span><br><span class="line"><span class="number">0x0000000080002898</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>你的终端中地址可能略有不同</p>
</blockquote>
<ul>
<li><p>编译器在每个 stack frame 中放置了一个帧指针（frame pointer），你的回溯应该使用这些帧指针，并在每个堆栈帧中打印保存的<strong>返回地址</strong></p>
</li>
<li><p>一些提示</p>
<ul>
<li><p>将回溯的原型添加到 <code>kernel/defs.h</code>，以便你可以在 <code>sys_sleep</code> 中调用回溯</p>
</li>
<li><p>GCC 编译器将当前执行函数的 frame pointer 存储在寄存器 s0 中，将以下函数添加到 <code>kernel/riscv.h</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在回溯中调用此函数来获取当前 frame pointer。此函数用内联汇编来读取 s0</p>
</li>
<li><p>请注意，返回地址与 stack frame 的 frame pointer 的固定偏移为 (-8)，保存的（调用者的）frame pointer 与当前的 frame pointer 的固定偏移为 (-16)</p>
<img src="/2024/06/13/6-S081-Lab4/image-20240614112232298.png" class="" title="image-20240614112232298">
</li>
<li><p>xv6 在 PAGE 对齐的地址为 xv6 内核中的每个堆栈分配一个页面，你可以使用 <code>PGROUNDDOWN(fp)</code> 和 <code>PGROUNDUP(fp)</code> 计算堆栈页面的顶部和底部地址（<code>kernel/riscv.h</code>），这些数字有助于回溯的终止其循环</p>
</li>
</ul>
</li>
<li><p>根据提示，在 <code>kernel/riscv.h</code> 中添加内联汇编函数，读取寄存器 s0</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// my change  get register s0</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 </span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/defs.h</code> 中添加 <code>backtrace</code> 的函数原型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// printf.c</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">()</span>;   <span class="comment">// my change</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在实现 <code>backtrace</code> 之前，我们先来关注一下 <code>PGROUNDDOWN(fp)</code> 和 <code>PGROUNDUP(fp)</code></li>
<li><code>PGROUNDDOWN(fp)</code> 和 <code>PGROUNDUP(fp)</code> 的作用分别是取整到页大小整数倍的下边界和上边界，由于 xv6 为内核中的每个堆栈分配一个页面（4096），所以 <code>PGROUNDDOWN(fp)</code> 和 <code>PGROUNDUP(fp)</code> 的值总是固定的，我的取值分别是 <code>0x0000003fffff9000 0x0000003fffffa000</code></li>
<li>因此我们的一种终止回溯循环的方式是 <code>PGROUNDDOWN(fp) != 0x0000003fffff9000 &amp;&amp; PGROUNDUP(fp) != 0x0000003fffffa000</code></li>
<li>还有一种终止循环的方式是 <code>PGROUNDUP(fp) - PGROUNDDOWN(fp) != PGSIZE</code><ul>
<li>这是因为在一般情况下，<code>PGROUNDUP(fp) - PGROUNDDOWN(fp)</code> 总是等于 <code>PGSIZE</code></li>
<li>而当 frame pointer 等于最初的帧指针，即等于 <code>PGROUNDUP(fp)</code> 时，frame pointer 是页大小（4096）的整数倍，<code>PGROUNDUP(fp) - PGROUNDDOWN(fp)</code> 等于 0</li>
</ul>
</li>
<li>我们可以在 <code>kernel/printf.c</code> 中实现 <code>backtrace</code> 来验证一下（先不关注如何实现）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, PGROUNDDOWN(fp), PGROUNDUP(fp));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (PGROUNDUP(fp) - PGROUNDDOWN(fp) == PGSIZE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, *((uint64*)(fp - <span class="number">16</span>)), *((uint64*)(fp - <span class="number">8</span>)));</span><br><span class="line">    fp = *((uint64*)(fp - <span class="number">16</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果如下所示，不难发现最初的 frame pointer 确实等于 <code>PGROUNDUP(fp)</code>（这是由于栈向下增长）</li>
</ul>
<img src="/2024/06/13/6-S081-Lab4/image-20240614114532099.png" class="" title="image-20240614114532099">

<ul>
<li>因此，我们最终在 <code>kernel/printf.c</code> 中实现 <code>backtrace</code></li>
<li>需要注意的是：<code>r_fp()</code> 返回的是一个地址，我们需要将其强转为指针（<code>uint64*</code>）后再解引用它</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (PGROUNDUP(fp) - PGROUNDDOWN(fp) == PGSIZE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *((uint64*)(fp - <span class="number">8</span>)));</span><br><span class="line">    fp = *((uint64*)(fp - <span class="number">16</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h1 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h1><ul>
<li><p>在这个任务中，你将向 xv6 添加一个功能，该功能会定期向使用CPU时间的进程发出警告</p>
<ul>
<li>这对于那些想要限制其消耗的 CPU 时间的计算密集型进程，或者那些既想进行计算又想定期执行某些操作的进程来说可能是有用的</li>
<li>更一般的来说，你将要实现用户级中断 &#x2F; 故障处理程序的原始形式</li>
<li>如果你通过 <code>alarmtest</code> 和 <code>usertests-q</code>，你的解决方案是正确的</li>
</ul>
</li>
<li><p>你应该添加一个新的 <code>sigalarm(interval, handler)</code> 系统调用</p>
<ul>
<li>如果应用程序调用 <code>sigalarm(n, fn)</code>，那么在消耗 n 个 tick 的 CPU 时间后，内核应该导致调用函数 fn</li>
<li>当 fn 返回时，应用程序应该从中断的地方恢复</li>
<li>tick 是 xv6 中相当任意的时间单位，由硬件计时器生成中断的频率决定</li>
<li>如果应用程序调用 <code>sigalarm(0, 0)</code>，内核应该停止生成周期性警报调用</li>
</ul>
</li>
<li><p>你将在 xv6 存储库中找到这样一个文件 <code>user/alarmtest.c</code>，将其添加到 Makefile 中</p>
<ul>
<li>在你添加 <code>sigalarm</code> 和 <code>sigreturn</code> 系统调用之前，它不会正确编译</li>
</ul>
</li>
<li><p>当 <code>alarmtest</code> 和 <code>usertests-q</code> 产生这样的输出时，你的解决方案是正确的</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">alarmtest</span></span><br><span class="line">test0 start</span><br><span class="line">........alarm!</span><br><span class="line">test0 passed</span><br><span class="line">test1 start</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">test1 passed</span><br><span class="line">test2 start</span><br><span class="line">................alarm!</span><br><span class="line">test2 passed</span><br><span class="line">test3 start</span><br><span class="line">test3 passed</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">usertest -q</span></span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<h2 id="test0：invoke-handler"><a href="#test0：invoke-handler" class="headerlink" title="test0：invoke handler"></a>test0：invoke handler</h2><ul>
<li><p>我们首先修改内核以便可以跳转到用户空间中的警报处理程序，这将会通过 <code>alarmtest</code> 中的 <code>test0</code></p>
</li>
<li><p>一些提示</p>
<ul>
<li><p>你需要修改 Makefile，以便将 <code>alarmtest.c</code> 编译成 xv6 用户程序</p>
</li>
<li><p>在 <code>user/user.h</code> 中正确声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span>(*handler) ())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新 <code>user/usys.pl</code>（以生成 <code>user/usys.S</code>）、<code>kernel/syscall.h</code> 和 <code>kernel/syscall.c</code>，以允许 <code>alarmtest</code> 调用 <code>sigalarm</code> 和 <code>sigreturn</code> 系统调用</p>
</li>
<li><p>目前，你的 <code>sys_sigreturn</code> 应该只返回 0</p>
</li>
<li><p>你的 <code>sys_sigalarm()</code> 应该将警报间隔 interval 和指向处理程序函数的指针 handler 存储在 struct proc（在 <code>kernel/proc.h</code> 中）的新字段</p>
</li>
<li><p>你需要跟踪自上次调用到进程的警报处理程序以来已经经过了多少 tick，因此，你也需要在 struct proc 中设置一个新字段</p>
</li>
<li><p>你可以在 <code>kernel/proc.c</code> 的 <code>allocproc()</code> 中初始化 proc 字段</p>
</li>
<li><p>每次 tick，硬件时钟都会强制中断，中断在 <code>kernel/trap.c</code> 中的 <code>usertrap()</code> 中处理</p>
</li>
<li><p>只有当定时器（时钟）中断时，你才想操纵进程的警报 tick。你想要类似 <code>if (which_dev == 2) ...</code></p>
</li>
<li><p>只有在进程有未处理的定时器时，才调用警报函数</p>
</li>
<li><p>您需要修改 <code>usertrap()</code> 函数，以便当一个进程的报警间隔到期时，用户进程执行处理函数。当 RISC-V 上的 trap 返回到用户空间时，是什么决定了用户空间代码恢复执行的指令地址？</p>
</li>
<li><p>如果你告诉 qemu 只使用一个 CPU，用 gdb 查看 trap 会更容易，通过运行 <code>mkae CPUS=1 qemu-gdb</code></p>
</li>
</ul>
</li>
<li><p>在 <code>user/user.h</code> 中正确声明 <code>sigalarm</code> 和 <code>sigreturn</code> 系统调用</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler) ())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 <code>user/usys.pl</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line">entry(&quot;sigalarm&quot;);</span><br><span class="line">entry(&quot;sigreturn&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 <code>kernel/syscall.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigalarm 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigreturn 23</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更新 <code>kernel/syscall.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prototypes for the functions that handle system calls.</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An array mapping syscall numbers from syscall.h</span></span><br><span class="line"><span class="comment">// to the function that handles the system call.</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[SYS_sigalarm] sys_sigalarm,</span><br><span class="line">[SYS_sigreturn] sys_sigreturn,</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/sysproc.c</code> 中实现 <code>sys_sigalarm()</code> 和 <code>sys_sigreturn()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">uint64 </span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="type">int</span> interval;</span><br><span class="line">  argint(<span class="number">0</span>, &amp;interval);</span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;handler);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64 </span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/proc.h</code> 中的 struct proc 中添加新字段</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint64 handler; 		<span class="comment">// 处理程序函数的指针</span></span><br><span class="line">  uint64 interval;   	<span class="comment">// 警报间隔</span></span><br><span class="line">  uint64 passedticks; 	<span class="comment">// 已经经过的tick </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/proc.c</code> 中的 <code>allocproc()</code> 中初始化 proc 的新字段</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.  在进程表中找一个未使用的进程</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,  如果找到，初始化在内核中运行所需要的状态</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.  返回并持有进程锁</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.  如果没有空闲进程，或内存分配失败，返回0</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  p-&gt;interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;handler = <span class="number">0</span>;</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/proc.c</code> 中的 <code>freeproc()</code> 中释放 proc 的新字段</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  p-&gt;interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;handler = <span class="number">0</span>;</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/sysproc.c</code> 中继续实现 <code>sigalarm()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">uint64 </span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="type">int</span> interval;</span><br><span class="line">  argint(<span class="number">0</span>, &amp;interval);</span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;handler);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;handler = handler;</span><br><span class="line">  p-&gt;interval = interval;</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64 </span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们从 xv6 book 的第 4 章中了解到：</li>
<li>我们在用户空间调用 <code>sigalarm</code> 和 <code>sigreturn</code> 系统调用时，由于更新了 <code>user/usys.pl</code>，编译会在 <code>user/usys.S</code> 中生成相应的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line">sigalarm:</span><br><span class="line"> li a7, SYS_sigalarm</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sigreturn</span><br><span class="line">sigreturn:</span><br><span class="line"> li a7, SYS_sigreturn</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<ul>
<li>汇编代码将 <code>kernel/syscall.h</code> 中的 <code>System call numbers</code> 放入寄存器 a7，通过 <code>ecall</code> 指令进入内核</li>
<li><code>ecall</code> 指令调转到 <code>kernel/trampoline.S</code> 中的 <code>uservec</code>，保存相关的寄存器后，跳转到 <code>kernel/trap.c</code> 中的 <code>usertrap()</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">        # ...</span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        # ...</span><br><span class="line">		</span><br><span class="line">		# ...</span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>usertrap()</code> 在当前进程的 trapframe 中保存了用户程序计数器防止它被更改，以便返回到用户空间中断的位置</li>
<li>如果陷入 trap 的原因是系统调用，那就调用 <code>syscall()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space. 处理一个来自用户空间的中断，异常或系统调用</span></span><br><span class="line"><span class="comment">// called from trampoline.S 被trampoline.S调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// save user program counter. 保存用户程序计数器</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction. 改变返回地址为ecall指令的下一个指令地址</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.  放弃CPU如果这是一个时钟中断</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  usertrapret();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/syscall.c</code> 中的 <code>syscall()</code> 会查看 trapframe 中的寄存器 a7，根据 a7 中的 <code>System call numbers</code> 调用 <code>kernel/sysproc.c</code> 中的 <code>sys_...</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An array mapping syscall numbers from syscall.h</span></span><br><span class="line"><span class="comment">// to the function that handles the system call.</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">    <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 <code>kernel/trap.c</code> 中的 <code>usertrapret()</code>，为下一次陷入内核做了一些准备后，调转到 <code>kernel/trampoline.S</code> 中的 <code>userret</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>userret</code> 恢复保存在 trapframe 中的寄存器，通过 <code>sret</code> 恢复保存在寄存器 spec 中的 <code>user pc</code>，回到用户空间中断的位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">userret:</span><br><span class="line">        # ...</span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        # ...</span><br><span class="line">	# restore user a0</span><br><span class="line">        ld a0, 112(a0)</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从上述描述中，我们发现从内核返回到用户空间位置的关键是 <code>usertrap()</code> 中的 <code>p-&gt;trapframe-&gt;epc</code></p>
</li>
<li><p>修改 <code>kernel/trap.c</code> 中的 <code>usertrap()</code>，每发生一次时钟中断时（<code>while_dev == 2</code>）增加 <code>passedticks</code> 计数</p>
</li>
<li><p>只有一个进程的报警间隔到期时（<code>p-&gt;passedticks == p-&gt;interval</code>），才更新 <code>p-&gt;trapframe-epc = handler</code>，用户进程执行处理函数</p>
</li>
<li><p>需要注意的是：<code>interval != 0</code>，如果应用程序调用 <code>sigalarm(0, 0)</code>，内核应该停止生成周期性警报调用</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space. 处理一个来自用户空间的中断，异常或系统调用</span></span><br><span class="line"><span class="comment">// called from trampoline.S 被trampoline.S调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;interval != <span class="number">0</span> &amp;&amp; ++p-&gt;passedticks == p-&gt;interval) &#123;</span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;handler;</span><br><span class="line">      p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.  </span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line">  usertrapret();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 Makefile，以便编译用户级的 <code>alarmtest.c</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_alarmtest\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; alarmtest</strong> 进行测试，结果如下所示：</li>
</ul>
<img src="/2024/06/13/6-S081-Lab4/image-20240616113601884.png" class="" title="image-20240616113601884">

<ul>
<li>可以发现 <code>test0 passed</code>，但 <code>test1 failed</code> 后崩溃，这是正常的，在之后的步骤中我们会解决它</li>
</ul>
<h2 id="test1-test2-test3-：resume-interrupted-code"><a href="#test1-test2-test3-：resume-interrupted-code" class="headerlink" title="test1&#x2F;test2()&#x2F;test3()：resume interrupted code"></a>test1&#x2F;test2()&#x2F;test3()：resume interrupted code</h2><ul>
<li><p>要解决这个问题，你必须确保警报处理程序完成后，控制返回到用户程序最初被计时器中断的位置</p>
<ul>
<li>你必须确保寄存器内容恢复到中断时持有的值，以便用户程序在警报后可以继续不受干扰</li>
</ul>
</li>
<li><p>作为起点，我们已经为你做出了一个设计决定：用户警报处理程序完成后需要调用 <code>sigreturn</code> 系统调用</p>
<ul>
<li>这意味着你可以将代码添加到 <code>usertrap</code> 和 <code>sys_sigreturn</code> 中，这些代码可以合作使用户进程在处理警报后恢复正常</li>
</ul>
</li>
<li><p><code>user/alarmtest.c</code> 中的用户警报处理程序 <code>periodic()</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">periodic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  count = count + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;alarm!\n&quot;</span>);</span><br><span class="line">  sigreturn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一些提示</p>
<ul>
<li>你的解决方案将要求你保存和恢复寄存器——你需要保存和恢复哪些寄存器才能恢复中断的代码？（提示：会很多）</li>
<li>当计时器中断发生时，<code>usertrap</code> 必须保存足够的状态在 <code>struct proc</code> 中，以便 <code>sigreturn</code> 能够正确地返回到被中断的用户代码</li>
<li>防止对警报处理程序的重新进入调用——如果处理程序尚未返回，内核不应该再次调用它。<code>test2</code> 会测试这一点</li>
<li>确保恢复 a0。<code>sigreturn</code> 是一个系统调用，其返回值存储在 a0 中</li>
</ul>
</li>
<li><p>在之前的描述中，我们了解到需要恢复的寄存器被保存在 <code>p-&gt;trapframe</code> </p>
<ul>
<li>如果返回到用户空间的警报处理程序 <code>periodic()</code>，警报处理程序执行后，原来存储在这些寄存器中的值会被覆盖</li>
<li>当我们调用 <code>sigreturn</code> 进入内核时，就无法恢复这些寄存器中原来存储的值从而正确地返回到被中断的用户代码了</li>
</ul>
</li>
<li><p>因此，在 <code>kernel/proc.c</code> 中的 struct proc 中添加新字段保存需要恢复的寄存器，即一个 struct trapframe</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint64 handler; <span class="comment">// 处理程序函数的指针</span></span><br><span class="line">  uint64 interval;   <span class="comment">// 警报间隔</span></span><br><span class="line">  uint64 passedticks; <span class="comment">// 已经经过的tick </span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe_copy</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>更新 <code>kernel/proc.c</code> 中的 <code>allocproc()</code>，为 struct proc 中的新字段分配空间</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.  在进程表中找一个未使用的进程</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,  如果找到，初始化在内核中运行所需要的状态</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.  返回并持有进程锁</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.  如果没有空闲进程，或内存分配失败，返回0</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  p-&gt;interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;handler = <span class="number">0</span>;</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ((p-&gt;trapframe_copy = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 <code>kernel/proc.c</code> 中的 <code>freeproc()</code>，释放 struct proc 中的新字段</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  p-&gt;interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;handler = <span class="number">0</span>;</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;trapframe_copy) &#123;</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe_copy);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;trapframe_copy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kernel/trap.c</code> 中的 <code>usertrap()</code>，当警报时间间隔到期，返回到用户空间的警报处理程序时，保存被中断用户程序的 trapframe</li>
<li>为了防止警报处理程序尚未返回就被重新调用，我们仅在 <code>sys_sigreturn</code> 中将 <code>passedticks</code> 重置为 0<ul>
<li>这样的话，当警报处理程序尚未返回时，即使因为计时器中断进入内核，也只是 <code>++p-&gt;passedticks</code></li>
<li>而不会满足 <code>p-&gt;passedticks == p-&gt;interval</code> 使得 <code>p-&gt;trapframe-&gt;epc = p-&gt;handler</code>，导致对警报处理程序的重新调用</li>
<li>只有警报处理程序返回后，调用 <code>sigreturn</code> 重新进入内核，<code>passedticks</code> 被重置为 0，才会重新进入计数</li>
<li>当然也可以通过添加一个新字段来实现</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space. 处理一个来自用户空间的中断，异常或系统调用</span></span><br><span class="line"><span class="comment">// called from trampoline.S 被trampoline.S调用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;interval != <span class="number">0</span> &amp;&amp; ++p-&gt;passedticks == p-&gt;interval) &#123;</span><br><span class="line">      memmove(p-&gt;trapframe_copy, p-&gt;trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> proc));</span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.  放弃CPU如果这是一个时钟中断</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  usertrapret();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 <code>kernel/sysproc.c</code> 中的 <code>sys_sigreturn</code>，恢复被中断用户程序的相关寄存器，重置计数器</li>
<li>需要注意的是：<code>sigreturn</code> 是一个系统调用，返回值会覆盖掉寄存器 a0 中原来的值，所以我们需要返回 a0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint64 </span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  memmove(p-&gt;trapframe, p-&gt;trapframe_copy, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; alarmtest</strong>，<code>test0 passed &amp;&amp; test1 passed &amp;&amp; test2 passed &amp;&amp; test3 passed</code></li>
</ul>
<img src="/2024/06/13/6-S081-Lab4/image-20240616153640855.png" class="" title="image-20240616153640855">

<ul>
<li><strong>usertests</strong>，<code>ALL TESTS PASSED</code></li>
</ul>
<img src="/2024/06/13/6-S081-Lab4/image-20240616153555150.png" class="" title="image-20240616153555150">

<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make grade | .&#x2F;grade-lab-traps</strong></li>
</ul>
<img src="/2024/06/13/6-S081-Lab4/image-20240616155708976.png" class="" title="image-20240616155708976">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/121341055">MIT 6.S081] Lab 4: traps_mit6.s081lab4-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16127351.html">MIT6.S081-Lab4 Traps 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://xv6.dgs.zone/labs/answers/lab4.html">Lab4: Traps · 6.S081 All-In-One (dgs.zone)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/05/xv6-book-chapter-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/05/xv6-book-chapter-4/" class="post-title-link" itemprop="url">xv6 book chapter 4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-05 20:02:43" itemprop="dateCreated datePublished" datetime="2024-06-05T20:02:43+08:00">2024-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-22 18:36:46" itemprop="dateModified" datetime="2024-06-22T18:36:46+08:00">2024-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h1><ul>
<li><p>有三种事件会导致 CPU 搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码</p>
<ul>
<li>一种情况是 <strong>系统调用</strong>，当用户程序执行 <strong>ecall</strong> 指令要求内核为其做某事时</li>
<li>另一种情况是 <strong>异常</strong>：一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址</li>
<li>第三种情况是设备 <strong>中断</strong>，当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时</li>
</ul>
</li>
<li><p>本书使用 <strong>trap</strong> 作为这些情况的通用术语</p>
<ul>
<li>通常，代码在执行时发生 trap，之后都会被恢复，而且不需要意识到发生了什么特殊的事情</li>
<li>也就是说，我们通常希望 trap 是透明的；这一点对于中断来说尤其重要，被中断的代码通常不会意识到会发生 trap</li>
<li>通常的顺序是：trap 迫使控制权转移到内核；内核保存寄存器和其他状态，以便恢复执行；内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；内核恢复保存的状态，并从 trap 中返回；代码从原来的地方恢复执行</li>
</ul>
</li>
<li><p>xv6 内核会处理所有的 trap</p>
<ul>
<li>这对于系统调用来说是很自然的</li>
<li>这对中断来说也是合理的，因为隔离要求用户进程不能直接使用设备，而且只有内核才有设备处理所需的状态</li>
<li>这对异常处理来说也是合理的，因为 xv6 响应所有来自用户空间的异常，并杀死该违规程序</li>
</ul>
</li>
<li><p>xv6 trap 处理分为四个阶段：</p>
<ul>
<li>RISC-V CPU 采取的硬件行为，为内核 C 代码准备的汇编入口，处理 trap 的 C 处理程序，以及系统调用或设备驱动服务</li>
<li>虽然三种 trap 类型之间的共性表明，内核可以用单一的代码入口处理所有的 trap，但事实证明，为三种不同的情况，即来自用户空间的 trap、来自内核空间的 trap 和定时器中断，设置单独的汇编入口和 C trap 处理程序会更方便的</li>
</ul>
</li>
</ul>
<h2 id="RISC-V-trap-machinery-RISC-V-陷阱处理机制"><a href="#RISC-V-trap-machinery-RISC-V-陷阱处理机制" class="headerlink" title="RISC-V trap machinery RISC-V 陷阱处理机制"></a>RISC-V trap machinery RISC-V 陷阱处理机制</h2><ul>
<li><p>每个 RISC-V CPU 都有一组控制寄存器，内核写入这些寄存器来告诉 CPU 如何处理 trap，内核可以通过读取这些寄存器来发现已经发生的 trap</p>
<ul>
<li>RISC-V 文档包含了完整的叙述[1]</li>
<li><code>riscv.h</code>（kernel&#x2F;riscv.h:1）包含了 xv6 使用的定义。这里是最重要的寄存器的概述</li>
</ul>
<ul>
<li><p><code>stvec</code>：内核在这里写下 trap 处理程序的地址；RISC-V 跳转到这里来处理 trap</p>
</li>
<li><p><code>sepc</code>：当 trap 发生时，RISC-V 会将程序计数器保存在这里（因为 <code>PC</code> 会被 <code>stvec</code> 覆盖）</p>
<ul>
<li><code>sret</code>（从 trap 中返回）指令将 <code>sepc</code> 复制到 <code>pc</code> 中。内核可以写 <code>sepc</code> 来控制 <code>sret</code> 的返回到哪里</li>
</ul>
</li>
<li><p><code>scause</code>：RISC -V 在这里放了一个数字，描述了 trap 的原因</p>
</li>
<li><p><code>sscratch</code>：内核在这里放置了一个值，在 trap 处理程序开始时可以方便地使用</p>
</li>
<li><p><code>sstatus</code>：<code>sstatus</code> 中的 <strong>SIE</strong> 位控制设备中断是否被启用，如果内核清除 <strong>SIE</strong>，RISC-V 将推迟设备中断，直到内核设置 <strong>SIE</strong></p>
<ul>
<li><strong>SPP</strong> 位表示 trap 是来自用户模式还是 supervisor 模式，并控制 <code>sret</code> 返回到什么模式</li>
</ul>
</li>
</ul>
</li>
<li><p>上述寄存器与在特权态模式下处理的 trap 有关，在用户模式下不能读或写</p>
<ul>
<li>对于机器模式下处理的 trap，有一组等效的控制寄存器；xv6 只在定时器中断的特殊情况下使用它们</li>
</ul>
</li>
<li><p>多核芯片上的每个 CPU 都有自己的一组这些寄存器，而且在任何时候都可能有多个 CPU 在处理一个 trap</p>
</li>
<li><p>当需要执行 trap 时，RISC-V 硬件对所有的 trap 类型（除定时器中断外）进行以下操作：</p>
<ul>
<li><p>如果该 trap 是设备中断，且 <code>sstatus</code> <strong>SIE</strong> 位为 0，则不执行以下任何操作</p>
</li>
<li><p>通过清除 SIE 来禁用中断</p>
</li>
<li><p>复制 <code>pc</code> 到 <code>sepc</code></p>
</li>
<li><p>将当前模式（用户态或特权态）保存在 <code>sstatus</code> 的 <strong>SPP</strong> 位</p>
</li>
<li><p>在 <code>scause</code> 设置该次 trap 的原因</p>
</li>
<li><p>将模式转换为特权态</p>
</li>
<li><p>将 <code>stvec</code> 复制到 <code>pc</code></p>
</li>
<li><p>从新的 <code>pc</code> 开始执行</p>
</li>
</ul>
</li>
<li><p>注意，CPU 不会切换到内核页表，不会切换到内核中的栈，也不会保存 pc 以外的任何寄存器</p>
<ul>
<li>内核软件必须执行这些任务</li>
<li>CPU 在 trap 期间做很少的工作的一个原因是为了给软件提供灵活性，例如，一些操作系统在某些情况下不需要页表切换，这可以提高性能</li>
</ul>
</li>
<li><p>你可能会想 CPU 的 trap 处理流程是否可以进一步简化</p>
<ul>
<li>例如，假设 CPU 没有切换程序计数器（pc）</li>
<li>那么 trap 可以切换到监督者模式时，还在运行用户指令。这些用户指令可以打破用户空间&#x2F;内核空间的隔离，例如通过修改 <code>satp</code> 寄存器指向一个允许访问所有物理内存的页表</li>
<li>因此，CPU 必须切换到内核指定的指令地址，即 <code>stvec</code></li>
</ul>
</li>
</ul>
<blockquote>
<p> 在进入 trampoline.S 之前，ecall 指令做了三件事情：</p>
<p> 保存用户 pc，将权限提升到内核模式，更改 pc 为 trampoline.S 的起始地址并跳转到 trampoline.S</p>
</blockquote>
<h2 id="Traps-from-user-space-来自用户空间的陷阱"><a href="#Traps-from-user-space-来自用户空间的陷阱" class="headerlink" title="Traps from user space 来自用户空间的陷阱"></a>Traps from user space 来自用户空间的陷阱</h2><ul>
<li><p>在用户空间执行时，如果用户程序进行了系统调用（<code>ecall</code> 指令），或者做了一些非法的事情，或者设备中断，都可能发生 trap</p>
<ul>
<li>来自用户空间的 trap 的处理路径是 <code>uservec</code>（kernel&#x2F;trampoline.S:16），然后是 <code>usertrap</code>（kernel&#x2F;trap.c:37）；返回时是<code>usertrapret</code>（kernel&#x2F;trap.c:90），然后是 <code>userret</code>（kernel&#x2F;trampoline.S:16）。</li>
</ul>
</li>
<li><p>来自用户代码的 trap 比来自内核的 trap 更具挑战性，因为 <code>satp</code> 指向的用户页表并不映射内核，而且栈指针可能包含一个无效甚至恶意的值</p>
</li>
<li><p>因为 RISC-V 硬件在 trap 过程中不切换页表，所以用户页表必须包含 <code>uservec</code> 的映射，即 <code>stvec</code> 指向的 trap 处理程序地址</p>
<ul>
<li><code>uservec</code> 必须切换 <code>satp</code>，使其指向内核页表；为了在切换后继续执行指令，<code>uservec</code> 必须被映射到内核页表与用户页表相同的地址</li>
</ul>
</li>
<li><p>xv6 用一个包含 <code>uservec</code> 的 trampoline 页来满足这些条件</p>
<ul>
<li>xv6 在内核页表和每个用户页表中的同一个虚拟地址上映射了 trampoline 页</li>
<li>这个虚拟地址就是 <code>TRAMPOLINE</code>（如我们在图 2.3 和图 3.3 中看到的）</li>
<li><code>trampoline.S</code> 中包含 trampoline 的内容，（执行用户代码时）<code>stvec</code> 设置为 <code>uservec</code>（kernel&#x2F;trampoline.S:16）。</li>
</ul>
</li>
<li><p>当 <code>uservec</code> 启动时，所有 32 个寄存器都包含被中断的代码所拥有的值</p>
<ul>
<li>但是 <code>uservec</code> 需要能够修改一些寄存器，以便设置 <code>satp</code> 和生成保存寄存器的地址</li>
<li>RISC-V 通过 <code>sscratch</code> 寄存器提供了帮助</li>
<li><code>uservec</code> 开始时的 <code>csrrw</code> 指令将 <code>a0</code> 和 <code>sscratch</code> 的内容互换</li>
<li>现在用户代码的 <code>a0</code> 被保存了；<code>uservec</code> 有一个寄存器（<code>a0</code>）可以使用；<code>a0</code> 包含了内核之前放在 <code>sscratch</code> 中的值。</li>
</ul>
</li>
<li><p><code>uservec</code> 的下一个任务是保存用户寄存器</p>
<ul>
<li><p>在进入用户空间之前，内核先设置 <code>sscratch</code> 指向该进程的 <code>trapframe</code>，这个 <code>trapframe</code> 可以保存所有用户寄存器（kernel&#x2F;proc.h:44）</p>
</li>
<li><p>因为 <code>satp</code> 仍然是指用户页表，所以 <code>uservec</code> 需要将 <code>trapframe</code> 映射到用户地址空间中</p>
</li>
<li><p>当创建每个进程时，xv6 为进程的 <code>trapframe</code> 分配一页内存，并将它映射在用户虚拟地址 <code>TRAPFRAME</code>，也就是 <code>TRAMPOLINE</code> 的下面</p>
</li>
<li><p>进程的 <code>p-&gt;trapframe</code> 也指向 <code>trapframe</code>，不过是指向它的物理地址[<a href="#_ftn1">1]</a>，这样内核可以通过内核页表来使用它</p>
</li>
</ul>
</li>
<li><p>因此，在交换 <code>a0</code> 和 <code>sscratch</code> 后，<code>a0</code> 将指向当前进程的 <code>trapframe</code></p>
<ul>
<li><code>uservec</code> 将在 <code>trapframe</code> 保存全部的寄存器，包括从 <code>sscratch</code> 读取的 <code>a0</code></li>
</ul>
</li>
<li><p><code>trapframe</code> 包含指向当前进程的内核栈、当前 CPU 的 hartid、<code>usertrap</code> 的地址和内核页表的地址的指针，<code>uservec</code> 将这些值设置到相应的寄存器中，并将 <code>satp</code> 切换到内核页表和刷新 TLB，然后调用 <code>usertrap</code></p>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">     # trap.c sets stvec to point here, so	trap.c设置的stvec指向这里</span><br><span class="line">     # traps from user space start here,		所以来自用户空间的陷阱从这里开始</span><br><span class="line">     # in supervisor mode, but with a		在监督者模式，但是有一个用户页表</span><br><span class="line">     # user page table.</span><br><span class="line">     #</span><br><span class="line"></span><br><span class="line">     # save user a0 in sscratch so			保存用户a0到sscratch以便a0可以被使用去到达TRAPFRAME</span><br><span class="line">     # a0 can be used to get at TRAPFRAME.</span><br><span class="line">     csrw sscratch, a0</span><br><span class="line"></span><br><span class="line">		# trap frame 陷阱帧，用于保存当前进程的重要信息</span><br><span class="line">     # each process has a separate p-&gt;trapframe memory area,	每个进程都有一个独立的p-&gt;trapframe内存区域</span><br><span class="line">     # but it&#x27;s mapped to the same virtual address			但是被映射到相同的虚拟地址</span><br><span class="line">     # (TRAPFRAME) in every process&#x27;s user page table.		（TRAPFRAME）在每个进程的用户页表中</span><br><span class="line">     li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">     # save the user registers in TRAPFRAME		保存用户寄存器在TRAPFRAME</span><br><span class="line">     sd ra, 40(a0)</span><br><span class="line">     sd sp, 48(a0)</span><br><span class="line">     sd gp, 56(a0)</span><br><span class="line">     sd tp, 64(a0)</span><br><span class="line">     sd t0, 72(a0)</span><br><span class="line">     sd t1, 80(a0)</span><br><span class="line">     sd t2, 88(a0)</span><br><span class="line">     sd s0, 96(a0)</span><br><span class="line">     sd s1, 104(a0)</span><br><span class="line">     sd a1, 120(a0)</span><br><span class="line">     sd a2, 128(a0)</span><br><span class="line">     sd a3, 136(a0)</span><br><span class="line">     sd a4, 144(a0)</span><br><span class="line">     sd a5, 152(a0)</span><br><span class="line">     sd a6, 160(a0)</span><br><span class="line">     sd a7, 168(a0)</span><br><span class="line">     sd s2, 176(a0)</span><br><span class="line">     sd s3, 184(a0)</span><br><span class="line">     sd s4, 192(a0)</span><br><span class="line">     sd s5, 200(a0)</span><br><span class="line">     sd s6, 208(a0)</span><br><span class="line">     sd s7, 216(a0)</span><br><span class="line">     sd s8, 224(a0)</span><br><span class="line">     sd s9, 232(a0)</span><br><span class="line">     sd s10, 240(a0)</span><br><span class="line">     sd s11, 248(a0)</span><br><span class="line">     sd t3, 256(a0)</span><br><span class="line">     sd t4, 264(a0)</span><br><span class="line">     sd t5, 272(a0)</span><br><span class="line">     sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# save the user a0 in p-&gt;trapframe-&gt;a0	保存用户a0在p-&gt;trapframe-&gt;a0</span><br><span class="line">     csrr t0, sscratch</span><br><span class="line">     sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">     # initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">     # 从 p-&gt;trapframe-&gt;kernel_sp 初始化内核栈指针</span><br><span class="line">     ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">     # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid </span><br><span class="line">     ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">     # load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap	初始化usertrap()的地址</span><br><span class="line">     ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">     # fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.	</span><br><span class="line">     # 从 p-&gt;trapframe-&gt;kernel_satp 获取内核页表地址</span><br><span class="line">     ld t1, 0(a0)</span><br><span class="line"></span><br><span class="line">     # wait for any previous memory operations to complete, so that</span><br><span class="line">     # they use the user page table.</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">     # install the kernel page table.	切换到内核页表</span><br><span class="line">     csrw satp, t1</span><br><span class="line"></span><br><span class="line">     # flush now-stale user entries from the TLB. 刷新TLB</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">     # jump to usertrap(), which does not return	跳转到usertrap()</span><br><span class="line">     jr t0</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">truct trapframe &#123;</span><br><span class="line"><span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table	</span></span><br><span class="line"><span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line"><span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line"><span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line"><span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line"><span class="comment">/*  40 */</span> uint64 ra;			  <span class="comment">// 上面这些与内核有关的寄存器在usertrapret返回到trampoline.S之前已经被设置</span></span><br><span class="line"><span class="comment">/*  48 */</span> uint64 sp;			  <span class="comment">// 需要注意的是：用户的a0和trapframe中的a0是不一样的</span></span><br><span class="line"><span class="comment">/*  56 */</span> uint64 gp;			  <span class="comment">// trapframe中的a0会被系统调用的返回值覆盖，返回到用户空间之前有被交换到a0</span></span><br><span class="line"><span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line"><span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line"><span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line"><span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line"><span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line"><span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line"><span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line"><span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line"><span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line"><span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line"><span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line"><span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line"><span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line"><span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line"><span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line"><span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line"><span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line"><span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line"><span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line"><span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line"><span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line"><span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line"><span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line"><span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line"><span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line"><span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line"><span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line"><span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>usertrap</code> 的作用是确定 trap 的原因，处理它，然后返回（kernel&#x2F; trap.c:37）</p>
<ul>
<li>如上所述，它首先改变 <code>stvec</code>，这样在内核中发生的 trap 将由 <code>kernelvec</code> 处理</li>
<li>它保存了 <code>sepc</code>（用户PC），这也是因为 <code>usertrap</code> 中可能会有一个进程切换，导致 <code>sepc</code> 被覆盖</li>
<li>如果 trap 是系统调用，<code>syscall</code> 会处理它；如果是设备中断，<code>devintr</code> 会处理；否则就是异常，内核会杀死故障进程</li>
<li><code>usertrap</code> 会把用户 <code>pc</code> 加 4，因为 RISC-V 在执行系统调用时，会留下指向 <code>ecall</code> 指令的程序指针<a href="#ftn2">[2]</a></li>
<li>在退出时，<code>usertrap</code> 检查进程是否已经被杀死或应该让出 CPU（如果这个 trap 是一个定时器中断）</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.  </span></span><br><span class="line"><span class="comment">// 处理一个来自用户空间的中断，异常，或系统调用</span></span><br><span class="line"><span class="comment">// called from trampoline.S   来自于trampoline.S的调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// send interrupts and exceptions to kerneltrap(), </span></span><br><span class="line"><span class="comment">// 因为我们现在处于内核中，将中断和异常发送到 kerneltrap() 函数处理</span></span><br><span class="line"><span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">w_stvec((uint64)kernelvec);	</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// save user program counter. 保存用户的程序计数器</span></span><br><span class="line">p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line"> <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(killed(p))</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// sepc points to the ecall instruction,  spec 指向ecall指令，但我们想要返回下一条指令</span></span><br><span class="line"> <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line"> p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// an interrupt will change sepc, scause, and sstatus, </span></span><br><span class="line"> <span class="comment">// 中断会改变 sepc、scause 和 sstatus 寄存器的值，所以只有在处理完这些寄存器之后，我们才启用中断</span></span><br><span class="line"> <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line"> intr_on(); <span class="comment">// 所以中断打开仅在处理syscall()时，从用户空间触发的中断是不允许嵌套的</span></span><br><span class="line"></span><br><span class="line"> syscall();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line"> <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line"> setkilled(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(killed(p))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line"> yield();</span><br><span class="line"></span><br><span class="line">usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>回到用户空间的第一步是调用 <code>usertrapret</code>（kernel&#x2F;trap.c:90）</p>
<ul>
<li><p>这个函数设置 RISC-V 控制寄存器，为以后用户空间 trap 做准备</p>
</li>
<li><p>这包括改变 <code>stvec</code> 来引用 <code>uservec</code>，准备 <code>uservec</code> 所依赖的 <code>trapframe</code> 字段，并将 <code>sepc</code> 设置为先前保存的用户程序计数器</p>
</li>
<li><p>最后，<code>usertrapret</code> 在用户页表和内核页表中映射的 trampoline 页上调用 <code>userret</code>，因为 <code>userret</code> 中的汇编代码会切换页表。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space 返回到用户空间</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// we&#x27;re about to switch the destination of traps from      </span></span><br><span class="line"><span class="comment">// 我们即将把陷阱（trap）的目的地从 kerneltrap() 切换到 usertrap()</span></span><br><span class="line"><span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until </span></span><br><span class="line"><span class="comment">// 所以在回到用户空间之前，先关闭中断直到返回到用户空间</span></span><br><span class="line"><span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">intr_off();</span><br><span class="line"></span><br><span class="line"><span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S </span></span><br><span class="line"><span class="comment">// 在trampoline.S中发送系统调用，中断，异常给uservec</span></span><br><span class="line">uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">w_stvec(trampoline_uservec);	<span class="comment">// 所以这里是在设置stvec为trampoline中的uservec，为下一次trap做准备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set up trapframe values that uservec will need when  </span></span><br><span class="line"><span class="comment">// 设置uservec将会需要的trapframe的值，当进程下一次陷入到内核中时</span></span><br><span class="line"><span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set up the registers that trampoline.S&#x27;s sret will use </span></span><br><span class="line"><span class="comment">// 设置寄存器，trampoline.S的sret将会使用去返回到用户空间</span></span><br><span class="line"><span class="comment">// to get to user space.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set S Previous Privilege mode to User. 模式置为用户模式，其实是设置返回到用户空间时的模式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode	这里设置返回后为用户模式</span></span><br><span class="line">x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode	且打开中断在用户模式中</span></span><br><span class="line">w_sstatus(x);	<span class="comment">// 是更新相关寄存器操作吗</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set S Exception Program Counter to the saved user pc. 设置sepc寄存器为epc，也就是epc+4</span></span><br><span class="line">w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tell trampoline.S the user page table to switch to.  告诉trampoline.S需要转换的用户页表</span></span><br><span class="line">uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line"><span class="comment">// 跳转到 trampoline.S 中的 userret，它位于内存顶部</span></span><br><span class="line"><span class="comment">// switches to the user page table, restores user registers, 用于切换到用户页表，恢复用户寄存器</span></span><br><span class="line"><span class="comment">// and switches to user mode with sret. 并使用 sret 指令切换到用户模式</span></span><br><span class="line">uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>usertrapret</code> 对 <code>userret</code> 的调用传递了参数 <code>a0</code>，<code>a1</code>， <code>a0</code> 指向 <code>TRAPFRAME</code>，<code>a1</code> 指向用户进程页表（kernel&#x2F;trampoline.S:88），<code>userret</code> 将 <code>satp</code> 切换到进程的用户页表</p>
<blockquote>
<p>可能由于版本不同了吧，这里只有一个参数，且 a0 指向的是用户进程页表</p>
</blockquote>
<ul>
<li>回想一下，用户页表同时映射了 trampoline 页和 <code>TRAPFRAME</code>，但没有映射内核的其他内容</li>
<li>同样，事实上，在用户页表和内核页表中，trampoline 页被映射在相同的虚拟地址上，这也是允许 <code>uservec</code> 在改变 <code>satp</code> 后继续执行的原因</li>
<li><code>userret</code> 将 <code>trapframe</code> 中保存的用户 <code>a0</code> 复制到 <code>sscratch</code> 中，为以后与 <code>TRAPFRAME</code> 交换做准备</li>
<li>从这时开始，<code>userret</code> 能使用的数据只有寄存器内容和 <code>trapframe</code> 的内容</li>
<li>接下来 <code>userret</code> 从 trapframe 中恢复保存的用户寄存器，对 <code>a0</code> 和 <code>sscratch</code> 做最后的交换，恢复用户 <code>a0</code> 并保存<code>TRAPFRAME</code>，为下一次 trap 做准备，并使用 <code>sret</code> 返回用户空间</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">userret:</span><br><span class="line">     # userret(pagetable)</span><br><span class="line">     # called by usertrapret() in trap.c to	被trap.c中的usertrapret()调用从内核返回到用户空间</span><br><span class="line">     # switch from kernel to user.</span><br><span class="line">     # a0: user page table, for satp.	</span><br><span class="line"></span><br><span class="line">     # switch to the user page table.</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line">     csrw satp, a0				# 好像被简化了，和之前的版本不一样，之前返回两个参数a0是trapframe，a1才是satp</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">     li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">     # restore all but a0 from TRAPFRAME</span><br><span class="line">     ld ra, 40(a0)</span><br><span class="line">     ld sp, 48(a0)</span><br><span class="line">     ld gp, 56(a0)</span><br><span class="line">     ld tp, 64(a0)</span><br><span class="line">     ld t0, 72(a0)</span><br><span class="line">     ld t1, 80(a0)</span><br><span class="line">     ld t2, 88(a0)</span><br><span class="line">     ld s0, 96(a0)</span><br><span class="line">     ld s1, 104(a0)</span><br><span class="line">     ld a1, 120(a0)</span><br><span class="line">     ld a2, 128(a0)</span><br><span class="line">     ld a3, 136(a0)</span><br><span class="line">     ld a4, 144(a0)</span><br><span class="line">     ld a5, 152(a0)</span><br><span class="line">     ld a6, 160(a0)</span><br><span class="line">     ld a7, 168(a0)</span><br><span class="line">     ld s2, 176(a0)</span><br><span class="line">     ld s3, 184(a0)</span><br><span class="line">     ld s4, 192(a0)</span><br><span class="line">     ld s5, 200(a0)</span><br><span class="line">     ld s6, 208(a0)</span><br><span class="line">     ld s7, 216(a0)</span><br><span class="line">     ld s8, 224(a0)</span><br><span class="line">     ld s9, 232(a0)</span><br><span class="line">     ld s10, 240(a0)</span><br><span class="line">     ld s11, 248(a0)</span><br><span class="line">     ld t3, 256(a0)</span><br><span class="line">     ld t4, 264(a0)</span><br><span class="line">     ld t5, 272(a0)</span><br><span class="line">     ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0</span><br><span class="line">     ld a0, 112(a0)</span><br><span class="line"></span><br><span class="line">     # return to user mode and user pc.</span><br><span class="line">     # usertrapret() set up sstatus and sepc.</span><br><span class="line">     sret</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Code-Calling-system-calls-调用系统调用"><a href="#Code-Calling-system-calls-调用系统调用" class="headerlink" title="Code: Calling system calls 调用系统调用"></a>Code: Calling system calls 调用系统调用</h2><ul>
<li>第 2 章以 <code>initcode.S</code> 调用 <code>exec</code> 系统调用结束（user&#x2F;initcode.S:11）<ul>
<li>让我们来看看用户调用是如何在内核中实现 <code>exec</code> 系统调用的</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  la a0, init</span><br><span class="line">  la a1, argv</span><br><span class="line">     li a7, SYS_exec</span><br><span class="line">     ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">  li a7, SYS_exit</span><br><span class="line">  ecall</span><br><span class="line">     jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">.string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">.long init</span><br><span class="line">.long 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>用户代码将 <code>exec</code> 的参数放在寄存器 <code>a0</code> 和 <code>a1</code> 中，并将系统调用号放在 <code>a7</code> 中。系统调用号与函数指针表 <code>syscalls</code> 数组（kernel&#x2F;syscall.c:108）中的项匹配<ul>
<li><code>ecall</code> 指令进入内核，执行 <code>uservec</code>、<code>usertrap</code>，然后执行 <code>syscall</code>，就像我们上面看到的那样</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An array mapping syscall numbers from syscall.h</span></span><br><span class="line"><span class="comment">// to the function that handles the system call.</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>syscall</code>（kernel&#x2F;syscall.c:133）从 trapframe 中的 <code>a7</code> 中得到系统调用号，并其作为索引在 <code>syscalls</code> 查找相应函数<ul>
<li>对于第一个系统调用 <code>exec</code>，<code>a7</code> 将为 <code>SYS_exec</code>（kernel&#x2F;syscall.h:8），这会让 <code>syscall</code> 调用 <code>exec</code> 的实现函数 <code>sys_exec</code></li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">num = p-&gt;trapframe-&gt;a7;</span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line"><span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line"><span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line"> p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">        p-&gt;pid, p-&gt;name, num);</span><br><span class="line"> p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>当系统调用函数返回时，<code>syscall</code> 将其返回值记录在 <code>p-&gt;trapframe-&gt;a0</code> 中<ul>
<li>用户空间的 <code>exec()</code> 将会返回该值，因为 RISC-V 上的 C 调用通常将返回值放在 <code>a0</code> 中</li>
<li>系统调用返回负数表示错误，0 或正数表示成功</li>
<li>如果系统调用号无效，<code>syscall</code> 会打印错误并返回 -1</li>
</ul>
</li>
</ul>
<h2 id="Code-System-call-arguments-系统调用参数"><a href="#Code-System-call-arguments-系统调用参数" class="headerlink" title="Code: System call arguments 系统调用参数"></a>Code: System call arguments 系统调用参数</h2><ul>
<li>内核的系统调用实现需要找到用户代码传递的参数<ul>
<li>因为用户代码调用系统调用的包装函数，参数首先会存放在寄存器中，这是 C 语言存放参数的惯例位置</li>
<li>内核 trap 代码将用户寄存器保存到当前进程的 trap frame 中，内核代码可以在那里找到它们</li>
<li>函数 <code>argint</code>、<code>argaddr</code> 和 <code>argfd</code> 从 trap frame 中以整数、指针或文件描述符的形式检索第 n 个系统调用参数</li>
<li>它们都调用 <code>argraw</code> 来获取保存的用户寄存器（kernel&#x2F;syscall.c:35）</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="keyword">switch</span> (n) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">&#125;</span><br><span class="line">panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>一些系统调用传递指针作为参数，而内核必须使用这些指针来读取或写入用户内存</p>
<ul>
<li>例如，<code>exec</code> 系统调用会向内核传递一个指向用户空间中的字符串的指针数组</li>
<li>这些指针带来了两个挑战</li>
<li>首先，用户程序可能是错误的或恶意的，可能会传递给内核一个无效的指针或一个旨在欺骗内核访问内核内存而不是用户内存的指针</li>
<li>第二，xv6 内核页表映射与用户页表映射不一样，所以内核不能使用普通指令从用户提供的地址加载或存储</li>
</ul>
</li>
<li><p>内核实现了安全地将数据复制到用户提供的地址或从用户提供的地址复制数据的函数</p>
<ul>
<li>例如 <code>fetchstr</code>（kernel&#x2F;syscall.c:25）</li>
<li>文件系统调用，如 <code>exec</code>，使用 <code>fetchstr</code> 从用户空间中检索字符串文件名参数</li>
<li><code>fetchstr</code> 调用 <code>copyinstr</code> 来做这些困难的工作</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nul-terminated string at addr from the current process.</span></span><br><span class="line"><span class="comment">// 在当前进程中的addr处，获得以null结尾的字符串</span></span><br><span class="line"><span class="comment">// Returns length of string, not including nul, or -1 for error.</span></span><br><span class="line"><span class="comment">// 返回字符串的长度，不包括null，-1表示error</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fetchstr</span><span class="params">(uint64 addr, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="keyword">if</span>(copyinstr(p-&gt;pagetable, buf, addr, max) &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>copyinstr</code>（kernel&#x2F;vm.c:406）将用户页表 <code>pagetable</code> 中的虚拟地址 <code>srcva</code> 复制到 <code>dst</code>，需指定最大复制字节数<ul>
<li>它使用 <code>walkaddr</code>（调用 <code>walk</code> 函数）在软件中模拟分页硬件的操作，以确定 <code>srcva</code> 的物理地址 <code>pa0</code></li>
<li><code>walkaddr</code>（kernel&#x2F;vm.c:109）检查用户提供的虚拟地址是否是进程用户地址空间的一部分，所以程序不能欺骗内核读取其他内存</li>
<li>类似的函数 <code>copyout</code>，可以将数据从内核复制到用户提供的地址</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.	复制以null结尾的字符串从用户空间到内核</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,	</span></span><br><span class="line"><span class="comment">// 复制字节从srcva虚拟地址到dst，在一个给定的页表中</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.	知道遇到 /0 或已经达到max</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.	返回0表示成功，-1</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 n, va0, pa0;</span><br><span class="line"><span class="type">int</span> got_null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">va0 = PGROUNDDOWN(srcva); <span class="comment">// #define PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1)) 作用是将srcva页对齐</span></span><br><span class="line">pa0 = walkaddr(pagetable, va0);</span><br><span class="line"><span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">n = PGSIZE - (srcva - va0);	<span class="comment">// 可以保证每次都处理一个页</span></span><br><span class="line"><span class="keyword">if</span>(n &gt; max)</span><br><span class="line">n = max;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *) (pa0 + (srcva - va0));`<span class="comment">// 得到srcva对应的物理地址</span></span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;	</span><br><span class="line"><span class="keyword">if</span>(*p == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">  *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  got_null = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  *dst = *p;</span><br><span class="line">&#125;</span><br><span class="line">--n;</span><br><span class="line">--max;</span><br><span class="line">p++;</span><br><span class="line">dst++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srcva = va0 + PGSIZE; <span class="comment">// 更新 srcva</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(got_null)&#123;	<span class="comment">// 检查是否遇到了/0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up a virtual address, return the physical address, 查找一个虚拟地址，返回物理地址</span></span><br><span class="line"><span class="comment">// or 0 if not mapped.	返回0表示没有映射</span></span><br><span class="line"><span class="comment">// Can only be used to look up user pages.	仅可以用于查找用户页面</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line">uint64 pa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pa = PTE2PA(*pte);</span><br><span class="line"><span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.  从内核复制到用户空间</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table. </span></span><br><span class="line"><span class="comment">// 从 src 复制 len 字节到给定页表中的虚拟地址 dstva</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.  成功时返回 0，错误时返回 -1</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 n, va0, pa0;</span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">va0 = PGROUNDDOWN(dstva);	<span class="comment">// 页对齐，不大于dstva且是PGSIZE的倍数</span></span><br><span class="line"><span class="keyword">if</span>(va0 &gt;= MAXVA)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> ||</span><br><span class="line"> (*pte &amp; PTE_W) == <span class="number">0</span>) <span class="comment">// pte没有找到 || 不是有效的 || 用户不可访问 || 不可写</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">pa0 = PTE2PA(*pte);	<span class="comment">// 这里是合理的，因为我们已经保证了va0是页对齐的了</span></span><br><span class="line">n = PGSIZE - (dstva - va0);	<span class="comment">// 保证每次处理一页</span></span><br><span class="line"><span class="keyword">if</span>(n &gt; len)</span><br><span class="line">n = len;</span><br><span class="line">memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);	<span class="comment">// 从src复制n个字节到dstva对应的物理地址</span></span><br><span class="line"></span><br><span class="line">len -= n;	<span class="comment">// 更新</span></span><br><span class="line">src += n;</span><br><span class="line">dstva = va0 + PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Traps-from-kernel-space-从内核空间触发的陷阱"><a href="#Traps-from-kernel-space-从内核空间触发的陷阱" class="headerlink" title="Traps from kernel space 从内核空间触发的陷阱"></a>Traps from kernel space 从内核空间触发的陷阱</h2><ul>
<li><p>xv6 根据用户还是内核代码正在执行，对 CPU 陷阱寄存器的配置略有不同行为</p>
<ul>
<li>当内核在 CPU 上执行时，内核将 <code>stvec</code> 指向 <code>kernelvec</code> 上的汇编代码（kernel&#x2F;kernelvec.S:10）</li>
<li>由于 xv6 已经在内核中，<code>kernelvec</code> 可以使用 <code>satp</code>，将其设置为内核页表，以及引用有效内核的堆栈指针</li>
<li><code>kernelvec</code> 保存所有寄存器，以便中断的代码最后可以在没有中断的情况下恢复</li>
</ul>
</li>
<li><p><code>kernelvec</code> 将寄存器保存在中断内核线程的堆栈上，因为寄存器值属于该线程，这是合理的</p>
<ul>
<li>如果 trap 导致切换到另一个线程—在这种情况下，trap 将实际返回到新线程的栈上，将中断线程保存的寄存器安全地保留在其堆栈上</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">kernelvec:</span><br><span class="line">     # make room to save registers.</span><br><span class="line">     addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">     # save the registers.</span><br><span class="line">     sd ra, 0(sp)</span><br><span class="line">     sd sp, 8(sp)</span><br><span class="line">     sd gp, 16(sp)</span><br><span class="line">     sd tp, 24(sp)</span><br><span class="line">     sd t0, 32(sp)</span><br><span class="line">     sd t1, 40(sp)</span><br><span class="line">     sd t2, 48(sp)</span><br><span class="line">     sd s0, 56(sp)</span><br><span class="line">     sd s1, 64(sp)</span><br><span class="line">     sd a0, 72(sp)</span><br><span class="line">     sd a1, 80(sp)</span><br><span class="line">     sd a2, 88(sp)</span><br><span class="line">     sd a3, 96(sp)</span><br><span class="line">     sd a4, 104(sp)</span><br><span class="line">     sd a5, 112(sp)</span><br><span class="line">     sd a6, 120(sp)</span><br><span class="line">     sd a7, 128(sp)</span><br><span class="line">     sd s2, 136(sp)</span><br><span class="line">     sd s3, 144(sp)</span><br><span class="line">     sd s4, 152(sp)</span><br><span class="line">     sd s5, 160(sp)</span><br><span class="line">     sd s6, 168(sp)</span><br><span class="line">     sd s7, 176(sp)</span><br><span class="line">     sd s8, 184(sp)</span><br><span class="line">     sd s9, 192(sp)</span><br><span class="line">     sd s10, 200(sp)</span><br><span class="line">     sd s11, 208(sp)</span><br><span class="line">     sd t3, 216(sp)</span><br><span class="line">     sd t4, 224(sp)</span><br><span class="line">     sd t5, 232(sp)</span><br><span class="line">     sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">     # call the C trap handler in trap.c</span><br><span class="line">     call kerneltrap</span><br><span class="line"></span><br><span class="line">     # restore registers.</span><br><span class="line">     ld ra, 0(sp)</span><br><span class="line">     ld sp, 8(sp)</span><br><span class="line">     ld gp, 16(sp)</span><br><span class="line">     # not tp (contains hartid), in case we moved CPUs</span><br><span class="line">     ld t0, 32(sp)</span><br><span class="line">     ld t1, 40(sp)</span><br><span class="line">     ld t2, 48(sp)</span><br><span class="line">     ld s0, 56(sp)</span><br><span class="line">     ld s1, 64(sp)</span><br><span class="line">     ld a0, 72(sp)</span><br><span class="line">     ld a1, 80(sp)</span><br><span class="line">     ld a2, 88(sp)</span><br><span class="line">     ld a3, 96(sp)</span><br><span class="line">     ld a4, 104(sp)</span><br><span class="line">     ld a5, 112(sp)</span><br><span class="line">     ld a6, 120(sp)</span><br><span class="line">     ld a7, 128(sp)</span><br><span class="line">     ld s2, 136(sp)</span><br><span class="line">     ld s3, 144(sp)</span><br><span class="line">     ld s4, 152(sp)</span><br><span class="line">     ld s5, 160(sp)</span><br><span class="line">     ld s6, 168(sp)</span><br><span class="line">     ld s7, 176(sp)</span><br><span class="line">     ld s8, 184(sp)</span><br><span class="line">     ld s9, 192(sp)</span><br><span class="line">     ld s10, 200(sp)</span><br><span class="line">     ld s11, 208(sp)</span><br><span class="line">     ld t3, 216(sp)</span><br><span class="line">     ld t4, 224(sp)</span><br><span class="line">     ld t5, 232(sp)</span><br><span class="line">     ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">     addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">     # return to whatever we were doing in the kernel.</span><br><span class="line">     sret</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>kernelvec</code> 在保存寄存器后跳转到 <code>kerneltrap</code>（kernel&#x2F;trap.c:134）</p>
<ul>
<li><code>kerneltrap</code> 是为两种类型的陷阱准备的：设备中断和异常	</li>
<li>它调用 <code>devintr</code>（kernel&#x2F;trap.c:177）来检查和处理前者</li>
<li>如果 trap 不是设备中断，那么它必须是异常，如果它发生在 xv6 内核中，则一定是一个致命错误；内核调用 <code>panic</code> 并停止执行</li>
</ul>
</li>
<li><p>如果由于计时器中断而调用了 <code>kerneltrap</code>，并且进程的内核线程正在运行（而不是调度程序线程），<code>kerneltrap</code> 调用 <code>yield</code> 让出 CPU，允许其他线程运行</p>
<ul>
<li>在某个时刻，其中一个线程将退出，并让我们的线程及其 <code>kerneltrap</code> 恢复</li>
<li>第 7 章解释了线程让出 CPU 控制权</li>
</ul>
</li>
<li><p>当 <code>kerneltrap</code> 的工作完成时，它需要返回到被中断的代码</p>
<ul>
<li>因为 <code>yield</code> 可能破坏保存的 <code>sepc</code> 和在 <code>sstatus</code> 中保存的之前的模式</li>
<li><code>kerneltrap</code> 在启动时保存它们。它现在恢复那些控制寄存器并返回到 <code>kernelvec</code>（kernel&#x2F;kernelvec.S:48）</li>
<li><code>kernelvec</code> 从堆栈恢复保存的寄存器并执行 <code>sret</code>，<code>sret</code> 将 <code>sepc</code> 复制到 <code>pc</code> 并恢复中断的内核代码</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,  </span></span><br><span class="line"><span class="comment">// 中断和异常从内核代码产生时，会通过 kernelvec 到达</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is. 无论当前的内核栈是什么</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">uint64 sepc = r_sepc(); <span class="comment">// 保存一些可能被修改的寄存器</span></span><br><span class="line">uint64 sstatus = r_sstatus();</span><br><span class="line">uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)  <span class="comment">// 如果是来自于用户模式，那太糟糕了</span></span><br><span class="line"> panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);  <span class="comment">// 此时中断不能打开</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;	<span class="comment">// 如果不是设备中断，只能是异常了</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line"> panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.  放弃CPU如果这是一个时钟中断</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line"> yield();</span><br><span class="line"></span><br><span class="line"><span class="comment">// the yield() may have caused some traps to occur, yield()可能造成一些陷阱的发生</span></span><br><span class="line"><span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction. </span></span><br><span class="line"><span class="comment">// 恢复陷阱寄存器以供kernelvec.S中的spec指令使用</span></span><br><span class="line">w_sepc(sepc);</span><br><span class="line">w_sstatus(sstatus);	<span class="comment">// 恢复这些可能被修改的寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>可以思考一下，如果因为时间中断，<code>kerneltrap</code> 调用了 <code>yield</code>，trap return 是如何发生的</p>
</li>
<li><p>当 CPU 从用户空间进入内核时，xv6 将 CPU 的 <code>stvec</code> 设置为 <code>kernelvec</code>；可以在 <code>usertrap</code>（kernel&#x2F;trap.c:29）中看到这一点</p>
<ul>
<li>内核运行但 <code>stvec</code> 被设置为 <code>uservec</code> 时，这期间有一个时间窗口，在这个窗口期，禁用设备中断是至关重要的</li>
<li>幸运的是，RISC-V 总是在开始使用 trap 时禁用中断，xv6 在设置 <code>stvec</code> 之前不会再次启用它们</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果不知道去哪里找到想要的函数，<code>kernel/defs.h</code> 是一个很好的选择</p>
</blockquote>
<h2 id="Page-fault-exceptions-缺页异常"><a href="#Page-fault-exceptions-缺页异常" class="headerlink" title="Page-fault exceptions 缺页异常"></a>Page-fault exceptions 缺页异常</h2><ul>
<li><p>xv6 对异常的响应是相当固定：如果一个异常发生在用户空间，内核就会杀死故障进程</p>
<ul>
<li>如果一个异常发生在内核中，内核就会 <strong>panic</strong>。真正的操作系统通常会以更有趣的方式进行响应</li>
</ul>
</li>
<li><p>举个例子，许多内核使用页面故障来实现 <strong>写时复制（copy-on-write，cow）fork</strong></p>
<ul>
<li>要解释写时复制 fork，可以想一想 xv6 的 <code>fork</code>，在第 3 章中介绍过</li>
<li><code>fork</code> 通过调用 <code>uvmcopy</code>（kernel&#x2F;vm.c:309）为子进程分配物理内存，并将父进程的内存复制到子程序中，使子进程拥有与父进程相同的内存内容</li>
<li>如果子进程和父进程能够共享父进程的物理内存，效率会更高。然而，直接实现这种方法是行不通的，因为父进程和子进程对共享栈和堆的写入会中断彼此的执行</li>
</ul>
</li>
<li><p>通过使用写时复制 fork，可以让父进程和子进程安全地共享物理内存，通过页面故障来实现</p>
<ul>
<li>当 CPU 不能将虚拟地址翻译成物理地址时，CPU 会产生一个页面故障异常（page-fault exception）</li>
<li>RISC-V 有三种不同的页故障：load 页故障（当加载指令不能翻译其虚拟地址时）、stote 页故障（当存储指令不能翻译其虚拟地址时）和指令页故障（当指令的地址不能翻译时）</li>
<li><code>scause</code> 寄存器中的值表示页面故障的类型，<code>stval</code> 寄存器中包含无法翻译的地址</li>
</ul>
</li>
<li><p><strong>COW</strong> fork 中的基本设计是父进程和子进程最初共享所有的物理页面，但将它们映射设置为只读</p>
<ul>
<li>因此，当子进程或父进程执行 store 指令时，RISC-V CPU 会引发一个页面故障异常</li>
<li>作为对这个异常的响应，内核会拷贝一份包含故障地址的页。然后将一个副本的读&#x2F;写映射在子进程地址空间，另一个副本的读&#x2F;写映射在父进程地址空间</li>
<li>更新页表后，内核在引起故障的指令处恢复故障处理</li>
<li>因为内核已经更新了相关的 PTE，允许写入，所以现在故障指令将正常执行</li>
</ul>
</li>
<li><p>这个 COW 设计对 <code>fork</code> 很有效，因为往往子程序在 fork 后立即调用 exec，用新的地址空间替换其地址空间</p>
<ul>
<li>在这种常见的情况下，子程序只会遇到一些页面故障，而内核可以避免进行完整的复制</li>
<li>此外，COW fork 是透明的：不需要对应用程序进行修改，应用程序就能受益</li>
</ul>
</li>
<li><p>页表和页故障的结合，将会有更多种有趣的可能性的应用</p>
<ul>
<li>另一个被广泛使用的特性叫做 **懒分配 (lazy allocation)**，它有两个部分</li>
<li>首先，当一个应用程序调用 <code>sbrk</code> 时，内核会增长地址空间，但在页表中把新的地址标记为无效</li>
<li>第二，当这些新地址中的一个出现页面故障时，内核分配物理内存并将其映射到页表中</li>
<li>由于应用程序经常要求获得比他们需要的更多的内存，所以懒分配是一个胜利：内核只在应用程序实际使用时才分配内存</li>
<li>像 COW fork 一样，内核可以对应用程序透明地实现这个功能</li>
</ul>
</li>
<li><p>另一个被广泛使用的利用页面故障的功能是从 <strong>磁盘上分页(paging from disk)</strong></p>
<ul>
<li>如果应用程序需要的内存超过了可用的物理 RAM，内核可以交换出一些页：将它们写入一个存储设备，比如磁盘，并将其 PTE 标记为无效</li>
<li>如果一个应用程序读取或写入一个被换出到磁盘的页，CPU 将遇到一个页面故障。内核就可以检查故障地址</li>
<li>如果该地址属于磁盘上的页面，内核就会分配一个物理内存的页面，从磁盘上读取页面到该内存，更新 PTE 为有效并引用该内存，然后恢复应用程序</li>
<li>为了给该页腾出空间，内核可能要交换另一个页</li>
<li>这个特性不需要对应用程序进行任何修改，如果应用程序具有引用的位置性（即它们在任何时候都只使用其内存的一个子集），这个特性就能很好地发挥作用</li>
</ul>
</li>
<li><p>其他结合分页和分页错误异常的功能包括自动扩展堆栈和内存映射文件</p>
</li>
</ul>
<h2 id="Real-world-现实情况"><a href="#Real-world-现实情况" class="headerlink" title="Real world 现实情况"></a>Real world 现实情况</h2><ul>
<li>如果将内核内存映射到每个进程的用户页表中（使用适当的 PTE 权限标志），就不需要特殊的 trampoline 页了<ul>
<li>这也将消除从用户空间 trap 进入内核时对页表切换的需求</li>
<li>这也可以让内核中的系统调用实现利用当前进程的用户内存被映射的优势，让内核代码直接去间接引用（对地址取值）用户指针</li>
<li>许多操作系统已经使用这些想法来提高效率</li>
<li>xv6 没有实现这些想法，以减少由于无意使用用户指针而导致内核出现安全漏洞的机会，并减少一些复杂性，以确保用户和内核虚拟地址不重叠</li>
</ul>
</li>
</ul>
<h2 id="Exercises-练习"><a href="#Exercises-练习" class="headerlink" title="Exercises 练习"></a>Exercises 练习</h2><ul>
<li><p>函数 <code>copyin</code> 和 <code>copyinstr</code> 在软件中 walk 用户页表。设置内核页表，使内核拥有用户程序的内存映射，<code>copyin</code> 和 <code>copyinstr</code> 可以使用 <code>memcpy</code> 将系统调用参数复制到内核空间，依靠硬件来完成页表的 walk</p>
</li>
<li><p>实现内存的懒分配</p>
</li>
<li><p>实现写时复制 fork</p>
</li>
</ul>
<hr>
<ol>
<li><p><a name="ftn1"></a>内核中物理地址和虚拟地址时直接映射的，所以可以在启用分页时，通过物理地址访问。</p>
</li>
<li><p><a name="ftn2"></a>执行系统调用时，进程的pc会指向ecall指令，这里需要加4清除，因为进程栈的地址空间是从高到低。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/03/6-S081-Lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/03/6-S081-Lab3/" class="post-title-link" itemprop="url">Lab Page tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-03 15:35:24" itemprop="dateCreated datePublished" datetime="2024-06-03T15:35:24+08:00">2024-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-04 17:44:13" itemprop="dateModified" datetime="2024-06-04T17:44:13+08:00">2024-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>实验讲义：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/labs/pgtbl.html">Lab: page tables (mit.edu)</a></p>
</li>
<li><p>在这个实验中，你将探索页表并对其进行修改，以加快某些系统调用的速度，并检测那些页面已被访问</p>
</li>
<li><p>开始编码前，请阅读：xv6 book 第 3 章和相关文件：</p>
<ul>
<li><code>kernel/memlayout.h</code>，它捕获了内存布局</li>
<li><code>kernel/vm.c</code>，包含大多数虚拟内存的代码</li>
<li><code>kernel/kalloc.c</code>，包含用于分配和释放物理内存的代码</li>
</ul>
</li>
<li><p>开始实验之前，请输入：<code>git fetch &amp;&amp; git checkout pgtbl &amp;&amp; make clean</code></p>
<blockquote>
<p>这是必要的！过程中如果 Git 提醒你处理当前工作区中未提交的修改，输入 <code>git stash</code> 贮藏你的修改</p>
</blockquote>
</li>
</ul>
<h1 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h1><ul>
<li><p>一些操作系统通过在用户空间和内核之间的只读区域共享数据来加快某些系统调用的速度，这是因为用户程序可以之间在用户态下访问这个只读共享区域中的数据，而不用陷入到内核。</p>
</li>
<li><p>你的任务就是为 xv6 中的 <code>getpid()</code> 系统调用实现此优化</p>
</li>
<li><p>步骤</p>
<ul>
<li>创建每个进程时，在 USYSCALL（<code>memlayout.h</code> 中定义的虚拟地址）上映射一个只读页面</li>
<li>在这个页面的开始位置存储一个 usyscall 结构（也定义在 <code>memlayout.h</code> 中），初始化它以存储当前进程的 PID</li>
<li>用户空间中提供了 <code>ugetpid()</code>，会自动使用 USYSCALL 映射。你需要运行 <code>pgtbltest</code> 并通过了 ugatpid 的测试</li>
</ul>
</li>
<li><p>一些建议</p>
<ul>
<li>你可以在 <code>kernel/proc.c</code> 的 <code>proc_pagetable()</code> 中执行映射</li>
<li>选择允许用户空间只读页面的权限</li>
<li>你可能会发现 <code>kernel/vm.c</code> 的 <code>mappages()</code> 是一个很有用的程序</li>
<li>不要忘记在 <code>allocproc()</code> 中分配和初始化页面（<code>kernel/proc.c</code>）</li>
<li>确保在 <code>freeproc()</code> 中释放页面（<code>kernel/proc.c</code>）</li>
</ul>
</li>
<li><p><code>memlayout.h</code>  中定义了 USYSCALL，usyscall</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// User memory layout.  用户内存布局</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/memlayout.h</code></p>
</blockquote>
<ul>
<li>依照 xv6 book 第 3 章中提到的内核地址空间布局，不难发现 USYSCALL 仅在 TRAMPOLINE 和 TRAPFRAME 之下，是一个相当高的虚拟地址</li>
</ul>
<img src="/2024/06/03/6-S081-Lab3/Figure-3.3.jpg" class="" title="img">

<ul>
<li><code>proc_pagetable()</code> 为一个新进程创建一个映射了 trampoline、trapframe 的用户页表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process, with no user memory, </span></span><br><span class="line"><span class="comment">// 为一个进程创建一个用户页表，没有用户内存</span></span><br><span class="line"><span class="comment">// but with trampoline and trapframe pages. 但有trampoline和tramframe页面</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return) </span></span><br><span class="line">  <span class="comment">// 映射trampoline代码（为了系统调用返回）到用户虚拟地址的最高处</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address. </span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way  仅仅内核所用它，在到/从用户空间时，所以不是PTE_U（用户可以访问）</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe page just below the trampoline page, for </span></span><br><span class="line">  <span class="comment">// trampoline.S.</span></span><br><span class="line">  <span class="comment">// 映射trapframe页面到trampoline页面的下边，为了trampoline.S</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<ul>
<li>依照 TRAPFRAME 映射的过程，我们需要在 proc 中添加一个 usyscall</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usyscall</span>;</span>  <span class="comment">// my change</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.h</code></p>
</blockquote>
<ul>
<li>修改 <code>proc_pagetable()</code> 在新创建的用户页表中进行 USYSCALL 映射</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// map the trapframe page just below the trampoline page, for </span></span><br><span class="line">  <span class="comment">// trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// my change</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE, (uint64)p-&gt;usyscall, PTE_R | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code>，需要注意的是：</p>
<p>USYSCALL 映射的页面的权限是用户只读 <code>PTE_R | PTE_U</code></p>
<p>当 USYSCALL 映射失败时，需要释放 TRAMPOLINE、TRAPFRAME、pagetable</p>
</blockquote>
<ul>
<li><code>allocproc()</code> 在进程表中找一个未使用的 proc，为 proc 中的一些成员分配物理内存，并进行初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.  在进程表中寻找一个未使用的进程</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,  如果找到，初始化运行在内核中所需要的状态</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.  并返回，同时持有进程锁</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.  </span></span><br><span class="line"><span class="comment">// 如果没有空闲的进程，或内存分配失败，返回0</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;  <span class="comment">// 遍历进程表</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  </span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;  <span class="comment">// 找一个未使用的进程</span></span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();  <span class="comment">//初始化pid和state</span></span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page. 分配一个trapframe页面</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.  一个空的用户页表</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret, 设置新的上下文，以便在forket处开始执行</span></span><br><span class="line">  <span class="comment">// which returns to user space. forket返回用户空间</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<ul>
<li>需要为 proc 中的 usyscall 分配物理内存，这样才能在访问虚拟地址 USYSCALL 时通过页表映射找到 usycall 所在的物理地址</li>
<li>依照为 trapframe 分配物理内存的过程，修改 <code>allocproc()</code> 在创建一个进程时为 usyscall 分配物理内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Allocate a trapframe page. </span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// my change</span></span><br><span class="line">  <span class="keyword">if</span> ((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code>，不要忘记初始化 <code>usycall</code> 的 <code>pid</code></p>
</blockquote>
<ul>
<li><code>freeproc()</code> 释放一个 proc 及其相关的数据</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,  释放一个进程结构和其相关联的数据</span></span><br><span class="line"><span class="comment">// including user pages.  包括用户页面</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.  进程锁必须被持有</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<ul>
<li>依照 trapframe 的释放过程，修改 <code>freeproc()</code> 在释放一个进程时释放 usyscall</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// my change</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;usyscall) &#123;</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<ul>
<li>一个很重要的点是：<code>freeoroc()</code> 中调用了 <code>proc_freepagetable()</code> 释放进程的页表及映射的物理内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the  释放一个进程的页表，并且释放它所指向的物理内存</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<ul>
<li>依照 TRAPFRAME 的释放过程，修改 <code>proc_freepagetable()</code> 在释放一个页表时释放 USYSCALL 映射的物理内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// my change</span></span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<h1 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h1><ul>
<li><p>为了帮助可视化 RISC-V 页表，你的第二个任务是编写一个打印页表内容的函数</p>
</li>
<li><p>步骤</p>
<ul>
<li><p>定义一个名为 <code>vmprint()</code> 的函数，它的参数是类型为 <code>pagetable_t</code>，以下格式打印 pagetable</p>
</li>
<li><p><code>exec.c</code> 中在返回 argc 之前，插入 <code>if (p-&gt;pid == 1) vmprint(p-&gt;pagetable)</code>，打印第一个进程的页表</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">page table <span class="number">0x0000000087f6e000</span></span><br><span class="line"> .<span class="number">.0</span>: pte <span class="number">0x0000000021fda801</span> pa <span class="number">0x0000000087f6a000</span></span><br><span class="line"> .. .<span class="number">.0</span>: pte <span class="number">0x0000000021fda401</span> pa <span class="number">0x0000000087f69000</span></span><br><span class="line"> .. .. .<span class="number">.0</span>: pte <span class="number">0x0000000021fdac1f</span> pa <span class="number">0x0000000087f6b000</span></span><br><span class="line"> .. .. .<span class="number">.1</span>: pte <span class="number">0x0000000021fda00f</span> pa <span class="number">0x0000000087f68000</span></span><br><span class="line"> .. .. .<span class="number">.2</span>: pte <span class="number">0x0000000021fd9c1f</span> pa <span class="number">0x0000000087f67000</span></span><br><span class="line"> .<span class="number">.255</span>: pte <span class="number">0x0000000021fdb401</span> pa <span class="number">0x0000000087f6d000</span></span><br><span class="line"> .. .<span class="number">.511</span>: pte <span class="number">0x0000000021fdb001</span> pa <span class="number">0x0000000087f6c000</span></span><br><span class="line"> .. .. .<span class="number">.509</span>: pte <span class="number">0x0000000021fdd813</span> pa <span class="number">0x0000000087f76000</span></span><br><span class="line"> .. .. .<span class="number">.510</span>: pte <span class="number">0x0000000021fddc07</span> pa <span class="number">0x0000000087f77000</span></span><br><span class="line"> .. .. .<span class="number">.511</span>: pte <span class="number">0x0000000020001c0b</span> pa <span class="number">0x0000000080007000</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行显示 <code>vmprint()</code> 的参数（即 pagetable）</p>
</li>
<li><p>之后的每一行包括引用树中更深层页面的 PTE，通过用 <code>..</code> 进行缩进，每条 PTE 显示：PTE 索引、PTE 的位、PTE 中提取的物理地址</p>
</li>
<li><p>不打印无效的 PTE</p>
</li>
<li><p>一些建议</p>
<ul>
<li>你可以将 <code>vmprint()</code> 放在 <code>kernel/vm.c</code> 中</li>
<li>使用 <code>kernel/riscv.h</code> 末尾定义的宏会很有用</li>
<li><code>freewalk</code> 函数可以对你很有帮助</li>
<li>在 <code>kernel/defs.h</code> 中定义 <code>vmprint</code> 的原型，以便你可以在 <code>exec.c</code> 中调用它</li>
<li>在 <code>printf</code> 中使用 <code>%p</code> 打印完整的 64 位十六进制 PTE 和地址</li>
</ul>
</li>
<li><p><code>kernel/riscv.h</code> 末尾定义的宏真的很有趣，它们都是和页表相关的</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;	<span class="comment">// pte_t是一个非负的64位整数类型，可以作为地址使用</span></span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs	pagetable_t是一个指向uint64的指针，可以作为数组使用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __ASSEMBLER__</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page	表示一个页表4096字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page		表示页内偏移的位数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))	<span class="comment">// 不知道是什么，还没见过</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid	权限位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L &lt;&lt; 4) <span class="comment">// user can access</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"><span class="comment">// 将物理地址右移到PTE（页表项）的正确位置，10位用来设置权限位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)	<span class="comment">// 从pte提取出56位的物理地址，44位来自pte的ppn + 12位0</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address. 从虚拟地址中提取三个9位的页表索引</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))	<span class="comment">// 12 + 9 *level</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK) <span class="comment">// 左移12再左移9*levle</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// one beyond the highest possible virtual address. 		超出最高可能虚拟地址的一个单位</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by 	MAXVA 实际上比 Sv39 允许的最大值少一个比特位</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses 	以避免需要对设置了最高位的虚拟地址进行符号扩展</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/riscv.h</code></p>
</blockquote>
<ul>
<li><code>freewalk</code> 帮助我们理解如何递归的遍历页表<ul>
<li>如果 <code>(pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == 0</code> 成立，说明当前 PTE 不是叶子 PTE，也说明只有叶子 PTE 才有可能可读、可写、可执行</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages. 递归地释放页表页面</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed 所有叶子映射必须先已经被移除</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table. 这个PTE指向一个低层的页表</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/vm.c</code></p>
</blockquote>
<ul>
<li>在 <code>kernel/vm.c</code> 中添加 <code>vmprint</code>。为了方便，创建一个辅助函数 <code>vmprint_help</code> 根据当前页表的 level 打印 <code>..</code></li>
<li>在 <code>vmprint</code> 中打印第一行，其他行通过 <code>vmprint_help</code> 递归打印</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my change</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint_help</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>) &#123;</span><br><span class="line">      uint64 child = PTE2PA(pte); <span class="comment">// 得到下一级页表的物理地址</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte)); </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte)); </span><br><span class="line">      &#125;</span><br><span class="line">      vmprint_help((<span class="type">pagetable_t</span>)child, level - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte)); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  vmprint_help(pagetable, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/vm.c</code></p>
</blockquote>
<ul>
<li>在 <code>kernel/defs.h</code> 中定义 <code>vmprint</code> 的原型，以便可以在 <code>exec.c</code> 中调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm.c</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// my change</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/defs.h</code></p>
</blockquote>
<ul>
<li>修改 <code>exec.c</code>，在 argc 返回之前打印第一个进程的 pagetable</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  p = myproc();</span><br><span class="line">  <span class="comment">// my change</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;pid == <span class="number">1</span>) vmprint(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/exec.c</code></p>
</blockquote>
<h1 id="Detecting-which-pages-have-benn-accessed"><a href="#Detecting-which-pages-have-benn-accessed" class="headerlink" title="Detecting which pages have benn accessed"></a>Detecting which pages have benn accessed</h1><ul>
<li><p>一些垃圾收集器可以从有关哪些页面被访问的信息中受益</p>
</li>
<li><p>你将向 xv6 添加一项新功能，该功能通过检查 RISC-V 页面表中的访问位来检测并向用户空间报告此信息</p>
</li>
<li><p>步骤</p>
<ul>
<li>你的工作是实现 <code>pgaccess()</code>，这是一个系统调用，用于报告哪些页面已被访问</li>
<li>该系统调用有三个参数：用户页面的起始虚拟地址，需要检查的页数，存储结果的位掩码</li>
<li>位掩码的每一位对应于每页，比如第一页对应于位掩码中的最低有效位</li>
</ul>
</li>
<li><p>一些建议</p>
<ul>
<li>首先在 <code>kernel/sysproc.c</code> 中实现 <code>sys_pgaccess()</code></li>
<li>你需要使用 <code>kernel/syscall.c</code> 中的  <code>argaddr()</code> 和 <code>argint()</code> 解析参数</li>
<li>对于输出的位掩码，在内核中存储临时缓冲区，在用正确的位填充后将其复制给用户（使用 <code>copyout()</code>）</li>
<li>可以对需要扫描的页数设置上限</li>
<li><code>kernel/vm.c</code> 中的 <code>walk()</code> 对于找到正确的 PTE 非常有用</li>
<li>你需要在 <code>kernel/riscv.h</code> 中定义 PTE_A，即访问位</li>
<li>在检查是否设置后，请务必清除 PTE_A，防止访问位被永久设置</li>
<li><code>vmprint()</code> 在调试页表可能会有所帮助</li>
</ul>
</li>
<li><p><code>user/user.h</code> 中已经定义好了 <code>pgaccess()</code> 的原型</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pgaccess</span><span class="params">(<span class="type">void</span> *base, <span class="type">int</span> len, <span class="type">void</span> *mask)</span>;	<span class="comment">// 用户页面起始虚拟地址 页数 掩码</span></span><br><span class="line"><span class="comment">// usyscall region</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ugetpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>user/user.h</code></p>
</blockquote>
<ul>
<li><code>user/pgtbltest.c</code> 中调用了 <code>pgaccess()</code>。第一个参数传入 32 页面的起始虚拟地址，第二个参数表示 32 个页面，第三个参数传入一个指向位掩码的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pgaccess_test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *buf;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> abits;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pgaccess_test starting\n&quot;</span>);</span><br><span class="line">  testname = <span class="string">&quot;pgaccess_test&quot;</span>;</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">32</span> * PGSIZE);</span><br><span class="line">  <span class="keyword">if</span> (pgaccess(buf, <span class="number">32</span>, &amp;abits) &lt; <span class="number">0</span>)</span><br><span class="line">    err(<span class="string">&quot;pgaccess failed&quot;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>user/pgtbltest.c</code></p>
</blockquote>
<ul>
<li>在 <code>kernel/riscv.h</code> 中定义 PTE_A</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L &lt;&lt; 4) <span class="comment">// user can access</span></span></span><br><span class="line"><span class="comment">// my change</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6) <span class="comment">// 访问位</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这是根据 xv6 book 第 3 章中提到的 RISC-V 标准设置的</li>
</ul>
<img src="/2024/06/03/6-S081-Lab3/Figure-3.2.jpg" class="" title="img">





<ul>
<li>在 <code>kernel/sysproc.c</code> 中实现 <code>sys_pgaccess()</code>。通过前边的学习，我们知道用户空间中的 <code>pgaccess()</code> 实际会调用 <code>kernel/sysproc.c</code> 中定义的 <code>sys_pgaccess()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span>  <span class="comment">// my change</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 base, addr;</span><br><span class="line">  uint32 mask = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;base);</span><br><span class="line">  argint(<span class="number">1</span>, &amp;len);</span><br><span class="line">  argaddr(<span class="number">2</span>, &amp;addr);</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">0</span> || len &gt; <span class="number">32</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (base &gt;= MAXVA) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> ((pte = walk(p-&gt;pagetable, base, <span class="number">0</span>)) != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_A) != <span class="number">0</span>) &#123;</span><br><span class="line">      mask |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">      *pte &amp;= (~PTE_A);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    base += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span> (copyout(p-&gt;pagetable, addr, (<span class="type">char</span>*)&amp;mask, <span class="keyword">sizeof</span>(mask)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/sysproc.c</code>，要注意不要自己再定义 <code>sys_pgaccess()</code> 了，官方已经给出了框架</p>
</blockquote>
<ul>
<li><p>在 <code>sys_pgaccess()</code> 中，有一些需要注意的点</p>
<ul>
<li><p>通过 <code>argaddr()</code>、<code>argint()</code> 提取出用户传递的参数</p>
</li>
<li><p>限制检测的页数 <code>len</code> 必须在 <code>[0, 32]</code> 之间</p>
<ul>
<li>因为 <code>user/pgtbltest.c</code> 中调用 <code>pgaccess()</code> 时传入的指针指向的是 <code>unsigned int</code> 类型的数据，只有 32 位，这也是为什么调用 <code>pgaccess()</code> 时直接硬编码了页数为 32</li>
<li>还有就是不要使用 <code>len &lt; 0 || len &gt; sizeof(uint32)</code>，<code>uint32</code> 其实是 <code>unsigned int</code> 64 位，而不是 32 位；<code>uint64</code> 为 <code>unsigned long</code></li>
</ul>
</li>
<li><p>通过 <code>walk()</code> 检测当前虚拟地址是否已经被访问，每当一个页面 TLB 未命中且处理过后，这个 PTE 的访问位会被置为 1</p>
<ul>
<li><code>*pte &amp; PTE_A</code> 的目的是：一个页面只能统计一次。每次检查完后会将 PTE_V 清除，后面再次检查这个页面时 PTE_A 无效</li>
</ul>
</li>
<li><p>检查过访问位后，通过 <code>*pte &amp;= (~PTE_A)</code> 清除访问位</p>
</li>
</ul>
</li>
<li><p><code>kernel/syscall.c</code> 中，一些添加系统调用的必备步骤已经被实现了</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line">[SYS_pgaccess] sys_pgaccess,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/syscall.c</code></p>
</blockquote>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make clean &amp;&amp; make grade</strong> 进行测试</li>
</ul>
<img src="/2024/06/03/6-S081-Lab3/image-20240604173924619.png" class="" title="image-20240604173924619">

<blockquote>
<p>如果你想要完整通过测试</p>
<p>创建一个名为 <code>answer-pgtbl.txt</code> 的文件，输入两个问题的答案（随便写也能通过）</p>
<p>创建一个名为 <code>time.txt</code> 的文件，输入在这个实验中花费的时间</p>
</blockquote>
<ul>
<li>当然，也可以 <strong>make clean &amp;&amp; make qemu &amp;&amp; pgtbltest</strong> 进行测试</li>
</ul>
<img src="/2024/06/03/6-S081-Lab3/image-20240604174347450.png" class="" title="image-20240604174347450">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16087757.html">MIT6.S081-Lab3 Pgtbl 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/AD-milk/p/16103905.html">6.S081-2021-Lab3 Pgtbl学习笔记 - AD_milk - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">计组复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-23 17:25:17" itemprop="dateCreated datePublished" datetime="2024-05-23T17:25:17+08:00">2024-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-31 21:29:01" itemprop="dateModified" datetime="2024-05-31T21:29:01+08:00">2024-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><ul>
<li>机械计算机</li>
<li>电子模拟计算机：数据由连续的量表示</li>
<li>电子数字计算机：数据不由连续的数字表示</li>
<li>专用机、通用机</li>
</ul>
<h2 id="计算机发展简史"><a href="#计算机发展简史" class="headerlink" title="计算机发展简史"></a>计算机发展简史</h2><ul>
<li><p>计算机的发展</p>
<ul>
<li>第一代：电子管计算机</li>
<li>第二代：晶体管计算机</li>
<li>第三代：集成电路计算机：半导体存储器，出现微程序设计，出现操作系统</li>
<li>第四代：大规模集成电路计算机：出现数据库系统、分步操作系统、微处理器和微型计算机</li>
<li>第五代：巨大规模集成电路计算机：单片机</li>
</ul>
</li>
<li><p>半导体存储器的发展</p>
<ul>
<li>微小的铁磁体环 -&gt; 半导体存储器</li>
</ul>
</li>
<li><p>微处理器的发展</p>
<ul>
<li>4 位的 4004 微处理器 -&gt; 16位 8086 微处理器，采用流水线技术</li>
</ul>
</li>
<li><p>微型计算机的特点</p>
<ul>
<li>体积小、功耗低</li>
<li>可靠性高、使用环境要求低</li>
<li>设计灵活</li>
</ul>
</li>
<li><p>摩尔定律：晶体管面积会逐渐缩小，说明同样的面积下，晶体管越来越多</p>
</li>
<li><p>计算机性能指标</p>
<ul>
<li><p>吞吐量：某一时间间隔能处理的信息量（byte&#x2F;s）</p>
</li>
<li><p>响应时间：输入到系统产生响应（微妙 10^-6^、纳秒 10^-9^）</p>
</li>
<li><p>利用率：给定时间间隔内，系统被实际使用的时间占比</p>
</li>
<li><p>处理机字长：处理机运算器中一次能完成二进制数的位数</p>
</li>
<li><p>总线宽度：CPU 中运算器和存储器相连的内部总线的二进制位数</p>
</li>
<li><p>存储器容量：存储器中存储单元的总数（KB 2^10^、MB 2^20^、GB 2^30^、TB 2^40^）</p>
</li>
<li><p>存储器带宽：单位时间内从存储器读出二进制数的量（byte&#x2F;s）</p>
</li>
<li><p>主频&#x2F;时钟周期：主时钟的频率 f 即为 CPU 的主频（兆赫兹 MHz、GHz），主频的倒数即为 CPU 时钟周期</p>
</li>
<li><p>CPU 执行时间：CPU 执行一段程序所占用的 CPU 时间</p>
<blockquote>
<p>CPU 时钟周期数 * CPU 时钟周期长</p>
</blockquote>
</li>
<li><p>CPI：每条指令周期数</p>
<blockquote>
<p>执行某段程序所需 CPU 时钟周期数 &#x2F; 该程序的指令条数</p>
</blockquote>
</li>
<li><p>MIPS：每秒百万条指令数</p>
<blockquote>
<p>指令条数 &#x2F; (程序执行时间 * 10^6^) &#x3D; 时钟频率 &#x2F; (CPI * 10^6^)</p>
</blockquote>
</li>
<li><p>Te：程序执行时间</p>
<blockquote>
<p>指令条数 &#x2F; (MIPS * 10^6^)</p>
</blockquote>
</li>
<li><p>MFLOPS：每秒百万次浮点操作数</p>
<blockquote>
<p>程序中浮点操作次数 &#x2F; (程序执行时间 * 10^6^)</p>
<p>MIPS 是基于指令的，MIPS 越高机器越快；MFLOPS 基于浮点操作，不能体现机器整体性能</p>
</blockquote>
</li>
<li><p>TFLOPS：每秒万亿次浮点操作次数，常用于超级计算机</p>
</li>
</ul>
</li>
</ul>
<h2 id="计算机的硬件"><a href="#计算机的硬件" class="headerlink" title="计算机的硬件"></a>计算机的硬件</h2><ul>
<li><p>冯诺依曼计算机的设计思想：程序存储，程序控制</p>
<ul>
<li>计算机由五部分组成：控制器、运算器、存储器、输入设备、输出设备</li>
<li>程序和数据都以二进制代码的形式不加区别的存放在存储器上</li>
<li>指令由操作码和地址码组成，由指令计数器 PC 指出要执行指令所在单元地址，一般顺序执行</li>
<li>I&#x2F;O 设备和存储器传送数据时都通过运算器，以运算器为中心</li>
</ul>
</li>
<li><p>控制器</p>
<ul>
<li><p>获得执行的指令，明确指令功能，获得操作的数据，执行指令，返回结果</p>
<blockquote>
<p>取指周期，从内存读出的信息流向控制器，执行周期流向运算器</p>
</blockquote>
</li>
</ul>
</li>
<li><p>适配器和 I&#x2F;O 设备</p>
<ul>
<li><p>输入设备：将人熟悉的信息变为机器棵识别的二进制信息</p>
</li>
<li><p>输出设备：将计算机处理的结果变为人熟悉的信息</p>
</li>
<li><p>适配器：使外围设备可通过系统总线与主机联系</p>
</li>
<li><p>总线：系统部件间数据传送的公共通路</p>
<blockquote>
<p>系统总线包含三个子总线：数据总线、地址总线、控制总线</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="计算机的软件"><a href="#计算机的软件" class="headerlink" title="计算机的软件"></a>计算机的软件</h2><ul>
<li>软件的分类：系统软件和应用软件</li>
<li>软件的发展演变<ul>
<li>编程语言：手写程序 -&gt; 汇编语言 -&gt; 高级语言</li>
<li>系统软件：操作系统 -&gt; 分布式操作系统</li>
</ul>
</li>
</ul>
<h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><ul>
<li><p>第一级是微程序级，第二级是机器语言级，第三级是操作系统级，第四级是汇编语言级，第五级是高级应用级</p>
</li>
<li><p>层次结构的特点</p>
<ul>
<li>每一级都可以直接编程，得到下一级的支持</li>
<li>1 - 3 是二进制语言，易于机器执行；4 - 5 级是符号，易于人理解</li>
<li>级数越低越接近硬件</li>
</ul>
</li>
<li><p>软件和硬件的逻辑等价性：任何操作既可以用软件实现，也可以用硬件实现</p>
<ul>
<li>需要考虑的是其他因素：价格、速度、可靠性 ……</li>
</ul>
</li>
</ul>
<h1 id="运算器和运算方法"><a href="#运算器和运算方法" class="headerlink" title="运算器和运算方法"></a>运算器和运算方法</h1><h2 id="数据与文字的表示方法"><a href="#数据与文字的表示方法" class="headerlink" title="数据与文字的表示方法"></a>数据与文字的表示方法</h2><ul>
<li><p>十进制到 R 进制的转换</p>
<ul>
<li>整数部分：除 R 取余，R 进制为基数</li>
<li>小数部分：乘 R 取整</li>
</ul>
</li>
<li><p>数据的表示格式</p>
<ul>
<li>定点表示：纯整数 &#x2F; 纯小数，带符号 &#x2F; 不带符号</li>
<li>浮点表示</li>
</ul>
</li>
<li><p>纯小数</p>
</li>
</ul>
<style>.fsdfsotkwecj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525092537175.png" class="fsdfsotkwecj" alt="image-20240525092537175">

<ul>
<li><p>纯整数的取值范围：<code>0 &lt;= |x| &lt;= 2^n^ -1 </code></p>
</li>
<li><p>IEEE 754 浮点标准</p>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525092918929.png" class="" title="image-20240525092918929">

<ul>
<li><p>32 位浮点数，<code>x = (-1)^S^ × (1.M) × 2^E-127^</code>、 <code>e = E - 127</code></p>
<ul>
<li>M 尾数 23 位；E 阶码 8 位，用移码表示</li>
</ul>
</li>
<li><p>64 位浮点数，<code>x = (-1)^S^ × (1.M) × 2^E-1023^</code> 、<code>e = E - 1023</code></p>
<ul>
<li>M 尾数 52 位；E 阶码 11 位</li>
</ul>
</li>
<li><p>表示 0：当 E 阶码位全为 0 时， M 尾数位也全为 0，根据 S 符号位是 1 &#x2F; 0，有正 0 和负 0 之分</p>
</li>
<li><p>表示无穷：当 E 阶码位全为 1 时，M 尾数位全为 0，根据 S 符号位是 1 &#x2F; 0，有正无穷和负无穷之分</p>
</li>
<li><p>因为要排除阶码 E 全 0 全 1 的情况，32 位浮点数的 E 的取值范围为：1 ~ 254，真正的指数 e 的取值范围为：-126 ~ 127</p>
</li>
</ul>
</li>
<li><p>BCD 码</p>
<ul>
<li>一般用 8421 码，其 4 个二进制码的权从高到低分别为 8、4、2 和 1。</li>
<li>用 0000，0001，…，1001 分别表示 0，1，…，9，每个数位内部满足二进制规则，而数位之间满足十进制规则，故称这种编码为 “以二进制编码的十进制 (binary coded decimal，简称 BCD) 码”</li>
<li>部实现 BCD 码算术运算，要对运算结果进行修正，对加法运算的修正规则是： <ul>
<li>如果两个一位 BCD 码相加之和小于或等于 (1001)2， 即 (9)10，不需要修正</li>
<li>如相加之和大于或等于 (10)10，要进行加 6 修正， 并向高位进位</li>
</ul>
</li>
</ul>
</li>
<li><p>机器码表示</p>
<ul>
<li>原码，反码，补码，移码</li>
</ul>
<p>	</p>
</li>
<li><p>原码</p>
<ul>
<li>定点小数的取值范围：<code>2^-n^ - 1 ~ 1 - 2^-n^</code></li>
<li>定点整数的取值范围：<code>1 - 2^n^ ~ 2^n^ – 1</code></li>
<li>缺点：加减很麻烦</li>
</ul>
</li>
<li><p>补码</p>
<style>.xoyhxicehlim{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525100239650.png" class="xoyhxicehlim" alt="image-20240525100239650">

<ul>
<li><p>原理是：一个负数用其补码代替，同样可以得到正确的运算结果</p>
<ul>
<li>如果是 n 位整数，其模为2^n^ </li>
<li>如果是 n 位小数，其模为 2</li>
</ul>
</li>
<li><p>补码的优点就是将减法运算可以转为加法运算，无正 0 和负 0 之分</p>
</li>
<li><p>由原码求补码</p>
<ul>
<li>正数的原码、反码、补码都相同</li>
<li>负数：符号位 1 保持不变，其余位取反，得到反码；反码最低位 + 1 得到补码</li>
</ul>
</li>
<li><p>由 x 的补码求 x&#x2F;2 的补码：算术右移</p>
</li>
</ul>
</li>
<li><p>反码</p>
<ul>
<li>正数的原码、反码、补码相同</li>
<li>负数的符号位保持不变，其他位按位取反</li>
<li>反码有正 0 和负 0 之分</li>
</ul>
</li>
<li><p>移码</p>
<ul>
<li>通常用在阶码中</li>
<li>特点：移码和补码尾数相同，符号位相反</li>
<li><code>00000000</code> 阶码表示数字 “0” ，尾数的隐含位为 0；<code>11111111</code> 阶码表示数字 “无穷大” ，尾数的隐含位为 0</li>
</ul>
</li>
<li><p>字符和字符串的表示</p>
<ul>
<li><p>字符用 ASCLL：一个字节表示，低 7 位用来编码，高 1 位用来校验</p>
</li>
<li><p>字符串用连续的字节表示，一个字符一个字节</p>
</li>
<li><p>汉字：两个字节组成，每个字节高位都为1（区别于英文字符）（PPT 和 UTF - 8 好像不太一样，存疑）</p>
</li>
</ul>
</li>
<li><p>校验码</p>
<ul>
<li>由于信息传输和处理过程中受到干扰和故障，容易出错，所以在有效信息中加入一些冗余信息（校验位）</li>
<li>原理：在 k 位数据码之外增加 1 位校验位，使 k + 1 位码字中取值为 1 的位数总保持为偶数（偶校验）或奇数（奇校验）</li>
<li>只能发现错误，不能改错</li>
</ul>
</li>
</ul>
<h2 id="定点加法、减法运算"><a href="#定点加法、减法运算" class="headerlink" title="定点加法、减法运算"></a>定点加法、减法运算</h2><ul>
<li><p>补码加法</p>
<ul>
<li><style>.dhtphvvpcygz{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525102611629.png" class="dhtphvvpcygz" alt="image-20240525102611629">
</li>
<li><style>.ugvtlwtsrtsk{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525102633614.png" class="ugvtlwtsrtsk" alt="image-20240525102633614">
</li>
<li><p>符号位作为数的一部分参加运算</p>
</li>
<li><p>在 2^n+1^ 模意义下相加，即超过 2^n+1^ 的进位要丢掉</p>
</li>
</ul>
</li>
<li><p>补码减法</p>
<ul>
<li><p>为了将减法转为加法，[x-y]补 &#x3D; [x]补 - [y]补 &#x3D; [x]补 + [-y]补</p>
</li>
<li><p>由 [y]补 求 [-y]补：包括符号位都取反，在末位 + 1</p>
</li>
<li><style>.lqbdcoabfeor{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525103035698.png" class="lqbdcoabfeor" alt="image-20240525103035698">
</li>
<li><style>.jgqtisyqledj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525103100440.png" class="jgqtisyqledj" alt="image-20240525103100440"></li>
</ul>
</li>
<li><p>溢出的概念</p>
<ul>
<li><p>两个正数相加得到负数，两个负数相加得到正数</p>
</li>
<li><p>溢出的检测</p>
<ul>
<li><p>双符号法：</p>
<style>.eulcyllsfgqy{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525104930090.png" class="eulcyllsfgqy" alt="image-20240525104930090">
</li>
<li><p>两符号位相异时，表示溢出；相同时，没有溢出。无论是否溢出，SF1 表示结果正确的（其实是本该正确的）</p>
</li>
<li><p>超出双符号的部分还是需要丢掉的</p>
</li>
</ul>
</li>
<li><style>.yafncrwdghex{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525105031857.png" class="yafncrwdghex" alt="image-20240525105031857">
</li>
<li><style>.qckbuqmgwtyu{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525105048066.png" class="qckbuqmgwtyu" alt="image-20240525105048066"></li>
</ul>
</li>
<li><p>基本的加法减法器</p>
<ul>
<li>半加器：不考虑进位</li>
<li>全加器：考虑进位</li>
</ul>
</li>
</ul>
<h2 id="定点乘法运算"><a href="#定点乘法运算" class="headerlink" title="定点乘法运算"></a>定点乘法运算</h2><ul>
<li><p>乘积的符号由两数的符号按异或运算得到，而乘 积的数值部分则是两个正数相乘之积</p>
</li>
<li><style>.katushgioeoy{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110244617.png" class="katushgioeoy" alt="image-20240525110244617">
</li>
<li><p>通常机器只有 n 位长，两个 n 位数相乘，乘积可能为 2n 位</p>
</li>
<li><p>不带符号位的阵列乘法器</p>
<ul>
<li><style>.gwvttwykheec{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110357689.png" class="gwvttwykheec" alt="image-20240525110357689"></li>
</ul>
</li>
<li><p>带符号位的阵列乘法器</p>
<ul>
<li><style>.vttmobuygdxn{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110427695.png" class="vttmobuygdxn" alt="image-20240525110427695">
</li>
<li><style>.wygdyeefjyjp{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110441784.png" class="wygdyeefjyjp" alt="image-20240525110441784"></li>
</ul>
</li>
</ul>
<h2 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h2><ul>
<li>人工除法时，人可以比较被除数（余数）和除数的 大小来确定商 1（够减）或商 0（不够减） </li>
<li>机器除法时，余数为正表示够减，余数为负表示不够减。不够减时必须恢复原来余数，才能继续向下 运算。这种方法叫恢复余数法，控制比较复杂。 </li>
<li><strong>不恢复余数法（加减交替法）</strong> 余数为正，商 1，下次除数右移做减法； 余数为负，商 0，下次除数右移做加法。 控制简单，有规律</li>
<li><style>.cncewjqllwbb{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525111512256.png" class="cncewjqllwbb" alt="image-20240525111512256"></li>
</ul>
<h2 id="定点运算器的组成"><a href="#定点运算器的组成" class="headerlink" title="定点运算器的组成"></a>定点运算器的组成</h2><ul>
<li>多功能算术&#x2F;逻辑运算单元 ALU</li>
</ul>
<h2 id="浮点运算方法和浮点运算器"><a href="#浮点运算方法和浮点运算器" class="headerlink" title="浮点运算方法和浮点运算器"></a>浮点运算方法和浮点运算器</h2><ul>
<li><p>浮点数加法</p>
<ul>
<li><style>.zmytlhwbaffj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145124955.png" class="zmytlhwbaffj" alt="image-20240525145124955">
</li>
<li><style>.shqvrltkmmqd{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145955228.png" class="shqvrltkmmqd" alt="image-20240525145955228">
</li>
<li><p>步骤：</p>
<ul>
<li><p>0 操作数检查</p>
<style>.jhnpsmxemdnf{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145607017.png" class="jhnpsmxemdnf" alt="image-20240525145607017">
</li>
<li><p>比较阶码大小并完成对阶（小阶向大阶对齐），通过尾数的移动以改变 Ex 和 Ey 对阶 ，使之相等</p>
<style>.wrdlpxcmdqyy{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145536692.png" class="wrdlpxcmdqyy" alt="image-20240525145536692">
</li>
<li><p>尾数进行加或减运算</p>
<style>.hnhakcndmqsl{zoom: 50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145644744.png" class="hnhakcndmqsl" alt="image-20240525145644744">
</li>
<li><p>结果格式化</p>
<style>.tjlukoscvdvm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145715674.png" class="tjlukoscvdvm" alt="image-20240525145715674">

<blockquote>
<p>这里左规处理，我觉得应该是因为之前的 1 是符号位，我们要将其转为 1.M 的形式</p>
</blockquote>
</li>
<li><p>舍入处理</p>
<style>.klmdzvkdoloh{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145838834.png" class="klmdzvkdoloh" alt="image-20240525145838834"></li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.wchwptkturlm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145910146.png" class="wchwptkturlm" alt="image-20240525145910146">

<ul>
<li><p>浮点乘除法</p>
<ul>
<li><style>.fyepubhpobli{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150047579.png" class="fyepubhpobli" alt="image-20240525150047579"></li>
<li><style>.mlptjfrtbihw{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150902680.png" class="mlptjfrtbihw" alt="image-20240525150902680">
</li>
<li><p>步骤：</p>
</li>
<li><style>.drmkdiikmvxj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150319867.png" class="drmkdiikmvxj" alt="image-20240525150319867">

<ul>
<li><p>0 操作数检查</p>
<style>.xsyruxnwmwkk{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150439676.png" class="xsyruxnwmwkk" alt="image-20240525150439676">
</li>
<li><p>阶码加减操作</p>
<style>.pbqwrnqzomxu{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150504727.png" class="pbqwrnqzomxu" alt="image-20240525150504727">
</li>
<li><p>尾数乘除操作</p>
<style>.ltipvhbimqpc{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150540605.png" class="ltipvhbimqpc" alt="image-20240525150540605">
</li>
<li><p>结果规格化</p>
<style>.essepasnqaqr{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150656893.png" class="essepasnqaqr" alt="image-20240525150656893">

<blockquote>
<p>使用第二种格式化结果感觉更合理</p>
</blockquote>
</li>
<li><p>舍入处理</p>
<style>.txjmrbiufngg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150232580.png" class="txjmrbiufngg" alt="image-20240525150232580"></li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.wfblokowuspq{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150827187.png" class="wfblokowuspq" alt="image-20240525150827187">

<ul>
<li><p>浮点运算流水线</p>
<ul>
<li>空间并行性：增加冗余部件；时间并行性：流水线技术</li>
<li>流水线原理：把一个任务分解为几个有联系的子任务</li>
<li>基本概念：<ul>
<li>过程段 Si 所需的时间为 Ti，缓冲寄存器的延时为 T1，线性流水线的时钟周期定义为 <code>t＝max&#123;Ti&#125;＋T1＝Tm＋T1</code>，流水线处理的频率为 <code>f＝1/t</code></li>
<li>k 级流水线处理 n 个任务需要的时钟周期数：<code>Tk＝k＋(n－1)</code>。其中 k 个时钟周期用来处理第一个任务，剩下的 n - 1 个任务只需要 n - 1 个时钟周期</li>
</ul>
</li>
</ul>
</li>
<li><p>非流水线处理 n 个任务顺序完成的时间为：<code>T＝ n × k × t</code>，而流水线技术需要：<code>T＝Tk × t</code></p>
</li>
<li><p>k级线性流水线的加速比： <code>Ck ＝ n * k / [k＋(n－1)]</code></p>
</li>
</ul>
<h1 id="内部存储器"><a href="#内部存储器" class="headerlink" title="内部存储器"></a>内部存储器</h1><h2 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h2><ul>
<li><p>一个双稳态半导体电路或一个 CMOS 晶体管或磁性材料的存储元，均可以存储一位二进制代码</p>
<ul>
<li>二进制代码位是存储器中最小的存储单位，称为存储位元</li>
<li>多个存储位元构成存储单元，多个存储单元构成存储器</li>
</ul>
</li>
<li><p>存储器的分类：</p>
<ul>
<li>按存储介质：磁面 &#x2F; 半导体</li>
<li>按存取方式：随机 &#x2F; 顺序</li>
<li>按读写功能：RAM（随机易失性） &#x2F; ROM（只读非易失性）</li>
<li>按信息的保存：永久性 &#x2F; 非永久性</li>
</ul>
</li>
<li><p>存储器层次结构</p>
</li>
</ul>
<style>.ejthlncjveox{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526094535554.png" class="ejthlncjveox" alt="image-20240526094535554">

<ul>
<li>主存储器技术指标<ul>
<li>字存储单元：存放一个机器字的存储单元</li>
<li>字节存储单元：存放一个字节的单元</li>
<li>存储容量：指一个存储器中可以容纳的存储单元总数</li>
<li>存取时间：指一次读操作命令发出 到该操作完成，将数据读出到数据总线上所经历的时间</li>
<li>存储周期：指连续启动两次读操作所需间隔的最小时间。 通常，存储周期略大于存取时间</li>
<li>存储器带宽：单位时间里存储器所存取的信息量，通常以位&#x2F;秒或字节&#x2F;秒做度量单位</li>
</ul>
</li>
</ul>
<h2 id="SRAM-存储器"><a href="#SRAM-存储器" class="headerlink" title="SRAM 存储器"></a>SRAM 存储器</h2><ul>
<li><p>主存是半导体存储器，分为两类：</p>
<ul>
<li>静态读写存储器 SRAM：存取速度块，容量不如 DRAM 大</li>
<li>动态读写存储器 DRAM</li>
</ul>
</li>
<li><p>SRAM 存储位元：一个锁存器（触发器）</p>
</li>
<li><p>只要直流供电电源一直加到这个记忆电路上，它就无限期地保持记忆的 1 状态或 0 状态。如果电源断电，那么存储的数据就会丢失</p>
</li>
<li><p>SRAM 存储器读写逻辑</p>
<ul>
<li>CS 拔是片选信号（低电平有效），无论读或写，总是打开（低电平）</li>
<li>OE 拔是读使能信号（低电平有效），读的时候打开</li>
<li>WE 拔是写使能信号（低电平有效），写时总是打开</li>
<li>读写要互斥，因此 OE 拔低电平时，WE 拔总是高电平，反之同理</li>
</ul>
</li>
</ul>
<style>.bwwespywrbwc{zoom: 67%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526100901062.png" class="bwwespywrbwc" alt="image-20240526100901062">

<ul>
<li><style>.qgfafgxriiku{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526101029931.png" class="qgfafgxriiku" alt="image-20240526101029931"></li>
</ul>
<h2 id="DRAM-存储器"><a href="#DRAM-存储器" class="headerlink" title="DRAM 存储器"></a>DRAM 存储器</h2><ul>
<li><p>DRAM 的存储单元：</p>
<ul>
<li>SRAM 的存储单元是一个触发器，它具有两个稳定状态</li>
<li>DRAM 的存储单元是由一个 MOS 晶体管和电容器组成的记忆电路，通过电容有无电荷来区分信号 0、1，MOS 管则作为开关使用</li>
</ul>
</li>
<li><p>DRAM 的逻辑结构</p>
<ul>
<li>由于 DRAM 的容量很大，增加了行地址锁存器和列地址锁存器</li>
<li>由于 DRAM 存储单元是基于电荷的，电荷量随着时间和温度而减少，必须定期刷新，所以增加了刷新计数器</li>
<li>读周期、写周期的定义是从行选通信号 RAS 下降沿开始，到下一个RAS信号的下降沿为止。刷新操作和读 &#x2F; 写操作是交替进行的</li>
</ul>
</li>
</ul>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103222840.png" class="" title="image-20240526103222840">

<ul>
<li><p>存储容量扩充</p>
<ul>
<li><p>字长位数扩充</p>
<style>.hdektvyfnzms{zoom:67%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103635832.png" class="hdektvyfnzms" alt="image-20240526103635832">
</li>
<li><p>字存储容量扩展</p>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103716715.png" class="" title="image-20240526103716715"></li>
</ul>
</li>
<li><p>高级 DRAM 结构</p>
<ul>
<li>FPM DRAM：快速页模式动态存储器，它是根据程序的局部性原理来实现的</li>
<li>CDRAM：带高速缓冲存储器（cache）的动态存储器，在 DRAM 芯片内又集成了一个小容量的 SRAM，从而使 DRAM 芯片的性能得到显著改进</li>
<li>SDRAM：同步型动态存储器，SDRAM 的操作要求与系统时钟相同步，在系统时钟的控制下从 CPU 获得地址、数据和控制信息</li>
</ul>
</li>
<li><p>DRAM 读写正确性校验：增加了附加位，用于读&#x2F;写操作正确性校验。增加的附加位也要同数据位一起写入 DRAM 中保存</p>
</li>
</ul>
<h2 id="只读存储器（ROM）和闪速存储器（EPROM）"><a href="#只读存储器（ROM）和闪速存储器（EPROM）" class="headerlink" title="只读存储器（ROM）和闪速存储器（EPROM）"></a>只读存储器（ROM）和闪速存储器（EPROM）</h2><ul>
<li><p>只读存储器 ROM：在工作时只能读，不能写，因此原始数据必须在它工作前写入</p>
</li>
<li><p>ROM 的分类：</p>
<ul>
<li>掩模 ROM：也就是一个由商家提供的内存固定的 ROM，一旦芯片做成就不能改变了</li>
<li>可编程 ROM：用户后写入内容，有的可以多次写入<ul>
<li>一次性编程 PROM</li>
<li>多次编程的 EPROM 和 E^2^PROM</li>
</ul>
</li>
</ul>
</li>
<li><p>可编程 ROM</p>
<ul>
<li><p>EPROM 叫光擦除可编程只读存储器，常用的有以浮栅雪崩注入型 MOS 管为存储单元的 EPROM</p>
</li>
<li><p>E^2^PROM 叫电擦除可编程只读存储器，其存储元是一个具有两个栅级的 NMOS 管</p>
</li>
<li><p>这两种存储器出厂时为全 1 状态，使用者可根据需要写 0</p>
</li>
</ul>
</li>
<li><p>闪速存储器</p>
<ul>
<li>FLASH 存储器也叫闪速存储器，它是高密度非易失性读&#x2F;写存储器</li>
<li>高密度说明其存储容量很大，非易失性说明数据没有电源也能长期保存</li>
<li>它既有 RAM 的优点，也有 ROM 的优点，是一个跨时代的进展</li>
<li>FLASH 存储元在 EPROM 存储元基础上发展起来的</li>
</ul>
</li>
</ul>
<h2 id="并行存储器"><a href="#并行存储器" class="headerlink" title="并行存储器"></a>并行存储器</h2><ul>
<li><p>为了解决 CPU 和主存储器之前的速度不匹配问题，解决途径：</p>
<ul>
<li>多个存储器并行工作：并行访问和交叉访问</li>
<li>采用分层存储系统：Cache、虚拟存储系统</li>
</ul>
</li>
<li><p>双端口存储器（空间并行）</p>
<ul>
<li>由于同一个存储器具有两组相互独立的读写控制电路而得名，通过 BUSY 位来保证读写互斥</li>
</ul>
</li>
<li><p>多模块交叉存储器（时间并行）</p>
<ul>
<li><p>一个由若干个模块组成的主存储器，有两种访问方式：一种是顺序方式，一种是交叉方式</p>
<ul>
<li>顺序方式</li>
</ul>
<style>.efdvczlmtsjc{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526112808903.png" class="efdvczlmtsjc" alt="image-20240526112808903">

<ul>
<li><p>交叉方式</p>
<style>.ozlpjfmcmtpu{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526112835300.png" class="ozlpjfmcmtpu" alt="image-20240526112835300">

<ul>
<li>通常在一个存储器周期内联系访问四个模块。各模块的 读写过程将重叠进行</li>
<li>各个存储体的启动间隔为 <code>t = T/n</code>（n为交叉存取度） </li>
<li><code>t顺序 = xT</code>（x 表示任务个数），<code>x交叉 = T + (x - 1)t</code>（第一个 T 是第一个任务，剩下的 x - 1 个任务都只需要 t）</li>
</ul>
<style>.uhrgbccurgei{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526113259735.png" class="uhrgbccurgei" alt="image-20240526113259735">

<blockquote>
<p>Mb 的 b 表示 bit，而 MB 的 B 表示 byte</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Cache-存储器"><a href="#Cache-存储器" class="headerlink" title="Cache 存储器"></a>Cache 存储器</h2><ul>
<li><p>Cache 是一种高速缓冲存储器介于 CPU 和主存之 间的小容量存储器，但存取速度比主存快。随着集成度的提高，Cache 已放入 CPU中，工作速度接近于 CPU 的速度，纯硬件控制</p>
</li>
<li><p>Cache 是由 SRAM 组成的，它的设计依据是局部性原理</p>
<ul>
<li>CPU 与 Cache 之间的数据传送是以字为单位</li>
<li>主存与 Cache 之间的数据传送是以块为单位</li>
</ul>
</li>
<li><p><code>Ne</code> 表示 cache 完成存取的总次数，<code>Nm</code> 表示主存完成存取的总次数，<code>h</code> 表示命中率</p>
</li>
<li><p><code>tc</code> 表示命中时 cache 的访问时间，<code>tm</code> 表示未命中时主存的访问时间，<code>1-h</code> 表示未命中率，<code>ta</code> 表示 cache&#x2F;主存储系统的平均访问时间</p>
</li>
<li><p><code>r = tm / tc</code>，表示主存慢于 cache 的倍率，<code>e</code> 表示访问效率</p>
</li>
</ul>
<style>.eicvlbeyjezu{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526135617821.png" class="eicvlbeyjezu" alt="image-20240526135617821">

<ul>
<li><style>.grfschybptfs{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526135756896.png" class="grfschybptfs" alt="image-20240526135756896">
</li>
<li><p>主存与 cache 的地址映射</p>
<ul>
<li><p>cache 的容量很小，保存的内容只是主存内容的一个子集，且 cache 与主存的数据交换是以块为单位</p>
</li>
<li><p>全相联的地址映射</p>
<ul>
<li><p>主存中的任一块可以映射到缓存中的任一块</p>
</li>
<li><p>此时内存地址由块号、偏移量组成，将块号和 cache 中每一行的标记位比较</p>
<style>.fkejdbcbvgcn{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526140337048.png" class="fkejdbcbvgcn" alt="image-20240526140337048">
</li>
<li><p>冲突概率小，Cache 的利用高，但比较器难实现，需要一个访问速度很快代 价高的相联存储器</p>
</li>
</ul>
</li>
<li><p>直接映射</p>
<ul>
<li><p>Cache 的行号 i 和主存的块号 j 函数关系 <code>i = j mod m</code>，m 是 cache 中的总行数</p>
</li>
<li><p>每个缓存块 i 可以和若干个主存块对应；每个主存块 j 只能和一个缓存块对应</p>
</li>
<li><p>此时内存地址有 tag、行号、偏移量组成，直接和 cache 中对于行的 tag 比较</p>
<style>.ethicwdpkoxv{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526140716082.png" class="ethicwdpkoxv" alt="image-20240526140716082">
</li>
<li><p>硬件实现简单，但冲突概率高（抖动）</p>
</li>
</ul>
</li>
<li><p>组相联映射方式</p>
<ul>
<li><p>前两者的组合，Cache 分组，组间采用直接映射方式，组内采用全相联的映射方式</p>
</li>
<li><p>主存块存放在哪个组是固定的，至于存到该组哪一行是灵活的</p>
</li>
<li><p>此时内存地址由 tag、组号、偏移量组成，在 cache 对应的组中逐个比较 tag</p>
<style>.shxlyhsduxwx{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526142729893.png" class="shxlyhsduxwx" alt="image-20240526142729893">
</li>
<li><p>当只有一个组时，是全映射；当组的容量为 1 时，是直接映射</p>
</li>
<li><p>组的容量一般取值比较小，假设为 v，则称为 v 路组相联 cache</p>
</li>
</ul>
</li>
<li><style>.jofbsksoijpt{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526143206068.png" class="jofbsksoijpt" alt="image-20240526143206068"></li>
</ul>
</li>
<li><p>替换策略</p>
<ul>
<li>LFU（最不经常使用 ）：被访问的行计数器增加 1， 换值小的行，不能反映近期 cache 的访问情况</li>
<li>LRU（近期最少使用）：被访问的行计数器置 0， 其他的计数器增加 1，换值大的行，符合局部性原理</li>
<li>随机替换：硬件上容易实现，且速度也比前两种策略快，但随意换出的数据很可能马上又要使用</li>
</ul>
</li>
<li><p>写操作策略</p>
<ul>
<li>由于 cache 的内容只是主存部分内容的拷贝，它应当与主存内容保持一致</li>
<li>写回法：换出时，对行的修改位进行判断，决定是写回到主存还是舍掉</li>
<li>全写法：写命中时，Cache 与内存一起写</li>
<li>写一次法：与写回法一致，但是第一次 Cache 命中时采用全写法</li>
</ul>
</li>
<li><p>使用多级 cache 减少缺失损失</p>
</li>
</ul>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><ul>
<li><p>基本概念</p>
<ul>
<li>用户编写的程序按照虚拟地址存放在辅存中，程序运行时，由地址变换机构依据当时分配给该程序的物理地址空间把程序的一部分调入实存</li>
</ul>
</li>
<li><p>cache - 主存和主存 - 虚拟内存的异同</p>
<ul>
<li>相同点：都是为了提高系统的性能价格比而进行的分层，都利用了局部性原理将经常访问的数据块调入容量小速度快的存储器</li>
<li>不同点：<ul>
<li>cache - 主存主要是解决 CPU 与主存速度不匹配问题，主存 - 虚拟内存主要是为了解决存储容量、管理、分配、保护等问题</li>
<li>透明性也不同，cache 是由硬件管理的，设置不暴露给系统程序员</li>
<li>未命中处罚不同：cache 的速度是主存的 5 - 10 倍，主存是辅存的 1000 倍</li>
</ul>
</li>
</ul>
</li>
<li><p>页式虚拟地址映射</p>
<ul>
<li><p>虚拟地址由逻辑页号和偏移量组成，物理地址由物理页号和偏移量组成，偏移量是相同的，而页号可能长度都不同</p>
</li>
<li><p>每个进程都有一个页表，逻辑页号 + 页表基址找到相应的物理页号，物理页号 + 偏移量 &#x3D; 物理地址</p>
<style>.qhjflucujuht{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526154921194.png" class="qhjflucujuht" alt="image-20240526154921194">

<style>.slotrimfitem{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526154941193.png" class="slotrimfitem" alt="image-20240526154941193">
</li>
<li><p>每个进程的页表的页数都不是固定的，有的进程页表可能很大，解决方案</p>
<ul>
<li>一些系统把页表存储在虚存中，因而页表本身也要进行分页。当一个进程运行时，其页表中一部分在主存中，另一部分则在辅存中保存</li>
<li>二级页表结构。每个进程有一个页目录表，其中的每个表项指向一个页表。若页目录表的长度（表项数）是 m，每个页表的最大长度（表项数）为 n，则一个进程最多可以有 m×n 个页</li>
<li>反向页表实现物理页号到逻辑页号的反向映射</li>
</ul>
</li>
<li><p>页表是虚地址到主存物理地址的变换表，通常称为内页表</p>
</li>
<li><p>外页表是用于虚地址与辅存地址之间的变换，主存缺页时就会用到</p>
</li>
<li><p>转换后援缓冲器 TLB</p>
<ul>
<li><p>把页表中的最活跃的部分存放在高 速存储器中，组成快表</p>
<style>.umlgrvfllszn{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526155823138.png" class="umlgrvfllszn" alt="image-20240526155823138">
</li>
<li><p>可能的情况</p>
<style>.initdlfnrcnq{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526155856547.png" class="initdlfnrcnq" alt="image-20240526155856547"></li>
</ul>
</li>
</ul>
</li>
<li><p>段式虚拟存储器</p>
<ul>
<li><p>把代码、数据、堆、栈等不同类型的数据划分到不同的段中</p>
</li>
<li><p>虚地址由段号、偏移量组成，每一个程序一个段表，段表的每一个表项对应一个段。段表常驻主存</p>
</li>
<li><p>每个表项包含：</p>
<ul>
<li>有效位：该段是否调入主存</li>
<li>段基址：该段在主存中的起始地址</li>
<li>段长：该段的实际长度，防止访问越界</li>
</ul>
</li>
<li><style>.khfbkbrpcxyv{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526160420104.png" class="khfbkbrpcxyv" alt="image-20240526160420104">
</li>
<li><p>分段易于管理，便于共享，但需要更多的硬件支持</p>
</li>
</ul>
</li>
<li><p>段页式虚拟存储器</p>
<ul>
<li><p>上面两者的结合，每个程序则先按逻辑结构分段， 每段再按照实存的页大小分页</p>
</li>
<li><p>虚拟地址构成</p>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526160833463.png" class="" title="image-20240526160833463">
</li>
<li><p>基号 N 找到段表，段号 S 找到页表，页号找到物理页号，物理页号 + 偏移量 D &#x3D; 物理地址</p>
<style>.uhcomqqsiuno{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161114148.png" class="uhcomqqsiuno" alt="image-20240526161114148"></li>
</ul>
</li>
</ul>
<style>.ndvgfsxpcpox{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161134274.png" class="ndvgfsxpcpox" alt="image-20240526161134274">

<blockquote>
<p>这些表项中都应该有一个有效位的</p>
</blockquote>
<ul>
<li><style>.lapucbthtnye{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161912949.png" class="lapucbthtnye" alt="image-20240526161912949">

<style>.xkiyvlihaduk{zoom: 50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161928436.png" class="xkiyvlihaduk" alt="image-20240526161928436">

<style>.vuqbgrduwegf{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161957376.png" class="vuqbgrduwegf" alt="image-20240526161957376">
</li>
<li><p>虚拟内存的替换算法</p>
<ul>
<li><p>当从辅存调页至主存而主存已满时，也需要进行主存页面的替换</p>
</li>
<li><p>替换算法与 cache 的替换算法类似：FIFO 算法、LRU 算法、LFU 算法</p>
</li>
<li><p>不同点</p>
<ul>
<li>cache 的替换全部靠硬件实现，而虚拟存储器的替换有操作系统的支持</li>
<li>虚存缺页对系统性能的影响比 cache未命中要大得多</li>
</ul>
</li>
<li><p>FIFO+LRU 算法是对 FIFO 算法的一种改进，如果某个页面命中，则将该页面移动到 FIFO 队列入口位置。因为局部性原理，刚被访问的页面在最近的将来被再次访问的概率较大，故将其被替换的时间延后</p>
</li>
</ul>
</li>
</ul>
<h2 id="奔腾系列机的虚存组织"><a href="#奔腾系列机的虚存组织" class="headerlink" title="奔腾系列机的虚存组织"></a>奔腾系列机的虚存组织</h2><ul>
<li>略</li>
</ul>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令系统的发展与性能要求"><a href="#指令系统的发展与性能要求" class="headerlink" title="指令系统的发展与性能要求"></a>指令系统的发展与性能要求</h2><ul>
<li><p>指令就是要计算机执行的某种操作，分为：微指令（硬件），宏指令（软件），机器指令（我们要讨论的）</p>
<ul>
<li>一台计算机的所有机器指令的集合就是它的指令系统</li>
</ul>
</li>
<li><p>指令系统的发展：复杂指令系统 CISC，精简指令系统 RISC</p>
</li>
<li><p>指令系统的性能要求：完备性、有效性、规整性、兼容性</p>
</li>
<li><p>高级语言：与计算机的硬件结构和指令系统无关</p>
</li>
<li><p>低级语言：机器语言（二进制语言），汇编语言（符号语言）：依赖于硬件和指令系统</p>
</li>
</ul>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><ul>
<li><p>指令格式包括操作码字段、地址码字段</p>
</li>
<li><p>操作码：不同的操作码字段表示该指令应进行什么性质的操作</p>
<ul>
<li>组成操作码字段的位数一般取决于计算机指令系统的规模</li>
</ul>
</li>
<li><p>地址码：根据一条指令有几个操作数地址，可以将该指令称为几操作数指令 &#x2F; 几地址指令</p>
<ul>
<li>一般的操作数有被操作数、操作数、操作结果</li>
<li>分为：三地址指令、二地址指令、单地址指令、零地址指令</li>
<li>二地址指令根据操作数的物理位置又分为：存储器 - 存储器，寄存器 - 存储器，寄存器 - 寄存器</li>
</ul>
</li>
<li><p>指令字长度：指令包含的二进制位数</p>
<ul>
<li>机器字长：计算机能直接处理的二进制位数</li>
<li>所以分为：单字长指令、半字长指令、双字长指令</li>
</ul>
</li>
<li><p>指令助记符：为了便于书写和阅读程序，每条指令通常用 3个或 4 个英文缩写字母来表示二进制操作码</p>
</li>
</ul>
<h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><ul>
<li>地址数据：地址也是一种形式上的数据</li>
<li>数值数据分为：定点正数、小数，浮点数，BCD</li>
<li>字符数据：ASCLL</li>
<li>逻辑数据：一个单元中有几位二进制 bit 项组成</li>
</ul>
<h2 id="指令和数据的寻址方式"><a href="#指令和数据的寻址方式" class="headerlink" title="指令和数据的寻址方式"></a>指令和数据的寻址方式</h2><ul>
<li><p>寻址方式是指 CPU 根据指令中给出的地址码字段寻找相应的操作数的方式</p>
</li>
<li><p>指令的寻址分为：顺序寻址、条约寻址</p>
<style>.oubmvlgudbll{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527204803749.png" class="oubmvlgudbll" alt="image-20240527204803749">
</li>
<li><p>操作数寻址的基本方式</p>
<ul>
<li><p>把操作数形式地址变为操作数有效地址的过程</p>
<style>.wctbujojykik{zoom: 67%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527204943758.png" class="wctbujojykik" alt="image-20240527204943758">
</li>
<li><p>隐含寻址：没有明确给出操作数的地址，而是以某些默认寄存器作为源&#x2F;目的寄存器</p>
</li>
<li><p>立即寻址：指令中在操作码字段后面的部分不是操作数地址，而是操作数本身，又称为立即数</p>
<ul>
<li>不够灵活，不容易修改且受到指令字长的限制，常用于给某一寄存器或主存单元赋初值，或用于提供一个常数</li>
</ul>
</li>
<li><p>直接寻址：指令中地址码字段给出的地址就是操作数的有效地址</p>
</li>
<li><p>间接寻址：指令的地址码部分给出的地址存放操作数地址的主存单元的地址，简称操作数地址的地址</p>
<ul>
<li>灵活，不必修改指令，但效率低下，至少需要两次访问主存储器才能取出操作数</li>
</ul>
</li>
<li><p>寄存器寻址：指令的地址码部分给出 CPU 内某一通用寄存器的编号，指令的操作数存放在相应的寄存器中</p>
<ul>
<li>访问快，且减少地址码字段长度</li>
</ul>
</li>
<li><p>寄存器间接寻址：操作数放在主存储器中，而操作数的地址放在某一通用寄存器中，指令的地址码部分给出该通用寄存器的编号</p>
<ul>
<li>解决了间接寻址慢的问题，灵活且只需要一次访问主存，被广泛使用</li>
</ul>
</li>
<li><p>偏移寻址：分为相对寻址、基址寻址、变址寻址</p>
<ul>
<li><p>相对寻址：由程序计数器 PC 提供基准地址，而指令的地址码部分给出相对的位移量 D，两者相加后作为操作数的有效地址</p>
<style>.onsndecjiior{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210450839.png" class="onsndecjiior" alt="image-20240527210450839">
</li>
<li><p>基址寻址：指令的地址码部分给出偏移量，而基准地址放在基址寄存器中，基准地址与偏移量相加得到有效地址</p>
<style>.gigygsminhbx{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210619747.png" class="gigygsminhbx" alt="image-20240527210619747">
</li>
<li><p>变址寻址：将指令的地址码部分给出的基准地址与 CPU 内某特定的变址寄存器中的偏移量相加，以形成操作数的有效地址</p>
<ul>
<li><p>被广泛使用，在遇到需要频繁修改操作数地址时，无须修改指令，只要修改寄存器中的变址值就可以了</p>
<style>.feukyfgxetke{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210803495.png" class="feukyfgxetke" alt="image-20240527210803495"></li>
</ul>
</li>
</ul>
</li>
<li><p>段寻址：内存空间被划分为多段</p>
<style>.ohvdqcbynfbs{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527211512391.png" class="ohvdqcbynfbs" alt="image-20240527211512391">
</li>
<li><p>堆结构：分为硬堆栈（专用寄存器），软堆栈（主存储器中）</p>
<ul>
<li>作用：实现程序调用，子程序嵌套调用和递归调用；实现中断，保存现场</li>
</ul>
</li>
<li><p>总结</p>
<style>.ssjbsxirqvbm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527211955003.png" class="ssjbsxirqvbm" alt="image-20240527211955003"></li>
</ul>
</li>
</ul>
<h2 id="典型指令"><a href="#典型指令" class="headerlink" title="典型指令"></a>典型指令</h2><ul>
<li><p>简单分类：</p>
<ul>
<li>数据传送类指令：一般传送指令，数据交换指令，堆栈操作指令</li>
<li>运算类指令：算术运算指令，逻辑运算指令，移位指令</li>
<li>程序控制类指令、输入输出指令、字符串处理指令 ……</li>
</ul>
</li>
<li><p>复杂指令集计算机 CISC</p>
<ul>
<li><p>28 定律：CISC 中大约有 20% 的指令使用占据了 80% 的处理机时间，而有 80% 的不常用指令只占用处理机的 20% 时间</p>
</li>
<li><p>特征：</p>
<ul>
<li>使用微代码：指令集可以直接在微代码内存（比主内存的速度快很多）里执行</li>
<li>庞大的指令集，通过增强指令系统的功能，简化了软件，增加了硬件的复杂程度</li>
<li>高级语言对应的指令集</li>
</ul>
</li>
<li><p>优点：能够有效缩短新指令的微代码设计时间，允许设计师实现 CISC 体系机器的向上兼容</p>
</li>
<li><p>缺点：设计越来越复杂，不同的指令，需要不同的时钟周期来完成，执行较慢的指令，将影响整台机器的执行效</p>
</li>
</ul>
</li>
<li><p>精简指令集计算机 RISC</p>
<ul>
<li>指令系统应当只包含那 些使用频率很高的少量指令。并提供一些必要的指令以支持操作系统和高级语言</li>
<li>特征（采用流水线技术）：<ul>
<li>指令条数少；简单而统一格式的指令译码；简单的寻址方式</li>
<li>大部分指令可以单周期执行； 只有LOAD&#x2F;STORE可以访问存储器；较多的寄存器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><h2 id="CPU-的功能和组成"><a href="#CPU-的功能和组成" class="headerlink" title="CPU 的功能和组成"></a>CPU 的功能和组成</h2><ul>
<li><p>CPU 的功能就是取指令和执行指令</p>
</li>
<li><p>CPU 的基本组成</p>
<ul>
<li><p>运算器：ALU、通用寄存器、数据缓冲寄存器、状态字寄存器</p>
<ul>
<li>功能：接受控制器的命令而进行操作</li>
</ul>
</li>
<li><p>控制器：程序计数器、指令寄存器、地址寄存器 ……</p>
<ul>
<li>功能：对指令进行译码或测试，并产生相应的操作控制信号</li>
</ul>
</li>
<li><p>cache</p>
</li>
</ul>
</li>
<li><p>CPU 的主要寄存器</p>
<ul>
<li><p>数据缓冲寄存器 DR：作为 ALU 运算结果和通用寄存器之间信息传送中时间上的缓冲</p>
</li>
<li><p>指令寄存器 IR、指令译码器 ID：存放从存储器中取出的待执行的指令，暂存的指令只有经译码后才能识别出是一条什么样的指令</p>
<ul>
<li>译码器经过对指令进行分析和解释，产生相应的控制信号</li>
</ul>
</li>
<li><p>程序计数器 PC：用来存放正在执行的指令的地址或接着将要执行的下一条指令的地址</p>
</li>
<li><p>数据地址寄存器 AR：保存当前 CPU 访问的数据在 cache 中单元的地址</p>
</li>
<li><p>通用寄存器 R0 ~ R3：可存放源操作数、结果操作数</p>
</li>
<li><p>状态字寄存器 PSW：保存由算术指令和逻辑指令运算或测试结果、中断或系统工作状态等信息</p>
</li>
</ul>
</li>
<li><p>操作控制器和时序产生器</p>
<ul>
<li><p>数据通路：寄存器之间传送信息的通路</p>
</li>
<li><p>操作控制器：为数据通路的建立提供各种操作信号。可分为时序逻辑型和存储逻辑型</p>
<ul>
<li>硬布线控制器：采用时序逻辑技术实现</li>
<li>微程序控制器：采用存储逻辑来实现</li>
</ul>
</li>
<li><p>时序产生器：提供定时和时序信号对各种操作信号实施时间上的控制</p>
</li>
</ul>
</li>
</ul>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><ul>
<li><p>指令周期：取指指令、分析指令到执行完该指令所需的全部时间</p>
</li>
<li><p>机器周期：通常又称 CPU 周期、时钟周期，通常把一条指令周期划分为若干个机器周期，每个机器周期完成一个基本操作</p>
<ul>
<li>不同的指令，可能包含不同数目的机器周期</li>
</ul>
</li>
<li><p>一个机器周期中，包含若干个 T 周期（节拍脉冲或 T 脉冲， 处理操作的最基本单位）</p>
</li>
</ul>
<style>.tgpasnbkpdbb{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192515259.png" class="tgpasnbkpdbb" alt="image-20240528192515259">

<ul>
<li><p>MOV 指令的指令周期</p>
<style>.dcnflnyyycul{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192643133.png" class="dcnflnyyycul" alt="image-20240528192643133">
</li>
<li><p>LAD 指令的指令周期：它的数据传 送方向是从内存到寄存器</p>
</li>
</ul>
<style>.ifiyxzhfurxa{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192751788.png" class="ifiyxzhfurxa" alt="image-20240528192751788">

<ul>
<li><p>ADD 指令的指令周期</p>
<style>.aingpnmuckmr{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192845807.png" class="aingpnmuckmr" alt="image-20240528192845807">
</li>
<li><p>STO 指令的指令周期：将寄存器或立即数中的值存储到指定的内存地址</p>
</li>
</ul>
<style>.jyjljnyatbdt{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192931988.png" class="jyjljnyatbdt" alt="image-20240528192931988">

<ul>
<li>JMP 指令的指令周期</li>
</ul>
<style>.qstmiymfpmcf{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192954705.png" class="qstmiymfpmcf" alt="image-20240528192954705">

<ul>
<li>方框图语言表示指令周期<ul>
<li>方框：按CPU周期；方框内内容：数据通路操作或控制操作；菱形符号：判别或测试</li>
</ul>
</li>
</ul>
<style>.jrmkxtsmurpq{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528193103420.png" class="jrmkxtsmurpq" alt="image-20240528193103420">

<ul>
<li>一条指令包括一个取指令周期和一个及一 个以上的执行周期组成</li>
</ul>
<h2 id="时序产生器和控制方式"><a href="#时序产生器和控制方式" class="headerlink" title="时序产生器和控制方式"></a>时序产生器和控制方式</h2><ul>
<li><p>时序产生器的作用：CPU 中的控制器用它指挥机器的工作，可以辨别从内存中取出的是指令还是数据</p>
</li>
<li><p>时序产生器的体制：电位—脉冲制</p>
</li>
<li><p>硬布线控制器</p>
<ul>
<li>时序信号采用主状态周期、节拍电位、节拍脉冲三级体制</li>
<li>一个节拍电位表示一个 CPU 周期，包含多个节拍脉冲</li>
<li>一个主状态周期包含多个节拍电位</li>
</ul>
</li>
<li><p>微程序控制器</p>
<ul>
<li>时序信号采用节拍电位（1个）、节拍脉冲（多个）二级体制</li>
</ul>
</li>
<li><p>时序产生器的功能：用逻辑电路来产生时序信号</p>
</li>
<li><p>控制方式：控制不同操作序列时序信号的方法，主要有以下几种</p>
<ul>
<li>同步控制方式：指令的机器周期和时钟周期数不变</li>
<li>异步控制方式：每条指令需要多长时间就占多长时间</li>
<li>联合控制方式：大部分指令在固定的周期内完成，少数难以确定的操作采用异步方式 <ul>
<li>机器周期的节拍脉冲固定，但是各指令的机器周期数不固定（微程序控制器采用）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><ul>
<li><p>基本思想：把操作控制信号编制成微指令，存放到控制存储器里，运行时，从控存中取出微指令，产生指令运行所需的操作控制信号</p>
<ul>
<li>以设计软件的方法设计硬件</li>
</ul>
</li>
<li><p>微命令：构成控制序列的最小单位，控制器件向执行部件发出的各种控制命令</p>
</li>
<li><p>微操作：微命令的操作过程，微操作是执行部件中最基本的操作，分为两类</p>
<ul>
<li>互斥的微操作：不能在同一 CPU 周期并行执行的微操作</li>
<li>相容的微操作：能够在同一 CPU 周期并行执行的微操作</li>
</ul>
</li>
<li><p>微指令：把在同一 CPU 周期内并行执行的微操作控制信息，存储在控制存储器里，称为一条微指令。分为两部分</p>
<ul>
<li><p>操作控制字段：又称微操作码字段，用以产生某一步操作所需的各个微操作控制信号。</p>
<ul>
<li>某位为 1 表明发微命令。微指令持续时间为一个 CPU 周期</li>
</ul>
</li>
<li><p>顺序控制字段：又称微地址码字段，用以控制产生下一条要执行的微指令地址</p>
</li>
</ul>
</li>
<li><p>微程序：一系列微指令的有序集合就是微程序。，一段微程序对应一条机器指令</p>
</li>
<li><p>微地址：存放微指令的控制存储器的单元地址</p>
</li>
<li><p>一些相关的寄存器</p>
<ul>
<li>控制存储器 μCM：这是微程序控制器的核心部件，用来存放微程序</li>
<li>微指令寄存器 μIR：用来存放从 μCM 取出的正在执行的微指令</li>
<li>微命令寄存器：用来保存一条微指令的操作控制字段和判别测试字段的信息</li>
<li>微地址寄存器 μMAR：决定将要访问的下一条微指令的地址</li>
</ul>
</li>
<li><p>CPU 周期与微指令的周期之间的关系</p>
<ul>
<li>微指令周期等于读出微指令的时间加上执行该条微指令的时间</li>
<li>一个微指令周期时间设计恰好和 CPU 周期时间相等</li>
</ul>
</li>
<li><p>微程序设计技术</p>
<ul>
<li><p>微命令的编码方法</p>
<ul>
<li><p>直接表示法：操作控制字段中的各位分别可以直接控制计算机，不需要进行译码</p>
<style>.oganjwhkpnmr{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203758900.png" class="oganjwhkpnmr" alt="image-20240528203758900">
</li>
<li><p>编码表示法：将操作控制字段分为若干个小段，每段内采用最短编码法，段与段之间采用直接控制法</p>
<style>.gulhqvadpumw{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203904975.png" class="gulhqvadpumw" alt="image-20240528203904975">
</li>
<li><p>混合编码法：两者的结合</p>
<style>.uacbsclmxssn{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203943373.png" class="uacbsclmxssn" alt="image-20240528203943373">
</li>
<li><p>编码的原则</p>
<ul>
<li>把互斥性的微命令分在同一段内，兼容性的微命令分在不同段内</li>
<li>每个小段中包含的信息位不能太多</li>
<li>一般每个小段还要留出一个状态，表示本字段不发出任何微命令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.yrsdfgsxvdio{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204109642.png" class="yrsdfgsxvdio" alt="image-20240528204109642">

<ul>
<li><style>.cfbsdllokamu{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204129483.png" class="cfbsdllokamu" alt="image-20240528204129483"></li>
</ul>
<style>.eeohuhrdvjpo{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204143019.png" class="eeohuhrdvjpo" alt="image-20240528204143019">

<style>.kqdoqqtjykbi{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204156706.png" class="kqdoqqtjykbi" alt="image-20240528204156706">

<ul>
<li><p>微指令地址的形成</p>
<ul>
<li>入口地址：每条机器指令对应一段微程序，由机器指令的操作码字段指出各段微程序的入口地址。主要方式有<ul>
<li>计数器的方式：微程序控制器中也有一个微程序计数器 μPC，一般情况下都是将微地址寄存器 μMAR 作为 μPC</li>
<li>多路转移的方式</li>
</ul>
</li>
</ul>
</li>
<li><p>微指令的格式，分为</p>
<ul>
<li><p>水平型微指令：指一次能定义并能并行执行多个微命令的微指令</p>
<ul>
<li>并行能力强，速度快，但难以掌握</li>
</ul>
</li>
<li><p>垂直型微指令：采用编码方式，一次只能执行一到二个微命令</p>
<ul>
<li>速度慢，相较而言容易掌握</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h2><ul>
<li><p>实现方法：通过逻辑电路直接连线而产生的，又称为组合逻辑控制方式</p>
</li>
<li><p>设计目标：使用最少元件，速度最高</p>
</li>
<li><p>指令的执行流程</p>
<style>.ueftycjuyemp{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528210718631.png" class="ueftycjuyemp" alt="image-20240528210718631">
</li>
<li><p>微信号的产生</p>
<ul>
<li>在微程序控制器中，微操作控制信号由微指令产生</li>
<li>在硬联线控制器中，某一微操作控制信号由布尔代数表达式描述的输出函数产生<ul>
<li>设计步骤<ul>
<li>画出指令流程图，列出微操作时间表，进行微操作信号的综合，实现电路</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="传统-CPU"><a href="#传统-CPU" class="headerlink" title="传统 CPU"></a>传统 CPU</h2><ul>
<li>略</li>
</ul>
<h2 id="流水-CPU"><a href="#流水-CPU" class="headerlink" title="流水 CPU"></a>流水 CPU</h2><ul>
<li><p>并行性：具有可以同时进行运算或操作的特性，在同一时刻或在同一时间间隔内完成两种或两种以上的工作，他们在时间上相互重叠，都体现了并行性</p>
<ul>
<li>时间并行（重叠）：让多个处理过程在时间上相互错开，轮流使用同一套硬件设备的各个部件， 实现方式就是采用流水处理</li>
<li>空间并行（资源重复）：以数量取胜，</li>
<li>时间+空间并行：超标量流水线技术它能真正的体现同时性</li>
</ul>
</li>
<li><p>流水线的分类：指令流水线（按照指令步骤的并行）、算术流水线（按照运算操作步骤的并行）、处理机流水线（按照程序步骤的并行）</p>
</li>
<li><p>流水线中的主要问题</p>
<ul>
<li><p>资源相关：多条指令进入流水线后在同一时钟周期内争用同一功能部件</p>
<ul>
<li>解决办法：后边指令拖一拍再推进；增设一个功能部件</li>
</ul>
</li>
<li><p>数据相关</p>
<ul>
<li>RAW (Read After Write)：后面指令用到前面指令所写的数据</li>
<li>WAW (Write After Write)：两条指令写同一个单元（在简单流水线中没有此类相关，因为不会乱序执行）</li>
<li>WAR (Write After Read)：后面指令覆盖前面指令所读的单元（在简单流水线中没有此类相关）</li>
<li>解决办法： 可以推后后继指令对相关单元的读操作</li>
</ul>
</li>
<li><p>控制相关 </p>
<ul>
<li>引起原因：转移指令</li>
<li>解决办法：延迟转移法，转移预测法</li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.zwgabeerpiyq{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528213126274.png" class="zwgabeerpiyq" alt="image-20240528213126274">

<h1 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h1><h2 id="总线的概念和结构形态"><a href="#总线的概念和结构形态" class="headerlink" title="总线的概念和结构形态"></a>总线的概念和结构形态</h2><ul>
<li><p>总线的基本概念：总线是构成计算机系统的互联机构，是多个系统功能部件之间进行数据传送的公共通路</p>
</li>
<li><p>总线的分类</p>
<ul>
<li>内部总线：CPU 内部连接各寄存器及运算器部件之间的总线</li>
<li>系统总线：外部总线，CPU 和计算机系统中其他高速功能部件相互连接的总线</li>
<li>I&#x2F;O总线：中低速 I&#x2F;O 设备相互连接的总线</li>
</ul>
</li>
<li><p>总线的特性</p>
<ul>
<li>物理特性：总线的物理连接方式</li>
<li>功能特性：每根线的功能</li>
<li>电气特性：每根线上信号的传递方向及有效电平范围</li>
<li>时间特性：规定了每根总线在什么时间有效</li>
</ul>
</li>
<li><p>总线标准</p>
<ul>
<li>由于标准化，不同厂家生产的内部实现不同但功能相同的功能部件可以互换使用</li>
<li>已经出现了很多总线标准：PCI、ISA</li>
</ul>
</li>
<li><p>总线带宽：总线本身所能达到的最高传输速率</p>
<ul>
<li>一次操作可以传输的数据位数（MB&#x2F;s），如 S100 为 8 位，ISA 为 16 位，EISA 为 32 位，PCI 可达 64 位</li>
<li>总线宽度不会超过微处理器外部数据总线的宽度</li>
</ul>
</li>
<li><style>.emqjrwypguwg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529180641225.png" class="emqjrwypguwg" alt="image-20240529180641225">
</li>
<li><p>单机系统中总线的基本结构</p>
<ul>
<li><p>单总线：使用一条单一的系统总线来连接 CPU、内存和 I&#x2F;O 设备</p>
<ul>
<li><p>要求连接到总线上的逻辑部件必须高速运行；而当不再使用总线时，能迅速放弃总线控制权</p>
<style>.mnxexborkwvf{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529180852668.png" class="mnxexborkwvf" alt="image-20240529180852668"></li>
</ul>
</li>
<li><p>多总线：在 CPU、主存、I&#x2F;O 之间互联采用多条总线</p>
<ul>
<li><style>.iixnvbobupuv{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181002510.png" class="iixnvbobupuv" alt="image-20240529181002510"></li>
</ul>
</li>
</ul>
</li>
<li><p>总线的内部结构</p>
<ul>
<li><p>早期是处理器芯片引脚的延伸，是处理器与 I&#x2F;O 设备适配器的通道</p>
<ul>
<li>总线结构紧密与 CPU 相关，通用性较差</li>
</ul>
</li>
<li><p>当代流行的内部结构</p>
<ul>
<li><style>.jkqqntxkzifw{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181527522.png" class="jkqqntxkzifw" alt="image-20240529181527522"></li>
</ul>
</li>
</ul>
</li>
<li><p>现代大多数计算机采用了分层次的多总线结构，三层次：CPU总线、PCI 总线和 ISA 总线</p>
<style>.trwgkesjixje{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181604088.png" class="trwgkesjixje" alt="image-20240529181604088"></li>
</ul>
<h2 id="总线接口"><a href="#总线接口" class="headerlink" title="总线接口"></a>总线接口</h2><ul>
<li><p>计算机中信息传输的三种基本方式：</p>
<ul>
<li>串行传输：仅使用一条传输线，采用脉冲传送，速度慢</li>
<li>并行传输：系统总线上传输的信息必须是并行传输。每一个数据位都需要使用一条传输线，一般使用电位传输法</li>
<li>分时传输：总线复用或共享总线的部件分时使用总线</li>
</ul>
</li>
<li><p>总线接口的基本概念：接口是 CPU 、主存和外设之间通过总线进行连接的逻辑部件</p>
<style>.fmfjvymjdbgn{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531142702926.png" class="fmfjvymjdbgn" alt="image-20240531142702926">
</li>
<li><p>接口的典型功能：控制、缓冲、状态、转换、整理、程序 中断</p>
<ul>
<li>一个适配器的两个接口：一个同系统总线相连，采用并行 方式，另外一个同设备相连，可能采用并行方式或是串行方式</li>
</ul>
</li>
<li><style>.xdsueqbcqbqm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531142756627.png" class="xdsueqbcqbqm" alt="image-20240531142756627"></li>
</ul>
<h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><ul>
<li><p>连接到总线上的功能模块有两种：主动和被动，主动方可以启动一个总线周期，被动方只能响应主动方的请求。每次总线操作中，只能有一个主动方，但被动方可以有多个</p>
<ul>
<li>对于多个设备提出的占用总线请求， 一般采用优先级或公平策略进行仲裁</li>
</ul>
</li>
<li><p>为了解决多个功能模块争用总线的问题，必须设置总线仲裁部件，按照仲裁电路的位置不同，分为：集中式和分布式两种</p>
</li>
<li><p>集中式仲裁有三种</p>
<ul>
<li><p>链式查询方式：离中央仲裁器最近的设备具有最高优先权，离总线控制器越 远，优先权越低</p>
</li>
<li><p>计数器定时查询方式：</p>
<ul>
<li><p>总线上的任一设备要求使用总线时， 通过 BR 线发出总线请求</p>
</li>
<li><p>中央仲裁器接到请求信号以后，在 BS 线为 “0” 的情况下让计数器开始计数，计数值通过一组地址线发向各设备</p>
</li>
<li><p>每个设备接口都有一个设备地址判别电路， 当地址线上的计数值与请求总线的设备地址相一致时，该设备置 “1” BS 线，获得了总线使用权，此时中止计数查询</p>
</li>
<li><p>计数器从 0 开始，则设备的优先级和链式查询一样，优先级是固定的，计数器从中止点开始奇数，则各个设备优先级相同</p>
</li>
</ul>
</li>
<li><p>独立请求的方式：</p>
<ul>
<li>每个共享总线的设备都有一对总线请求线 BRi 和总线授权线 BGi。总线仲裁器中有一个排队电路，它根据一定的优先次序决定首先响应哪个设备的请求</li>
<li>很灵活，当代总线标准普遍采用独立请求的方式</li>
</ul>
</li>
</ul>
</li>
<li><p>分布式：不需要中央仲裁器，而是多个仲裁器竞争使用总线</p>
<ul>
<li>当它们有总线请求时，把它们唯一的仲裁号发送到共享的仲裁总线上</li>
<li>每个仲裁器将 仲裁总线上得到的号与自己的号进行比较</li>
<li>如果仲裁总线上的号大，则它的总线请求不予响应，并撤消它的仲裁号</li>
<li>最后，获胜者的仲裁号保留在仲裁总线上</li>
</ul>
</li>
<li><p>总线定时：事件出现在总线上的时序关系，分为：同步定时、异步定时</p>
<ul>
<li>同步定时：事件出现在总线 上的时刻由总线时钟信号来确定</li>
<li>异步定时：后一事件出现在总线上的时刻取决于前一事件的出现</li>
</ul>
</li>
<li><p>总线的信息传递的过程：请求总线、总线仲裁、寻址、信息传送、状态返回</p>
</li>
<li><style>.itnlvbaeifjy{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531161030531.png" class="itnlvbaeifjy" alt="image-20240531161030531"></li>
</ul>
<style>.dqjmuahosbot{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531161041767.png" class="dqjmuahosbot" alt="image-20240531161041767">

<style>.hltvbqjiabuc{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531161058791.png" class="hltvbqjiabuc" alt="image-20240531161058791">

<ul>
<li><p>总线的数据传送模式</p>
<ul>
<li><p>读、写操作：读操作是由从方到主方的数据传送； 写操作是由主方到从方的数据传送</p>
</li>
<li><p>块传送操作：只需给出块的起始地址，然后对固定块长度的数据一个接一个地读出或写入（猝发式传送）</p>
</li>
<li><p>写后读、读修改写操作：只给出地址一次，或进行先写后读操作，或进行先读后写操作</p>
</li>
<li><p>广播、广集操作：允许一个主方对多个从方进行写操作，这种操作称为广播。与广播相反的操作称为广集</p>
</li>
</ul>
</li>
</ul>
<style>.sxykxugmukmb{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531161613526.png" class="sxykxugmukmb" alt="image-20240531161613526">

<h1 id="外围设备"><a href="#外围设备" class="headerlink" title="外围设备"></a>外围设备</h1><h2 id="外围设备概述"><a href="#外围设备概述" class="headerlink" title="外围设备概述"></a>外围设备概述</h2><ul>
<li><p>外围设备的基本组成：</p>
<ul>
<li>存储介质：具有保存信息的物理特征</li>
<li>驱动装置：用于移动存储介质</li>
<li>控制电路：它向存储介质发送数据或从存储介质接受数据</li>
</ul>
</li>
<li><p>外围设备的分类：输入设备、输出设备、外存设备、数据通信设备和过程控制设备几大类</p>
<ul>
<li>每一种外围设备，都是在它自己的设备控制器控制下进行工作，而设备控制器则通过I&#x2F;O接口和主机连接，并受主机控制</li>
</ul>
</li>
</ul>
<h2 id="磁盘存储设备"><a href="#磁盘存储设备" class="headerlink" title="磁盘存储设备"></a>磁盘存储设备</h2><ul>
<li><p>磁盘记录原理</p>
<ul>
<li>磁表面存储，是用某些磁性材料薄薄地涂在金属铝或塑料表面作载磁体来存储信息</li>
</ul>
</li>
<li><p>磁表面存储器的读写原理</p>
<ul>
<li>写操作：利用磁头来形成 磁层中的磁化状态<ul>
<li>电磁变换，利用磁头写线圈中的脉冲电流，可把一位二进制代码转换成载磁体存储元的不同剩磁状态</li>
</ul>
</li>
<li>读操作：利用磁头来判别磁层中的磁化状态<ul>
<li>通过磁电变换，利用磁头读出线圈， 可将由存储元的不同剩磁状态表示的二进制代码转换成电信号输出</li>
</ul>
</li>
</ul>
</li>
<li><p>硬磁盘：记录介质为硬质圆形盘片的磁表面存储器</p>
<ul>
<li><p>包括：磁记录介质、磁盘控制器（数据并-串变换电路 串-并变换电路）、磁盘驱动器</p>
</li>
<li><p>写入时，将计算机并行送来的数据取至并串变换寄存器，变为串行数据，然后一位一位地由功率放大并加到写磁头线圈上产生电流，从而在盘片磁层上形成按位的磁化存储元</p>
</li>
<li><p>读出时，此读出信息经放大检测就可还原成原来存入的数据，由于数据是一位一位串行读出的，故要送至串-并变 换寄存器变换为并行数据，再并行送至计算机</p>
</li>
<li><p>根据盘片结构也分为：可移动磁头固定盘片、可移动磁头可换盘片、固定磁头（每个磁道一个磁头）</p>
</li>
</ul>
</li>
<li><p>温彻斯特磁盘：可移动磁头固定盘片的磁盘机。高速旋转在盘面上形成的气垫将磁头平稳浮起，优点是防尘性能好，工作环境要求不高</p>
</li>
<li><p>磁盘驱动器的基本结构：定位驱动系统、主轴系统和数据转换系统</p>
<style>.petlfifhucrd{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531193436351.png" class="petlfifhucrd" alt="image-20240531193436351">
</li>
<li><p>磁盘控制器是主机与磁盘驱动器之间的接口，它需要有两个方面的接口： </p>
<ul>
<li>一个是与主机的接口，控制外存与主机总线之间交换 数据；另一个是与设备的接口，根据主机命令控制设备的操作</li>
</ul>
</li>
<li><p>主机与磁盘驱动器交换数据：</p>
<ul>
<li><p>磁盘上的信息经读磁头读出以后送读出放大器，然后进行数据与时钟的分离，再进行串——并变换、格式变换，最后送入数据缓冲器，经 DMA (直接存储器传送) 控制将数据传送到主机总线</p>
<style>.xxhmcfyzckbe{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531193644566.png" class="xxhmcfyzckbe" alt="image-20240531193644566"></li>
</ul>
</li>
<li><p>磁盘上的信息分布：</p>
<ul>
<li><p>盘片的上下两面都能记录信息，通常把磁盘片表面称为记录面</p>
</li>
<li><p>记录面上一系列同心圆称为磁道，每个盘片表面通常有几百到几千个磁道</p>
</li>
<li><p>每个磁道又分为若干个扇区</p>
</li>
<li><p>磁盘地址由记录面号（也称磁头号)、磁道号和扇区号三部分组成</p>
<style>.nesaaouuofmk{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531193843290.png" class="nesaaouuofmk" alt="image-20240531193843290"></li>
</ul>
</li>
<li><p>磁盘存储器的技术指标：</p>
<ul>
<li><p>存储密度：存储密度分道密度、位密度和面密度</p>
<ul>
<li>道密度：沿磁盘半径方向单位长度上的磁道数</li>
<li>位密度：磁道单位长度上能记录的二进制代码位数</li>
<li>面密度：位密度和道密度的乘积</li>
</ul>
</li>
<li><p>存储容量：一个磁盘存储器所能存储的字节总数，称为磁盘存储器的存储容量</p>
</li>
<li><p>存取时间：从发出读写命令后，磁头从某一起始位置移动至新的记录位置，到开始从盘片表面读出或写入信息加上传送数据所需要的时间</p>
<ul>
<li>取决于：寻道时间、旋转时间、数据传送时间</li>
</ul>
</li>
<li><p>数据传输效率：磁盘存储器在单位时间内向主机传送数据的字节数</p>
<ul>
<li>假设磁盘旋转速度为 n转&#x2F;秒，每条磁道容量为 N 个字节，则数据传输率：<code>Dr = nN</code> (字节&#x2F;秒)</li>
</ul>
</li>
</ul>
</li>
<li><style>.oqnklihkyacg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531194247266.png" class="oqnklihkyacg" alt="image-20240531194247266"></li>
</ul>
<style>.obmlolfknixs{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531194301199.png" class="obmlolfknixs" alt="image-20240531194301199">

<h2 id="磁盘存储设备的技术发展"><a href="#磁盘存储设备的技术发展" class="headerlink" title="磁盘存储设备的技术发展"></a>磁盘存储设备的技术发展</h2><ul>
<li><p>磁盘 cache</p>
<ul>
<li>主存和 CPU 之间设置高速缓存 cache 是为了弥补主存和 CPU之间速度上的差异</li>
<li>同样，磁盘 cache 是为了弥补慢速磁盘和主存之间速度上的差异</li>
<li>磁盘 cache 利用了被访问数据的空间局部性和时间局部性原理</li>
</ul>
</li>
<li><p>磁盘阵列 RAID</p>
<ul>
<li>RAID 称廉价冗余磁盘阵列，它是用多台磁盘存储器组成的大容量外存系统</li>
<li>利用数据分块技术和并行处理技术，在多个磁盘上交错存放数据，可实现数据的并行存储、交叉存储、单独存储</li>
</ul>
</li>
</ul>
<h2 id="磁带存储设备"><a href="#磁带存储设备" class="headerlink" title="磁带存储设备"></a>磁带存储设备</h2><ul>
<li>磁带机的记录原理与磁盘机基本相同，只是它的载磁体是一种带状塑料，叫做磁带</li>
<li>磁带存储设备由磁带机和磁带两部分组成。磁带速度比磁盘速度慢，原因是磁带上的数据采用顺序访问方式，而磁盘则采用随机访问方式，所以它通常存储海量数据</li>
</ul>
<h2 id="光盘和磁光盘存储设备"><a href="#光盘和磁光盘存储设备" class="headerlink" title="光盘和磁光盘存储设备"></a>光盘和磁光盘存储设备</h2><ul>
<li><p>只读型光盘系统都基于一个共同原理，即光盘上的信息以坑点形式分布，有坑点表示为 “1”，无坑点表示为 “0”，一系列的坑点 (存储元) 形成信息记录道。必须采用激光作为光源，并采用良好的光学系统才能实现</p>
</li>
<li><p>光盘的记录信息以凹坑方式永久性存储</p>
</li>
</ul>
<h2 id="显示设备"><a href="#显示设备" class="headerlink" title="显示设备"></a>显示设备</h2><ul>
<li><p>器件：CRT（阴极射线管）、LCD、等离子体 </p>
</li>
<li><p>显示内容：字符、图象 </p>
</li>
<li><p>CRT 中又可以分类： </p>
<ul>
<li>扫描方式：光栅扫描和随机扫描 </li>
<li>分辨率：高分辨率和低分辨率 <ul>
<li>分辨率：显示器所能显示的像素个数</li>
<li>灰度级：像素点的亮暗差别（黑白）颜色的不同（彩色）。灰度级越多，图象层次越清楚越逼真</li>
</ul>
</li>
<li>显示颜色：单色和彩色 </li>
<li>显示屏幕大小：14、15、17、19 等</li>
</ul>
</li>
<li><p>刷新：电子束打在荧光粉上引起的发光只能维持几十毫 秒的时间。因此必须让电子束反复不断地扫描整个屏幕， 该过程称为刷新</p>
</li>
</ul>
<h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="外围设备的定时方式和信息交换方式"><a href="#外围设备的定时方式和信息交换方式" class="headerlink" title="外围设备的定时方式和信息交换方式"></a>外围设备的定时方式和信息交换方式</h2><ul>
<li><p>高速的 CPU 与速度参差不齐的外设怎样在时间上同步？</p>
<ul>
<li>解决办法时在 CPU 和外设之间数据传送时加以定时（同步定时）</li>
</ul>
</li>
<li><p>输入输出设备同 CPU 交换数据的过程：</p>
<ul>
<li><p>输入过程：</p>
<ul>
<li>CPU 把一个地址值放到地址总线上，这一步将选择某一输入设备</li>
<li>CPU 等候输入设备的数据成为有效</li>
<li>CPU 从数据总线输入数据，并放在一个相应的寄存器中</li>
</ul>
</li>
<li><p>输出过程：</p>
<ul>
<li>CPU 把一个地址值放到地址总线上，这一步将选择 某一输出设备</li>
<li>CPU 把数据放在数据总线上</li>
<li>输出设备认为数据有效，从而把数据取</li>
</ul>
</li>
</ul>
</li>
<li><p>外围设备的速度分类：</p>
<ul>
<li>速度慢的设备：CPU只需要接受或者发送数据即可</li>
<li>中速的设备：CPU从外设接收一个字，则它首先询问外设的状态，如果准备就绪，则 CPU 将数据取走，发出响应信号，外设将状态位复位，进行下一个字节的交换。如果外设状态是忙，那 CPU 进入一个循环，每次询问外设状态</li>
<li>高速的设备：采用同步定时方式，CPU 和外设以相等的时间间隔执行操作</li>
</ul>
</li>
<li><p>信息的交换方式：</p>
<style>.xcvfwxdpysqg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531203549926.png" class="xcvfwxdpysqg" alt="image-20240531203549926">

<ul>
<li>程序查询方式：CPU 和外围设备之间的传送完全靠计算机程序控制，由于查询循环的存在，浪费 CPU 时间</li>
<li>程序中断方式：中断是外围设备用来 “主动” 通知 CPU，节省 CPU 时间<ul>
<li>以上两种方式适用于：数据传输率比 较低的外围设备</li>
</ul>
</li>
<li>直接内存访问（DMA）方式：DMA控制器从CPU完全接管对总线的控制，数据交换不经过 CPU，而直接在内存和外围设备之间进行，完全由硬件控制</li>
<li>通道方式：通道是一个具有特殊功能的处理器，实现对外围设备的统一管理<ul>
<li>以上两种方式适用于：数据传输率比较高的设备</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="程序的查询方式"><a href="#程序的查询方式" class="headerlink" title="程序的查询方式"></a>程序的查询方式</h2><ul>
<li><p>数据在 CPU 和外围设备之间的传送完全靠计算机程序控制，是在CPU主动控制下进行的</p>
<ul>
<li>当需要输入&#x2F;输出时，CPU 暂停执行主程序，转去执行设备输入&#x2F;输出的服务程序，根据服务 程序中的 I&#x2F;O 指令进行数据传送</li>
</ul>
</li>
<li><p>设备编址</p>
<ul>
<li>统一编址：输入&#x2F;输出设备和内存单元一样看待，联合变址，可以用访问内存的指令访问 I&#x2F;O 设备，不需要专门的 I&#x2F;O 指令组</li>
<li>单独编址：内存和 I&#x2F;O 设备分开看待，需要专门的 I&#x2F;O 指令组</li>
</ul>
</li>
<li><p>输入输出指令</p>
<ul>
<li>I&#x2F;O 指令：<ul>
<li>置 “1” 或置 “0” I&#x2F;O 接口的某些控制触发器，用于控制设备的某些动作</li>
<li>测试设备状态</li>
<li>传送数据</li>
</ul>
</li>
</ul>
</li>
<li><p>程序查询方式的接口：设备选择电路、数据缓冲寄存器、设备状态寄存器</p>
</li>
</ul>
<style>.vlpmrgusfngq{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531204806636.png" class="vlpmrgusfngq" alt="image-20240531204806636">

<h2 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h2><ul>
<li>中断（Interrupt）是指 CPU 暂时中止现行程序， 转去处理随机发生的紧急事件，处理完后自动 返回原程序的功能和技术</li>
<li>中断处理过程注意几个问题： <ul>
<li>响应中断时机：外界中断请求是随机的， 但 CPU 只有在当前指令执行完毕后，才转至公操作</li>
<li>断点保护问题（PC，寄存器内容和状态 的保存）</li>
<li>开中断和关中断问题</li>
<li>中断是由软硬件结合起来实现的</li>
</ul>
</li>
</ul>
<style>.zsqgtnkwckab{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531210416282.png" class="zsqgtnkwckab" alt="image-20240531210416282">

<ul>
<li><p>程序中断方式的基本接口</p>
<ul>
<li>BS 外设接口忙（BuSy）标志 </li>
<li>RD 外设准备就绪（ReaDy）标志 </li>
<li>EI（Enable Interrupt中断允许触发器）</li>
<li>IR（Interrupt Request）中断请求触发器 </li>
<li>IM（Interrupt Mask）中断屏蔽触发器</li>
</ul>
</li>
<li><p>单级中断</p>
<ul>
<li>所有中断源属于同一级，离 CPU 越近优先级越高</li>
<li>不允许其它中断源再打断中断服务程序，即使优先权比它高的中断源也不能再打断</li>
<li>中断向量：CPU 响应中断时，由硬件直接产生一个固定的地址，即向量地址<ul>
<li>由向量地址指出每个中断源设备的中断服务程序入口，每个中断源分别有一个中断服务程序</li>
<li>有些产生的向量地址不是直接地址，而是一个偏移量，有的则是通过地址转移法来灵活的分配中断处理程序</li>
</ul>
</li>
</ul>
</li>
<li><p>多级中断</p>
<ul>
<li>一个系统有 n 级中断，则 CPU 中有 n 个 IR、IM，某级中断被响应后，则关闭本级和低于本级的 IM，开放更高级的 IM</li>
<li>多级中断可以嵌套，但同一级的中断不允许嵌套</li>
</ul>
</li>
</ul>
<h2 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h2><ul>
<li><p>直接存储器访问（Direct Memory Address） DMA 方式是为了在主存储器与 I&#x2F;O 设备间高速交换批量数据而设置的</p>
<ul>
<li>基本思想是：通过硬件控制实现主存与 I&#x2F;O 设备间的直接数据传送，在传送过程中无需 CPU 的干预</li>
</ul>
</li>
<li><p>基本操作</p>
<ul>
<li>从外围设备发出 DMA 请求</li>
<li>CPU 响应请求，把 CPU 工作改为 DMA 操作方式，DMA 控制器从 CPU 接管总线的控制</li>
<li>由 DMA 控制器对内存寻址，即决定数据传送的内存单元地址及数据传送个数的计数，并执行数据传送的操作</li>
<li>向 CPU 报告 DMA 操作的结束， DMA 让出总线控制权</li>
</ul>
</li>
<li><p>DMA 传送的方式</p>
<ul>
<li>停止CPU访问内存：主机响应 DMA 请求后，让出存储总线，直到 DMA 控制器把总线控制权交还给 CPU</li>
<li>周期挪用方式：一旦 I&#x2F;O 设备有 DMA 请求，则由 I&#x2F;O 设备挪用一个或几个内存周期</li>
<li>DMA 和 CPU 交替访问内存工作方式：如果 CPU 的工作周期比内存存取周期长很多，可以采用该种方法</li>
</ul>
</li>
<li><p>选择型和多路型 DMA 控制器</p>
<ul>
<li>选择型：物理上连接多个设备，逻辑上只允许连接一个设备</li>
<li>多路型：不仅物理上可以连接多个外围设备，而且在逻辑上也允许这些外围设备同时工作<ul>
<li>以字节交叉方式通过 DMA 控制器进行数据传送</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h2><ul>
<li>通道是计算机系统中代替 CPU 管理控制外设的独立部件，是一种能执行有限 I&#x2F;O 指令集合（通道 命令）的 I&#x2F;O 处理机</li>
<li>CPU 将 “传输控制” 功能下放给通道后只负责 “数据处理” 功能<ul>
<li>通道与CPU分时使用存储器，实现 CPU 内部运算与 I&#x2F;O 设备的并行工作</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
