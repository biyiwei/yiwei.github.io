<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yiweiboi.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yiweiBoi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yiweiboi.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-24 15:55:38" itemprop="dateCreated datePublished" datetime="2024-01-24T15:55:38+08:00">2024-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-04 16:33:48" itemprop="dateModified" datetime="2023-11-04T16:33:48+08:00">2023-11-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">C++Primer-10-泛型算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-20 09:13:45 / 修改时间：17:46:24" itemprop="dateCreated datePublished" datetime="2024-01-20T09:13:45+08:00">2024-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="10-泛型算法"><a href="#10-泛型算法" class="headerlink" title="10 泛型算法"></a>10 泛型算法</h1><blockquote>
<p>顺序容器只定义了很少的操作，用户可能还做一些其他很有用的操作，标准库并未给每个容器都定义成员函数来实现它们，而是定义了一组 <strong>泛型算法</strong></p>
<p><strong>算法</strong> 是因为它们实现了一些经典算法的公共接口，<strong>泛型</strong> 是因为它们可以用于不同类型的元素和多种容器类型</p>
</blockquote>
<h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><blockquote>
<p>大多数算法都定义在头文件 <strong>algorithm</strong> 中，标准库还在头文件 <strong>numeric</strong> 中定义了一组数值泛型算法</p>
<p>一般情况下，算法并不直接操作容器，而是遍历由两个迭代器指定的一个容器范围来进行操作</p>
</blockquote>
<h4 id="迭代器令算法不依赖于容器"><a href="#迭代器令算法不依赖于容器" class="headerlink" title="迭代器令算法不依赖于容器"></a>迭代器令算法不依赖于容器</h4><ul>
<li><strong>find</strong> 算法的前两个参数表示元素范围的迭代器，第三个参数是一个值，返回第一个指向等于给定值的元素的迭代器<ul>
<li>如果没有匹配，则 find 返回第二个参数表示搜索失败，所以我们可以比较返回值和第二个参数判断是否成功</li>
<li>完成算法中的这些步骤都不依赖于容器所保存的元素类型</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095429785.png" class="" title="image-20240120095429785">

<h4 id="但算法依赖于元素类型的操作"><a href="#但算法依赖于元素类型的操作" class="headerlink" title="但算法依赖于元素类型的操作"></a>但算法依赖于元素类型的操作</h4><ul>
<li>虽然迭代器的使用令算法不依赖容器类型，但大多数算法都使用了一个或多个元素类型上的操作</li>
</ul>
<blockquote>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器上，执行迭代器的操作</p>
<p>这个特性带来了一个非常必要的编程假定：算法永远不会改变底层容器的大小</p>
</blockquote>
<h2 id="10-2-初始泛型算法"><a href="#10-2-初始泛型算法" class="headerlink" title="10.2 初始泛型算法"></a>10.2 初始泛型算法</h2><blockquote>
<p>除了少数例外，标准库算法都对一个范围内的元素进行操作，这个元素范围称为 <strong>输入范围</strong></p>
<p>虽然大多数算法遍历输入范围的方式类似，但它们使用范围中元素的方式不同</p>
</blockquote>
<h3 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法</h3><ul>
<li><p>只读取输入范围的元素，而不改变元素</p>
</li>
<li><p>find 就是一种只读算法，另一个只读算法是 <strong>accumulate</strong>，定义在头文件 numeric 中</p>
<ul>
<li><p>接受三个参数，前两个指出需要 <strong>求和</strong> 的范围，第三个参数是和的初始值</p>
<blockquote>
<p>accumulate 的第三个参数的类型决定了函数中使用哪个加法运算符及返回值的类型</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120094024649.png" class="" title="image-20240120094024649">

<blockquote>
<p>对于只读算法，通常最好使用 cbegin 和 cend</p>
</blockquote>
<h4 id="操作两个序列的算法"><a href="#操作两个序列的算法" class="headerlink" title="操作两个序列的算法"></a>操作两个序列的算法</h4><ul>
<li><p>另一个只读算法是 <strong>equal</strong>，用于确定两个序列算法保存相同的值</p>
<ul>
<li><p>接受三个迭代器，前两个表示输入范围，第三个表示第二个序列的首元素</p>
</li>
<li><p>它将第一个序列中每个元素于第二个序列中对应元素进行比较，都相等返回 true，否则返回 false</p>
<blockquote>
<p>equal 基于一个非常重要的 <strong>假设</strong>：第二个序列至少于第一个序列一样长</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095507828.png" class="" title="image-20240120095507828">

<blockquote>
<p>那些只接受一个单一迭代器表示第二个序列的算法，都假定第二个序列至少于第一个序列一样长</p>
</blockquote>
<h3 id="10-2-2-写容器元素的算法"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a>10.2.2 写容器元素的算法</h3><ul>
<li><p>这类算法要求原序列大小至少不小于我们要求算法写入的元素数目（因此它们最多写入和给定序列一样多的元素）</p>
</li>
<li><p><strong>fill</strong> 算法接受一对迭代器参数表示范围，还接受一个值作为第三个参数，将给定值赋予输入序列中的每个元素</p>
<blockquote>
<p>因此 fill 算法很安全，只要确保传递了一个有效的输入序列</p>
</blockquote>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095532562.png" class="" title="image-20240120095532562">

<h4 id="算法不检查写操作"><a href="#算法不检查写操作" class="headerlink" title="算法不检查写操作"></a>算法不检查写操作</h4><ul>
<li><p>一些算法只接受一个迭代器来指出一个单独的目的位置</p>
</li>
<li><p><strong>fill_n</strong> 函数接受一个单迭代器、一个计数器和一个值，它将给定值赋予迭代器指向的元素开始的指定个元素</p>
<blockquote>
<p>full_n 假定：dest 指向一个元素，而从 dest 开始的序列至少包含 n 个元素</p>
</blockquote>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095605020.png" class="" title="image-20240120095605020">

<blockquote>
<p>一个很容易犯的 <strong>错误</strong> 就是：在一个空容器上调用 fill_n</p>
<p>向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素</p>
</blockquote>
<h4 id="介绍-back-inserter"><a href="#介绍-back-inserter" class="headerlink" title="介绍 back_inserter"></a>介绍 back_inserter</h4><ul>
<li><p>一种保证算法有足够空间来容纳输入数据的方法是使用 <strong>插入迭代器</strong></p>
<ul>
<li>一般情况下，我们通过一个迭代器向容器赋值时，值被赋予迭代器指向的元素</li>
<li>而当我们通过一个插入迭代器赋值时，一个值相等的新元素被添加到容器中</li>
</ul>
</li>
<li><p><strong>back_inserter</strong> 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器</p>
<ul>
<li>当我们通过它赋值时，赋值运算符会调用 <strong>push_back</strong> 将一个给定值元素加入容器</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100204810.png" class="" title="image-20240120100204810">

<ul>
<li>我们通常将插入迭代器作为算法的 <strong>目的位置</strong> 来使用</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100247186.png" class="" title="image-20240120100247186">

<h4 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h4><ul>
<li>拷贝算法也是向 目的位置迭代器 指向的输入序列 中的元素 写入数据的算法<ul>
<li>接受三个迭代器，前两个表示输入范围，第三个表示目的序列的起始位置</li>
<li>将输入范围中的元素拷贝到目的序列中</li>
<li>因此，目的序列至少包含于输入序列一样多的元素</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100846520.png" class="" title="image-20240120100846520">

<ul>
<li><p>很多算法都提供了 <strong>拷贝版本</strong>，它们不会改变原序列，而是创建一个新的序列保存这些结果</p>
<ul>
<li><p><strong>replace</strong> 接受 4 个参数，前两个是输入序列，后两个一个是要搜索的值，一个是要替换的新值</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101225937.png" class="" title="image-20240120101225937">
</li>
<li><p><strong>replace_copy</strong> 接受额外的一个迭代器参数，指出调整后序列的保存位置</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101333789.png" class="" title="image-20240120101333789"></li>
</ul>
</li>
</ul>
<h3 id="10-2-3-重排容器元素的算法"><a href="#10-2-3-重排容器元素的算法" class="headerlink" title="10.2.3 重排容器元素的算法"></a>10.2.3 重排容器元素的算法</h3><ul>
<li><strong>sort</strong> 算法是利用元素类型的 <strong>&lt; 运算符</strong> 来实现排序的</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102044011.png" class="" title="image-20240120102044011">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102109934.png" class="" title="image-20240120102109934">

<blockquote>
<p>算法并不能执行容器操作，所以使用 vector 的 erase 来完成真正的删除操作</p>
</blockquote>
<h4 id="消除重复元素"><a href="#消除重复元素" class="headerlink" title="消除重复元素"></a>消除重复元素</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101657896.png" class="" title="image-20240120101657896">

<h4 id="使用-unique"><a href="#使用-unique" class="headerlink" title="使用 unique"></a>使用 unique</h4><ul>
<li><strong>unique</strong> 算法重排输入序列，将相邻的重复项 <strong>“消除”</strong>，并返回一个指向不重复范围末尾的迭代器</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102131214.png" class="" title="image-20240120102131214">

<h4 id="使用容器操作删除元素"><a href="#使用容器操作删除元素" class="headerlink" title="使用容器操作删除元素"></a>使用容器操作删除元素</h4><h2 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h2><blockquote>
<p>很多算法都会比较输入序列，默认情况下，这类算法使用元素类型的 <strong>&lt; 或 &#x3D;&#x3D; 运算符</strong> 完成比较</p>
<p>标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符</p>
</blockquote>
<h3 id="10-3-1-向算法传递函数"><a href="#10-3-1-向算法传递函数" class="headerlink" title="10.3.1 向算法传递函数"></a>10.3.1 向算法传递函数</h3><ul>
<li><strong>sort</strong> 的第二个版本，接受一个额外的参数，此参数是一个 <strong>谓词</strong></li>
</ul>
<h4 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h4><ul>
<li>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值，谓词又分为两类：<ul>
<li><strong>一元谓词</strong> 只能接受一个参数，<strong>二元谓词</strong> 有两个参数</li>
<li>接受谓词参数的算法，对输入序列中的元素调用谓词，因此元素类型必须能转换为谓词的参数类型</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103050597.png" class="" title="image-20240120103050597">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103100877.png" class="" title="image-20240120103100877">

<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><ul>
<li><strong>stable_sort</strong> 算法，这种 <strong>稳定</strong> 排序算法维持相等元素的原有顺序</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103241249.png" class="" title="image-20240120103241249">

<blockquote>
<p>通常情况下，我们不关心有序序列中相等元素的相对顺序，但在这个例子中，我们将 <strong>相等</strong> 定义为了 <strong>具有相同长度</strong></p>
</blockquote>
<h3 id="10-3-2-lambda-表达式"><a href="#10-3-2-lambda-表达式" class="headerlink" title="10.3.2 lambda 表达式"></a>10.3.2 lambda 表达式</h3><h4 id="介绍-lambda"><a href="#介绍-lambda" class="headerlink" title="介绍 lambda"></a>介绍 lambda</h4><ul>
<li><p>我们可以向一个算法传递任何类别的 <strong>可调用对象</strong>，对于一个对象或一个表达式，如果可以对其使用 <strong>（）调用运算符</strong>，则称它为可调用的</p>
</li>
<li><p>可调用对象有 4 种：函数、函数指针、重载了函数调用运算符的类、<strong>lambda 表达式</strong></p>
</li>
<li><p>一个 lambda 表达式表示一个可调用的代码单元</p>
<ul>
<li><p>具有一个返回类型，一个参数列表、一个函数体</p>
</li>
<li><p>与函数不同的是，lambda 可以定义在函数内部，形式如下：</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104014949.png" class="" title="image-20240120104014949">

<ul>
<li><strong>capture list（捕获列表）</strong>是一个 lambda 所在函数种定义的局部遍历的列表（通常为空）</li>
<li><strong>return type、parameter list 和 function body</strong> 分别表示返回类型、参数类别和函数体</li>
<li>不同的是，lambda 必须使用尾置返回来指定返回类型</li>
</ul>
</li>
</ul>
</li>
<li><p>我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104347020.png" class="" title="image-20240120104347020">

<blockquote>
<p>lambda 中忽略括号和参数列表等价于指定一个空参数列表</p>
<p>如果忽略返回类型，则 lambda 根据函数体中的代码推断出返回类型</p>
<p>如果函数体只是一个 return 语句，返回类型可以推测，否则忽略返回类型的话，返回类型为 void</p>
</blockquote>
<ul>
<li>lambda 的调用方式和普通函数一样，都使用调用运算符</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104423846.png" class="" title="image-20240120104423846">

<h4 id="向-lambda-传递参数"><a href="#向-lambda-传递参数" class="headerlink" title="向 lambda 传递参数"></a>向 lambda 传递参数</h4><ul>
<li>lambda 不能有默认参数，因此 lambda 的调用的实参数目永远与形参数目相等</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104841160.png" class="" title="image-20240120104841160">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104849527.png" class="" title="image-20240120104849527">

<h4 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h4><ul>
<li>lambda 通过将局部遍历包含在其捕获列表中来指出将会使用这些变量</li>
</ul>
<h4 id="调用-find-if"><a href="#调用-find-if" class="headerlink" title="调用 find_if"></a>调用 find_if</h4><ul>
<li><strong>find_if</strong> 算法可以查找第一个具有特定大小的元素<ul>
<li>接受三个参数，前两个参数表示输入范围，第三个参数是一个谓词，且是一个一元谓词</li>
<li>返回第一个使用谓词返回非 0 值的元素，如果不存在则返回尾迭代器</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105305781.png" class="" title="image-20240120105305781">

<h4 id="for-each-算法"><a href="#for-each-算法" class="headerlink" title="for_each 算法"></a>for_each 算法</h4><ul>
<li>接受三个参数，前两个为输入范围，第三个为一个可调用对象，对输入序列中的每个元素调用此对象</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105456109.png" class="" title="image-20240120105456109">

<blockquote>
<p>捕获列表只用于局部非 static 变量，lambda 可以直接使用局部 static 变量和它所在函数之外声明的名字</p>
</blockquote>
<h4 id="完整的-biggies"><a href="#完整的-biggies" class="headerlink" title="完整的 biggies"></a>完整的 biggies</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105640375.png" class="" title="image-20240120105640375">

<h3 id="10-3-3-lambda-捕获与返回"><a href="#10-3-3-lambda-捕获与返回" class="headerlink" title="10.3.3 lambda 捕获与返回"></a>10.3.3 lambda 捕获与返回</h3><ul>
<li>当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名的）类类型</li>
<li>当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象（未命名对象）<ul>
<li>默认情况下，从 lambda 生成的类都包含一个对应 lambda 所捕获的变量的数据成员</li>
</ul>
</li>
</ul>
<h4 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h4><ul>
<li>变量的捕获方式可以是值或引用<ul>
<li>采用值捕获的前提是变量可以拷贝，被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120110529067.png" class="" title="image-20240120110529067">

<h4 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120110557764.png" class="" title="image-20240120110557764">

<ul>
<li>如果我们采用引用的方式捕获变量，就必须保证被引用的对象在 lambda 这些的时候是存在的</li>
<li>lambda 捕获的是局部变量，这些变量在函数结束后就不复存在了</li>
<li>如果函数返回一个 lambda，则该 lambda 不能包含引用捕获</li>
</ul>
<blockquote>
<p>一般来说，我们应该尽量减少捕获的数据量，如果可能的话，应该避免捕获指针或引用</p>
</blockquote>
<h4 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h4><ul>
<li>可以让编译器根据 lambda 体中的代码来推断我们要使用那些变量<ul>
<li>在捕获列表中写 **&amp; 或 &#x3D;**，&amp; 告诉编译器采用捕获引用方式，&#x3D; 则表采用值捕获方式</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111417949.png" class="" title="image-20240120111417949">

<ul>
<li>也可以混合使用隐式捕获和显示捕获</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111540565.png" class="" title="image-20240120111540565">

<blockquote>
<p>混合使用隐式捕获和显示捕获时，捕获列表中的第一个元素必须是一个 &amp; 或 &#x3D;，且显示捕获的变量必须使用与隐式捕获不同的方式</p>
</blockquote>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111722099.png" class="" title="image-20240120111722099">

<h4 id="可变-lambda"><a href="#可变-lambda" class="headerlink" title="可变 lambda"></a>可变 lambda</h4><ul>
<li>默认情况下，一个值拷贝的变量，lambda 不会改变其值</li>
<li>如果我们希望改变一个捕获的变量的值，就必须在参数列表首加上关键字 <strong>mutable</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112046142.png" class="" title="image-20240120112046142">

<ul>
<li>一个引用捕获的变量算法可以修改则依赖于指向的是一个 const 还是 非 const</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112131621.png" class="" title="image-20240120112131621">

<h4 id="指定-lambda-返回类型"><a href="#指定-lambda-返回类型" class="headerlink" title="指定 lambda 返回类型"></a>指定 lambda 返回类型</h4><ul>
<li><p><strong>transform</strong> 函数接受三个迭代器和一个可调用对象，前两个迭代器表示输入序列，第三个迭代器表示目的位置</p>
<ul>
<li>算法对输入序列中每个元素调用可调用对象，结果写入到目的位置</li>
</ul>
</li>
<li><p>lambda 体只包含一个 return 语句时，可以隐式推断出返回类型</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112507534.png" class="" title="image-20240120112507534">

<ul>
<li>如果 lambda 体包含 return 之外的任何语句，则编译器假定此 lambda 返回 <strong>void</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112604726.png" class="" title="image-20240120112604726">

<ul>
<li>当我们需要为一个 lambda 定义返回类型时，必须使用 <strong>尾置返回类型</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112650976.png" class="" title="image-20240120112650976">

<h3 id="10-3-4-参数绑定"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a>10.3.4 参数绑定</h3><blockquote>
<p>在那种只有一两个地方使用的简单操作，lambda 表达式是最有用的</p>
<p>如果需要在很多地方使用，或一个操作需要很多语句才能完成，通常使用函数更好</p>
<p>对于捕获局部变量的 lambda，用函数替换它就不是那么容易了</p>
</blockquote>
<h4 id="标准库-bind-函数"><a href="#标准库-bind-函数" class="headerlink" title="标准库 bind 函数"></a>标准库 bind 函数</h4><ul>
<li><p>可以将 <strong>bind</strong> 看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来 <strong>“适应”</strong> 原对象的参数列表</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113047932.png" class="" title="image-20240120113047932">

<ul>
<li><strong>newCallable</strong> 是一个可调用对象，<strong>arg_list</strong> 是一个参数列表，对应给定的 <strong>callable（旧的可调用对象）</strong> 的参数</li>
<li><strong>arg_list</strong> 中的参数可能包含 <strong>_n</strong> 这样的名字，n 为一个整数，称为 <strong>占位符</strong>，表示 newCallable 的参数<ul>
<li><strong>_1</strong> 为 newCallable 的第一个参数，**_2** 为第二个参数……</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113624892.png" class="" title="image-20240120113624892">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113636991.png" class="" title="image-20240120113636991">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113749208.png" class="" title="image-20240120113749208">

<ul>
<li>对 find_if 使用</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113802747.png" class="" title="image-20240120113802747">

<h4 id="使用-placeholders-名字"><a href="#使用-placeholders-名字" class="headerlink" title="使用 placeholders 名字"></a>使用 placeholders 名字</h4><ul>
<li><p><strong>_n</strong> 这样的名字都定义在一个名为 <strong>placeholders</strong> 的命名空间中，这个命名空间本身就定义在 <strong>std</strong> 命名空间</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114153398.png" class="" title="image-20240120114153398">
</li>
<li><p>我们可以使用如下声明，说明希望所有来自 <strong>namespace_name</strong> 的名字都可以在我们的程序中直接使用</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114144721.png" class="" title="image-20240120114144721">

<h4 id="bind-的参数"><a href="#bind-的参数" class="headerlink" title="bind 的参数"></a>bind 的参数</h4><ul>
<li>可以用 bind 绑定给定可调用对象中的参数或重新安排其顺序</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114316937.png" class="" title="image-20240120114316937">

<ul>
<li>此时 g 的第一个参数被传递给 f 的最后一个参数，g 的第二个参数被传递给 f 的第三个参数</li>
</ul>
<h4 id="用-bind-重排参数顺序"><a href="#用-bind-重排参数顺序" class="headerlink" title="用 bind 重排参数顺序"></a>用 bind 重排参数顺序</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114514241.png" class="" title="image-20240120114514241">

<h4 id="绑定引用参数"><a href="#绑定引用参数" class="headerlink" title="绑定引用参数"></a>绑定引用参数</h4><ul>
<li>默认情况下，bind 的那些不是占位符的参数被拷贝到 bind 返回的可调用函数中</li>
<li>如果必须传递给 bind 一个对象而不是拷贝它，就必须使用 <strong>ref</strong> 函数（比如 ostream）</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114718943.png" class="" title="image-20240120114718943">

<ul>
<li><strong>cref</strong> 函数生成一个保存 const 引用的类</li>
</ul>
<h2 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器</h2><ul>
<li>除了在每个容器中定义的迭代器外，标志库在头文件 <strong>iterator</strong> 中还定义了额外几种迭代器</li>
<li><strong>插入迭代器</strong>：这些迭代器绑定到一个容器上，可以用来向容器中插入元素</li>
<li><strong>流迭代器</strong>：这些迭代器被绑定到输入或输出流上，可以用来遍历所关联的 IO 流</li>
<li><strong>反向迭代器</strong>：这些迭代器向后而不是向前移动（除了 forward_list 外的标准库都有反向迭代器）</li>
<li><strong>移动迭代器</strong>：这些专用的迭代器不是拷贝其中的元素，而是移动它们</li>
</ul>
<h3 id="10-4-1-插入迭代器"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a>10.4.1 插入迭代器</h3><ul>
<li>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，可以实现向给定容器添加元素</li>
<li>通过一个插入迭代器赋值时，该迭代器会调用容器操作来向给定容器的指定位置插入一个元素</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120130709219.png" class="" title="image-20240120130709219">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120130721421.png" class="" title="image-20240120130721421">

<h3 id="10-4-2-iostream-迭代器"><a href="#10-4-2-iostream-迭代器" class="headerlink" title="10.4.2 iostream 迭代器"></a>10.4.2 iostream 迭代器</h3><ul>
<li>虽然 iostream 类型不是容器，但标准库定义了可用于这些 IO 类型对象的迭代器</li>
<li><strong>istream_iterator</strong> 读取输入流，<strong>ostream_iterator</strong> 向一个输出流写数据</li>
<li>这些迭代器将给定的流当作一个特定类型的元素序列来处理</li>
</ul>
<h4 id="istream-iterator-操作"><a href="#istream-iterator-操作" class="headerlink" title="istream_iterator 操作"></a>istream_iterator 操作</h4><ul>
<li><p>创建一个流迭代器时，必须指定迭代器要读写的对象的类型</p>
<ul>
<li>一个 istream_iterator 使用 <strong>&gt;&gt;</strong> 来读取流，因此它读取的类型必须定义了 &gt;&gt; 输出运算符</li>
</ul>
</li>
<li><p>默认初始化迭代器时，会创建一个可以当作 <strong>尾后值</strong> 使用的迭代器</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131257862.png" class="" title="image-20240120131257862">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131310063.png" class="" title="image-20240120131310063">

<blockquote>
<p>对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到 IO 错误，迭代器的值就与尾后迭代器相等</p>
</blockquote>
<ul>
<li>我们以如下的方式构造 vector，从 cin 中读取数据，知道遇到文件尾或遇到一个不是 int 数据为止</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131627364.png" class="" title="image-20240120131627364">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131643099.png" class="" title="image-20240120131643099">

<h4 id="使用算法操作流迭代器"><a href="#使用算法操作流迭代器" class="headerlink" title="使用算法操作流迭代器"></a>使用算法操作流迭代器</h4><ul>
<li>通过一对 istream_iterator 来调用 accumulate：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131739797.png" class="" title="image-20240120131739797">

<h4 id="istream-iterator-允许使用懒惰求值"><a href="#istream-iterator-允许使用懒惰求值" class="headerlink" title="istream_iterator 允许使用懒惰求值"></a>istream_iterator 允许使用懒惰求值</h4><ul>
<li>当一个 istream_iterator 绑定到一个流时，标准库并不保证马上从流读取数据，可能直到我们使用迭代器时才真正读取</li>
</ul>
<h4 id="ostream-iterator-操作"><a href="#ostream-iterator-操作" class="headerlink" title="ostream_iterator 操作"></a>ostream_iterator 操作</h4><ul>
<li><p>我们可以对任何具有 <strong>&lt;&lt; 输出运算符</strong> 的类型定义 ostream_iterator</p>
<ul>
<li>创建时，我们也可以提供（可选的）第二参数，它是一个 C 风格的字符串，在输出每个元素后都会打印此字符串</li>
</ul>
</li>
<li><p>必须将 ostream_iterator 绑定到一个指定的流，不允许空的或表示尾后位置的 ostream_iterator</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132315074.png" class="" title="image-20240120132315074">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132346862.png" class="" title="image-20240120132346862">

<ul>
<li>当我们向 ostream_iterator 赋值时，可以忽略解引用和递增运算符，因为实际上它们什么也不做</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132509140.png" class="" title="image-20240120132509140">

<blockquote>
<p>但更推荐写上解引用和递增运算符，因为这样对读者来说更清晰，也更易修改</p>
</blockquote>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132700171.png" class="" title="image-20240120132700171">

<h4 id="使用流迭代器处理类类型"><a href="#使用流迭代器处理类类型" class="headerlink" title="使用流迭代器处理类类型"></a>使用流迭代器处理类类型</h4><ul>
<li>我们可以为任何定义了 <strong>&gt;&gt; 输入运算符</strong> 的类型创建 istream_iterator 对象，对定义有 <strong>&lt;&lt; 输出运算符</strong> 的类型创建 ostream_iterator 对象</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132900248.png" class="" title="image-20240120132900248">

<h3 id="10-4-3-反向迭代器"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a>10.4.3 反向迭代器</h3><ul>
<li>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器，递增及递减操作的含义颠倒过来</li>
<li>除了 **forward_list **之外的其他容器都支持反向迭代器，我们可以通过调用 rbegin、rend、crbegin、crend 函数来获得反向迭代器</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133138976.png" class="" title="image-20240120133138976">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133645835.png" class="" title="image-20240120133645835">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133654972.png" class="" title="image-20240120133654972">

<h4 id="反向迭代器需要递减运算符"><a href="#反向迭代器需要递减运算符" class="headerlink" title="反向迭代器需要递减运算符"></a>反向迭代器需要递减运算符</h4><ul>
<li>我们只能从既支持 ++ 也支持 - - 的迭代器来定义反向迭代器<ul>
<li><strong>流迭代器</strong> 不支持递减迭代器，而除了 forward_list 外，标准库容器上的其他迭代器都都既支持递增也支持递减运算符</li>
</ul>
</li>
</ul>
<h4 id="反向迭代器和其他迭代器之间的关系"><a href="#反向迭代器和其他迭代器之间的关系" class="headerlink" title="反向迭代器和其他迭代器之间的关系"></a>反向迭代器和其他迭代器之间的关系</h4><ul>
<li><p>调用反向迭代器（reverse_iterator）的 <strong>base</strong> 成员函数完成从一个反向迭代器转换为普通迭代器</p>
<blockquote>
<p>反向迭代器转换为普通迭代器后，指向不同的元素</p>
</blockquote>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120134322779.png" class="" title="image-20240120134322779">

<blockquote>
<p>反向迭代器和普通迭代器都反映了左闭合区间的特性，**[ line.crbegin( )，rcomma ），[ rcomma.base( )，line.cend( ) ）**</p>
</blockquote>
<h2 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构</h2><ul>
<li>算法所要求的迭代器操作可分为 5 个 <strong>迭代器类别</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120134619601.png" class="" title="image-20240120134619601">

<h3 id="10-5-1-5-类迭代器"><a href="#10-5-1-5-类迭代器" class="headerlink" title="10.5.1 5 类迭代器"></a>10.5.1 5 类迭代器</h3><ul>
<li>一个高层类别的迭代器支持低层类别迭代器的所有操作，而向算法传递一个哪里更差的迭代器会产生错误</li>
</ul>
<h4 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h4><ul>
<li>可以读取序列中的元素，一个输入迭代器必须支持：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120135823274.png" class="" title="image-20240120135823274">

<blockquote>
<p>输入迭代器只能用于单遍扫描算法</p>
</blockquote>
<h4 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h4><ul>
<li>只写而不读元素，输出迭代器必须支持：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120135944553.png" class="" title="image-20240120135944553">

<blockquote>
<p>我们只能向一个输出迭代器赋值一次，输出迭代器也只能用于单遍扫描算法</p>
<p>用作目的位置的迭代器通常是输出迭代器</p>
</blockquote>
<h4 id="向前迭代器"><a href="#向前迭代器" class="headerlink" title="向前迭代器"></a>向前迭代器</h4><ul>
<li>可以读写元素，这类迭代器只能在序列中沿一个方向移动</li>
<li>可以多次读写同一个元素，因此可以使用向前迭代器的算法对序列进行多次扫描</li>
</ul>
<h4 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h4><ul>
<li>提供在常量时间内访问序列中任意元素的哪里，支持双向迭代器的所有功能，还支持：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120140323390.png" class="" title="image-20240120140323390">

<blockquote>
<p>sort 就要求随机访问迭代器，array、deque、vector、string 的迭代器都是随机访问迭代器，用于访问内置数组的指针也是</p>
</blockquote>
<h3 id="10-5-2-算法形参模式"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a>10.5.2 算法形参模式</h3><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120140501206.png" class="" title="image-20240120140501206">

<ul>
<li><strong>alg</strong> 是算法的名字，<strong>beg 和 end</strong> 表示算法所操作的输入范围（几乎所有算法都接受一个输入范围）</li>
<li><strong>dest 和 beg2、end2</strong> 都是迭代器参数，分别表示目的位置和第二个范围的角色</li>
<li><strong>other args</strong> 表示其他额外的非迭代器参数，一些算法还接受它们</li>
</ul>
<h4 id="接受单个目标迭代器的算法"><a href="#接受单个目标迭代器的算法" class="headerlink" title="接受单个目标迭代器的算法"></a>接受单个目标迭代器的算法</h4><ul>
<li>蕴含一个编程假定，且通常 dest 被绑定到一个插入迭代器</li>
</ul>
<h4 id="接受第二个输入序列的算法"><a href="#接受第二个输入序列的算法" class="headerlink" title="接受第二个输入序列的算法"></a>接受第二个输入序列的算法</h4><ul>
<li>蕴含一个编程假定：从 beg2 开始的范围与 beg 和 end 所表示的范围至少一样大</li>
</ul>
<h3 id="10-5-3-算法命名规范"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a>10.5.3 算法命名规范</h3><h4 id="一些算法使用重载形式传递一个谓词"><a href="#一些算法使用重载形式传递一个谓词" class="headerlink" title="一些算法使用重载形式传递一个谓词"></a>一些算法使用重载形式传递一个谓词</h4><ul>
<li>接受谓词参数替换 &lt; 或 &#x3D;&#x3D; 运算符的算法，以及那些不接受额外参数的算法，通常是重载函数</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141052933.png" class="" title="image-20240120141052933">

<h4 id="if-版本的算法"><a href="#if-版本的算法" class="headerlink" title="_if 版本的算法"></a>_if 版本的算法</h4><ul>
<li>接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词替代元素值，都附加有 <strong>_if</strong> 前缀</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141402297.png" class="" title="image-20240120141402297">

<h4 id="区分拷贝元素的版本和不拷贝的版本"><a href="#区分拷贝元素的版本和不拷贝的版本" class="headerlink" title="区分拷贝元素的版本和不拷贝的版本"></a>区分拷贝元素的版本和不拷贝的版本</h4><ul>
<li>默认情况下，重排元素的算法将重排后的元素写到给定的输入序列中，它们还提供了一个拷贝版本，将元素写到一个指定的输出目的位置，都在名字后边附加一个 <strong>_copy</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141621469.png" class="" title="image-20240120141621469">

<ul>
<li>一些算法同时提供了 _copy 和 _if 版本</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141735652.png" class="" title="image-20240120141735652">

<h2 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法</h2><ul>
<li>特别的，<strong>链式类型 list 和 forward_list</strong> 定义了几个成员函数形式的算法，这些链表版本的算法的性能比对应的通用版本好得多</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141924398.png" class="" title="image-20240120141924398">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141934406.png" class="" title="image-20240120141934406">

<blockquote>
<p>对于 list 和 forward_list 应该优先使用成员函数版本的算法，而不是通用版本算法</p>
</blockquote>
<h4 id="spilce-成员"><a href="#spilce-成员" class="headerlink" title="spilce 成员"></a>spilce 成员</h4><ul>
<li>此算法是链表数据结构所特有的，不需要通用版本</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120142111787.png" class="" title="image-20240120142111787">

<h4 id="链表特有的操作会改变容器"><a href="#链表特有的操作会改变容器" class="headerlink" title="链表特有的操作会改变容器"></a>链表特有的操作会改变容器</h4><ul>
<li>多数链表特有的算法都与其通用版本相似，但不完全相同</li>
<li>链表特有的版本与通用版本的一个至关重要的的区别是 <strong>链表版本会改变底层的容器</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">C++Primer-9-顺序容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-19 11:18:05" itemprop="dateCreated datePublished" datetime="2024-01-19T11:18:05+08:00">2024-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-20 17:50:17" itemprop="dateModified" datetime="2024-01-20T17:50:17+08:00">2024-01-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="9-顺序容器"><a href="#9-顺序容器" class="headerlink" title="9 顺序容器"></a>9 顺序容器</h1><blockquote>
<p>一个容器就是一个特定类型的集合，顺序容器提供了控制元素存储和访问顺序的能力</p>
<p>这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应</p>
<p>标准库还定义了三种容器适配器来与容器类型适配</p>
</blockquote>
<h2 id="9-1-顺序容器概述"><a href="#9-1-顺序容器概述" class="headerlink" title="9.1 顺序容器概述"></a>9.1 顺序容器概述</h2><img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119112935811.png" class="" title="image-20240119112935811">

<ul>
<li><p><strong>string</strong> 和 <strong>vector</strong> 将元素保存在连续的内存空间中</p>
<ul>
<li>由于是 <strong>连续存储</strong> 的，由元素的下标来计算地址是非常快速的</li>
<li>但在中间位置添加或删除元素就很耗时，因为会移动其他元素来保持连续存储，且还有可能分配额外的存储空间</li>
</ul>
</li>
<li><p><strong>list</strong> 和 <strong>forward_list</strong> 的设计目的是在任何位置进行添加和删除都很快速</p>
<ul>
<li>不支持元素的随机访问，为了访问一个元素，只能遍历整个容器</li>
<li>额外内存开销也很大</li>
<li>特殊的，forward_list 没有 size 操作</li>
</ul>
</li>
<li><p><strong>deque</strong> 支持快速随机访问，同样在中间位置添加和删除元素很耗时，但在两端添加元素就很快速</p>
</li>
<li><p><strong>array</strong> 与内置数组类似，大小固定，不支持添加和删除元素以及改变容器大小的操作</p>
</li>
</ul>
<blockquote>
<p>现代 C++ 程序应该使用标准库容器，而不是更原始的数据结构，如内置数组</p>
<p>通常，使用 vector 是最好的选择，除非你有更好的理由选择其他容器</p>
</blockquote>
<ul>
<li>选择容器的基本原则：</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119113738503.png" class="" title="image-20240119113738503">

<ul>
<li>一般来说，占应用中主导地位的操作决定了容器类型的选择</li>
</ul>
<h2 id="9-2-容器库概览"><a href="#9-2-容器库概览" class="headerlink" title="9.2 容器库概览"></a>9.2 容器库概览</h2><blockquote>
<p>一般来说，每个容器都定义在了一个与文件名与类名同名的头文件中</p>
<p>容器均定义为模板类型</p>
</blockquote>
<h4 id="对容器可以保持的元素类型的限制"><a href="#对容器可以保持的元素类型的限制" class="headerlink" title="对容器可以保持的元素类型的限制"></a>对容器可以保持的元素类型的限制</h4><ul>
<li>顺序容器几乎可以保存任意类型的元素</li>
<li>但如果保存的是自定义数据类型，容器就只能使用那些没有特殊要求的容器操作了</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119114345994.png" class="" title="image-20240119114345994">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119114433741.png" class="" title="image-20240119114433741">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119114450674.png" class="" title="image-20240119114450674">

<h3 id="9-2-1-迭代器"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器</h3><blockquote>
<p>如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的</p>
<p>特殊的，forward_list 迭代器不支持递减运算符 - - </p>
</blockquote>
<h4 id="迭代器范围"><a href="#迭代器范围" class="headerlink" title="迭代器范围"></a>迭代器范围</h4><ul>
<li><p>一个 <strong>迭代器范围</strong> 由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置</p>
<blockquote>
<p>第二个迭代器从来不会指向范围中的最后一个元素，而是指向尾元素之后的位置</p>
<p>这种元素范围被称为 <strong>左闭合区间</strong>，即 <strong>[begin，end）</strong></p>
</blockquote>
</li>
</ul>
<h4 id="使用左闭合区间蕴含的编程假定"><a href="#使用左闭合区间蕴含的编程假定" class="headerlink" title="使用左闭合区间蕴含的编程假定"></a>使用左闭合区间蕴含的编程假定</h4><ul>
<li>如果 <strong>begin !&#x3D; end</strong>，范围内至少包含一个元素，且 begin 指向范围中的第一个元素</li>
<li>如果 <strong>begin &#x3D;&#x3D; end</strong>，范围为空</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119115237939.png" class="" title="image-20240119115237939">

<h3 id="9-2-2-容器类型成员"><a href="#9-2-2-容器类型成员" class="headerlink" title="9.2.2 容器类型成员"></a>9.2.2 容器类型成员</h3><ul>
<li>除了 iterator 和 const_iterator 类型，大多数容器还提供 <strong>反向迭代器</strong></li>
<li>反向迭代器是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒<ul>
<li>比如 ++ 操作会得到上一个元素</li>
</ul>
</li>
<li><strong>类型别名</strong>：通过类型别名我们可以在不了解容器中元素类型的情况下使用它<ul>
<li>比如使用 <strong>value_type</strong> 得到 <strong>元素类型</strong>，需要元素类型的一个引用，可以使用 <strong>reference</strong> 和 <strong>const_reference</strong></li>
<li>这些类型别名在泛型编程中非常有用</li>
</ul>
</li>
</ul>
<h3 id="9-2-3-begin-和-end-成员"><a href="#9-2-3-begin-和-end-成员" class="headerlink" title="9.2.3 begin 和 end 成员"></a>9.2.3 begin 和 end 成员</h3><ul>
<li><strong>begin</strong> 和 <strong>end</strong> 有多个版本：<strong>带 r</strong> 的版本返回反向迭代器，<strong>以 c 开头</strong> 的版本返回 const 迭代器</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119120530777.png" class="" title="image-20240119120530777">

<ul>
<li><p><strong>不以 c 开头</strong> 的函数都是被 <strong>重载</strong> 过的</p>
</li>
<li><p>因此实际上有两个 begin 成员，一个是 const 成员，返回 const_iterator 类型，另一个非常量成员返回 iterator 类型</p>
<ul>
<li>rbegin、rend 和 end 也是类似，如果我们用一个 const 对象调用它们时，得到 const 版本，反之亦然</li>
</ul>
</li>
<li><p>可以使用 auto 与 begin 和 end 结合使用</p>
</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119121258809.png" class="" title="image-20240119121258809">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119121320323.png" class="" title="image-20240119121320323">

<blockquote>
<p>当不需要写访问时，应该使用 cbegin 和 cend</p>
</blockquote>
<h3 id="9-2-4-容器定义和初始化"><a href="#9-2-4-容器定义和初始化" class="headerlink" title="9.2.4 容器定义和初始化"></a>9.2.4 容器定义和初始化</h3><ul>
<li>除了 array 之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119122320327.png" class="" title="image-20240119122320327">

<h4 id="将一个容器初始化为另一个容器的拷贝"><a href="#将一个容器初始化为另一个容器的拷贝" class="headerlink" title="将一个容器初始化为另一个容器的拷贝"></a>将一个容器初始化为另一个容器的拷贝</h4><ul>
<li>直接拷贝整个容器 或者 拷贝由一个迭代器对指定的元素范围（array 除外）</li>
<li>为了 <strong>创建一个容器为另一个容器的拷贝</strong>，两容器的类型及元素类型必须 <strong>匹配</strong></li>
<li>如果传递迭代器参数拷贝一个 <strong>范围</strong>，不要求容器和元素类型相同，只要求元素类型 <strong>可以转换</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119122638382.png" class="" title="image-20240119122638382">

<ul>
<li>也可以使用范围拷贝来拷贝一个容器的子序列：</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119122729707.png" class="" title="image-20240119122729707">

<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><ul>
<li>除了 array 之外的容器类型，列表初始化还隐含指定了容器的大小</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119122831449.png" class="" title="image-20240119122831449">

<h4 id="与顺序容器大小相关的构造函数"><a href="#与顺序容器大小相关的构造函数" class="headerlink" title="与顺序容器大小相关的构造函数"></a>与顺序容器大小相关的构造函数</h4><ul>
<li>接受一个容器大小和一个（可选的）元素初始值，如果没有接受元素初始值，则元素类型需要有默认构造函数</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119123013609.png" class="" title="image-20240119123013609">

<h4 id="标准库-array-具有固定大小"><a href="#标准库-array-具有固定大小" class="headerlink" title="标准库 array 具有固定大小"></a>标准库 array 具有固定大小</h4><ul>
<li>标准库 <strong>array 的大小</strong> 也是类型的一部分，因此定义一个 array 时，除了指定元素类型，还需要指定容器大小</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119123118897.png" class="" title="image-20240119123118897">

<ul>
<li>一个 <strong>默认构造的 array 是非空</strong> 的，它包含了与其大小一样多的元素，这些元素都被默认初始化，因此元素类型必须有一个默认构造函数</li>
<li>如果我们对 array 进行列表初始化，则初始值个数必须小于等于 array 大小，如果小于的话，后边的元素都会进行值初始化</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119123448208.png" class="" title="image-20240119123448208">

<ul>
<li>值得注意的是，虽然我们不能对内置数组进行拷贝或赋值，但 array 可以：</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119123538605.png" class="" title="image-20240119123538605">

<blockquote>
<p>当然，拷贝或赋值时元素类型和大小都需要匹配</p>
</blockquote>
<h3 id="9-2-5-赋值和-swap"><a href="#9-2-5-赋值和-swap" class="headerlink" title="9.2.5  赋值和 swap"></a>9.2.5  赋值和 swap</h3><ul>
<li>赋值运算符将其左边容器中所有元素替换为右边容器中元素的拷贝</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119141207073.png" class="" title="image-20240119141207073">

<ul>
<li>与内置数组不同，标准库 array 类型允许赋值，但左右两边运算对象必须有相同类型</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119141304928.png" class="" title="image-20240119141304928">

<blockquote>
<p>由于左右两边运算对象的大小可能不同，所以 array 不支持 assign 及花括号包围的值的列表进行赋值</p>
</blockquote>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119141539683.png" class="" title="image-20240119141539683">

<h4 id="使用-assign（仅顺序容器）"><a href="#使用-assign（仅顺序容器）" class="headerlink" title="使用 assign（仅顺序容器）"></a>使用 assign（仅顺序容器）</h4><ul>
<li><strong>assign</strong> 允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值</li>
<li>assign 用参数所指定的元素（的拷贝）<strong>替换</strong> 左边容器中所有元素</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119141755675.png" class="" title="image-20240119141755675">

<blockquote>
<p>由于旧元素被替换，因此传递给 assign 的迭代器不能指向调用 assign 的容器</p>
</blockquote>
<ul>
<li>assign 的第二个版本接受一个整型值和一个元素值</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119142008797.png" class="" title="image-20240119142008797">

<h4 id="使用-swap"><a href="#使用-swap" class="headerlink" title="使用 swap"></a>使用 swap</h4><ul>
<li>除了 array 之外，交换其他的两个容器会很快（元素本身并未交换，swap 只是交换了两个容器的内部数据结构）</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119142152075.png" class="" title="image-20240119142152075">

<blockquote>
<p>除 array 外，swap 不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成</p>
<p>而元素不会被移动表示，除 string 外，指向容器的迭代器、引用和指针在 swap 后仍然有效，只是已经属于不同容器了</p>
</blockquote>
<ul>
<li>与其他容器不同，<strong>swap 两个 array 会真的交换它们</strong>，因此所需时间与 array 中元素个数成正比</li>
</ul>
<blockquote>
<p>虽然有成员 swap 和非成员版本的 swap，但统一使用非成员版本的 swap 是一个好习惯</p>
</blockquote>
<h3 id="9-2-6-容器大小操作"><a href="#9-2-6-容器大小操作" class="headerlink" title="9.2.6 容器大小操作"></a>9.2.6 容器大小操作</h3><ul>
<li><strong>size</strong>：返回容器中元素数目</li>
<li><strong>empty</strong>：当 size 为 0 时返回 true，否则返回 false</li>
<li><strong>max_size</strong>：返回一个大于或等于该容器所能容纳的最大元素数的值</li>
</ul>
<blockquote>
<p>forward_list 支持 max_size、empty，但不支持 size</p>
</blockquote>
<h3 id="9-2-7-关系运算符"><a href="#9-2-7-关系运算符" class="headerlink" title="9.2.7 关系运算符"></a>9.2.7 关系运算符</h3><ul>
<li>每个容器都支持 <strong>相等运算符 &#x3D;&#x3D; 、!&#x3D;</strong></li>
<li>除了无序关联容器外，所有容器都支持 <strong>关系运算符 &gt;、 &gt;&#x3D;、 &lt;、 &lt;&#x3D;</strong>**<ul>
<li>关系运算符左右两边必须是相同类型的容器且元素类型也相同，比较策略是逐个比较</li>
</ul>
</li>
</ul>
<h4 id="容器的关系运算符使用元素的关系运算符完成比较"><a href="#容器的关系运算符使用元素的关系运算符完成比较" class="headerlink" title="容器的关系运算符使用元素的关系运算符完成比较"></a>容器的关系运算符使用元素的关系运算符完成比较</h4><ul>
<li>实际上，容器的相等运算符是使用 <strong>&#x3D;&#x3D; 运算符</strong> 实现比较的，而其他运算符是使用 <strong>&lt; 运算符</strong> 完成比较的</li>
<li>如果元素类型不支持所需的运算符，则容器就不能使用相应的运算符比较</li>
</ul>
<h2 id="9-3-顺序容器操作"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作</h2><blockquote>
<p>顺序容器个关联容器的不同之处在于两者组织元素的方式，这直接关系到了元素如何存储、访问、添加以及删除</p>
</blockquote>
<h3 id="9-3-1-向顺序容器添加元素"><a href="#9-3-1-向顺序容器添加元素" class="headerlink" title="9.3.1 向顺序容器添加元素"></a>9.3.1 向顺序容器添加元素</h3><ul>
<li>除了 array 之外，所有标准库都提供灵活的内存关联，在运行时可以动态的添加或删除元素改变容器的大小</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119143804807.png" class="" title="image-20240119143804807">

<blockquote>
<p>当我们使用这些操作时，必须记得不同容器使用不同策略来分配元素空间，这些策略会直接影响性能</p>
</blockquote>
<h4 id="使用-push-back"><a href="#使用-push-back" class="headerlink" title="使用 push_back"></a>使用 push_back</h4><ul>
<li><strong>除了 array 和 forward_list 外</strong>，其他容器都支持 push_back，push_back 将一个元素追加到一个容器的尾部</li>
</ul>
<blockquote>
<p>实际放入容器中的是对象值的一个拷贝，而不是对象本身</p>
</blockquote>
<h4 id="使用-push-front"><a href="#使用-push-front" class="headerlink" title="使用 push_front"></a>使用 push_front</h4><ul>
<li><strong>forward_list、list、deque 都支持 push_front</strong>，将元素插入到容器头部</li>
</ul>
<h4 id="在容器中的特定位置添加元素"><a href="#在容器中的特定位置添加元素" class="headerlink" title="在容器中的特定位置添加元素"></a>在容器中的特定位置添加元素</h4><ul>
<li><strong>vector、deque、list、string</strong> 都支持 insert，<strong>forward_list</strong> 提供了特殊版本的 insert</li>
<li><strong>insert</strong> 将元素插入到迭代器所指定的位置之前</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119144508718.png" class="" title="image-20240119144508718">

<h4 id="插入范围内元素"><a href="#插入范围内元素" class="headerlink" title="插入范围内元素"></a>插入范围内元素</h4><ul>
<li><p>除了第一个迭代器参数外，insert 函数还可以接受更多参数</p>
<ul>
<li><p>接受 <strong>一个元素数目和一个值</strong>，它将指定数量的元素添加到指定位置</p>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119144752618.png" class="" title="image-20240119144752618">
</li>
<li><p>接受 <strong>一对迭代器</strong> 或 <strong>一个初始化列表</strong>，将指定范围内的元素 <strong>插入指定位置之前</strong>，<strong>返回指向第一个新加入元素的迭代器</strong>，范围为空则返回第一个参数</p>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119144842479.png" class="" title="image-20240119144842479">

<blockquote>
<p>如果传递给 insert 一对迭代器，它们不能指向添加元素的目标容器</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="使用-insert-的返回值"><a href="#使用-insert-的返回值" class="headerlink" title="使用 insert 的返回值"></a>使用 insert 的返回值</h4><ul>
<li>通过使用 insert 的返回值，可以在容器中一个特定位置反复插入元素</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119145201837.png" class="" title="image-20240119145201837">

<h4 id="使用-emplace-操作"><a href="#使用-emplace-操作" class="headerlink" title="使用 emplace 操作"></a>使用 emplace 操作</h4><ul>
<li>这些操作 <strong>构造函数</strong>，而不是拷贝函数，它们将参数传递给元素类型的构造函数，参数必须与元素类型构造函数的参数相 <strong>匹配</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119145342291.png" class="" title="image-20240119145342291">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119145427328.png" class="" title="image-20240119145427328">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119145437306.png" class="" title="image-20240119145437306">

<blockquote>
<p>emplace 函数在容器中直接构造元素</p>
</blockquote>
<h3 id="9-3-2-访问元素"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素</h3><ul>
<li>包括 array 在内，每个容器都有一个 <strong>front</strong> 成员函数，而除了 forward_list 外，所有顺序容器都有一个 <strong>back</strong> 成员函数</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119145727854.png" class="" title="image-20240119145727854">

<h4 id="访问成员函数返回的是引用"><a href="#访问成员函数返回的是引用" class="headerlink" title="访问成员函数返回的是引用"></a>访问成员函数返回的是引用</h4><ul>
<li>在容器中访问元素的成员函数（<strong>front、back、下标、at</strong>）返回的都是 <strong>引用</strong>，如果容器是 const 对象，则返回 const 的引用</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119150226511.png" class="" title="image-20240119150226511">

<blockquote>
<p>使用 auto 保存返回值，希望用来改变元素的值，必须将变量定义为引用类型</p>
</blockquote>
<h4 id="下标操作和安全的随机访问"><a href="#下标操作和安全的随机访问" class="headerlink" title="下标操作和安全的随机访问"></a>下标操作和安全的随机访问</h4><ul>
<li>提供快速随机访问的容器（<strong>string、vector、deque、array</strong>）都提供下标运算符</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119150235629.png" class="" title="image-20240119150235629">

<blockquote>
<p>如果希望确保下标是合法的，可以使用 at 成员函数，越界时会抛出 out_of_range 异常</p>
</blockquote>
<h3 id="9-3-3-删除元素"><a href="#9-3-3-删除元素" class="headerlink" title="9.3.3 删除元素"></a>9.3.3 删除元素</h3><img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119150347885.png" class="" title="image-20240119150347885">

<blockquote>
<p>删除元素的函数并不检测其参数，所以删除前需要确保它们确实存在</p>
</blockquote>
<h4 id="pop-front-和-pop-back-成员函数"><a href="#pop-front-和-pop-back-成员函数" class="headerlink" title="pop_front 和 pop_back 成员函数"></a>pop_front 和 pop_back 成员函数</h4><ul>
<li>这些操作返回 <strong>void</strong>，如果你需要弹出的元素的值，必须在弹出前保存它</li>
</ul>
<h4 id="从容器内部删除一个元素"><a href="#从容器内部删除一个元素" class="headerlink" title="从容器内部删除一个元素"></a>从容器内部删除一个元素</h4><ul>
<li><strong>erase</strong> 从容器中指定位置删除元素<ul>
<li>可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的元素</li>
<li>都返回指向删除的（最后一个）元素之后位置的迭代器</li>
</ul>
</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119150822054.png" class="" title="image-20240119150822054">

<h4 id="删除多个元素"><a href="#删除多个元素" class="headerlink" title="删除多个元素"></a>删除多个元素</h4><ul>
<li>第一个迭代器指向要删除的第一个元素，第二个迭代器指向要删除的最后一个元素 <strong>之后</strong> 的位置</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119151031191.png" class="" title="image-20240119151031191">

<ul>
<li><strong>clear</strong> 删除容器中所有元素</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119151105553.png" class="" title="image-20240119151105553">

<h3 id="9-3-4-特殊的-forward-list-操作"><a href="#9-3-4-特殊的-forward-list-操作" class="headerlink" title="9.3.4 特殊的 forward_list 操作"></a>9.3.4 特殊的 forward_list 操作</h3><ul>
<li><p>由于 <strong>forward_list 是单向链表</strong>，当添加或删除一个元素时，我们需要访问它的 <strong>前驱</strong>，但在一个单向链表中我们并没有简单的方法获得前驱，因此 <strong>forward_list 提供了一些特殊版本的添加和删除操作</strong></p>
</li>
<li><p>forward_list 定义了 <strong>insert_after、emplace_after 和 erase_after</strong> 操作，都是向后操作</p>
<ul>
<li>为了支持这些操作，还定义了 <strong>before_begin</strong> 返回一个 <strong>首前</strong> 迭代器，指向首元素的前一个不存在的位置</li>
</ul>
</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119151706401.png" class="" title="image-20240119151706401">

<blockquote>
<p>因此，在 forward_list 中添加或删除元素时，我们需要关注两个迭代器：处理的元素及它的前驱</p>
</blockquote>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119151819772.png" class="" title="image-20240119151819772">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119151835982.png" class="" title="image-20240119151835982">

<h3 id="9-3-5-改变容器大小"><a href="#9-3-5-改变容器大小" class="headerlink" title="9.3.5 改变容器大小"></a>9.3.5 改变容器大小</h3><ul>
<li>我们可以使用 <strong>resize</strong> 来增加或缩小容器（array 不支持 resize）<ul>
<li>如果当前大小大于要求的大小，则后边的元素被删除</li>
<li>如果当前大小小于要求的大小，会将新元素添加到容器后（也可以接受一个可选的元素值来初始化新增的元素）</li>
</ul>
</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119152111835.png" class="" title="image-20240119152111835">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119152125794.png" class="" title="image-20240119152125794">

<h3 id="9-3-6-容器操作可能使迭代器失效"><a href="#9-3-6-容器操作可能使迭代器失效" class="headerlink" title="9.3.6 容器操作可能使迭代器失效"></a>9.3.6 容器操作可能使迭代器失效</h3><ul>
<li>向容器中 <strong>添加元素和从容器中删除元素</strong> 的操作可能使指向容器元素的 <strong>指针、引用或迭代器失效</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119152253466.png" class="" title="image-20240119152253466">

<blockquote>
<p>当我们添加或删除元素时，<strong>尾后迭代器总是会失效</strong></p>
<p>由于向迭代器添加或删除元素可能使迭代器失效，因此必须保证每次改变容器的操作之后都正确的 <strong>重新定位迭代器</strong></p>
</blockquote>
<h4 id="编写改变容器的循环程序"><a href="#编写改变容器的循环程序" class="headerlink" title="编写改变容器的循环程序"></a>编写改变容器的循环程序</h4><ul>
<li>必须保证每个循环步中都 <strong>更新</strong> 迭代器、引用和指针</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119152921542.png" class="" title="image-20240119152921542">

<h4 id="不要保存-end-返回的迭代器"><a href="#不要保存-end-返回的迭代器" class="headerlink" title="不要保存 end 返回的迭代器"></a>不要保存 end 返回的迭代器</h4><ul>
<li>原来 end 返回的迭代器总是会失效，因此需要在循环过程中返回调用</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119153038860.png" class="" title="image-20240119153038860">

<h2 id="9-4-vector-对象是如何增长的"><a href="#9-4-vector-对象是如何增长的" class="headerlink" title="9.4 vector 对象是如何增长的"></a>9.4 vector 对象是如何增长的</h2><blockquote>
<p>策略：<strong>当不得不获取新的内存空间时</strong>，vector 和 string 的实现通常会分配比新的空间需求更大的内存空间</p>
</blockquote>
<h4 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h4><ul>
<li><strong>capacity</strong> 操作告诉我们容器在不扩张内存的情况下可以容纳多少个元素</li>
<li><strong>reserve</strong> 操作允许我们通知容器应该准备保存多少个元素</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119153401527.png" class="" title="image-20240119153401527">

<blockquote>
<p>reserve 并不改变容器中元素的数量，仅影响容器预先分配多大的内存空间</p>
<p>只有需要的内存空间超过当前容量时，reserve 才会改变容器的容量，需求量小于当前容量时，什么也不做</p>
</blockquote>
<ul>
<li><strong>shrink_to_fit</strong> 仅仅是请求，不一定保证一定退回内存空间</li>
</ul>
<h4 id="capacity-和-size"><a href="#capacity-和-size" class="headerlink" title="capacity 和 size"></a>capacity 和 size</h4><ul>
<li><strong>size</strong> 是指它已经保存的元素数目，<strong>capacity</strong> 则是在不分配新的内存空间的前提下它最多可以保存多少元素</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119153949464.png" class="" title="image-20240119153949464">

<blockquote>
<p>一个空的 vector 的 size 为 0，显然它的 capacity 也为 0</p>
</blockquote>
<h2 id="9-5-额外的-stirng-操作"><a href="#9-5-额外的-stirng-操作" class="headerlink" title="9.5 额外的 stirng 操作"></a>9.5 额外的 stirng 操作</h2><blockquote>
<p>除了顺序容器共同的操作外，string 还提供了一些额外操作</p>
</blockquote>
<h3 id="9-5-1-构造-string-的其他方法"><a href="#9-5-1-构造-string-的其他方法" class="headerlink" title="9.5.1 构造 string 的其他方法"></a>9.5.1 构造 string 的其他方法</h3><img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119154505375.png" class="" title="image-20240119154505375">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119154607072.png" class="" title="image-20240119154607072">

<ul>
<li>当我们从一个 <strong>const char</strong>* 创建 string 时，指针指向的数组必须以空字符结尾，拷贝到空字符停止</li>
</ul>
<h4 id="substr-操作"><a href="#substr-操作" class="headerlink" title="substr 操作"></a>substr 操作</h4><ul>
<li>返回一个 string，它是原始 stirng 的一部分或全部的拷贝，可以传递一个可选的开始位置和计数值</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119154935662.png" class="" title="image-20240119154935662">

<ul>
<li>如果开始位置加上计数值大于 string 的大小，则 substr 只会拷贝到 string 的末尾（调整了计数值）</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119155050964.png" class="" title="image-20240119155050964">

<h3 id="9-5-2-改变-string-的其他方法"><a href="#9-5-2-改变-string-的其他方法" class="headerlink" title="9.5.2 改变 string 的其他方法"></a>9.5.2 改变 string 的其他方法</h3><ul>
<li>string 还提供了可以 <strong>接受下标的版本的 insert 和 erase</strong>，下标指出了开始删除的位置，或插入到给定值之前的位置</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119155719822.png" class="" title="image-20240119155719822">

<ul>
<li>string 还提供了 <strong>接受 C 风格字符数组的 insert 和 assign</strong> 版本</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160015197.png" class="" title="image-20240119160015197">

<blockquote>
<p>assign 中要求赋值的字符数必须小于等于 cp 指向数组中的字符数（不包括空字符）</p>
</blockquote>
<ul>
<li>也可以指定插入来自其他 string 或 子字符串</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160301990.png" class="" title="image-20240119160301990">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160310843.png" class="" title="image-20240119160310843">

<h4 id="append-和-replace-函数"><a href="#append-和-replace-函数" class="headerlink" title="append 和 replace 函数"></a>append 和 replace 函数</h4><ul>
<li><strong>append</strong> 操作是在 string <strong>末尾进行插入操作</strong> 的一种简写形式</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160416553.png" class="" title="image-20240119160416553">

<ul>
<li><strong>replace</strong> 操作是调用 <strong>erase 和 insert</strong> 的一种简写形式</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160456236.png" class="" title="image-20240119160456236">

<blockquote>
<p>replace 函数中插入的文本可以与删除的文本不一样长</p>
</blockquote>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160559461.png" class="" title="image-20240119160559461">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119160609786.png" class="" title="image-20240119160609786">

<h4 id="改变-string-的多种重载函数"><a href="#改变-string-的多种重载函数" class="headerlink" title="改变 string 的多种重载函数"></a>改变 string 的多种重载函数</h4><ul>
<li><p><strong>assign</strong> 总是 <strong>替换</strong> string 中的 <strong>所有内容</strong></p>
</li>
<li><p><strong>append</strong> 总是将新字符 <strong>追加</strong> 到 string <strong>末尾</strong></p>
</li>
<li><p><strong>replace</strong> 提供了两种指定删除元素范围的方式</p>
<ul>
<li>通过一个位置和一个长度指定范围</li>
<li>通过一一个迭代器范围来指定</li>
</ul>
</li>
<li><p><strong>insert</strong> 允许我们用两种方式指定插入点</p>
<ul>
<li>用一个下标或一个迭代器，新元素总会插入到给定下标之前的位置</li>
</ul>
</li>
<li><p>添加到字符串中的字符</p>
<ul>
<li>可以来自一个 string，或来自一个字符指针，此时可以通过一个额外参数控制拷贝字符数目</li>
<li>也可以来自一个花括号包围的字符列表</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果我们希望用迭代器指定位置，就不能用字符指针指定新字符的来源</p>
</blockquote>
<h3 id="9-5-3-string-搜索操作"><a href="#9-5-3-string-搜索操作" class="headerlink" title="9.5.3 string 搜索操作"></a>9.5.3 string 搜索操作</h3><ul>
<li>每个搜索操作都返回一个 <strong>string: :size_type</strong> 值表示匹配发生位置的下标，如果搜索失败，则返回一个 <strong>string: :npos</strong> 的 static 成员，值为 <strong>-1</strong></li>
</ul>
<blockquote>
<p>string 搜索函数返回 string: :size_type 值，是一个 <strong>unsigned</strong> 类型，因此使用一个 int 或其他带符号类型来保存这些返回值不是一个好主意</p>
</blockquote>
<ul>
<li>搜索是大小写敏感的</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162323525.png" class="" title="image-20240119162323525">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162332714.png" class="" title="image-20240119162332714">

<h4 id="指定在哪里开始搜索"><a href="#指定在哪里开始搜索" class="headerlink" title="指定在哪里开始搜索"></a>指定在哪里开始搜索</h4><ul>
<li>传递给 <strong>find</strong> 操作一个可选的开始位置，指定从哪个位置开始进行搜索（默认情况下，该值为 0）</li>
</ul>
<h4 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h4><ul>
<li>find 是从左至右搜索，标准库还提供了从右至左的搜索，<strong>refind</strong> 搜索最后一个匹配</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162544412.png" class="" title="image-20240119162544412">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162558516.png" class="" title="image-20240119162558516">

<ul>
<li>每个操作都接受一个可选的第二参数，可用来指定从什么位置开始搜索</li>
</ul>
<h3 id="9-5-4-compare-函数"><a href="#9-5-4-compare-函数" class="headerlink" title="9.5.4 compare 函数"></a>9.5.4 compare 函数</h3><ul>
<li>根据 s 是等于、大于还是小于参数指定的字符串，<strong>compare 返回 0、正数或负数</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162813917.png" class="" title="image-20240119162813917">

<h3 id="9-5-5-数值转换"><a href="#9-5-5-数值转换" class="headerlink" title="9.5.5 数值转换"></a>9.5.5 数值转换</h3><ul>
<li>要转换为数值的 string 中 <strong>第一个非空白符必须是数值中可能出现的字符</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119162935788.png" class="" title="image-20240119162935788">

<blockquote>
<p>string 参数中第一个非空白符必须是 <strong>符号（+ 或 -） 或数字</strong></p>
<p>也可以是 <strong>0x</strong> 开头表示 16 进制数</p>
<p>对于浮点数，可以以 <strong>小数点 .</strong> 开头，并且可以包含 <strong>e</strong> 表示指数部分</p>
<p>对于表示整型值的函数，也可以包含 <strong>字母字符</strong> 表示大于数字 9 的数</p>
</blockquote>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119163458474.png" class="" title="image-20240119163458474">

<h2 id="9-6-容器适配器"><a href="#9-6-容器适配器" class="headerlink" title="9.6 容器适配器"></a>9.6 容器适配器</h2><blockquote>
<p>除了顺序容器外，标准库还定义了三个顺序容器适配器：<strong>stack、queue 和 priority_queue</strong></p>
<p>适配器是一个通用概念，本质上是一种机制，能使某种事物的行为看起来像另一种事物一样</p>
</blockquote>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119163713519.png" class="" title="image-20240119163713519">

<h4 id="定义一个适配器"><a href="#定义一个适配器" class="headerlink" title="定义一个适配器"></a>定义一个适配器</h4><ul>
<li>每个适配器有两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器</li>
<li>默认情况下，<strong>stack 和 queue 是基于 deque 实现的</strong></li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119164921544.png" class="" title="image-20240119164921544">

<ul>
<li>我们也可以在创建一个适配器时将一个命名的顺序容器作为第二个参数来重载默认容器类型</li>
</ul>
<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119165006260.png" class="" title="image-20240119165006260">

<ul>
<li><strong>stack</strong> 只要求 <strong>push_back、pop_back 和 back</strong> 操作，因此可以用除了 array 和 forward_list 之外所有容器构造</li>
<li><strong>queue</strong> 只要求 <strong>back、push_back、front 和 push_front</strong>，因此可以构造与 list 或 deque</li>
<li><strong>priority_queue</strong> 除了 <strong>front、push_back 和 pop_back</strong> 操作外，还要求随机访问哪里，因此可以构造与 vector 或 deque</li>
</ul>
<h4 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h4><img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119165354756.png" class="" title="image-20240119165354756">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119165406885.png" class="" title="image-20240119165406885">

<blockquote>
<p>我们只能使用适配器操作，而不能使用底层容器类型的操作</p>
</blockquote>
<h4 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h4><img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119165504986.png" class="" title="image-20240119165504986">

<img src="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/image-20240119165514487.png" class="" title="image-20240119165514487">

<ul>
<li><strong>queue</strong> 使用一种 <strong>先进先出（first-in，first-out，FIFO）</strong> 的存储和访问策略</li>
<li>进入队列的对象被放置在队尾，离开队列的对象则从队首删除</li>
<li><strong>priority_queue</strong> 允许我们为队列中的元素建立 <strong>优先级</strong>，新加入的元素会排在所有优先级比它低的已有元素之前</li>
<li>默认情况下，标准库在元素类型上使用 <strong>&lt; 运算符</strong> 来确定相对优先级</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/19/8-IO%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/19/8-IO%E5%BA%93/" class="post-title-link" itemprop="url">C++Primer-8-IO库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-19 10:00:08" itemprop="dateCreated datePublished" datetime="2024-01-19T10:00:08+08:00">2024-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-20 17:50:06" itemprop="dateModified" datetime="2024-01-20T17:50:06+08:00">2024-01-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-IO-库"><a href="#8-IO-库" class="headerlink" title="8 IO 库"></a>8 IO 库</h1><blockquote>
<p>我们之前已经使用过的 IO 类型和对象都是操作 char 数据的</p>
<p>默认情况下，这些对象都是关联到用户的控制台窗口的</p>
<p>当然，我们不能仅通过控制台窗口进行 IO 操作，应用程序常常需要读写文件</p>
<p>而且，使用 IO 操作处理 string 中的字符会很方便</p>
</blockquote>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119100804465.png" class="" title="image-20240119100804465">

<h2 id="8-1-IO-类"><a href="#8-1-IO-类" class="headerlink" title="8.1 IO 类"></a>8.1 IO 类</h2><blockquote>
<p><strong>iostream</strong> 定义了用于读写流的基本类型</p>
<p><strong>fstream</strong> 定义了读写命名文件的类型</p>
<p><strong>sstream</strong> 定义了读写内存 string 对象的类型</p>
</blockquote>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119100831652.png" class="" title="image-20240119100831652">

<ul>
<li>为了支持使用宽字符的语言，标准库也定义了一组类型和对象来操作 wchar_t 类型的数据</li>
</ul>
<h4 id="IO-类型间的关系"><a href="#IO-类型间的关系" class="headerlink" title="IO 类型间的关系"></a>IO 类型间的关系</h4><ul>
<li>标准库使我们能忽略不同类型之间的差异，是通过 <strong>继承机制</strong>，我们通常可以将一个派生类对象当作其基类对象来使用</li>
<li>而类型 ifstream 和 istringstream 都继承自 istream，因此可以像使用 istream 对象一样来使用它们</li>
</ul>
<h3 id="8-1-1-IO-对象无拷贝或赋值"><a href="#8-1-1-IO-对象无拷贝或赋值" class="headerlink" title="8.1.1 IO 对象无拷贝或赋值"></a>8.1.1 IO 对象无拷贝或赋值</h3><blockquote>
<p>我们不能对 IO 对象拷贝或赋值，进行 IO 操作的函数通常以 <strong>引用</strong> 方式传递和返回流</p>
</blockquote>
<h3 id="8-1-2-条件状态"><a href="#8-1-2-条件状态" class="headerlink" title="8.1.2 条件状态"></a>8.1.2 条件状态</h3><ul>
<li>IO 操作一个与生俱来的问题是可能发生错误，一些错误是可修复的，而其他错误已经超出应用程序可修正的范围</li>
<li>IO 类定义了一些函数和标志，可以帮助我们访问和操纵流的 <strong>条件状态</strong></li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119101713080.png" class="" title="image-20240119101713080">

<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119101721718.png" class="" title="image-20240119101721718">

<ul>
<li>由于流可能处于错误状态，因此代码通常应该 <strong>在使用一个流之前检查</strong> 它是否处于良好的状态</li>
<li>确定一个流对象的状态的最简单方法是将它当作一个条件使用：</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119101927320.png" class="" title="image-20240119101927320">

<h4 id="查询流的状态"><a href="#查询流的状态" class="headerlink" title="查询流的状态"></a>查询流的状态</h4><ul>
<li><p><strong>badbit</strong>：表示系统级错误，一旦被置位，流就无法再使用了</p>
</li>
<li><p><strong>failbit</strong>：发生可恢复错误后，failbit 被置位，比如期望读取一个 int 却读取了一个字符；修正后，流还可以继续使用</p>
</li>
<li><p><strong>eofbit</strong>：到达文件结束位置后被置位，failbit 此时也会被置位</p>
</li>
<li><p><strong>goodbit</strong>：值为 0 表示流未发生错误</p>
</li>
<li><p>使用 <strong>good</strong> 和 <strong>fail</strong> 是确定流的 <strong>总体状态</strong> 的正确方法</p>
</li>
</ul>
<h4 id="管理条件状态"><a href="#管理条件状态" class="headerlink" title="管理条件状态"></a>管理条件状态</h4><img src="/2024/01/19/8-IO%E5%BA%93/image-20240119102904908.png" class="" title="image-20240119102904908">

<ul>
<li>下面代码将 failbit 和 badbit 复位，但保持 eofbit 不变：</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119102952003.png" class="" title="image-20240119102952003">

<h3 id="8-1-3-管理输出缓冲"><a href="#8-1-3-管理输出缓冲" class="headerlink" title="8.1.3 管理输出缓冲"></a>8.1.3 管理输出缓冲</h3><ul>
<li><p>每个输入流都管理严格缓冲区，用来保存程序读写的数据，文本可能立即打印，也可能保存在缓冲区</p>
</li>
<li><p>由于设别的写操作可能很耗时，缓冲区允许操作系统将对各输出操作组合为单一的设备写操作，可以带来很大的性能提升</p>
</li>
<li><p>导致缓冲区刷新的原因：</p>
</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119103417735.png" class="" title="image-20240119103417735">

<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119103428573.png" class="" title="image-20240119103428573">

<h4 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h4><ul>
<li><strong>flush</strong>：刷新缓冲区，但不输出任何额外的字符</li>
<li><strong>ends</strong>：向缓冲区插入一个空字符，然后刷新缓冲区</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119103708247.png" class="" title="image-20240119103708247">

<h4 id="unitbuf-操纵符"><a href="#unitbuf-操纵符" class="headerlink" title="unitbuf 操纵符"></a>unitbuf 操纵符</h4><ul>
<li>使用 <strong>unitbuf</strong> 操作符告诉刘在接下来的每次写操作之后都进行一次 flush 操作</li>
<li>而 <strong>nounitbuf</strong> 操纵符则重置流，恢复正常的系统管理的缓冲区刷新机制</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119103922615.png" class="" title="image-20240119103922615">

<blockquote>
<p>如果程序异常终止，输出缓冲区是不会刷新的，当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印</p>
<p>所以当调试一个已经崩溃的程序时，你需要确认你认为已经输出的数据确实已经刷新了</p>
</blockquote>
<h4 id="关联输入和输出流"><a href="#关联输入和输出流" class="headerlink" title="关联输入和输出流"></a>关联输入和输出流</h4><ul>
<li><p>默认情况下，标准库将 cout 和 cin 关联在一起，所以 <code>cin &gt;&gt; val</code> 总是导致 cout 的缓冲区被刷新</p>
<blockquote>
<p>这在交互式系统中很有用，意味着所有输出总可以在读操作之前被打印出来</p>
</blockquote>
</li>
<li><p><strong>tie</strong> 有两个版本</p>
<ul>
<li>不带参数，返回指向的输出流的指针，如果没有关联，返回空指针，如果有，则返回本对象关联到的输出流的指针</li>
<li>带参数，接受一个 ostream 指针，将自己关联到 ostream</li>
</ul>
</li>
<li><p>我们可以通过 tie 将一个 istream 对象关联到另一个 ostream，也可以将一个 ostream 关联到另一个 ostream：</p>
</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119105058004.png" class="" title="image-20240119105058004">

<ul>
<li>每个流同时最多关联到一个流，但多个流可以同时关联到同一个 ostream</li>
</ul>
<h2 id="8-2-文件输入输出"><a href="#8-2-文件输入输出" class="headerlink" title="8.2 文件输入输出"></a>8.2 文件输入输出</h2><blockquote>
<p><strong>ifstream</strong>：从一个给定文件读取数据</p>
<p><strong>ostream</strong>：向一个给定文件写入数据</p>
</blockquote>
<ul>
<li>这些类型提供了和 cin、cout 一样的操作，还定义了一些新的成员来管理与流关联的文件：</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119105430658.png" class="" title="image-20240119105430658">

<h3 id="8-2-1-使用文件流对象"><a href="#8-2-1-使用文件流对象" class="headerlink" title="8.2.1 使用文件流对象"></a>8.2.1 使用文件流对象</h3><ul>
<li>创建文件流对象时，如果提供了一个文件名，则 <strong>open</strong> 会自动被调用</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119105603344.png" class="" title="image-20240119105603344">

<h4 id="成员函数-open-和-close"><a href="#成员函数-open-和-close" class="headerlink" title="成员函数 open 和 close"></a>成员函数 open 和 close</h4><ul>
<li>如果 open 调用失败，failit 会被置位，因此进行 open 是否成功的检测是一个好习惯</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119105807954.png" class="" title="image-20240119105807954">

<ul>
<li>实际上，对于一个已经打开的文件流调用 open 也会失败，导致 failbit 被置位</li>
</ul>
<h4 id="自动构造和析构"><a href="#自动构造和析构" class="headerlink" title="自动构造和析构"></a>自动构造和析构</h4><ul>
<li>当一个 fstream 对象离开其作用域时，与之关联的文件会自动关闭，即 <strong>当一个 fstream 对象被销毁时，close 会被自动调用</strong></li>
</ul>
<h3 id="8-2-2-文件模式"><a href="#8-2-2-文件模式" class="headerlink" title="8.2.2 文件模式"></a>8.2.2 文件模式</h3><ul>
<li>每个流都有一个与之关联的 <strong>文件模式</strong></li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119110130994.png" class="" title="image-20240119110130994">

<ul>
<li>指定文件模式的限制：</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119110245075.png" class="" title="image-20240119110245075">

<ul>
<li>每个文件流类型都有一个默认的文件模式，ifstream 为 in，ofstream 为 out，fstream 为 in 和 out</li>
</ul>
<h4 id="以-out-模式打开文件会丢弃已有数据"><a href="#以-out-模式打开文件会丢弃已有数据" class="headerlink" title="以 out 模式打开文件会丢弃已有数据"></a>以 out 模式打开文件会丢弃已有数据</h4><ul>
<li>默认情况下，以 out 打开的文件也会有 <strong>trunc 截断模式</strong>，阻止一个 ostream 清空给定文件内容的方法是指定 <strong>app 模式</strong></li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119110631551.png" class="" title="image-20240119110631551">

<h4 id="每次调用-open-时都会确定文件模式"><a href="#每次调用-open-时都会确定文件模式" class="headerlink" title="每次调用 open 时都会确定文件模式"></a>每次调用 open 时都会确定文件模式</h4><img src="/2024/01/19/8-IO%E5%BA%93/image-20240119110756988.png" class="" title="image-20240119110756988">

<h2 id="8-3-string-流"><a href="#8-3-string-流" class="headerlink" title="8.3 string 流"></a>8.3 string 流</h2><blockquote>
<p><strong>istringstream</strong>：从 string 读取数据</p>
<p><strong>ostringstream</strong>：向 string 写入数据</p>
<p><strong>stringstream</strong>：既可以从 string 读取数据也可以向 string 写入数据</p>
</blockquote>
<ul>
<li>除了继承自 iostream 的操作，还有一些特有的成员来关联与流相关联的 string：</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119111025023.png" class="" title="image-20240119111025023">

<h3 id="8-3-1-使用-istringstream"><a href="#8-3-1-使用-istringstream" class="headerlink" title="8.3.1 使用 istringstream"></a>8.3.1 使用 istringstream</h3><ul>
<li>当我们的某些工作是对整个文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用 istringstream</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119111407277.png" class="" title="image-20240119111407277">

<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119111420472.png" class="" title="image-20240119111420472">

<h3 id="8-3-2-使用-ostringstream"><a href="#8-3-2-使用-ostringstream" class="headerlink" title="8.3.2 使用 ostringstream"></a>8.3.2 使用 ostringstream</h3><ul>
<li>当我们希望逐步构造输出，对吼一起打印时，ostringstream 是很有用的</li>
</ul>
<img src="/2024/01/19/8-IO%E5%BA%93/image-20240119111545554.png" class="" title="image-20240119111545554">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/17/CSAPP-Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/17/CSAPP-Lab1/" class="post-title-link" itemprop="url">CSAPP-Lab1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-17 19:45:22" itemprop="dateCreated datePublished" datetime="2024-01-17T19:45:22+08:00">2024-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-19 17:50:07" itemprop="dateModified" datetime="2024-01-19T17:50:07+08:00">2024-01-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><strong>bits.c</strong> 文件是我们需要进行修改和编写的文件</li>
<li><strong>btest.c</strong> 是编译并检测我们代码（<strong>bits.c</strong> 文件）</li>
<li>每次修改 <strong>bits.c</strong> 文件后，我们都需要保存 <strong>CTRL + S</strong>，然后在命令行终端输入 <strong>make btest</strong> 重新进行编译生成新的可执行文件</li>
<li>通过 <strong>.&#x2F;btest -f function</strong> 来检测某个函数的正确性（<strong>function</strong> 为函数名）</li>
<li>通过 <strong>.&#x2F;btest</strong> 测试所有函数的正确性</li>
<li>通过 <strong>.&#x2F;dlc -e bits.c</strong> 打印每个函数使用的运算符数目</li>
</ul>
<h1 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要求：<strong>^</strong> 表示与非，仅使用 <strong>~ 取反</strong> 和 <strong>&amp; 与</strong> 来实现 <strong>^ 与非</strong></li>
<li><strong>^</strong> 的特性为：x 和 y 只有一个为 1 时才为 1，否则为 0，即可以表示为 <code>x^y = (~x &amp; y) | (x &amp; ~y)</code></li>
<li>因为仅可以使用 ~ 和 &amp;，我们通过公式法可以转换为：<ul>
<li><code>(~x &amp; y) | (x &amp; ~y)</code> &#x3D; <code>~(~(~x &amp; y) &amp; ~(x &amp; ~y))</code></li>
<li>也可以这样想，<code>(~x &amp; y) | (x &amp; ~y)</code> &#x3D; <code>(~x | ~y) &amp; (x | y)</code> &#x3D; <code>~(x &amp; y) &amp; ~(~x &amp; ~y)</code></li>
<li>原理：<strong>与非 &#x3D; 非 的 或 | 或非 &#x3D; 非 的 与</strong>（当然，也可以扩展为 <strong>或 &#x3D; 非 的 与非 | 与 &#x3D; 非 的 或非</strong>）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(x &amp; ~y) &amp; ~(~x &amp; y));</span><br><span class="line">  <span class="comment">// return ~(x &amp; y) &amp; ~(~x &amp; ~y);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要求：返回 <strong>32 位二进制中的最小数</strong>，仅可以使用 <strong>! 逻辑非、~ 取反、&amp; 与、^ 异或、| 或、+ 加法、&lt;&lt; 左移、&gt;&gt; 右移</strong> 来实现</li>
<li><strong>32 位二进制中的最小数</strong> 的位模式为 <strong>100……00</strong>，即符号位为 1 表示负数，其他位全为 0</li>
<li>1 的位模式为 <strong>00……01</strong>，我们可以通过将 1 <strong>左移 31</strong> 位来得到最小数 <strong>100……00</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="isTMax"><a href="#isTMax" class="headerlink" title="isTMax"></a>isTMax</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：如果 x 是 32 位二进制中最大数，返回 1，否则返回 0，仅可以使用 <strong>!  ~  &amp;  ^  +</strong> 来实现</p>
</li>
<li><p>32 位二进制中的最大数的位模式为 <strong>011……11</strong>，我们可以发现它有一些特殊特性：</p>
<ul>
<li><strong>011……11</strong> 加 1 得到 <strong>100……00</strong>，我们将这两个数相加又得到 <strong>11……11</strong></li>
<li>我们将 <strong>11……11</strong> 取反得到 <strong>00……00</strong>，这好像是其他数所没有的！</li>
</ul>
</li>
<li><p>然而，<strong>11……11</strong> 也有这样的特性</p>
<ul>
<li><strong>11……11</strong> 加 1 得到 <strong>00……00</strong>，这两个数相加也会得到 <strong>11……11</strong></li>
</ul>
</li>
<li><p>通过分析，我们又发现 <strong>11……11</strong> 有一些真正的且唯一的特殊特性：</p>
<ul>
<li>我们将 <strong>11……11</strong> 取反得到 <strong>00……00</strong>，在进行逻辑非 <strong>!</strong> ，就会得到 0，而其他数经过这样的操作都会得到 1</li>
<li>注：逻辑非 <strong>!</strong> 的作用为 <strong>将不为 0 的数转为 0，将 0 转为 1</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = x + <span class="number">1</span>; 	<span class="comment">// 得到 10……0 | 00……0 | 其他情况下的非零值</span></span><br><span class="line">  x = ~(x + y); 	<span class="comment">// 得到 00……0 | 其他情况下的非零值</span></span><br><span class="line">  y = !y; 			<span class="comment">// 排除 x = 11……1 的情况，如果是，则此时 y = !0 = 1 ，其他情况下 y = !非零值 = 0</span></span><br><span class="line">  x = x + y; 		<span class="comment">// 排村 x = 11……1 的情况，如果是，则此时 x = 0 + 1 = 1，</span></span><br><span class="line">    				<span class="comment">// 而对于 x = 0……11，此时 x = 0 + 0 = 0，当然其他情况为 x = 非零值 + 0 = 非零值</span></span><br><span class="line">  <span class="keyword">return</span> !x; 		<span class="comment">// 返回，x = 01……1 时，返回 !x = !0 = 1，x = 11……1 时，返回 !x = !1 = 0，</span></span><br><span class="line">    				<span class="comment">// 而其他情况，返回 x = !非零值 = 0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 另一种写法，好像更容易理解一些</span></span><br><span class="line">  <span class="comment">// !(~(x + x + 1) 筛选得到 x = 01……11 和 x = 11……11 的情况，!!(~x) 排除 x = 11……1 的情况</span></span><br><span class="line">  <span class="comment">// return !(~(x + x + 1)) &amp; !!(~x);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一种方法，真值表：</li>
</ul>
<table>
<thead>
<tr>
<th>x</th>
<th>011……11</th>
<th>11……11</th>
<th>其他情况</th>
</tr>
</thead>
<tbody><tr>
<td>y &#x3D; x + 1</td>
<td>100……00</td>
<td>00……00</td>
<td>未知值</td>
</tr>
<tr>
<td>x &#x3D; ~(x + y)</td>
<td>00……00</td>
<td>00……00</td>
<td>非零值</td>
</tr>
<tr>
<td>y &#x3D; ! y</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>x &#x3D; x + y</td>
<td>0</td>
<td>1</td>
<td>非零值</td>
</tr>
<tr>
<td>! x</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<ul>
<li>第二种方法，真值表：</li>
</ul>
<table>
<thead>
<tr>
<th>x</th>
<th>011……11</th>
<th>11……11</th>
<th>其他情况</th>
</tr>
</thead>
<tbody><tr>
<td>! (~x + x + 1)</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>! ! (~x)</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>&amp;</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：如果 32 位二进制数的奇数位全为 1，返回 1，否则返回 0，仅通过 <strong>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</p>
</li>
<li><p>如果一个数的奇数位全为 1，那么如果我们把它的偶数位也全变为 1，那么就得到了 <strong>11……11</strong>，我们再将它取反再取非，就得到了1，这是奇数位全为 1 的数的特殊特性！其他情况下都会得到 0！</p>
<ul>
<li>那么我们将它的偶数位全部置为 1 呢？我们可以通过与掩码 <strong>0101……0101（16 进制为 0X55……55）</strong> 进行 <strong>或</strong> 操作来实现</li>
<li>那么如何得到 <strong>0X55……55</strong> 呢？我们可以先将 0X55 左移 8 位，再加上 0X55 得到 0X5555，再将 0X5555 左移 16 位加上 0X5555 就得到了 0X55555555 了</li>
</ul>
</li>
<li><p>还有一种思路，我们将这个数的偶数位全都置为 0，再检测它的奇数位是否都为 1</p>
<ul>
<li>如何将它的偶数位全置为 0 呢？通过与掩码 <strong>1010……1010（16进制为 0XAA……AA）</strong> 进行 <strong>与</strong> 操作来实现<ul>
<li>0XAAAAAAAA 通过 0X55555555 的类似操作得到</li>
</ul>
</li>
<li>如何检测它是否所有奇数位全为 1 呢？通过与掩码 <strong>0XAA……AA</strong> 进行 <strong>异或</strong> 操作来实现<ul>
<li>如果奇数位全为 1 的话，异或得到 0，取非得到 1，其他情况下，得到非零值取非得到 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// int y = 0x55&lt;&lt;8; </span></span><br><span class="line">  <span class="comment">// y = y + 0x55;</span></span><br><span class="line">  <span class="comment">// y = y &lt;&lt; 16;</span></span><br><span class="line">  <span class="comment">// y = y + 0x5555;</span></span><br><span class="line">  <span class="comment">// x = x | y;</span></span><br><span class="line">  <span class="comment">// return !~x;</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> y = <span class="number">0xAA</span>&lt;&lt;<span class="number">8</span>;</span><br><span class="line">  y = y + <span class="number">0xAA</span>;</span><br><span class="line">  y = y &lt;&lt; <span class="number">16</span>;</span><br><span class="line">  y = y + <span class="number">0xAAAA</span>;</span><br><span class="line">  x = x &amp; y;</span><br><span class="line">  <span class="keyword">return</span> !(x^y); <span class="comment">// 括号是必须加的...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要求：返回 -x，仅通过 <strong>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</li>
<li>通过书上的公式 <code>-x = ~x + 1</code> 可以很容易实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：如果 <strong>0x30 &lt;&#x3D; x &lt;&#x3D; 0x39**，返回 1，否则返回 0，仅通过 **! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</p>
</li>
<li><p>我们可以通过两个特殊的数来判断 x 是否处于这个范围，一个数加上大于 0x39 的数后，由正数变为负数，另一个数加上大于 0x30 的数后，由负数变为正数</p>
<ul>
<li>因此我们需要设法得到这两个特殊的数，通过加上 x 来判断他们的符号位，如果都为正数，则 x 位于这个范围，如果至少一个为负数，则 x 不属于这个范围</li>
<li>对于第一个特殊的数，我们可以先得到 10……00，将它和 0x39 进行 或 操作，再进行取反得到</li>
<li>对于第二个特殊的数，我们可以通过将 0x30 取反 加 1 得到，也可以直接对 0x2F 取反得到</li>
</ul>
</li>
<li><p>还有一种更简单直观的思路，利用 negate 函数的技巧</p>
<ul>
<li>如果 <strong>x - 0X3A 小于 0 且 x - 0x30 大于等于 0</strong>，x 位于这个返回（x - 0X3A 而不是 0x39，是因为要判断是否是负数，即符号位是否为 1，x - 0X39 可能得到 0 使结果混淆）</li>
<li>-0X3A 和 -0X30 通过 ~x + 1 得到</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> y1 = ~(y | <span class="number">0x39</span>); 	<span class="comment">// 得到第一个特殊的数</span></span><br><span class="line">  <span class="type">int</span> y2 = ~<span class="number">0x30</span> + <span class="number">1</span>; 		<span class="comment">// 得到第二个特殊的数</span></span><br><span class="line">  <span class="type">int</span> sign1 = (y1 + x)&gt;&gt;<span class="number">31</span>; <span class="comment">// 判断 x 是否大于 0x39</span></span><br><span class="line">  <span class="type">int</span> sign2 = (y2 + x)&gt;&gt;<span class="number">31</span>; <span class="comment">// 判断 x 是否小于 0x30</span></span><br><span class="line">  <span class="keyword">return</span> !(sign1 | sign2);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// return (x + ~0x3A+1)&gt;&gt;31 &amp; !(x + ~0x30+1)&gt;&gt;31;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：实现 <strong>x ? y : z</strong>，即如果 x !&#x3D; 0，返回 y，x &#x3D;&#x3D; 0，返回 z，仅通过 <strong>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</p>
</li>
<li><p>首先我们应该想一个方法将 x &#x3D; 0 和 x &#x3D; 非零值 这两种情况分开，然后我们需要想办法如何根据 x 的值区分 y 和 z</p>
</li>
<li><p>我们可以通过 <strong>! 运算 将 x &#x3D; 0 和 x !&#x3D; 0 两种情况分开</strong>，<strong>如果 x &#x3D; 0，x &#x3D; ! x &#x3D; 1，如果 x !&#x3D; 0，x &#x3D; ! x &#x3D; 0</strong></p>
</li>
<li><p>我们如何通过此时的 x 值区分 y 和 z 呢？我们知道 <strong>t &amp; 11……11 &#x3D; t，t &amp; 00……00 &#x3D; 0</strong>，我们是否可以根据当前的 x 值来得到 11……11 和 00……00呢？</p>
<ul>
<li>通过 <code>x = ~x + 1</code> 就可以实现，x &#x3D; 0 时，x &#x3D; 00……00，x &#x3D; 1 时，x &#x3D; 11……11</li>
</ul>
</li>
<li><p>这样我们就可以区分 y 和 z 了，通过 <strong>(y &amp; ~x) + (z &amp; x)</strong> 来实现</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  x = !x;  </span><br><span class="line">  x = ~x + <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> (y &amp; ~x) + (z &amp; x); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>要求：如果 x &lt;&#x3D; y，返回 1，否则返回 0，仅通过 <strong>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</p>
</li>
<li><p>注意：不要轻易对范围不确定的 int 使用 + ，两个正数相加很容易溢出得到一个负数</p>
<blockquote>
<p>之前还想着用 y + ~x + 1 ，再判断符号位得到结果……</p>
</blockquote>
</li>
<li><p>我们需要记住一个原则：符号位不同，正数为大，符号位相同，作差判断符号位</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> signX = x&gt;&gt;<span class="number">31</span>; <span class="comment">// 得到 x 的符号位</span></span><br><span class="line">  <span class="type">int</span> signY = y&gt;&gt;<span class="number">31</span>; <span class="comment">// 得到 y 的符号位</span></span><br><span class="line">  <span class="type">int</span> sign = signX^signY; <span class="comment">// 判断 x 和 y 是否有相同的符号</span></span><br><span class="line">  <span class="comment">// !sign &amp; !((y+~x+1)&gt;&gt;31) 符号相同，作差判断符号，!!sign &amp; !signY 符号位不同，检查 y 的符号位</span></span><br><span class="line">  <span class="keyword">return</span> (!sign &amp; !((y+~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>)) | (!!sign &amp; !signY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>! sign &amp; ! ((y ~x + 1)&gt;&gt;31))</strong> 检查符号位相同的情况，此时 sign 为 00……00，取非得到 00……01，如果 y - x 为正，则 <strong>((y ~x + 1)&gt;&gt;31))</strong> 得到 11……11 ，取非同样得到 00……01</p>
</li>
<li><p><strong>! ! sign &amp; ! signY</strong> 检查符号位不同的情况，此时 ! ! sigh 为 00……01，**! signY** 判断 y 的符号位，如果 y 为正，则 ! sighY 为 00……01</p>
<blockquote>
<p>记住，千万别 x &#x3D; x&gt;&gt;31，y &#x3D; y&gt;&gt;31，这样会改变 x、y 的值，后边还要作差呢……</p>
</blockquote>
</li>
</ul>
<h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要求：实现 <strong>逻辑非 !</strong> 运算符，仅通过 <strong>~ &amp; ^ | + &lt;&lt; &gt;&gt;</strong> 来实现</li>
<li>我们需要想一个方法将 0 和其他非零情况分开进行处理，我们可以利用补码的非这个特性来实现<ul>
<li>0 的非还是 0，特殊的 TMin 的非也还是 TMin，其他数的非为 -x</li>
<li>然而，我们发现除了 0，其他数（包括 TMin）和它的非的 <strong>或</strong> 的值的符号位总为 1，而只有 0 和它的非的 或 的值的符号位为 0</li>
<li>我们可以利用这个特点分开处理 0 和其他情况</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// x = 0 时，00……00 + 1 = 1，x = 其他情况时，11……11 + 1 = 0</span></span><br><span class="line">  <span class="keyword">return</span> ((x | (~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们不确定不同运算符的优先级，加上括号让他符合你的逻辑总是没错的</p>
</blockquote>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>虚拟机下载相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45912291/article/details/108901106">虚拟机VMware安装ubuntu教程（ubuntu-20.04.1-desktop-amd64.iso）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45912291/article/details/108894737">虚拟机VMware下载与安装教程（详细）</a></p>
<ul>
<li>换源相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bryan_QAQ/article/details/89951443">ubuntu 更改浏览器搜索引擎</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11Drlzij">ubuntu镜像_阿里巴巴开源镜像站 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45912291/article/details/108900602">Ubuntu系统下载（清华大学开源软件镜像站）（ubuntu-20.04.1-desktop-amd64.iso）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39514906/article/details/119703781">ubuntu sudo password 无法输入解决方法-CSDN博客</a></p>
<ul>
<li>中文设置相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gymaisyl/article/details/100981982">ubuntu 设置中文环境</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45965432/article/details/115446648">Ubuntu设置中文界面_ubuntu怎么设置中文</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43431593/article/details/106444769">Ubuntu设置中文输入法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/meyungle/article/details/98808528">Ubuntu中文语言包下载失败解决方法</a></p>
<ul>
<li>实验相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45703010/article/details/120897185">【CSAPP】lab0 环境的配置_虚拟机安.&#x2F;dlc是什么意思-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45698833/article/details/118689278">CSAPP实验记录（一）：环境配置&amp;datalab_unix make btest-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45677541/article/details/123955438">CSAPP Lab1：Data Lab （虚拟机安装+Lab环境配置+函数实现）-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7199280265914023997">CSAPP: Data Lab - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59534845">CSAPP 之 DataLab详解，没有比这更详细的了 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Yuan_Cl/article/details/83960550">CS:APP Data Lab_cs:app data lab 中文翻译-CSDN博客</a></p>
<ul>
<li>关于我</li>
</ul>
<p><strong>虚拟机全名</strong>：YiweiBoi</p>
<p><strong>用户名</strong>：yiweiboi</p>
<p><strong>密码</strong>：woainimen1314</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">CSAPP-2-信息的表示与处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-16 09:19:56 / 修改时间：12:12:20" itemprop="dateCreated datePublished" datetime="2024-01-16T09:19:56+08:00">2024-01-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2-信息的表示与处理"><a href="#2-信息的表示与处理" class="headerlink" title="2. 信息的表示与处理"></a>2. 信息的表示与处理</h1><blockquote>
<p>现代计算机存储和处理数据以 <strong>位（bit）</strong> 为基础，二进制值工作的更好，能够被更好的表示、存储和传输</p>
<p>孤立的来说，单个位并不是非常有用，当把位组合在一起，再加上某种 <strong>解释</strong> ，那就赋予了位模式以含义，可以表示任何有限集合</p>
<p>我们研究的三种最重要的数字：<strong>无符号编码、补码、浮点数</strong></p>
</blockquote>
<h2 id="2-1-信息的存储"><a href="#2-1-信息的存储" class="headerlink" title="2.1 信息的存储"></a>2.1 信息的存储</h2><blockquote>
<p>大多数计算机都是以 <strong>8个位的块（字节）</strong> 作为最小的可寻址的内存单位</p>
<p>虚拟内存：机器程序将内存是为一个 <strong>非常大的字节数组</strong> ，所有可能的集合即为 <strong>虚拟地址空间</strong> ，但它只是一个 <strong>被展示给机器级程序的概念性映像</strong> </p>
<p>编译器将指针和类型信息联合起来，便于生成不同的机器级代码来访问存储在指针所指地址空间的值，但其生成的机器级程序并不包含关于数据类型的信息</p>
</blockquote>
<h3 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h3><ul>
<li>二进制表示法太冗长，十进制表示法与位模式相互转换很麻烦</li>
</ul>
<h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><ul>
<li>字长：决定了虚拟地址空间的最大大小，字长为 <strong>w</strong> 位的机器，虚拟地址的范围位 <strong>0 ~ 2^w^-1</strong> ，即程序最多访问 <strong>2^w^</strong> 个字节</li>
<li>32位程序和64位程序的区别在于 <strong>程序是如何编译的，而不是其运行的机器的类型</strong></li>
<li>为了避免依赖 <strong>典型</strong> 大小和不同编译器设置带来的奇怪行为，设计了一些固定大小的数据类型</li>
</ul>
<style>.gbxgbxgwpsss{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.1.2.png" class="gbxgbxgwpsss" alt="image-20240113161658749">

<h3 id="2-1-3寻址和字节顺序"><a href="#2-1-3寻址和字节顺序" class="headerlink" title="2.1.3寻址和字节顺序"></a>2.1.3寻址和字节顺序</h3><ul>
<li>多字节对象都被存储在 <strong>连续的字节序列</strong>，对象的 <strong>地址</strong> 为所使用字节中最小地址</li>
<li>表示一个对象的字节有两种通用的规则<ul>
<li><strong>小端法</strong>：最低有效字节在最左边</li>
<li><strong>大端法</strong>：最高有效字节在最左边</li>
<li>注意，<strong>我们一般书写的顺序为大端法</strong></li>
</ul>
</li>
</ul>
<style>.mpvybjdzvwfh{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.1.3.png" class="mpvybjdzvwfh" alt="image-20240113162025395">

<ul>
<li>由于不同字节顺序所引发的问题：网络传输二进制数据、阅读整数数据的字节序列、编写规避正常的类型系统的程序</li>
<li>整数和浮点数编码不同的原因是：两种格式使用不同的编码方法</li>
<li>指针值编码完全不同的原因：不同机器 &#x2F; 操作系统配置使用不同的存储分配规则</li>
</ul>
<style>.loujmpxuwxmr{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.1.3.1.png" class="loujmpxuwxmr" alt="image-20240113162214103">

<h3 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h3><ul>
<li>字符编码与字节顺序和字大小规则无关，与使用编码规则有关，如ASCLL字符码，使用相同字符编码规则在任何系统上都会得到相同的结果，因此文本数据比二进制数据有更好的平台独立性</li>
</ul>
<h3 id="2-1-5-表示代码"><a href="#2-1-5-表示代码" class="headerlink" title="2.1.5 表示代码"></a>2.1.5 表示代码</h3><ul>
<li>不同机器类型使用不同的且不兼容的指令和编码方式，二进制代码是不兼容的，很少可以移植</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.1.5.png" class="" title="image-20240113162325035">

<h3 id="2-1-6-布尔代数简介"><a href="#2-1-6-布尔代数简介" class="headerlink" title="2.1.6 布尔代数简介"></a>2.1.6 布尔代数简介</h3><h3 id="2-1-7-C语言中的位级运算"><a href="#2-1-7-C语言中的位级运算" class="headerlink" title="2.1.7 C语言中的位级运算"></a>2.1.7 C语言中的位级运算</h3><ul>
<li>位级运算的一个常用方法是 <strong>掩码运算</strong> ，这里的掩码是一个位模式，表示从一个字中选出位的集合</li>
</ul>
<h3 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h3><ul>
<li>千万不要把逻辑运算和位级运算混淆，它们是完全不同的两种功能</li>
<li>一个重要区别就是，逻辑运算如果对第一个参数求值结果就能确定的话，那么就不会对第二个参数求值</li>
</ul>
<h3 id="2-1-9-C语言中的移位运算"><a href="#2-1-9-C语言中的移位运算" class="headerlink" title="2.1.9 C语言中的移位运算"></a>2.1.9 C语言中的移位运算</h3><ul>
<li><strong>左移</strong>：&gt;&gt;</li>
<li><strong>逻辑右移</strong>：用于 <strong>无符号数</strong></li>
<li><strong>算术右移</strong>：几乎所有编译器 &#x2F; 机器组合都对<strong>有符号数</strong> 使用算术右移，且我们也假设机器使用算术右移</li>
<li>在很多机器中，当移动一个 <strong>w</strong> 位的值时，如果要移动 <strong>k &gt;&#x3D; w 位</strong> ，实际上的移动量为 <strong>k mod w</strong>，但一些程序并不能保证</li>
</ul>
<h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><blockquote>
<p>主要描述用位来编码整数的两种不同的方式：无符号数、有符号数</p>
</blockquote>
<h3 id="2-2-1-整数数据类型"><a href="#2-2-1-整数数据类型" class="headerlink" title="2.2.1 整数数据类型"></a>2.2.1 整数数据类型</h3><style>.syhljidvgirn{zoom: 67%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.1.png" class="syhljidvgirn" alt="image-20240113165907711"><style>.cxgfchvkoihz{zoom: 67%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.1.1.png" class="cxgfchvkoihz" alt="image-20240113165956780">

<ul>
<li>这里给出的唯一一个取值范围与机器相关的类型位 long</li>
<li>并且我们可以注意到，取整范围不是对称的，负数的取整范围比整数的范围大 1</li>
</ul>
<h3 id="2-2-2-无符号数的编码"><a href="#2-2-2-无符号数的编码" class="headerlink" title="2.2.2 无符号数的编码"></a>2.2.2 无符号数的编码</h3><ul>
<li>无符号编码的基本原理：</li>
</ul>
<style>.ocquwlxatdll{zoom: 80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.2.png" class="ocquwlxatdll" alt="image-20240113170435788"><style>.htthhnpytxyi{zoom:67%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.2.1.png" class="htthhnpytxyi" alt="image-20240113170602003">

<ul>
<li>无符号编码具有唯一性，即每个介于 <strong>0 ~ 2^w^-1</strong> 之间的数都有唯一一个 <strong>w</strong> 位的值编码</li>
</ul>
<h3 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h3><ul>
<li>最常见的有符号数的计算机表示方式就是 <strong>补码</strong>，在补码的定义中，字的最高有效位解释位 <strong>负权</strong></li>
</ul>
<style>.kqckwwyscvgx{zoom:67%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.2.2.png" class="kqckwwyscvgx" alt="image-20240113170936379"><style>.elrrswefbirb{zoom:67%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.2.3.png" class="elrrswefbirb" alt="image-20240113171032126">

<ul>
<li>同无符号表示一样，在可表示的取值范围内的每个数字都有一个唯一的 <strong>w</strong> 位的补码编码</li>
<li>补码的范围是不对称的：**|TMin| &#x3D; |TMax| + 1**，这是因为 TMin &#x3D; [1000……0]，TMax &#x3D; [0111……1]，0为非负数，从而导致的 TMax 比 TMin 少 1</li>
<li>最大的无符号数 UMax 比补码的最大值 TMax 的 2 倍还大 1，即 <strong>UMax &#x3D; 2TMax + 1</strong></li>
</ul>
<h3 id="2-2-4-有符号数和无符号数之间的转换"><a href="#2-2-4-有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 有符号数和无符号数之间的转换"></a>2.2.4 有符号数和无符号数之间的转换</h3><ul>
<li>需要明确的是：<strong>类型转换的结果保持位不变，只是改变了解释这些位的方式</strong>，即数值可能改变，但位模式不变</li>
<li>有符号数转无符号数：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.4.png" class="" title="image-20240113172139014">

<ul>
<li>所以，当一个有符号数映射位它相应的无符号数时，负数就转换为大的正数，而非负数保持不变</li>
<li>无符号数转有符号数：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.4.1.png" class="" title="image-20240113172405854">

<h3 id="2-2-5-C语言中的有符号数和无符号数"><a href="#2-2-5-C语言中的有符号数和无符号数" class="headerlink" title="2.2.5 C语言中的有符号数和无符号数"></a>2.2.5 C语言中的有符号数和无符号数</h3><ul>
<li>当执行一个运算时，C 语言会隐式的将有符号参数强制转换为无符号数，并假设这两个数都是非负的</li>
</ul>
<h3 id="2-2-6-扩展一个数字的位表示"><a href="#2-2-6-扩展一个数字的位表示" class="headerlink" title="2.2.6 扩展一个数字的位表示"></a>2.2.6 扩展一个数字的位表示</h3><ul>
<li>无符号数的零扩展：</li>
</ul>
<style>.wbjmfcxjswsd{}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.6.png" class="wbjmfcxjswsd" alt="image-20240113173032471">

<ul>
<li>有符号数的符合扩展</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.6.1.png" class="" title="image-20240113173130459">

<ul>
<li>这两种扩展都不会改变数值</li>
<li>对于 <code>short sx = -12345; unsigned uy = sx;</code> ，首先改变大小，之后再完成从有符号到无符号的转换，即等价于 <code>(unsigned) (int) sx</code></li>
</ul>
<h3 id="2-2-7-截断数字"><a href="#2-2-7-截断数字" class="headerlink" title="2.2.7 截断数字"></a>2.2.7 截断数字</h3><ul>
<li>截断一个数字可能会改变它的值，这是 <strong>溢出</strong> 的一种形式</li>
<li>截断无符号数：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.7.png" class="" title="image-20240113174106480">

<ul>
<li>截断有符号数：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.2.7.1.png" class="" title="image-20240113174144727">

<ul>
<li>即先将其看作无符号数，截断以后再转为有符号数</li>
</ul>
<h2 id="2-3-整数运算"><a href="#2-3-整数运算" class="headerlink" title="2.3 整数运算"></a>2.3 整数运算</h2><blockquote>
<p>我们有时会惊奇地发现，两个正数相加会得到一个负数，而表达式 x &lt; y 和 x - y &lt; 0 会产生不同的结果</p>
<p>这些属性是由计算机运算的有限性造成的</p>
</blockquote>
<h3 id="2-3-1-无符号加法"><a href="#2-3-1-无符号加法" class="headerlink" title="2.3.1 无符号加法"></a>2.3.1 无符号加法</h3><ul>
<li>我们总是将 x + y 截断为 w 位 得到的结果，再把它看作一个无符号数：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.1.png" class="" title="image-20240114120057057">

<ul>
<li>算术运算的溢出，是指完整的整数结果不能放到数据类型的字长限制中去</li>
<li>无符号加法是否溢出的检测：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.1.1.png" class="" title="image-20240114120303899">

<ul>
<li>无符号数求反：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.1.2.png" class="" title="image-20240114120355251">

<h3 id="2-3-2-补码加法"><a href="#2-3-2-补码加法" class="headerlink" title="2.3.2 补码加法"></a>2.3.2 补码加法</h3><ul>
<li>我们同样通过表示截断到 w 位，来避免数据大小的不断扩张：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.2.png" class="" title="image-20240114120610165">

<ul>
<li><p>我们可以观察到：<strong>两个数的 w 位补码之和与无符号之和有完全相同的位级表示，只是解释方式不同</strong></p>
</li>
<li><p>补码加法是否溢出的检测：</p>
</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.2.1.png" class="" title="image-20240114120841612">

<h3 id="2-3-3-补码的非"><a href="#2-3-3-补码的非" class="headerlink" title="2.3.3 补码的非"></a>2.3.3 补码的非</h3><ul>
<li>补码的加法逆元即补码的非：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.3.png" class="" title="image-20240114121013371">

<ul>
<li>补码的非的位级表示的几种方法：<ul>
<li>对每一位求补，再对结果加 1</li>
<li>假设 k 是最右边的 1 的位置，则我们对位 k 左边的所有位取反</li>
<li>注意：上述方法，都不考虑符合位，全都取反</li>
</ul>
</li>
</ul>
<h3 id="2-3-4-无符号乘法"><a href="#2-3-4-无符号乘法" class="headerlink" title="2.3.4 无符号乘法"></a>2.3.4 无符号乘法</h3><ul>
<li>无符号数乘法：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.4.png" class="" title="image-20240114121627890">

<h3 id="2-3-5-补码乘法"><a href="#2-3-5-补码乘法" class="headerlink" title="2.3.5 补码乘法"></a>2.3.5 补码乘法</h3><ul>
<li>相当于计算 x 和 y 的无符号乘法，再将无符号数转换位补码得到：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.5.png" class="" title="image-20240114121923127">

<ul>
<li>我们认为对于无符号和补码乘法来说，乘法运算的位级表示都是一样的</li>
</ul>
<style>.jejogahrglwf{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.5.1.png" class="jejogahrglwf" alt="image-20240114122632606">

<h3 id="2-3-6-乘以常数"><a href="#2-3-6-乘以常数" class="headerlink" title="2.3.6 乘以常数"></a>2.3.6 乘以常数</h3><ul>
<li>首先考虑乘以 2 的幂的情况：</li>
</ul>
<style>.usogvuwqrtfi{}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.6.png" class="usogvuwqrtfi" alt="image-20240114123451331">

<ul>
<li>我们可以看出左移一个数值等价于执行一个与 2 的幂相乘的无符号乘法</li>
<li>需要注意的是：无论是无符号运算还是补码运算，乘以 2 的幂都可能导致溢出，但即使溢出的时候，我们通过移位得到的结果也是一样的，即位模式还是一样的</li>
<li>由于<strong>整数乘法比移位和加法的代价要大得多</strong>，编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况<ul>
<li>如表达式 <strong>x * 14</strong>，利用 <strong>14 &#x3D; 2^3^ + 2^2^ + 2^1^</strong> ，编译器会将乘法重写为 <strong>(x&lt;&lt;3) + (x&lt;&lt;2) + (x&lt;&lt;1)</strong></li>
<li>编译器还可以利属性 <strong>14 &#x3D; 2^4^ - 2^1^</strong>，将乘法重写为 <strong>(x&lt;&lt;4) - (x&lt;&lt;1)</strong></li>
<li>大多数编译器只在需要少量移位、加法和减法就足够的时候才使用这种优化</li>
</ul>
</li>
</ul>
<h3 id="2-3-7-除以-2-的幂"><a href="#2-3-7-除以-2-的幂" class="headerlink" title="2.3.7 除以 2 的幂"></a>2.3.7 除以 2 的幂</h3><ul>
<li>在大多数机器上，整数除法要比整数乘法更慢</li>
<li>除以 2 的幂也可以用移位运算来实现，只不过是右移</li>
<li>无符号数的右移一定是 <strong>逻辑右移</strong></li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.png" class="" title="image-20240114135657324">

<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.1.png" class="" title="image-20240114135806413">

<ul>
<li><p>有符号数为了保证负数仍然为负，移位要执行的是 <strong>算术右移</strong></p>
<ul>
<li>但我们如果只是执行算术右移，有时会与整数除法的规则不符</li>
</ul>
</li>
<li><p>如果只是简单的算术右移：</p>
</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.2.png" class="" title="image-20240114140311743">

<style>.funjlcwokyrv{}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.3.png" class="funjlcwokyrv" alt="image-20240114140339504">

<ul>
<li>我们可以通过在移位之前 <strong>偏置</strong> 这个值，来修正这种不合适的舍入：</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.4.png" class="" title="image-20240114140508967">

<blockquote>
<p>修正：产生数值$\lceil x&#x2F;2^k \rceil$</p>
</blockquote>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.3.7.5.png" class="" title="image-20240114140548404">

<ul>
<li>C 表达式为：<code>(x&lt;0 ? x+(1&lt;&lt;k)-1 : x) &gt;&gt; k</code></li>
<li>同乘法不同，我们不能用除以 2 的幂的除法来表示除以任意常数 K 的除法</li>
</ul>
<h3 id="2-3-8-关于整数运算的最后思考"><a href="#2-3-8-关于整数运算的最后思考" class="headerlink" title="2.3.8 关于整数运算的最后思考"></a>2.3.8 关于整数运算的最后思考</h3><ul>
<li>计算机执行 <strong>“整数”</strong> 运算实际上是一种 <strong>模运算</strong> 的形式</li>
<li>表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出</li>
<li>无符号数和补码实行了相同的运算包括加法、减法、乘法，甚至除法，都有完全一样或非常类似的位级行为</li>
</ul>
<h2 id="2-4-浮点数"><a href="#2-4-浮点数" class="headerlink" title="2.4 浮点数"></a>2.4 浮点数</h2><blockquote>
<p>浮点表示形如 <strong>V &#x3D; x * 2^y^</strong> 的有理数进行编码</p>
<p>它对于执行涉及非常大的数字 |V| &gt;&gt; 0，非常接近于 0 的数字 |V| &lt;&lt; 1，以及更普遍地作为实数运算的近似值的计算，是很有用的</p>
<p>目前，实际上所有的计算机都支持 <strong>IEEE 浮点</strong> 标准，大大提高了科学应用程序在不同机器上的可移植性</p>
<p>IEEE 格式是定义在一组小而非一致的原则上的</p>
</blockquote>
<h3 id="2-4-1-二进制小数"><a href="#2-4-1-二进制小数" class="headerlink" title="2.4.1 二进制小数"></a>2.4.1 二进制小数</h3><ul>
<li>二进制数 <strong>101.11</strong> 表示数字 **1 * 2^2^ + 0 * 2^1^ + 1 * 2^0^ + 1 * 2^-1^ + 1 * 2^-2^ **</li>
</ul>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.1.png" class="" title="image-20240114150353692">

<ul>
<li><p>二进制小数点向左移一位相当于这个数被 2 除，右移一位相当于这个数乘 2</p>
</li>
<li><p>形如 <strong>0.1111……1</strong> 这样的二进制数表示刚好小于 1 的数，简单表示为 <strong>1.0-ε</strong></p>
</li>
<li><p>小数的二进制表示法只能表示那些能够被写成 x * 2^y^ 的数，其他值只能近似的表示</p>
</li>
</ul>
<h3 id="2-4-2-IEEE-浮点表示"><a href="#2-4-2-IEEE-浮点表示" class="headerlink" title="2.4.2 IEEE 浮点表示"></a>2.4.2 IEEE 浮点表示</h3><ul>
<li><p>IEEE 浮点标准用 <strong>V &#x3D; (-1)^s^ * M * 2^E^</strong>  的形式来表示一个数</p>
<ul>
<li><strong>符号 s</strong>：决定这个数的符合，负数（s &#x3D; -1）还是正数（s &#x3D; 0），由一个单独的符号位直接编码</li>
<li><strong>尾数 M</strong>：是一个二进制小数，由 n 位的小数字段编码</li>
<li><strong>阶码 E</strong>：作用为给浮点数加权，权重位 2 的 E 次幂，由 k 位的阶码字段（整数部分）编码</li>
</ul>
</li>
<li><p>单精度浮点格式 float，1 个符号位，k &#x3D; 8，n &#x3D; 23，得到一个 32 位的表示</p>
</li>
<li><p>双精度浮点格式 double，1 个符号位，k &#x3D; 11，n &#x3D; 52，得到一个 64 位的表示</p>
</li>
</ul>
<style>.lwftqnmauqnk{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.2.png" class="lwftqnmauqnk" alt="image-20240114152534113">

<ul>
<li><p>根据 exp（阶码字段）的值，被编码的值可以分成三中不同的情况</p>
<ul>
<li><p><strong>规格化的值</strong>：最普遍的情况，exp 的位模式有 0 有 1</p>
<ul>
<li><p>阶码字段被解释为以 <strong>偏置</strong> 的形式表示有符号整数，阶码的值 <strong>E &#x3D; e - Bias</strong></p>
<ul>
<li>e 为无符号数 exp，Bias 为 2^k-1^ - 1（float 为 127，double 为 1023）</li>
</ul>
</li>
<li><p>此时单精度是 -126 ~ 127</p>
<blockquote>
<p>对于单精度来说，因为有 0 有 1，所以取值范围为 [00……01，11……10]</p>
<p>单精度为 [1 - 127，254 - 127] &#x3D; [-126，127]</p>
</blockquote>
</li>
<li><p>尾数定义为 <strong>M &#x3D; 1 + f</strong></p>
<ul>
<li>f 为小数字段，这是一种<strong>隐含的以1开头的</strong> 表示</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>非规格化的值</strong>：当阶码域（整数部分）全为 0 时</p>
<ul>
<li><p>阶码值是 <strong>E &#x3D; 1 - Bias</strong>，尾数的值是 <strong>M &#x3D; f</strong></p>
<blockquote>
<p>E &#x3D; 1 - Bias 而不是 E &#x3D; -Bias，是为了让最大非规格化的值 [0.11……1] 和最小规格化的值 [1.00……0] 无缝衔接</p>
</blockquote>
</li>
<li><p>非规格化的值为我们提供了一种表示 0 的方法，因为根据 IEEE 浮点格式，在一些方面 +0.0 和 -0.0 被认为是不同的，而规格化的数，我们总是必须让 M &gt;&#x3D; 1，即整数部分总是不能全为 0，非规格化的数很好的表示了 +0.0</p>
</li>
</ul>
</li>
<li><p><strong>特殊值</strong>：阶码全为 1 时</p>
<ul>
<li>小数域全为 0 时，得到的值表示无穷，s &#x3D; 0 时表示正无穷，s &#x3D; 1 时表示负无穷</li>
<li>小数域为非零时，结果值被称为 <strong>NAN</strong>，即 <strong>Not a Number</strong> 的缩写</li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.xzwmkbfgqcbf{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.2.1.png" class="xzwmkbfgqcbf" alt="image-20240114154957055">

<h3 id="2-4-3-数字示例"><a href="#2-4-3-数字示例" class="headerlink" title="2.4.3 数字示例"></a>2.4.3 数字示例</h3><ul>
<li>越靠近原点 0，可表示的数越稠密</li>
</ul>
<style>.covnfttmcbtp{}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.3.png" class="covnfttmcbtp" alt="image-20240114155045884">

<ul>
<li>最大非规格化数和最小规格化数之间的平滑转变，归功于将 E 定义为 1 - Bias，可以补充非规格化数的尾数没有隐含的开头的 1</li>
</ul>
<style>.hsytdygmowny{zoom:80%;}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.3.1.png" class="hsytdygmowny" alt="image-20240114155308630">

<ul>
<li>如果按照无符号解释，它们就是按照升序排列的，这样设计是为了浮点数能够使用整数排序函数来进行排序</li>
</ul>
<h3 id="2-4-4-舍入"><a href="#2-4-4-舍入" class="headerlink" title="2.4.4 舍入"></a>2.4.4 舍入</h3><ul>
<li><p>表示方法限制了浮点数的范围和精度，只能近似表示实数运算，舍入运算的任务就是能够找到 <strong>最近接的</strong> 匹配值</p>
</li>
<li><p>IEEE 浮点格式定义了死者不同的舍入方式，默认方法是找到最接近的匹配</p>
<ul>
<li><p><strong>向偶舍入</strong> 也被称为 <strong>最接近的值舍入</strong>，<strong>是默认方式</strong></p>
<ul>
<li>对于 1.4 舍入到 1，对于 1.6 舍入到 2，得到最接近的整数，而对于 1.5 和 2.5，都舍入到 2，使结果的最低有效数字是偶数</li>
<li>相似的，也可以运用在二进制小数上，我们将最低有效位 0 认为是偶数，1 认为是奇数</li>
<li>向偶舍入在大多数现实情况中避免了统计的偏差</li>
</ul>
</li>
<li><p><strong>向零舍入</strong> 方式把正数向下舍入，把负数向上舍入</p>
</li>
<li><p><strong>向下舍入</strong> 方式把正数和负数都向下舍入</p>
</li>
<li><p><strong>向上舍入</strong> 方式把正数和负数都向上舍入</p>
</li>
</ul>
</li>
</ul>
<style>.nwgezstjhdtn{}</style><img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.4.png" class="nwgezstjhdtn" alt="image-20240114161650259">

<h3 id="2-4-5-浮点运算"><a href="#2-4-5-浮点运算" class="headerlink" title="2.4.5 浮点运算"></a>2.4.5 浮点运算</h3><ul>
<li><p>对于实数 x、y，计算将产生 **Round(x * y)**，这是对实数运算的精确结果进行舍入后的结果，但在实际中，通常会避免执行这些精确的运算，因为计算只要精确到能够保证得到一个正确的舍入结果就可以了</p>
</li>
<li><p>浮点运算的一些特性</p>
<ul>
<li><p>浮点加法：可交换的、不可结合的，都不是 NaN 的话，是单调的（无符号和补码加法没有单调性）</p>
</li>
<li><p>浮点乘法：可交换的、不可分配的，都不是 NaN的话，满足如下单调性（当然，无符号和补码乘法没有这些单调性）</p>
<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.5.png" class="" title="image-20240114163833483">		<img src="/2024/01/16/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/2.4.5.1.png" class="" title="image-20240114163904931"></li>
</ul>
</li>
</ul>
<h3 id="2-4-6-C-语言中的浮点数"><a href="#2-4-6-C-语言中的浮点数" class="headerlink" title="2.4.6 C 语言中的浮点数"></a>2.4.6 C 语言中的浮点数</h3><ul>
<li><p>int 转为 float 不会溢出，但可能会被舍入</p>
</li>
<li><p>double 转为 float，可能溢出，也可能舍入</p>
</li>
<li><p>double、float 转为 int，值会向零舍入，且值可能溢出</p>
<blockquote>
<p>与 Intel 兼容的微处理器指定位模式 [10……00] (TMin) 为正数不确定值，如果一个浮点数到正数的转换不能找到一个合理的整数近似值，将会得到这样的一个结果</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="post-title-link" itemprop="url">代码随想录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-16 09:07:05" itemprop="dateCreated datePublished" datetime="2024-01-16T09:07:05+08:00">2024-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-17 21:45:55" itemprop="dateModified" datetime="2024-01-17T21:45:55+08:00">2024-01-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>全面：YiweiBoi</p>
<p>用户名：yiweiboi</p>
<p>密码：woainimen1314</p>
<h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43031092/article/details/105322677">Markdown如何实现多文档之间的跳转_markdown 跳转其他md文件-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_77285173/article/details/130189857">在hexo博客中插入图片的方法_hexo 博客添加图片-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_43401436/article/details/107191688">hexo博客中插入图片失败——解决思路及个人最终解决办法_hexo无法插入图片-CSDN博客</a></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><a href="./LeetCode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md">二分查找</a></p>
<p><a href="./LeetCode-27-%E7%A7%BB%E5%87%BA%E5%85%83%E7%B4%A0.md">移出元素</a></p>
<p><a href="./LeetCode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.md">有序数组的平方</a></p>
<p><a href="./LeetCode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.md">长度最小的子数组</a></p>
<p><a href="./LeetCode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52.md">螺旋矩阵2</a></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><a href="./LeetCode-203-%E7%A7%BB%E5%87%BA%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.md">移出链表元素</a></p>
<p><a href="./LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md">反转链表</a></p>
<p><a href="./LeetCode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.md">两两交换链表中的结点</a></p>
<p><a href="./LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.md">删除链表的倒数第N个结点</a></p>
<p><a href="./LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9802-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.md">链表相交</a></p>
<p><a href="./LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.md">环形链表2</a></p>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p><a href="./LeetCode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.md">有效的字母异位词</a></p>
<p><a href="./LeetCode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.md">两个数组的交集</a></p>
<p><a href="./LeetCode-202-%E5%BF%AB%E4%B9%90%E6%95%B0.md">快乐数</a></p>
<p><a href="./LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md">两数之和</a></p>
<p><a href="./LeetCode-454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A02.md">四数相加2</a></p>
<p><a href="./LeetCode-383-%E8%B5%8E%E9%87%91%E4%BF%A1.md">赎金信</a></p>
<p><a href="./LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.md">三数之和</a></p>
<p><a href="./LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.md">四数之和</a></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><a href="./LeetCode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.md">反转字符串</a></p>
<p><a href="./LeetCode-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22.md">反转字符串2</a></p>
<p><a href="./LeetCode-151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D.md">反转字符串中的单词</a></p>
<p><a href="./LeetCode-28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87.md">找出字符串中第一个匹配项的下标</a></p>
<p><a href="./LeetCode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.md">重复的子字符串</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/29/KMP%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/29/KMP%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">KMP算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-29 23:11:20" itemprop="dateCreated datePublished" datetime="2023-11-29T23:11:20+08:00">2023-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-15 16:10:47" itemprop="dateModified" datetime="2024-01-15T16:10:47+08:00">2024-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="KMP算法详解"><a href="#KMP算法详解" class="headerlink" title="KMP算法详解"></a>KMP算法详解</h1><ul>
<li><p>KMP算法常用来在一个字符串中匹配另一个字符串，它的核心是通过构建一个next数组，通过next数组中对应的值来快速跳转到下一个需要比较节点的位置！（原来是LeetCode28的题解的延申，这里把它独立出来方便查阅）</p>
<ul>
<li><p>首先我们要明白为什么要使用KMP算法，我们可以通过比较暴力算法和KMP算法在匹配过程中的区别：</p>
<ul>
<li>暴力算法：当原串和匹配串不匹配时，原串指针重新移动到<strong>发起点</strong>的下一个位置，匹配串的指针重新回到发起点</li>
<li>KMP算法：当原串和匹配串不匹配时，原串指针不动，匹配串检测是否有<strong>相同的前缀和后缀</strong>，如果有的话，移动到<strong>前缀的下一个位置</strong>，否则重新回到发起点</li>
</ul>
</li>
<li><p>此时，我们就需要理解什么是前缀、后缀以及什么是相同前后缀：</p>
<ul>
<li>前缀：<code>aaa*****bc</code>，那么当前字符串的前缀就是<code>aaa</code></li>
<li>后缀：同理，当前字符串的后缀就是<code>bc</code></li>
<li>相同前后缀：可以很明显的看出当前字符串没有相同的前后缀，如果字符串为<code>aaa****aa</code>，那么此时相同前后缀即为<code>aa</code></li>
</ul>
</li>
<li><p>到这里，我们就已经明白了为什么KMP算法效率更高了！</p>
<ul>
<li>在匹配过程中，暴力算法总是将原串指针移动到发起点的下一个位置，而KMP算法则保证了原串指针不会回溯，始终坚定的向前走</li>
<li>并且暴力算法的匹配串指针也总是回到发起点，而KMP算法的匹配串指针可以根据是否有相同前后缀来确定移动位置</li>
</ul>
</li>
<li><p>可能有同学要问：<strong>为什么KMP算法需要将匹配串指针移动到前缀的下一个位置呢？原串指针为什么可以保持始终前进呢？</strong></p>
<ul>
<li>假设原串为<code>abeababeabf</code>，匹配串为<code>abeabf</code></li>
<li>当第一次不匹配时，即原串中&#x3D;<code>abeaba</code>部分的字符<code>a</code>和匹配串<code>abeabf</code>中的字符<code>f</code>不匹配</li>
<li>此时匹配串<code>abeab</code>部分的相同前后缀为<code>ab</code>，我们观察原串和匹配串，由于相同前后缀，<strong>我们可以省去原串（<code>abeab</code>部分）中后缀<code>ab</code>和匹配串中（<code>abeab</code>部分）的前缀<code>ab</code>的比较</strong>，而直接从匹配串中字符<code>e</code>（前缀的下一个位置）和原串中不匹配字符<code>a</code>（后缀的下一个位置）进行比较，而不移动原串指针（讲的好乱！！！）</li>
<li>如果还还不匹配，检查匹配串中<code>ab</code>部分是否有相同前后缀，我们发现没有相同前后缀，那么此时重新从发起点进行比较</li>
</ul>
</li>
<li><p>为了不去重复的扫描匹配串（子串）中是否有相同前后缀，以及需要移动到的位置（前缀的下一个位置），我们显然可以通过预处理得到<strong>next数组</strong>，数组中每一个位置的元素值都为该下标应该跳转的目标位置</p>
</li>
<li><p><strong>同时我们发现，对于匹配串的任意一个位置而言，该位置的跳转目标位置与原串无关！</strong>举一个例子：<code>abcabd</code>中字符<code>d</code>的跳转位置一定是<code>c</code>，而与原串无关</p>
</li>
<li><p>如何通过预处理得到next数组呢？如何在时间复杂度为O（n）的基础上进行构建呢？</p>
<ul>
<li>设置两个指针，<strong>i从0开始，j从1开始，将<code>next[0]</code>初始化为0</strong></li>
<li><strong>如果<code>nums[i] == nums[j]</code>，令next[j] &#x3D; i + 1（将j的回溯位置设置为i + 1，即前缀的下一个位置），i和j同时后移</strong></li>
<li><strong>如果<code>nums[i] != nums[j]</code>，令nums[i] &#x3D; nums[j - 1]（进行回溯，回溯位置为j - 1中前缀的下一个位置），直到nums[i] &#x3D; nums[j] 或则 i &#x3D;&#x3D; 0，如果i &#x3D;&#x3D; 0还不相等，令nums[j] &#x3D; 0，i不变，j向后移</strong></li>
</ul>
</li>
<li><p>next数组的实际实现细节如下：</p>
<ul>
<li><p><strong>我们发现如果i位置发生不匹配，那么i指针回溯的位置是next[i - 1]，而在编程过程中，为了解题方便，我们通常将next数组后移一位，即i指针回溯的位置为next[i]</strong></p>
<ul>
<li>怎么实现将next数组后移一位呢？很简单：我们通过先移动再赋值的方式实现，将当前位置的相同前缀下一个位置赋值给当前位置的下一个位置！</li>
</ul>
</li>
<li><p><strong>可能有同学有一些疑问：为什么要将next[0]初始化为-1呢？</strong>其实这里并没有什么特殊含义，只是为了编程方便！</p>
</li>
<li><p>如果我们将next[0]初始化为0，可能会有如下判断语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (array[i] == array[j]) &#123; </span><br><span class="line">    i++;</span><br><span class="line">    j++;</span><br><span class="line">    next[j] = i; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 我们还需要在array[i] != array[j]时再判断i是否已经为0</span></span><br><span class="line">        j++;</span><br><span class="line">        next[j] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = next[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果我们将next[0]初始化为-1，我们就可能有如下判断语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == -<span class="number">1</span> || array[i] == array[j]) &#123; </span><br><span class="line">    i++;</span><br><span class="line">    j++;</span><br><span class="line">    next[j] = i; <span class="comment">// 如果array[i] != array[j]，i就会回溯到-1，直接通过第一个判断语句将next[j]赋值为0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    i = next[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可能有些同学又有一些疑问：<strong>为什么i从-1开始，j从0开始呢？</strong></li>
<li>如果i从0开始，j从1开始，由于我们先移动再赋值的策略，<strong>我们会跳过next[1]的赋值</strong>（虽然next[1]的值无论如何都是0，而Java数组中每个元素初始值都为0，影响不大），当然我们也可以显示的将next[1]赋值为0，但你懂的…</li>
<li>而如果i从-1开始，j从0开始，我们就不会跳过next[1]位置的赋值，<strong>而且i &#x3D;&#x3D; -1恰好是需要将 j（其实是j + 1） 赋值为0的标志</strong>，所以我们就可以顺理成章的在循环中将next[1]赋值为0，而不用额外显示赋值！很高级！！！</li>
</ul>
</li>
</ul>
</li>
<li><p>具体构建next数组实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建next数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getNext(<span class="type">char</span>[] array) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果t == -1，说明回溯到底了，当前位置i还是没有相同前后缀，通过t++、i++将i+1的回溯位置设置为0</span></span><br><span class="line">        <span class="comment">// 如果array[t] == array[i]，说明发现相同前后缀，通过t++、i++将i+1的回溯位置设置为t+1，即前缀的下一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span> || array[i] == array[j]) &#123; </span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[j] = i; <span class="comment">// 先移动再赋值，将next数组后移一位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则进行回溯</span></span><br><span class="line">            i = next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KMP算法实现代码如下：（构建next数组省略了）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] mainString = haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] subString = needle.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = getNext(subString);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; subString.length &amp;&amp; i &lt; mainString.length) &#123;</span><br><span class="line">            <span class="comment">// 如果j=-1,说明主串需要进一位再重新和子串的第一个位置开始比较</span></span><br><span class="line">            <span class="comment">// 如果相等,i++，j++,继续比较下一个</span></span><br><span class="line">            <span class="comment">// 如果不相等,j根据next表找到回溯点继续和i比较</span></span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || subString[j] == mainString[i]) &#123; </span><br><span class="line">                <span class="keyword">if</span> (j == subString.length - <span class="number">1</span>) &#123; <span class="comment">// 此时最后一个字符已经比较完成</span></span><br><span class="line">                    <span class="keyword">return</span> begin; <span class="comment">// 其实不用begin记录，直接返回i - j也可以</span></span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">                begin = i - j; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/23/LeetCode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/23/LeetCode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">LeetCode.459.重复的子字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-23 21:17:54" itemprop="dateCreated datePublished" datetime="2023-11-23T21:17:54+08:00">2023-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-16 11:58:17" itemprop="dateModified" datetime="2024-01-16T11:58:17+08:00">2024-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2023/11/23/LeetCode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/459.png" class="" title="image-20240115161254056">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// i指针指向子串的尾部</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// j指针指向原串中需要比较的位置</span></span><br><span class="line">        <span class="keyword">while</span> ((i + <span class="number">1</span>) * <span class="number">2</span> &lt;= ch.length) &#123; <span class="comment">// 子串长度需要小于等于原串长度的一半</span></span><br><span class="line">            j = i + <span class="number">1</span>; <span class="comment">// 更新比较位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; ch.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch[k] != ch[j]) <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">if</span> (k == i) k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j==ch.length，说明原串已经比较完了</span></span><br><span class="line">            <span class="comment">// k==0，说明子串也恰好比较完了，原串是子串的整数倍，防止原串比较完了但子串没有比较完的情况</span></span><br><span class="line">            <span class="comment">// 也可以判断ch.length%(i+1)==0，判断原串是否是子串的整数倍</span></span><br><span class="line">            <span class="keyword">if</span> (j == ch.length &amp;&amp; k == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li><p>可以很明显的看到，我上边的解法又是暴力算法，时间复杂度为O（n^2）！</p>
</li>
<li><p>通过看一些大佬的题解，发现这道题还有很多很有趣的解法，我会在下面一一列举！</p>
</li>
<li><p>移动匹配法：</p>
<ul>
<li><p>当一个字符串可以由重复子串构成时，如果当前字符串为s，那么对于s + s这样的字符串，其内部（不包含头尾）就一定也包含一个s！</p>
</li>
<li><p>假设字符串为<code>abcabc</code>，对于s + s字符串为<code>abcabcabcabc</code>，我们发现<code>abc(abcabc)abc</code>其内部有一个s，说明它可以由重复子串构成！</p>
</li>
<li><p>代码实现如下：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s + s;</span><br><span class="line">        <span class="keyword">return</span> str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>).contains(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于移动匹配法，我们也可以换一种思路去理解！</p>
<ul>
<li><p>对于一个可以由重复子串构成的字符串s，它可以经过有效次移动来重新得到它本身！</p>
</li>
<li><p>假设当前字符串为<code>abcabc</code>：</p>
<ul>
<li>一次移动：<code>cabcab</code>；二次移动：<code>bcabca</code>；三次移动：<code>abcabc</code>！匹配到字符串自己了！</li>
</ul>
</li>
<li><p>基于这个思想，我们可以经过至多length - 1次移动，如果还匹配不到，则不能由重复子串构成，但这样的效率很低</p>
</li>
<li><p>因此我们可以通过s + s这样的字符串，它包含了所有需要移动的字符串，比如对于字符串<code>abcabc</code>：</p>
<ul>
<li>s + s为<code>abcabcabcabc</code>，一次移动<code>abcab(cabcab)c</code>；两次移动：<code>abca(bcabca)bc</code>；三次移动：<code>abc(abcabc)abc</code>，匹配到了s！</li>
<li>移动的可能都包含在了s + s，匹配的过程就像一个滑动窗口一样！</li>
</ul>
</li>
</ul>
</li>
<li><p>KMP算法：</p>
<ul>
<li><p>是的你没有看错，KMP算法不仅可以用于匹配一个字符串中是否包含另一个字符串，也可以用来查看字符串是否可以由重复子串构成！</p>
</li>
<li><p>首先先回顾一下前后缀的定义：</p>
<ul>
<li>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</li>
<li>后缀是指不包含最后一个字符的所有以最后一个字符结尾的连续子串</li>
</ul>
</li>
<li><p>而对于可以由重复子串构成的字符串，我们应该知道：<strong>由重复子串构成的字符串中，这个字符串中最长相同前后缀不包含的子串就是最小重复子串！</strong></p>
<ul>
<li>假设字符串为<code>abababab</code>，它的最长相同前后缀为：<code>ababab</code>，那么最小重复子串为：<code>ab</code>！</li>
</ul>
</li>
<li><p>实现代码如下：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next = getNext(ch);</span><br><span class="line">        <span class="comment">// 如果拥有最长相同前后缀且最长前缀不包含的子串可以整除整个字符串长度，即表示可以由重复子串构成</span></span><br><span class="line">        <span class="keyword">return</span> next[ch.length - <span class="number">1</span>] != -<span class="number">1</span> &amp;&amp; ch.length % (ch.length - (next[ch.length - <span class="number">1</span>] + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(<span class="type">char</span>[] ch) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[ch.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; ch.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// if (i == -1 || ch[i] == ch[j]) &#123;</span></span><br><span class="line">            <span class="comment">//     i++;</span></span><br><span class="line">            <span class="comment">//     j++;</span></span><br><span class="line">            <span class="comment">//     next[j] = i;</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     i = next[i];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// 这个方法得到的next数组和以往的不太一样，之前的next数组中的元素值为当前下标需要回溯的位置(前缀的下一个位置)</span></span><br><span class="line">            <span class="comment">// 而这个方法得到的next数组中的元素值为当前下标对应的前缀的尾部</span></span><br><span class="line">            <span class="comment">// 而且这个next数组中对于没有相同前后缀回溯值位置为-1</span></span><br><span class="line">            <span class="comment">// 之前的情况是，没有相同前后缀的回溯位置为0</span></span><br><span class="line">            <span class="comment">// 这样做的目的是为了区分对于aa这种特殊情况，即使有相同前后缀，回溯位置也是0，无法和没有相同前后缀的字符串区分</span></span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">while</span> (i != -<span class="number">1</span> &amp;&amp; ch[i + <span class="number">1</span>] != ch[j]) i = next[i];</span><br><span class="line">            <span class="keyword">if</span> (ch[i + <span class="number">1</span>] == ch[j]) i++;</span><br><span class="line">            next[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其实对于KMP算法，我们还可以有另一种解题思路：<ul>
<li>因为KMP算法主要是为了查找一个字符串中是否包含另一个字符串，而对于s + s这样的字符串，我们去除首尾字符，使用KMP算法来查找内部是否包含了s</li>
<li>不仅运用了移动匹配法的基本思想：如果s可以由重复子串构成，那么s + s（除去首尾字符）一定可以包含了一个s！还结合了KMP算法的使用！</li>
<li>代码的实际实现就不列举了</li>
</ul>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="./KMP%E7%AE%97%E6%B3%95">KMP算法详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/22/LeetCode-28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/22/LeetCode-28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/" class="post-title-link" itemprop="url">LeetCode.28.找出字符串中第一个匹配项的下标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-22 21:26:44" itemprop="dateCreated datePublished" datetime="2023-11-22T21:26:44+08:00">2023-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-17 21:47:39" itemprop="dateModified" datetime="2024-01-17T21:47:39+08:00">2024-01-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2023/11/22/LeetCode-28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/28.png" class="" title="image-20240115160929756">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] hay = haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] nee = needle.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= hay.length - nee.length; i++) &#123; <span class="comment">// hay.length - nee.length防止下边的hay[i + j]越界且减少不必要的比较</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; nee.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hay[i + j] != nee[j]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == nee.length) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li><p>可以很明显的看到，这个写法是暴力算法，它的<em><em>时间复杂度为O（（m-n）</em> n）</em><em>，其中</em><strong>m为haystack的长度，n为needle的长度</strong></p>
</li>
<li><p>看了一些题解后，发现这道题可以使用<strong>KMP算法</strong>求解，接下来我会详细解释一下KMP算法的实现思路以及代码的具体实现！</p>
</li>
<li><p><strong>KMP算法详解：</strong></p>
<ul>
<li><p>首先我们要明白为什么要使用KMP算法，我们可以通过比较暴力算法和KMP算法在匹配过程中的区别：</p>
<ul>
<li>暴力算法：当原串和匹配串不匹配时，原串指针重新移动到<strong>发起点</strong>的下一个位置，匹配串的指针重新回到发起点</li>
<li>KMP算法：当原串和匹配串不匹配时，原串指针不动，匹配串检测是否有<strong>相同的前缀和后缀</strong>，如果有的话，移动到<strong>前缀的下一个位置</strong>，否则重新回到发起点</li>
</ul>
</li>
<li><p>此时，我们就需要理解什么是前缀、后缀以及什么是相同前后缀：</p>
<ul>
<li>前缀：<code>aaa*****bc</code>，那么当前字符串的前缀就是<code>aaa</code></li>
<li>后缀：同理，当前字符串的后缀就是<code>bc</code></li>
<li>相同前后缀：可以很明显的看出当前字符串没有相同的前后缀，如果字符串为<code>aaa****aa</code>，那么此时相同前后缀即为<code>aa</code></li>
</ul>
</li>
<li><p>到这里，我们就已经明白了为什么KMP算法效率更高了！</p>
<ul>
<li>在匹配过程中，暴力算法总是将原串指针移动到发起点的下一个位置，而KMP算法则保证了原串指针不会回溯，始终坚定的向前走</li>
<li>并且暴力算法的匹配串指针也总是回到发起点，而KMP算法的匹配串指针可以根据是否有相同前后缀来确定移动位置</li>
</ul>
</li>
<li><p>可能有同学要问：<strong>为什么KMP算法需要将匹配串指针移动到前缀的下一个位置呢？原串指针为什么可以保持始终前进呢？</strong></p>
<ul>
<li>假设原串为<code>abeababeabf</code>，匹配串为<code>abeabf</code></li>
<li>当第一次不匹配时，即原串中&#x3D;<code>abeaba</code>部分的字符<code>a</code>和匹配串<code>abeabf</code>中的字符<code>f</code>不匹配</li>
<li>此时匹配串<code>abeab</code>部分的相同前后缀为<code>ab</code>，我们观察原串和匹配串，由于相同前后缀，<strong>我们可以省去原串（<code>abeab</code>部分）中后缀<code>ab</code>和匹配串中（<code>abeab</code>部分）的前缀<code>ab</code>的比较</strong>，而直接从匹配串中字符<code>e</code>（前缀的下一个位置）和原串中不匹配字符<code>a</code>（后缀的下一个位置）进行比较，而不移动原串指针（讲的好乱！！！）</li>
<li>如果还还不匹配，检查匹配串中<code>ab</code>部分是否有相同前后缀，我们发现没有相同前后缀，那么此时重新从发起点进行比较</li>
</ul>
</li>
<li><p>为了不去重复的扫描匹配串（子串）中是否有相同前后缀，以及需要移动到的位置（前缀的下一个位置），我们显然可以通过预处理得到<strong>next数组</strong>，数组中每一个位置的元素值都为该下标应该跳转的目标位置</p>
</li>
<li><p><strong>同时我们发现，对于匹配串的任意一个位置而言，该位置的跳转目标位置与原串无关！</strong>举一个例子：<code>abcabd</code>中字符<code>d</code>的跳转位置一定是<code>c</code>，而与原串无关</p>
</li>
<li><p>如何通过预处理得到next数组呢？如何在时间复杂度为O（n）的基础上进行构建呢？</p>
<ul>
<li>设置两个指针，<strong>i从0开始，j从1开始，将<code>next[0]</code>初始化为0</strong></li>
<li><strong>如果<code>nums[i] == nums[j]</code>，令next[j] &#x3D; i + 1（将j的回溯位置设置为i + 1，即前缀的下一个位置），i和j同时后移</strong></li>
<li><strong>如果<code>nums[i] != nums[j]</code>，令nums[i] &#x3D; nums[j - 1]（进行回溯，回溯位置为j - 1中前缀的下一个位置），直到nums[i] &#x3D; nums[j] 或则 i &#x3D;&#x3D; 0，如果i &#x3D;&#x3D; 0还不相等，令nums[j] &#x3D; 0，i不变，j向后移</strong></li>
</ul>
</li>
<li><p>next数组的实际实现细节如下：</p>
<ul>
<li><p><strong>我们发现如果i位置发生不匹配，那么i指针回溯的位置是next[i - 1]，而在编程过程中，为了解题方便，我们通常将next数组后移一位，即i指针回溯的位置为next[i]</strong></p>
<ul>
<li>怎么实现将next数组后移一位呢？很简单：我们通过先移动再赋值的方式实现，将当前位置的相同前缀下一个位置赋值给当前位置的下一个位置！</li>
</ul>
</li>
<li><p><strong>可能有同学有一些疑问：为什么要将next[0]初始化为-1呢？</strong>其实这里并没有什么特殊含义，只是为了编程方便！</p>
</li>
<li><p>如果我们将next[0]初始化为0，可能会有如下判断语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (array[i] == array[j]) &#123; </span><br><span class="line">    i++;</span><br><span class="line">    j++;</span><br><span class="line">    next[j] = i; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 我们还需要在array[i] != array[j]时再判断i是否已经为0</span></span><br><span class="line">        j++;</span><br><span class="line">        next[j] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = next[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果我们将next[0]初始化为-1，我们就可能有如下判断语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == -<span class="number">1</span> || array[i] == array[j]) &#123; </span><br><span class="line">    i++;</span><br><span class="line">    j++;</span><br><span class="line">    next[j] = i; <span class="comment">// 如果array[i] != array[j]，i就会回溯到-1，直接通过第一个判断语句将next[j]赋值为0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    i = next[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可能有些同学又有一些疑问：<strong>为什么i从-1开始，j从0开始呢？</strong></li>
<li>如果i从0开始，j从1开始，由于我们先移动再赋值的策略，<strong>我们会跳过next[1]的赋值</strong>（虽然next[1]的值无论如何都是0，而Java数组中每个元素初始值都为0，影响不大），当然我们也可以显示的将next[1]赋值为0，但你懂的…</li>
<li>而如果i从-1开始，j从0开始，我们就不会跳过next[1]位置的赋值，<strong>而且i &#x3D;&#x3D; -1恰好是需要将 j（其实是j + 1） 赋值为0的标志</strong>，所以我们就可以顺理成章的在循环中将next[1]赋值为0，而不用额外显示赋值！很高级！！！</li>
</ul>
</li>
</ul>
</li>
<li><p>具体构建next数组实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建next数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getNext(<span class="type">char</span>[] array) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果t == -1，说明回溯到底了，当前位置i还是没有相同前后缀，通过t++、i++将i+1的回溯位置设置为0</span></span><br><span class="line">        <span class="comment">// 如果array[t] == array[i]，说明发现相同前后缀，通过t++、i++将i+1的回溯位置设置为t+1，即前缀的下一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span> || array[i] == array[j]) &#123; </span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[j] = i; <span class="comment">// 先移动再赋值，将next数组后移一位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则进行回溯</span></span><br><span class="line">            i = next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KMP算法实现代码如下：（构建next数组省略了）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] mainString = haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] subString = needle.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = getNext(subString);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; subString.length &amp;&amp; i &lt; mainString.length) &#123;</span><br><span class="line">            <span class="comment">// 如果j=-1,说明主串需要进一位再重新和子串的第一个位置开始比较</span></span><br><span class="line">            <span class="comment">// 如果相等,i++，j++,继续比较下一个</span></span><br><span class="line">            <span class="comment">// 如果不相等,j根据next表找到回溯点继续和i比较</span></span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || subString[j] == mainString[i]) &#123; </span><br><span class="line">                <span class="keyword">if</span> (j == subString.length - <span class="number">1</span>) &#123; <span class="comment">// 此时最后一个字符已经比较完成</span></span><br><span class="line">                    <span class="keyword">return</span> begin; <span class="comment">// 其实不用begin记录，直接返回i - j也可以</span></span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">                begin = i - j; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="KMP%E7%AE%97%E6%B3%95">KMP算法详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
