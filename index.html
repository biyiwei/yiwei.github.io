<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yiweiboi.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yiweiBoi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yiweiboi.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/09/15/6-S081-Lab10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/15/6-S081-Lab10/" class="post-title-link" itemprop="url">6.S081 Lab10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-15 16:58:02" itemprop="dateCreated datePublished" datetime="2024-09-15T16:58:02+08:00">2024-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-16 22:41:54" itemprop="dateModified" datetime="2024-09-16T22:41:54+08:00">2024-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>Lab Guidance：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/labs/mmap.html">Lab: mmap (mit.edu)</a></li>
<li><code>mmap</code> 和 <code>munmap</code> 系统调用允许 UNIX 程序对其地址空间进行详细的控制。这些系统调用可以用于在进程之间共享内存、将文件映射到进程的地址空间，以及作为用户级页面错误方案的一部分</li>
<li>在本次实验中，您将为 xv6 添加 <code>mmap</code> 和 <code>munmap</code> 功能，重点关注内存映射文件</li>
<li>输入 <code>git fetch &amp;&amp; git checkout mmap &amp;&amp; make clean</code> 切换到 mmap 实验分支</li>
</ul>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li><p>mmap 函数的手册页（通过运行 <code>man 2 mmap</code> 查看）显示了以下声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mmap</code> 可以以多种方式调用，但本实验仅要求实现与文件内存映射相关的部分功能</p>
<ul>
<li>你可以假设 <code>addr</code> 总是为零，这意味着内核应该决定映射文件的虚拟地址</li>
<li><code>mmap</code> 返回该地址，如果失败则返回 <code>0xffffffffffffffff</code></li>
<li><code>len</code> 是要映射的字节数，它可能与文件的长度不同</li>
<li><code>prot</code> 指示内存是否应该被映射为可读、可写和&#x2F;或可执行；你可以假设 <code>prot</code> 是 <code>PROT_READ</code> 或 <code>PROT_WRITE</code> 或两者都包含</li>
<li><code>flags</code> 将是 <code>MAP_SHARED</code>，意味着对映射内存的修改应该写回到文件，或者是 <code>MAP_PRIVATE</code>，意味着它们不应该写回。你不需要实现 <code>flags</code> 中的其他位</li>
<li><code>fd</code> 是要映射的文件的打开文件描述符</li>
<li>你可以假设 <code>offset</code> 为零（它是文件中开始映射的起始点）</li>
</ul>
</li>
<li><p>如果映射相同 <code>MAP_SHARED</code> 文件的进程不共享物理页面，这也是可以接受的</p>
</li>
<li><p>munmap 函数的手册页（通过运行 <code>man 2 munmap</code> 查看）显示了以下声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>munmap</code> 应该移除指定地址范围内的 <code>mmap</code> 映射</p>
<ul>
<li>如果进程已经修改了内存并且以 <code>MAP_SHARED</code> 方式映射，那么修改应该首先被写回到文件中</li>
<li>一个 <code>munmap</code> 调用可能只覆盖 <code>mmap</code> 映射区域的一部分，但你可以假设它将从区域开始处、结束处或整个区域（但不会在中间打洞）进行取消映射</li>
</ul>
</li>
<li><p>你应该实现足够的 <code>mmap</code> 和 <code>munmap</code> 功能，以使 <code>mmaptest</code> 测试程序能够正常工作。如果 <code>mmaptest</code> 没有使用 <code>mmap</code> 的某个特性，那么你不需要实现那个特性</p>
</li>
<li><p>一些提示</p>
<ul>
<li><p>添加用户程序和系统调用</p>
<ul>
<li>首先，将 <code>mmaptest</code> 添加到 <code>UPROGS</code> 中，并添加 <code>mmap</code> 和 <code>munmap</code> 系统调用，以便能够编译 <code>user/mmaptest.c</code>。目前，<code>mmap</code> 和 <code>munmap</code> 只需返回错误即可</li>
<li>我们在 <code>kernel/fcntl.h</code> 中已经为您定义了 <code>PROT_READ</code> 等常量</li>
<li>运行 <code>mmaptest</code>，它将在第一次调用 <code>mmap</code> 时失败</li>
</ul>
</li>
<li><p>按需填充页表</p>
<ul>
<li>在处理页面错误时，按需填充页表。也就是说，<code>mmap</code> 不应该分配物理内存或读取文件。相反，这些操作应该在（或由）<code>usertrap</code> 中的页面错误处理代码中执行，类似于 “写时复制” 实验中的操作。这样做的原因是确保对大文件的 <code>mmap</code> 操作是快速的，并且即使文件大小超过物理内存，也能进行 <code>mmap</code></li>
</ul>
</li>
<li><p>跟踪每个进程的映射</p>
<ul>
<li>定义一个与 “应用程序的虚拟内存” 讲座中描述的 VMA（虚拟内存区域）相对应的结构。这个结构应该记录由 <code>mmap</code> 创建的虚拟内存范围的地址、长度、权限、文件等信息。由于 xv6 内核中没有内核内存分配器，因此可以声明一个固定大小的 VMA 数组，并按需从中分配（大小为 16 应该足够了）</li>
</ul>
</li>
<li><p>实现 mmap</p>
<ul>
<li>在进程的地址空间中找到一个未使用的区域来映射文件，并向进程的映射区域表中添加一个 VMA。VMA 应该包含一个指向正在映射的文件的 <code>struct file</code> 的指针；<code>mmap</code> 应该增加文件的引用计数，以防止在文件关闭时结构消失（提示：查看 <code>filedup</code>）</li>
<li>运行 <code>mmaptest</code>：第一次 <code>mmap</code> 应该成功，但首次访问映射的内存将导致页面错误并终止 <code>mmaptest</code></li>
</ul>
</li>
<li><p>处理 mmap 区域的页面错误</p>
<ul>
<li>在 mmap 区域的页面错误处理中，分配一个物理内存页，将相关文件的 4096 字节读入该页，并将其映射到用户地址空间。使用 <code>readi</code> 读取文件，它接受一个偏移量参数来指定在文件中读取的位置（但您需要锁定&#x2F;解锁传递给 <code>readi</code> 的 inode）。不要忘记正确设置页面的权限</li>
<li>运行 <code>mmaptest</code>；它应该能够到达第一个 <code>munmap</code></li>
</ul>
</li>
<li><p>实现 munmap</p>
<ul>
<li>找到对应地址范围的 VMA 并取消映射指定的页面（提示：使用 <code>uvmunmap</code>）。如果 <code>munmap</code> 删除了之前 <code>mmap</code> 的所有页面，则应减少相应 <code>struct file</code> 的引用计数。如果未映射的页面已被修改且文件是以 <code>MAP_SHARED</code> 映射的，则应将页面写回文件（可以参考 <code>filewrite</code> 的实现）</li>
</ul>
</li>
<li><p>优化写回操作</p>
<ul>
<li>理想情况下，您的实现应该只写回程序实际修改过的 <code>MAP_SHARED</code> 页面。RISC-V PTE 中的脏位（D）指示页面是否已被写入。然而，<code>mmaptest</code> 并没有检查未脏页是否未被写回；因此，您可以在不查看 D 位的情况下写回页面</li>
</ul>
</li>
<li><p>修改 exit</p>
<ul>
<li>修改 <code>exit</code> 以模拟调用 <code>munmap</code> 来取消映射进程的映射区域</li>
<li>运行 <code>mmaptest</code>；<code>mmap_test</code> 应该通过，但 <code>fork_test</code> 可能不会</li>
</ul>
</li>
<li><p>修改 fork</p>
<ul>
<li>修改 <code>fork</code> 以确保子进程具有与父进程相同的映射区域。不要忘记为 VMA 的 <code>struct file</code> 增加引用计数。在子进程的页面错误处理程序中，分配一个新的物理页面而不是与父进程共享页面是可以的。后者会更酷，但需要更多的实现工作</li>
<li>运行 <code>mmaptest</code>；它应该通过 <code>mmap_test</code> 和 <code>fork_test</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><ul>
<li>分别在 <code>user/usys.pl</code>、<code>user/user.h</code>、<code>kernel/syscall.h</code> 和 <code>kernel/syscall.c</code> 中添加 mmap，munmap 系统调用的相关定义和声明</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span>*, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mmap   22   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_munmap 23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[SYS_mmap]    sys_mmap,</span><br><span class="line">[SYS_munmap]  sys_munmap,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/proc.h</code> 中定义 struct VMA 及相关变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VMASIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> &#123;</span></span><br><span class="line">  uint addr;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> prot;</span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">  <span class="type">int</span> offset;</span><br><span class="line">  <span class="type">int</span> vaild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> <span class="title">vma</span>[<span class="title">VMASIZE</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/sysfile.c</code> 中实现 <code>sys_mmap</code><ul>
<li>需要注意一个权限检查上的细节：一个文件不可写时（<code>f-&gt;writable = 0</code>），但仍然想要映射为可写（<code>prot = PROT_WRITE</code>），当这个文件是私有的（<code>flags = MAP_PRIVATE</code>），那么这个文件仍然可以映射为可写的</li>
<li>我们总是将 len 向上页对齐，目的是为了在映射的时候总是以页为单位（不会出现半页的情况），且方便后续对 <code>mappages</code> 等函数的调用（它们总是要求页对齐）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">uint64 </span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len, prot, flags, offset;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;addr);  </span><br><span class="line">  argint(<span class="number">1</span>, &amp;len);</span><br><span class="line">  argint(<span class="number">2</span>, &amp;prot);</span><br><span class="line">  argint(<span class="number">3</span>, &amp;flags);</span><br><span class="line">  argint(<span class="number">5</span>, &amp;offset); </span><br><span class="line">  <span class="keyword">if</span> (argfd(<span class="number">4</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || offset &lt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (prot &amp; ~(PROT_READ | PROT_WRITE | PROT_EXEC)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!f-&gt;readable &amp;&amp; prot &amp; PROT_READ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; ~(MAP_SHARED | MAP_PRIVATE)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags != MAP_SHARED &amp;&amp; flags != MAP_PRIVATE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; MAP_SHARED &amp;&amp; prot &amp; PROT_WRITE &amp;&amp; !f-&gt;writable) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  len = PGROUNDUP(len);</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;sz + len &gt; MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; VMASIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;vma[i].vaild) &#123; </span><br><span class="line">      vma = &amp;p-&gt;vma[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!vma) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vma-&gt;addr = addr;</span><br><span class="line">  vma-&gt;file = f;</span><br><span class="line">  vma-&gt;flags = flags;</span><br><span class="line">  vma-&gt;prot = prot;</span><br><span class="line">  vma-&gt;len = len;</span><br><span class="line">  vma-&gt;offset = offset;</span><br><span class="line">  vma-&gt;vaild = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  filedup(vma-&gt;file);</span><br><span class="line">  p-&gt;sz += addr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vma-&gt;addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/trap.c</code> 中实现 <code>vmamap</code> 以处理 mmap 区域的映射错误，实现按需填充页表。并在 <code>usertrap</code> 中调用<ul>
<li>一次仅分配一页，实现按需分配</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sleeplock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vmamap</span><span class="params">(uint va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> n, prot, perm = <span class="number">0x0</span>;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (va &gt; MAXVA || va &gt; p-&gt;sz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; VMASIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[i].vaild &amp;&amp; va &gt;= p-&gt;vma[i].addr &amp;&amp; va &lt; p-&gt;vma[i].addr + p-&gt;vma[i].len) &#123;</span><br><span class="line">      vma = &amp;p-&gt;vma[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vma) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(pa = (uint64)kalloc())) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">void</span>*)pa, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  ip = vma-&gt;file-&gt;ip;</span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  </span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="keyword">if</span> ((n = readi(ip, <span class="number">0</span>, pa, va - vma-&gt;addr + vma-&gt;offset, PGSIZE)) &lt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlock(ip);</span><br><span class="line"></span><br><span class="line">  prot = vma-&gt;prot;</span><br><span class="line">  <span class="keyword">if</span> (prot &amp; PROT_READ) perm |= PTE_R;</span><br><span class="line">  <span class="keyword">if</span> (prot &amp; PROT_WRITE) perm |= PTE_W;</span><br><span class="line">  <span class="keyword">if</span> (prot &amp; PROT_EXEC) perm |= PTE_X;</span><br><span class="line">  perm |= PTE_V | PTE_U;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mappages(p-&gt;pagetable, va, PGSIZE, pa, perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="type">void</span>*)pa);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span> (vmamap(va) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      setkilled(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/sysfile.c</code> 中实现 <code>sys_munmap</code><ul>
<li>由于在 munmap 时，有的页还没有映射，所以我们在 writei 时一页一页的 writei，防止写入还没有映射的页时发送错误</li>
<li>我们在 writei 时并没有检查脏页位，只是简单的当这个映射文件为 MAP_SHARED 时就写回</li>
<li>我们还需要明确的是：你可以假设一个 munmap 将从区域开始处、结束处或整个区域（但不会在中间打洞）进行取消映射，这就使得最后对 addr、len 的调整变得很简单了</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> n, addr, len, flags;</span><br><span class="line">  <span class="type">pte_t</span> *pte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;addr);</span><br><span class="line">  argint(<span class="number">1</span>, &amp;len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr &lt; <span class="number">0</span> || len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; VMASIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[i].vaild &amp;&amp; addr &gt;= p-&gt;vma[i].addr &amp;&amp; addr &lt; p-&gt;vma[i].addr + p-&gt;vma[i].len) &#123;</span><br><span class="line">      vma = &amp;p-&gt;vma[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vma) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flags = vma-&gt;flags;</span><br><span class="line">  ip = vma-&gt;file-&gt;ip;</span><br><span class="line">  addr = PGROUNDDOWN(addr);</span><br><span class="line">  len = PGROUNDUP(len);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (flags &amp; MAP_SHARED) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = addr; i &lt; addr + len; i += PGSIZE) &#123;</span><br><span class="line">      pte = walk(p-&gt;pagetable, i, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (*pte &amp; PTE_V) &#123;</span><br><span class="line">        begin_op();</span><br><span class="line">        ilock(ip);</span><br><span class="line">        <span class="keyword">if</span> ((n = writei(ip, <span class="number">1</span>, i, i - vma-&gt;addr + vma-&gt;offset, PGSIZE)) != PGSIZE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iunlock(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        uvmunmap(p-&gt;pagetable, i, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr == vma-&gt;addr &amp;&amp; len == vma-&gt;len) &#123;	<span class="comment">// 释放完了</span></span><br><span class="line">    fileclose(vma-&gt;file);</span><br><span class="line">    vma-&gt;addr = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;file = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;len = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;prot = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;vaild = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;offset = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addr == vma-&gt;addr) &#123;	<span class="comment">// 开头相同</span></span><br><span class="line">    vma-&gt;addr += len;</span><br><span class="line">    vma-&gt;offset += len;</span><br><span class="line">    vma-&gt;len -= len;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addr + len == vma-&gt;addr + vma-&gt;len) &#123;	<span class="comment">// 结尾相同</span></span><br><span class="line">    vma-&gt;len -= len;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 不可能中间开洞</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kernel/proc.c</code> 中的 exit<ul>
<li>和 munmap 一样，有的页可能还没有被映射，所以我们需要一页一页的 writei</li>
<li>对 <code>uvmunmap</code> 的调用，由于我们后续修改了 <code>uvmunmap</code> 的相关定义，所以并不会出现取消未映射的页的情况</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sleeplock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">vma</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == initproc)</span><br><span class="line">    panic(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; VMASIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;vma[i].vaild) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    vma = &amp;p-&gt;vma[i];</span><br><span class="line">    <span class="type">int</span> n, addr = vma-&gt;addr, len = PGROUNDUP(vma-&gt;len);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span> =</span> vma-&gt;file-&gt;ip;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[i].flags &amp; MAP_SHARED) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = addr; i &lt; addr + len; i += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = walk(p-&gt;pagetable, i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (*pte &amp; PTE_V) &#123;</span><br><span class="line">          begin_op();</span><br><span class="line">          ilock(ip);</span><br><span class="line">          <span class="keyword">if</span> ((n = writei(ip, <span class="number">1</span>, i, i - vma-&gt;addr + vma-&gt;offset, PGSIZE)) != PGSIZE) &#123;</span><br><span class="line">            panic(<span class="string">&quot;exit: writei\n&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          iunlock(ip);</span><br><span class="line">          end_op();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uvmunmap(p-&gt;pagetable, addr, len / PGSIZE, <span class="number">1</span>); </span><br><span class="line">    </span><br><span class="line">    fileclose(vma-&gt;file);</span><br><span class="line">    vma-&gt;addr = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;file = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;len = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;prot = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;vaild = <span class="number">0</span>;</span><br><span class="line">    vma-&gt;offset = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kernel/proc.c</code> 中的 fork</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; VMASIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[i].vaild) &#123;</span><br><span class="line">      np-&gt;vma[i].addr = p-&gt;vma[i].addr;</span><br><span class="line">      np-&gt;vma[i].file = p-&gt;vma[i].file;</span><br><span class="line">      np-&gt;vma[i].flags = p-&gt;vma[i].flags;</span><br><span class="line">      np-&gt;vma[i].len = p-&gt;vma[i].len;</span><br><span class="line">      np-&gt;vma[i].prot = p-&gt;vma[i].prot;</span><br><span class="line">      np-&gt;vma[i].offset = p-&gt;vma[i].offset;</span><br><span class="line">      np-&gt;vma[i].vaild = <span class="number">1</span>;</span><br><span class="line">      filedup(np-&gt;vma[i].file);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kernel/vm.c</code> 中的 <code>uvmunmap</code><ul>
<li>一段连续的虚拟内存中，一些对应的页可能是未映射的</li>
<li>第一个 continue 是因为这个 pte 可能不存在。页表是多级的，walk 对这个页的 pte 的遍历可能在页表的一级或二级就没有了</li>
<li>第二个 continue 是因为这个页的 pte 有，但它也可能是无效的（<code>!PTE_V</code>）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kernel/vm.c</code> 中的 <code>uvmcopy</code><ul>
<li>这个函数会在 fork 中被调用，父进程的虚拟内存可能对应一些未映射的页（物理内存）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 Makefile 中添加 <code>mmaptest</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_mmaptest\</span><br></pre></td></tr></table></figure>

<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; mmaptest</strong></li>
</ul>
<img src="/2024/09/15/6-S081-Lab10/image-20240916215550762.png" class="" title="image-20240916215550762">

<ul>
<li><strong>usertests -q</strong></li>
</ul>
<img src="/2024/09/15/6-S081-Lab10/image-20240916215958607.png" class="" title="image-20240916215958607">

<ul>
<li><strong>make grade</strong></li>
</ul>
<img src="/2024/09/15/6-S081-Lab10/image-20240916220242420.png" class="" title="image-20240916220242420">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45668004/article/details/137356398">【MIT 6.S081】2020, 实验记录（10），Lab: mmap_xv6 mmap-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/686681660">MIT 6.S081 (详细) - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/630791971">MIT 6.S081 Operating System  - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/121437327">MIT 6.S081] Lab 10: mmap_mit xv6 lab10mmap-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/121418421">MIT 6.S081] Lab 5: xv6 lazy page allocation-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16494452.html">MIT6.S081-Lab10 mmap 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/09/07/6-S081-Lab9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/07/6-S081-Lab9/" class="post-title-link" itemprop="url">Lab File system</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-07 19:38:53" itemprop="dateCreated datePublished" datetime="2024-09-07T19:38:53+08:00">2024-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-08 21:10:45" itemprop="dateModified" datetime="2024-09-08T21:10:45+08:00">2024-09-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>Lab Guidance：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/labs/fs.html">Lab: file system (mit.edu)</a></p>
</li>
<li><p>在这个实验中，你将向 xv6 文件系统添加大文件和符号链接</p>
</li>
<li><p>在开始之前，你需要阅读 xv6 book 的第 8 章 “文件系统”，并研究相关代码</p>
</li>
<li><p>输入 <code>git fetch &amp;&amp; git checkout fs &amp;&amp; make clean</code> 开始实验</p>
</li>
</ul>
<h1 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h1><ul>
<li><p>在此任务中，你将增加 xv6 文件的最大大小。目前，xv6 文件限制为 268 个块（268 * BSIZE 字节），这是因为 xv6 inode 包含 12 个 “直接” 块和 1 个 ”间接“ 块（最多容纳 256 个块）</p>
</li>
<li><p>你将修改 xv6 文件系统代码，来支持每个 inode 中的 ”双间接” 块（最多容纳 256 * 256 个块），这样的话一个文件就能够由 <code>11 + 256 + 256 * 256</code> 个块组成（11 的原因是牺牲一个 “直接块“ 变为 ”双间接“ 块）</p>
</li>
<li><p>如果在实验中的任何时候，你发现自己必须从头开始创建文件系统，请运行 <code>make clean</code></p>
</li>
<li><p>磁盘上的 inode 的格式由 <code>kernel/fs.h</code> 中的 struct dinode 定义。你可能对 NDIRECT、NINDIRECT、MAXFILE 和 struct dinode 中的 addrs 特别感兴趣</p>
</li>
<li><p>在磁盘上查找文件数据的代码在 fs.h 中的 <code>bmap()</code> 中，你需要了解它做了什么</p>
</li>
<li><p><code>bmap()</code> 处理两种块号，bn 参数是逻辑块号（文件中的块号），相对于文件的开头；ip-&gt;addrs[] 中的块号和 <code>bread()</code> 的参数是磁盘块号；你可以将 <code>bmap()</code> 的作用视为将文件的逻辑块号映射到磁盘块号</p>
</li>
<li><p>你的工作是修改 <code>bmap()</code>，使其除了 ”直接“ 块和 ”间接“ 块之外，还实现了 ”双间接“ 块（前 11 个块是 ”直接“ 块，第 12 个块是 ”间接“ 块，第 13 个块是 ”双间接“ 块）</p>
</li>
<li><p>一些提示</p>
<ul>
<li>如果你要更改 NDIRECT 的定义，你也需要修改 <code>kernel/file.h</code> 中 struct inode 中的 addrs，并确保和 struct dinode 中的 addrs 相对应</li>
<li>确保 <code>itrunc()</code> 释放文件所有的块，包括 ”双间接“ 块</li>
</ul>
</li>
<li><p>在 <code>kernel/fs.h</code> 中修改 NDIRECT 的定义（应该表示的是 ”直接“ 块的数量）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>同样的修改 <code>kernel/fs.h</code> 中 struct dinode 中 addrs 的定义和 <code>kernel/file.h</code> 中 struct inode 中 addrs 的定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses // my change</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>]; <span class="comment">// my change</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kernel/fs.c</code> 中的 <code>bmap()</code>，使其能够处理 ”双间接“ 块。由于是 ”双间接“ 块，也就是说需要索引两次，方法和处理 ”间接“ 块类似（先读，看有没有，没有就分配，再读，看有没有，没有就分配）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ip-&gt;addrs[bn] = addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr;</span><br><span class="line">    &#125;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr)&#123;</span><br><span class="line">        a[bn] = addr;</span><br><span class="line">        log_write(bp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bn &lt; NINDIRECT * NINDIRECT) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span> (addr == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr;</span><br><span class="line">    &#125;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> ((addr = a[bn/NINDIRECT]) == <span class="number">0</span>) &#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span> (addr == <span class="number">0</span>) &#123;</span><br><span class="line">        brelse(bp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      a[bn/NINDIRECT] = addr;</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> ((addr = a[bn%NINDIRECT]) == <span class="number">0</span>) &#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span> (addr) &#123;</span><br><span class="line">        a[bn%NINDIRECT] = addr;</span><br><span class="line">        log_write(bp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kernel/fs.c</code> 中的 <code>itrunc()</code>，使其能够释放文件中的 ”双间接“ 块。当然，由于是 ”双间接“ 块，也就需要双重循环去遍历它</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>, *<span class="title">buf</span>;</span></span><br><span class="line">  uint *a, *b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) &#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NINDIRECT; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">        buf = bread(ip-&gt;dev, a[i]);</span><br><span class="line">        b = (uint*)buf-&gt;data;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NINDIRECT; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (b[j])</span><br><span class="line">            bfree(ip-&gt;dev, b[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(buf);</span><br><span class="line">        bfree(ip-&gt;dev, a[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后千万别忘记修改 <code>kernel/fs.h</code> 中 MAXFILE 的定义，否则你就永远别想通过测试</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; bigfile</strong></li>
</ul>
<img src="/2024/09/07/6-S081-Lab9/image-20240908194956341.png" class="" title="image-20240908194956341">

<ul>
<li><strong>usertests -q</strong></li>
</ul>
<img src="/2024/09/07/6-S081-Lab9/image-20240908200123915.png" class="" title="image-20240908200123915">

<ul>
<li><strong>.&#x2F;grade-lab-fs bigfile</strong></li>
</ul>
<img src="/2024/09/07/6-S081-Lab9/image-20240908200553678.png" class="" title="image-20240908200553678">

<h1 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h1><ul>
<li><p>在本次练习中，你将像 xv6 添加符号链接。符号链接（软链接）通过路径名引用链接文件；当符号链接被打开时，内核会跟随链接到引用的文件。实现此系统调用是了解路径名查找工作原理的一个很好的练习</p>
</li>
<li><p>你将实现 <code>symlink(char *target, char *path)</code> 系统调用，该系统调用在 path 上创建一个新的符号链接，该链接指向 target 命名的文件</p>
</li>
<li><p>测试时，请将 symlinktest 添加到 Makefile</p>
</li>
<li><p>一些提示</p>
<ul>
<li>为符号链接创建一个新的系统调用号，向 <code>user/usys.pl</code>、<code>user/user.h</code> 添加一个条目，并在 <code>kernel/sysfile.c</code> 中实现一个空的 <code>sys_symlink()</code></li>
<li>向 <code>kernel/stat.h</code> 添加新文件类型 T_SYMLINK，以表示符号链接</li>
<li>向 <code>kernel/fcntl.h</code> 添加一个新标志 O_NOFOLLOW，该标志可以和 open 系统调用一起使用（标志通过 OR 运算符组合）</li>
<li>实现 <code>symlink(target, path)</code> 系统调用，请注意，系统调用的成功并不需要目标真的存在</li>
<li>修改 open 系统调用，以处理引入符号链接的情况。如果文件不存在，一定打开失败；当进程要打开的标志中指定 O_NOFOLLOW 时，打开符号链接（而不是引用的文件）</li>
<li>如果链接的文件也是符号链接，你必须递归的跟随它，直到到达非符号链接文件。如果链接形成一个环，你必须返回一个错误（你可以设置一个递归深度的阈值，比如 10）</li>
</ul>
</li>
<li><p>分别在 <code>user/usys.pl</code>、<code>user/user.h</code>、<code>kernel/syscall.h</code> 和 <code>kernel/syscall.c</code> 中添加有关 symlink 系统调用的声明</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;symlink&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">char</span> *, <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_symlink 22</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[SYS_symlink] sys_symlink,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/stat.h</code> 中添加新的文件类型 T_SYMLINK</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYMLINK 4   </span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/fcntl.h</code> 中添加新的标志位 O_NOFOLLOW（注意不能和别的标志位重叠）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O_NOFOLLOW 0x004</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/sysfile.c</code> 中实现 <code>sys_symlink()</code> 系统调用<ul>
<li>我们需要明确的是，符号链接是一种新的文件类型，它的数据内容就是链接文件的路径。因此我们只需要通过 <code>create()</code> 在 path 处创建一个 T_SYMLINK 类型的文件，文件内容为引用的 target 文件的路径就可以了</li>
<li>请注意，<code>create()</code> 返回的 struct inode 是持有锁的，如果你再次 <code>ilock()</code> 就会造成死锁</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">uint64 </span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, target, MAXPATH)) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="keyword">if</span> ((dp = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ilock(dp); create() 返回的 inode 是持有锁的</span></span><br><span class="line">  <span class="keyword">if</span> (writei(dp, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, n) &lt; n) &#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>open 系统调用在没有 O_NOFOLLOW 标志的情况下打开符号链接文件时，需要跟随到它所链接的非符号链接文件，因此我们需要编写一个额外的函数 <code>follow_symlink()</code> 来处理这种情况<ul>
<li>如果我们了解过 <code>sys_open()</code> 的具体实现后，就会发现传递给 <code>follow_symlink()</code> 的参数会是一个已经上了锁的 struct inode</li>
<li>由于需要保持一致性（应该可以这么说吧……），我们返回也是一个加了锁的 struct inode</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">follow_symlink</span><span class="params">(<span class="keyword">struct</span> inode *dp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> name[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">// ilock(dp); dp 在 open 中已经加锁了</span></span><br><span class="line">  <span class="keyword">if</span> (readi(dp, <span class="number">0</span>, (uint64)name, <span class="number">0</span>, MAXPATH) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(dp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((ip = namei(name)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="keyword">while</span> (ip-&gt;type == T_SYMLINK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num++ &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (readi(ip, <span class="number">0</span>, (uint64)name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">if</span> ((ip = namei(name)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// iunlock(ip); 需要返回一个加锁了的 inode</span></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>sys_open()</code>，使其能够处理打开 T_SYMLINK 类型的文件时，有、或没有 O_NOFOLLOW 标志的情况<ul>
<li>在有 O_NOFOLLOW 标志的情况下，我们需要打开的仅仅是符号链接文件（不是引用的文件），即使不修改 open，我们也已经打开了，所以我们需要处理的情况仅是没有 O_NOFOLLOW 标志的情况</li>
<li>如果 <code>follow_symlink()</code> 返回失败的话，我们传入的 struct inode 已经被解锁了，因此不需要 <code>iunlockput()</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> fd, omode;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">1</span>, &amp;omode);</span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;type == T_SYMLINK &amp;&amp; !(omode &amp; O_NOFOLLOW)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((ip = follow_symlink(ip)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// iunlockput(ip); 如果失败的话，ip 已经被解锁了</span></span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">      fileclose(f);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class="line">    f-&gt;type = FD_DEVICE;</span><br><span class="line">    f-&gt;major = ip-&gt;major;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    f-&gt;type = FD_INODE;</span><br><span class="line">    f-&gt;off = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;ip = ip;</span><br><span class="line">  f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class="line">  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;</span><br><span class="line">    itrunc(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 Makefile 中添加 symlinktest 用于测试</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_symlinktest\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; symlinktest</strong></li>
</ul>
<img src="/2024/09/07/6-S081-Lab9/image-20240908203942303.png" class="" title="image-20240908203942303">

<ul>
<li><strong>usertests -q</strong></li>
</ul>
<img src="/2024/09/07/6-S081-Lab9/image-20240908204344539.png" class="" title="image-20240908204344539">

<ul>
<li><strong>.&#x2F;grade-lab-fs symlinktest</strong></li>
</ul>
<img src="/2024/09/07/6-S081-Lab9/image-20240908204412315.png" class="" title="image-20240908204412315">

<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make grade</strong></li>
</ul>
<img src="/2024/09/07/6-S081-Lab9/image-20240908205225879.png" class="" title="image-20240908205225879">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/121431163">MIT 6.S081] Lab 9: file system_操作系统 mit 6.s081 lab9: file system-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16456046.html#%E5%8F%82%E8%80%83%E6%9D%90%E6%96%99">MIT6.S081-Lab9 FS 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/09/04/xv6-book-chapter-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/04/xv6-book-chapter-9/" class="post-title-link" itemprop="url">xv6 book chapter 9</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-04 22:36:00" itemprop="dateCreated datePublished" datetime="2024-09-04T22:36:00+08:00">2024-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-05 20:07:54" itemprop="dateModified" datetime="2024-09-05T20:07:54+08:00">2024-09-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><ul>
<li>要同时获得良好的的性能、并发的正确性和易于理解的代码是内核设计的一大挑战。直接使用锁是保证正确性的最佳途径，但不总是可行的。本章重点介绍了 xv6 不得不使用锁的例子，以及使用类似锁（但不是锁）的例子</li>
</ul>
<h2 id="Locking-patterns-加锁模式"><a href="#Locking-patterns-加锁模式" class="headerlink" title="Locking patterns 加锁模式"></a>Locking patterns 加锁模式</h2><ul>
<li><p>缓存项通常是锁的一个挑战。例如，文件系统的块缓存 (kernel&#x2F;bio.c:26) 存储了 <strong>NBUF</strong> 个磁盘块的副本。一个给定的磁盘块在缓存中最多只有一个副本，这一点非常重要；否则，不同的进程对同一磁盘块的不同副本进行修改时可能会发生冲突</p>
</li>
<li><p>每一个缓存的磁盘块都被存储在一个 <strong>buf</strong> 结构中 (kernel&#x2F;buf.h:1)。<strong>buf</strong> 结构有一个锁字段，它确保每次只有一个进程使用一个给定的磁盘块。然而，这个锁是不够的：如果一个块根本不存在于缓存中，而两个进程想同时使用它怎么办？没有 <strong>buf</strong> (因为该块还没有被缓存)，因此没有能加锁的东西。xv6 对所有块的标识符关联一个额外的锁来处理这种情况（如果没有 bcache.lock，那么可能会导致一个磁盘块有两个缓存副本）。判断块是否被缓存的代码（eg bget(kernel&#x2F;bio.c:59)），或改变缓存块集合的代码，必须持有 <strong>bcache.lock</strong>。当代码找到它所需要的块和 <strong>buf</strong> 结构后，它就可以释放 <strong>bcache.lock</strong>，然后锁定特定的块，这是一种通用模式：一组一把锁，外加每个项一把锁</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line"><span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line"><span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">uint dev;</span><br><span class="line">uint blockno;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">uint refcnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look through buffer cache for block on device dev. 在 buf 缓存中查找设备 dev 上的数据块</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer. 如果没有找到，则分配一个缓冲区</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer. 在任何一种情况下，都返回已加锁的缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is the block already cached? 数据块是否已经被缓存</span></span><br><span class="line"><span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line"> <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">   b-&gt;refcnt++;</span><br><span class="line">   release(&amp;bcache.lock);</span><br><span class="line">   acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not cached. 没有被缓存</span></span><br><span class="line"><span class="comment">// Recycle the least recently used (LRU) unused buffer. 回收最近最少使用（LRU）的未使用缓冲区</span></span><br><span class="line"><span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line"> <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">   b-&gt;dev = dev;</span><br><span class="line">   b-&gt;blockno = blockno;</span><br><span class="line">   b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">   b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">   release(&amp;bcache.lock);</span><br><span class="line">   acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>通常情况下，获取锁的函数会释放那把锁。但更准确的说法是，当一个序列需要保证原子性时，会在该序列开始时获取锁，而在序列结束时释放锁。如果序列的开始和结束在不同的函数中，或者不同的线程中，或者在不同的 CPU 上，那么锁的获取和释放也必须是一样的。锁的功能是强制其他的使用者等待，而不是将一段数据绑定给特定的代理</p>
<ul>
<li><p>一个例子是 yield 中的 <strong>acquire</strong> (kernel&#x2F;proc.c:515)，它是在调度线程中释放的，而不是在获取锁的进程中释放的</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Give up the CPU for one scheduling round.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">acquire(&amp;p-&gt;lock);</span><br><span class="line">p-&gt;state = RUNNABLE;</span><br><span class="line">sched();</span><br><span class="line">release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>另一个例子是 <strong>ilock</strong> (kernel&#x2F;fs.c:289) 中的 <strong>acquiresleep</strong>；这段代码经常在读取磁盘时睡眠；它可能在不同的 CPU 上被唤醒，这意味着锁可能在不同的 CPU 上获取和释放</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock the given inode.</span></span><br><span class="line"><span class="comment">// Reads the inode from disk if necessary.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ilock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip == <span class="number">0</span> || atomic_read4(&amp;ip-&gt;ref) &lt; <span class="number">1</span>)</span><br><span class="line"> panic(<span class="string">&quot;ilock&quot;</span>);</span><br><span class="line"></span><br><span class="line">acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line"> bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line"> dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line"> ip-&gt;type = dip-&gt;type;</span><br><span class="line"> ip-&gt;major = dip-&gt;major;</span><br><span class="line"> ip-&gt;minor = dip-&gt;minor;</span><br><span class="line"> ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line"> ip-&gt;size = dip-&gt;size;</span><br><span class="line"> memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line"> brelse(bp);</span><br><span class="line"> ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)</span><br><span class="line">   panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>释放一个被锁保护的且锁内嵌在其中的对象是一件很棘手的事情，因为拥有锁并不足以保证释放对象的正确性。当有其他线程在 <strong>acquire</strong> 中等待时，问题就会出现；释放这个对象就意味着释放内嵌的锁，而释放这个锁会导致等待线程出错。一种方式是追踪该对象有多少个引用，只有在最后一个引用消失时才会释放对象。<strong>pipeclose (kernel&#x2F;pipe.c:59)</strong> 就是这样的例子。<strong>pi-&gt;readopen</strong> 和 <strong>pi-&gt;writeopen</strong> 跟踪是否有文件描述符引用该管道</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pipeclose</span><span class="params">(<span class="keyword">struct</span> pipe *pi, <span class="type">int</span> writable)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;pi-&gt;lock);</span><br><span class="line"><span class="keyword">if</span>(writable)&#123;</span><br><span class="line"> pi-&gt;writeopen = <span class="number">0</span>;</span><br><span class="line"> wakeup(&amp;pi-&gt;nread);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> pi-&gt;readopen = <span class="number">0</span>;</span><br><span class="line"> wakeup(&amp;pi-&gt;nwrite);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pi-&gt;readopen == <span class="number">0</span> &amp;&amp; pi-&gt;writeopen == <span class="number">0</span>)&#123;</span><br><span class="line"> release(&amp;pi-&gt;lock);</span><br><span class="line"> freelock(&amp;pi-&gt;lock);  </span><br><span class="line"> kfree((<span class="type">char</span>*)pi);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"> release(&amp;pi-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Lock-like-patterns-类似锁的模式"><a href="#Lock-like-patterns-类似锁的模式" class="headerlink" title="Lock-like patterns 类似锁的模式"></a>Lock-like patterns 类似锁的模式</h2><ul>
<li><p>在许多地方，xv6 使用引用计数或标志位作为一种软锁（soft lock），以表明一个对象已被分配，不应该被释放或重用。进程的 <strong>p-&gt;state</strong> 依此工作，<strong>file</strong>、<strong>inode</strong> 和 <strong>buf</strong> 结构中的引用计数也是如此。虽然在每种情况下，锁都会保护标志位或引用计数，但正是标志位或引用计数防止了对象被过早释放</p>
</li>
<li><p>文件系统使用结构体 <strong>inode</strong> 的引用计数作为一种共享锁，可以由多个进程持有，以避免代码使用普通锁时出现的死锁。例如，<strong>namex</strong> (kernel&#x2F;fs.c:626) 中的循环依次锁定路径上的每个目录。然而，<strong>namex</strong> 必须在循环末尾释放每一个锁，因为如果它持有多个锁，那么如果路径名中包含. (即当前目录，例如，a&#x2F;.&#x2F;b)，它可能会与自己发生死锁。它也可能因为涉及目录和 .. 的并发查找而死锁。正如第 8 章所解释的那样，解决方案是让循环将目录的 inode 带入下一次迭代，并增加其引用计数，但不锁定</p>
</li>
<li><p>有些数据项在不同的时候会受到不同机制的保护。它有时可能会被 xv6 代码的结构隐式保护，而不是通过显式的锁来防止并发访问。例如，当一个物理页是空闲的时候，它被 <strong>kmem.lock（kernel&#x2F;kalloc.c:24）</strong> 保护。如果页面被分配作为管道 (kernel&#x2F;pipe.c:23)，它将被一个不同的锁 (内嵌的 <strong>pi-&gt;lock</strong>) 保护。如果该页被重新分配给一个新进程的用户内存，它就不会受到锁的保护。相反，分配器不会将该页交给任何其他进程（直到它被释放）的事实保护了它不被并发访问。一个新进程的内存的所有权是很复杂的：首先父进程在 <strong>fork</strong> 中分配和操作它，然后子进程使用它，（在子进程退出后）父进程再次拥有内存，并将其传递给 <strong>kfree</strong>。这里有两个需要注意的地方：第一，一个数据对象在其生命周期中的不同时刻可以用不同的方式来保护它不被并发访问；第二，保护的形式可能是隐式结构而不是显式锁</p>
</li>
<li><p>最后一个类似于锁的例子是在调用 <strong>mycpu()</strong> (kernel&#x2F;proc.c:68) 时需要禁用中断。禁用中断会导致调用代码对定时器中断是原子性的，而定时器中断可能会强制上下文切换，从而将进程移到不同的 CPU 上</p>
</li>
</ul>
<h2 id="No-locks-at-all-完全没有锁"><a href="#No-locks-at-all-完全没有锁" class="headerlink" title="No locks at all 完全没有锁"></a>No locks at all 完全没有锁</h2><ul>
<li><p>xv6 有几个地方是在完全没有锁的情况下共享可变数据的。一个是在 <strong>spinlocks</strong> 的实现中，尽管你可以把 RISC-V 原子指令看作是依靠硬件实现的锁。另一个是 <strong>main.c</strong> (kernel&#x2F;main.c:7) 中的 <strong>started</strong> 变量，用来防止其他 CPU 运行，直到 CPU 0 完成 xv6 的初始化；<strong>volatile</strong> 确保编译器真正生成加载和存储指令。第三个例子是 proc.c (kernel.proc.c:398) (kernel&#x2F;proc.c:306) 中的 p-&gt;parent。它的一些用法会导致死锁，但是明显不会有其他进程能够同时修改 p-&gt;parent。第四个例子是 p-&gt;killed。它在持有 p-&gt;lock 时被设置，但在检查时却并不需要锁</p>
</li>
<li><p>xv6 包含这样的情况：一个 CPU 或线程写一些数据，另一个 CPU 或线程读数据，但没有专门的锁来保护这些数据。例如，在 <strong>fork</strong> 中，父进程写入子进程的用户内存页，子进程 (可能在不同的 CPU 上) 读取这些页。这些页没有锁来显式地保护。严格来说，这不是锁的问题，因为子进程在父进程写完后才开始执行。这是一个潜在的内存操作的顺序问题（见第 6 章），因为没有内存屏障，没有理由期望一个 CPU 看到另一个 CPU 的写入。然而，由于父进程 CPU 释放锁，而子进程 CPU 在启动时获取锁，所以在 <strong>acquire</strong> 和 <strong>release</strong> 中的内存屏障保证了子进程 CPU 能看到父进程 CPU 的写入</p>
</li>
</ul>
<h2 id="Parallelism-并行性"><a href="#Parallelism-并行性" class="headerlink" title="Parallelism 并行性"></a>Parallelism 并行性</h2><ul>
<li><p>锁主要是为了正确性而抑制并行性。但是性能也很重要，所以内核设计者经常要考虑如何使用锁，来同时保证正确性和良好的并行性。虽然 xv6 并未对高性能进行系统地设计，但仍然值得考虑哪些 xv6 操作可以并行执行，哪些操作可能在锁上发生冲突</p>
</li>
<li><p>xv6 中的管道是一个并行性相当好的例子。每个管道都有自己的锁，因此不同的进程可以在不同的 CPU 上并行读写不同的管道。然而，对于一个给定的管道，writer 和 reader 必须等待对方释放锁，他们不能同时读&#x2F;写同一个管道。还有一种情况是，从一个空管道读（或向一个满管道写）必须阻塞，但这不是锁的方案导致的问题</p>
</li>
<li><p>上下文切换是一个更复杂的例子。两个在各自 CPU 上执行的内核线程，可以同时调用 <strong>yield</strong>、<strong>sched</strong> 和 <strong>swtch</strong>，并且这些调用能并行执行。这两个线程各自持有一个锁，但是不同的锁，所以它们不必等待对方。一旦进入 <strong>scheduler</strong>，两个 CPU 在遍历进程表寻找一个 RUNNABLE 的进程的时候，却可能会发生锁冲突。也就是说，xv6 在上下文切换的过程中，很可能会从多个 CPU 中获得性能上的好处，但可能没有那么多</p>
</li>
<li><p>另一个例子是在不同的 CPU 上从不同的进程并发调用 <strong>fork</strong>。这些调用可能需要互相等待 <strong>pid_lock</strong> 和 <strong>kmem.lock</strong>，以及在进程表中搜索一个 <strong>UNUSED</strong> 进程所需的进程锁。另一方面，两个正在 fork 的进程可以完全并行地复制用户内存页和格式化页表页</p>
</li>
<li><p>上述每个例子中的锁方案在某些情况下都牺牲了并行性能。在每一种情况下，都有可能通过更复杂的设计获得更多的并行性。这是否值得取决于细节：相关操作被调用的频率、代码在锁竞争的情况下所花费的时间、有多少 CPU 可能同时运行冲突的操作、是否代码的其他部分才是性能瓶颈。很难猜测一个给定的锁方案是否会导致性能问题，或者一个新的设计是否有明显的改进，所以往往需要在现实的工作负载上进行测量</p>
</li>
</ul>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li><p>修改 xv6 管道的实现，允许对同一管道的读和写在不同内核上并行进行</p>
</li>
<li><p>修改 xv6 **scheduler()**，以减少不同内核同时寻找可运行进程时的锁竞争</p>
</li>
<li><p>消除 <strong>fork</strong> 中一些串行执行的代码</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/09/02/6-S081-Lab8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/02/6-S081-Lab8/" class="post-title-link" itemprop="url">Lab Lock</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-02 09:00:04" itemprop="dateCreated datePublished" datetime="2024-09-02T09:00:04+08:00">2024-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-03 20:35:31" itemprop="dateModified" datetime="2024-09-03T20:35:31+08:00">2024-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>Lab Guidance：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/labs/lock.html">Lab: locks (mit.edu)</a></p>
</li>
<li><p>在这个实验中，你将重新设计代码以增加并行性，多核及其并行性差的一个常见症状是锁争用高，改善并行性通常涉及改变数据结构和锁定策略，以减少竞争。你将为 xv6 内存分配器和块缓存这样做</p>
</li>
<li><p>在开始前，请务必阅读：</p>
<ul>
<li>xv6 book 第 6 章：“Locking” 和相关代码</li>
<li>xv6 book 第 3.5 节：“Code：物理内存分配器”</li>
<li>xv6 book 第 8.1~8.3 节：“Overview”  和 “Buffer cache layer” 和 “Code：Buffer cache”</li>
</ul>
</li>
<li><p>输入 <code>git fetch &amp;&amp; git checkout &amp;&amp; make clean</code> 以切换分支</p>
</li>
</ul>
<h1 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h1><ul>
<li><p><code>user/kalloctest</code> 用于测试 xv6 的内存分配器，这会导致对 <code>kalloc</code> 和 <code>kfree</code> 的多次调用。<code>kalloc</code> 和 <code>kfree</code> 会获取 <code>kmem.lock</code>。<code>kalloctest</code> 会打印由于尝试获取另一个核心已经持有的锁而在获取时发生的循环迭代次数</p>
</li>
<li><p><code>user/kalloctest</code> 中锁竞争的根本原因是 <code>kalloc()</code> 有一个由单个锁保护的空闲列表。要消除锁竞争，你必须重新设计内存分配器，基本思想是为每个 CPU 维护一个空闲列表，每个列表都有自己的锁</p>
</li>
<li><p>主要挑战是处理一个 CPU 的空闲列表为空，但另一个 CPU 的空闲列表有可用内存的情况；在这种情况下，一个 CPU 必须 “偷” 另一个 CPU 的空闲列表的一部分，“偷” 可能会带来锁竞争，但希望这不会很常见</p>
</li>
<li><p>你的工作是实现每个 CPU 的空闲列表，在空闲列表为空时进行 “偷”；你应该为每个锁调用 <code>initlock()</code> 并给出一个以 “kmem” 开头的锁名</p>
</li>
<li><p>确保 <code>usertests -q</code> 中的所有测试都通过</p>
</li>
<li><p>一些提示</p>
<ul>
<li>你可以使用 <code>kernel/param.h</code> 中的常量 NCPU</li>
<li>让 <code>freerange()</code> 将所有可用内存提供给运行 <code>freerange()</code> 的 CPU</li>
<li>函数 <code>cpuid()</code> 返回当前核心编号，但只有在中断关闭时调用它才安全。你应该使用 <code>push_off()</code> 和 <code>pop_off()</code> 来关闭和打开中断</li>
<li>查看 <code>kernel/sprintf.c</code> 中的 <code>sprintf()</code>，了解字符串格式的想法。当然，把所有锁命名为 “kmem” 也是可以的</li>
</ul>
</li>
<li><p>首先，我们需要为每个 CPU 维护一个空闲列表，因此需要修改 <code>kernel/kalloc.c</code> 中的全局变量 <code>kmem</code> 为大小 <code>NCPU</code> 的 <code>kmem</code> 数组</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU];</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>kinit()</code> 会被调用来初始化相关锁、通过 <code>freerange()</code> 为空闲列表分配可用内存。修改 <code>kinit()</code>，为每个锁调用 <code>initlock()</code></p>
<blockquote>
<p>这里偷了个懒，将每个锁都命名为了 <code>kmem</code></p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">    initlock(&amp;kmem[i].lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>提示中说到，<code>freerange()</code> 可以将所有可用内存提供给运行 <code>freerange()</code> 的 CPU，由于 <code>freerange()</code> 调用 <code>kfree()</code> 来分配可用内存，所以只需要修改 <code>kfree()</code></li>
<li>当然不要忘记在调用 <code>cpuid()</code> 时需要通过 <code>push_off()</code> 和 <code>pop_off()</code> 来关闭和开启中断</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem[id].lock);</span><br><span class="line">  r-&gt;next = kmem[id].freelist;</span><br><span class="line">  kmem[id].freelist = r;</span><br><span class="line">  release(&amp;kmem[id].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最后需要处理的情况是，当一个 CPU 的空闲列表为空时，它需要去 ”偷“ 另一个空闲列表的一部分可用内存。因此我们需要修改 <code>kalloc()</code> ，同时创建一个新的函数 <code>steal()</code> 来处理这种 ”偷“ 的情况</p>
</li>
<li><p><code>steal()</code> 函数遍历 <code>kmem</code> 数组，当满足条件时，通过快慢指针法将找到的空闲列表的一半分配给调用 <code>steal()</code> 进行 ”偷“ 操作的 CPU 对应的空闲列表</p>
<blockquote>
<p>快慢指针法中有一个小细节，<code>fast</code> 指针被初始化为 <code>slow-&gt;next</code>，这可以有效处理找到的空闲列表仅有一个有效节点的情况</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">steal</span> <span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">fast</span>, *<span class="title">slow</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == id || !kmem[i].freelist) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem[i].lock);</span><br><span class="line">    slow = kmem[i].freelist;</span><br><span class="line">    fast = slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">      fast = fast-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (fast) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kmem[id].freelist = kmem[i].freelist;</span><br><span class="line">    kmem[i].freelist = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="number">0</span>;</span><br><span class="line">    release(&amp;kmem[i].lock);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem[id].lock);</span><br><span class="line">  <span class="keyword">if</span> (!kmem[id].freelist) </span><br><span class="line">    steal(id);</span><br><span class="line"></span><br><span class="line">  r = kmem[id].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem[id].freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem[id].lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; kalloctest</strong></li>
</ul>
<img src="/2024/09/02/6-S081-Lab8/image-20240903151128175.png" class="" title="image-20240903151128175">

<ul>
<li><strong>usertests sbrkmuch</strong></li>
</ul>
<img src="/2024/09/02/6-S081-Lab8/image-20240903151208947.png" class="" title="image-20240903151208947">

<ul>
<li><strong>usertests -q</strong></li>
</ul>
<img src="/2024/09/02/6-S081-Lab8/image-20240903151551056.png" class="" title="image-20240903151551056">

<ul>
<li><strong>.&#x2F;grade-lab-lock kalloctest</strong></li>
</ul>
<img src="/2024/09/02/6-S081-Lab8/image-20240903151857879.png" class="" title="image-20240903151857879">

<h1 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h1><ul>
<li><p>如果你查看 <code>kernel/bio.c</code> 中的代码，你会看到 <code>bcache.lock</code> 保护缓存块列表、每个缓存块的引用计数（<code>b-&gt;refcnt</code>）以及缓存块的标识（<code>b-&gt;dev</code> 和 <code>b-&gt;blickno</code>） ，正是由于 <code>bcache.lock</code> 维护了多个缓冲块的信息从而引起了大量竞争</p>
</li>
<li><p>因此我们需要修改块缓存，我们建议你使用哈希表来查找缓存中的块号，并为每个哈希桶提供一个锁。可以使用固定数量的桶，并且不动态调整哈希表的大小。使用质数个桶（例如13）以减少哈希冲突的可能性</p>
</li>
<li><p>修改 <code>bget()</code> 和 <code>brelse()</code>，以便对 <code>bcache</code> 中不同块的并发查找和释放不太可能在锁上发生冲突</p>
</li>
<li><p>我们仍需要给出所有以 “bcache” 开头的锁命名。也就是说，你应该为每个锁调用 <code>initlock()</code>，并传递一个以 “bcache” 开头的名称</p>
</li>
<li><p>一些提示</p>
<ul>
<li>阅读 xv6 book 中关于块缓存的描述（8.1- 8.3 节）</li>
<li>在哈希表中搜索缓冲区并在未找到缓冲区时为其分配条目必须是原子的</li>
<li>你的解决方案在某些情况下可能需要持有两个锁，请确保避免死锁</li>
<li>在替换块时，你可能需要将一个 <code>struct buf</code> 从一个桶移动到另一个桶，因为新块哈希到不同的桶。你可能会遇到一种棘手的情况：新块可能会哈希到与旧块相同的桶。请确保在这种情况下避免死锁</li>
</ul>
</li>
<li><p>创建一个新结构体作为哈希表，以及定义相关的哈希函数</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 13</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; hashtable[TABLE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(uint blockno)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> blockno % TABLE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>binit()</code><ul>
<li>首先，初始化每个哈希桶对应的锁，由于每个哈希桶也是环形链表，因此在循环中需要初始化每个哈希桶的 <code>head</code> 相关变量</li>
<li>第二个循环将 <code>bcache</code> 中所有的缓冲块都分配给第一个哈希桶（同样是环形链表）这样方便后续在 <code>bget()</code> 中将这些缓存块分配给其他哈希桶</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">    hashtable[i].head.prev = &amp;hashtable[i].head;</span><br><span class="line">    hashtable[i].head.next = &amp;hashtable[i].head;</span><br><span class="line">    initlock(&amp;hashtable[i].lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = hashtable[<span class="number">0</span>].head.next;</span><br><span class="line">    b-&gt;prev = &amp;hashtable[<span class="number">0</span>].head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    hashtable[<span class="number">0</span>].head.next-&gt;prev = b;</span><br><span class="line">    hashtable[<span class="number">0</span>].head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>bget()</code> 函数<ul>
<li>首先检查这个缓存块是否已经已经被缓存了。通过块号找到对应的哈希桶，遵循 LRU 从前向后开始遍历对应的哈希桶，如果找到就引用计数++</li>
<li>如果没有缓存，那么首先在原来本应存在的哈希桶中寻找是否有引用计数为零的空闲缓存块，同样遵循 LRU 从后向前遍历哈希桶，如果找到就设置相关变量进行覆盖</li>
<li>如果原来本应存在的哈希桶中没有引用计数为零的缓存块，那么依次遍历其他哈希桶，找到引用计数为零的缓存块，将它进行哈希桶之间的传递（注意由于都是环形链表，实现起来比较繁琐），由于遵循 LRU，将找到的缓存块插入到原来本应存在的哈希表的头部，最后设置相关变量</li>
<li>在具体实现中，尤其需要注意相关锁的 <code>acquire</code> 和 <code>release</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> no = hash(blockno);</span><br><span class="line">  acquire(&amp;hashtable[no].lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span> (b = hashtable[no].head.next; b != &amp;hashtable[no].head; b = b-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;hashtable[no].lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="keyword">for</span> (b = hashtable[no].head.prev; b != &amp;hashtable[no].head; b = b-&gt;prev) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;hashtable[no].lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == no || !hashtable[i].head.next) <span class="keyword">continue</span>;</span><br><span class="line">    acquire(&amp;hashtable[i].lock);</span><br><span class="line">    <span class="keyword">for</span> (b = hashtable[i].head.prev; b != &amp;hashtable[i].head; b = b-&gt;prev) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">        b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">        b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">        release(&amp;hashtable[i].lock);</span><br><span class="line">        b-&gt;next = hashtable[no].head.next;</span><br><span class="line">        b-&gt;prev = &amp;hashtable[no].head;</span><br><span class="line">        hashtable[no].head.next-&gt;prev = b;</span><br><span class="line">        hashtable[no].head.next = b;</span><br><span class="line">        b-&gt;dev = dev;</span><br><span class="line">        b-&gt;blockno = blockno;</span><br><span class="line">        b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">        b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">        release(&amp;hashtable[no].lock);</span><br><span class="line">        acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;hashtable[i].lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>brelse()</code><ul>
<li>当一个缓存块的引用计数为零时，将它插入到对应哈希桶的头部，遵循 LRU</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;hashtable[hash(b-&gt;blockno)].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = hashtable[hash(b-&gt;blockno)].head.next;</span><br><span class="line">    b-&gt;prev = &amp;hashtable[hash(b-&gt;blockno)].head;</span><br><span class="line">    hashtable[hash(b-&gt;blockno)].head.next-&gt;prev = b;</span><br><span class="line">    hashtable[hash(b-&gt;blockno)].head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;hashtable[hash(b-&gt;blockno)].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后被忘了修改 <code>bpin()</code> 和 <code>bunpin()</code><ul>
<li>使用对应哈希桶的锁</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  acquire(&amp;hashtable[hash(b-&gt;blockno)].lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;hashtable[hash(b-&gt;blockno)].lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bunpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  acquire(&amp;hashtable[hash(b-&gt;blockno)].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;hashtable[hash(b-&gt;blockno)].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; bcachetest</strong></li>
</ul>
<img src="/2024/09/02/6-S081-Lab8/image-20240903201959101.png" class="" title="image-20240903201959101">

<ul>
<li><strong>usertests -q</strong></li>
</ul>
<img src="/2024/09/02/6-S081-Lab8/image-20240903202316198.png" class="" title="image-20240903202316198">

<ul>
<li><strong>.&#x2F;grade-lab-lock bcachetest</strong></li>
</ul>
<img src="/2024/09/02/6-S081-Lab8/image-20240903202615228.png" class="" title="image-20240903202615228">

<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make grade</strong></li>
</ul>
<img src="/2024/09/02/6-S081-Lab8/image-20240903203337667.png" class="" title="image-20240903203337667">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/121430900">MIT 6.S081] Lab 8: locks_6s081 lab 8:locks-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16389164.html">MIT6.S081-Lab8 Lock 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/07/09/xv6-book-chapter-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/09/xv6-book-chapter-8/" class="post-title-link" itemprop="url">xv6 book chapter 8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-09 20:43:15" itemprop="dateCreated datePublished" datetime="2024-07-09T20:43:15+08:00">2024-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-11 12:31:45" itemprop="dateModified" datetime="2024-07-11T12:31:45+08:00">2024-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><ul>
<li><p>文件系统的目的是组织和存储数据。文件系统通常支持用户和应用程序之间的数据共享，以及支持持久性，以便数据在重启后仍然可用</p>
</li>
<li><p>xv6 文件系统提供了类 Unix 的文件、目录和路径名（见第 1 章），并将其数据存储在 virtio 磁盘上以实现持久化（见第 4 章）。该文件系统解决了几个挑战：</p>
<ul>
<li><p>文件系统需要磁盘上的数据结构来表示命名目录和文件的树，记录保存每个文件内容的块的身份，并记录磁盘上哪些区域是空闲的</p>
</li>
<li><p>文件系统必须支持崩溃恢复。也就是说，如果发生崩溃（如电源故障），文件系统必须在重新启动后仍能正常工作。风险在于，崩溃可能会中断更新序列，并在磁盘上留下不一致的数据结构（例如，一个块既在文件中使用，又被标记为空闲）</p>
</li>
<li><p>不同的进程可能并发在文件系统上运行，所以文件系统代码必须协调维护每一个临界区</p>
</li>
<li><p>访问磁盘的速度比访问内存的速度要慢几个数量级，所以文件系统必须在内存维护一个缓冲区，用于缓存常用块</p>
</li>
</ul>
</li>
<li><p>本章剩下的部分将解释 xv6 如何解决这些问题</p>
</li>
</ul>
<h2 id="Overview-概述"><a href="#Overview-概述" class="headerlink" title="Overview 概述"></a>Overview 概述</h2><img src="/2024/07/09/xv6-book-chapter-8/Figure-8.1-17206131871324.png" class="" title="Figure-8.1">

<ul>
<li>xv6 文件系统的实现分为七层，如图 8.1 所示<ul>
<li>disk 层在 virtio 磁盘上读写块</li>
<li>Buffer cache 缓存磁盘块，并同步访问它们，确保一个块只能同时被内核中的一个进程访问</li>
<li>日志层允许上层通过事务更新多个磁盘块，并确保在崩溃时，磁盘块是原子更新的（即全部更新或不更新）</li>
<li>inode 层将一个文件都表示为一个 <strong>inode</strong>，每个文件包含一个唯一的 i-number 和一些存放文件数据的块</li>
<li>目录层将实现了一种特殊的 <strong>inode</strong>，被称为目录，其包含一个目录项序列，每个目录项由文件名称和 i-number 组成</li>
<li>路径名层提供了层次化的路径名，如 &#x2F;<strong>usr&#x2F;rtm&#x2F;xv6&#x2F;fs.c</strong>，可以用递归查找解析他们</li>
<li>文件描述符层用文件系统接口抽象了许多 Unix 资源（如管道、设备、文件等），使程序员的生产力得到大大的提高</li>
</ul>
</li>
</ul>
<img src="/2024/07/09/xv6-book-chapter-8/Figure-8.2-17206131871325.png" class="" title="Figure-8.2">

<img src="/2024/07/09/xv6-book-chapter-8/image-20240711123126129.png" class="" title="image-20240711123126129">

<ul>
<li><p>文件系统必须安排好磁盘存储 inode 和内容块的位置。为此，xv6 将磁盘分为几个部分，如图 8.2 所示</p>
<ul>
<li><p>文件系统不使用块 0（它存放 boot sector）</p>
</li>
<li><p>第 1 块称为 <strong>superblock</strong>，它包含了文件系统的元数据（以块为单位的文件系统大小、数据块的数量、inode 的数量和日志中的块数）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Disk layout:</span></span><br><span class="line"><span class="comment">// [ boot block | super block | log | inode blocks |</span></span><br><span class="line"><span class="comment">//                                          free bit map | data blocks]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mkfs computes the super block and builds an initial file system. The</span></span><br><span class="line"><span class="comment">// super block describes the disk layout:</span></span><br><span class="line"><span class="comment">// 磁盘布局：  </span></span><br><span class="line"><span class="comment">// [引导块 | 超级块 | 日志 | inode 块 |  </span></span><br><span class="line"><span class="comment">//                                          空闲位图 | 数据块]  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// mkfs 工具计算超级块并构建初始文件系统。  </span></span><br><span class="line"><span class="comment">// 超级块描述了磁盘的布局：  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> &#123;</span></span><br><span class="line">uint magic;        <span class="comment">// Must be FSMAGIC 必须为FSMAGIC，用于验证文件系统的魔数</span></span><br><span class="line">uint size;         <span class="comment">// Size of file system image (blocks) 文件系统映像的大小（以块为单位）</span></span><br><span class="line">uint nblocks;      <span class="comment">// Number of data blocks 数据块的数量</span></span><br><span class="line">uint ninodes;      <span class="comment">// Number of inodes. inode的数量</span></span><br><span class="line">uint nlog;         <span class="comment">// Number of log blocks 日志块的数量</span></span><br><span class="line">uint logstart;     <span class="comment">// Block number of first log block 第一个日志块的块号 </span></span><br><span class="line">uint inodestart;   <span class="comment">// Block number of first inode block 第一个inode块的块号</span></span><br><span class="line">uint bmapstart;    <span class="comment">// Block number of first free map block 第一个空闲位图块的块号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>从块 2 开始存放着日志</p>
</li>
<li><p>日志之后是 inodes，每个块会包含多个 inode</p>
</li>
<li><p>在这些块之后是 **位图块(bitmap)**，记录哪些数据块在使用</p>
</li>
<li><p>其余的块是数据块，每个数据块要么在 bitmap 块中标记为空闲，要么持有文件或目录的内容</p>
</li>
<li><p>超级块由一个单独的程序 <strong>mkfs</strong> 写入，它建立了一个初始文件系统</p>
</li>
</ul>
</li>
<li><p>本章的其余部分将讨论每一层，从 buffer 缓存开始。从讨论中我们将看到如何选择合适的低层抽象，来方便更高层的设计</p>
</li>
</ul>
<h2 id="Buffer-cache-layer"><a href="#Buffer-cache-layer" class="headerlink" title="Buffer cache layer"></a>Buffer cache layer</h2><ul>
<li><p>buffer 缓存有两项工作。(1) 同步访问磁盘块，以确保磁盘块在内存中只有一个 buffer 缓存，并且一次只有一个内核线程能使用该 buffer 缓存；(2) 缓存使用较多的块，这样它们就不需要从慢速磁盘中重新读取。代码见 <strong>bio.c</strong></p>
</li>
<li><p>buffer 缓存的主要接口包括 <strong>bread</strong> 和 <strong>bwrite</strong>，bread 返回一个在内存中可以读取和修改的块副本 <strong>buf</strong>，<strong>bwrite</strong> 将修改后的 buffer 写到磁盘上相应的块</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a locked buf with the contents of the indicated block. 返回一个包含指定块内容的已锁定缓冲区</span></span><br><span class="line"><span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">b = bget(dev, blockno);</span><br><span class="line"><span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line"> virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line"> b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked. 将b的内容写入磁盘，必须持有锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line"> panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>内核线程在使用完一个 buffer 后，必须通过调用 <strong>brelse</strong> 释放它</li>
<li>buffer 缓存为每个 buffer 的都设有 sleep-lock，以确保每次只有一个线程使用 buffer（从而使用相应的磁盘块）</li>
<li><strong>bread</strong> 返回的 buffer 会被锁定，而 <strong>brelse</strong> 释放锁</li>
</ul>
</li>
<li><p>我们再来看看 buffer 缓存。buffer 缓存有固定数量的 buffer 来存放磁盘块，这意味着如果文件系统需要一个尚未被缓存的块，buffer 缓存必须回收一个当前存放其他块的 buffer。buffer 缓存为新块寻找最近使用最少的 buffer（lru 机制）。因为最近使用最少的 buffer 是最不可能被再次使用的 buffer</p>
</li>
</ul>
<h2 id="Code-Buffer-cache"><a href="#Code-Buffer-cache" class="headerlink" title="Code: Buffer cache"></a>Code: Buffer cache</h2><ul>
<li><p>buffer 缓存是一个由 buffer 组成的双端链表。由函数 <strong>binit</strong> 用静态数组 <strong>buf</strong> 初始化这个链表，<strong>binit</strong> 在启动时由 <strong>main</strong> (kernel&#x2F;main.c:27) 调用。访问 buffer 缓存是通过链表，而不是 <strong>buf</strong> 数组</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBUF (MAXOPBLOCKS*3)   <span class="comment">// size of disk block cache</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Linked list of all buffers, through prev/next.  通过 prev/next 指针链接所有缓冲区，形成一个链表</span></span><br><span class="line"><span class="comment">// Sorted by how recently the buffer was used. 根据缓冲区最近被使用的时间进行排序</span></span><br><span class="line"><span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line"><span class="comment">// head.next 指向最近被使用的缓冲区，head.prev 指向最久未被使用的缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create linked list of buffers 创建缓冲区的链表(很好的创建双向环形链表的方式)</span></span><br><span class="line">bcache.head.prev = &amp;bcache.head;</span><br><span class="line">bcache.head.next = &amp;bcache.head;</span><br><span class="line"><span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">b-&gt;next = bcache.head.next;</span><br><span class="line">b-&gt;prev = &amp;bcache.head;</span><br><span class="line">initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">bcache.head.next-&gt;prev = b;</span><br><span class="line">bcache.head.next = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>buffer 有两个与之相关的状态字段。字段 <strong>valid</strong> 表示是否包含该块的副本（是否从磁盘读取了数据）。字段 <strong>disk</strong> 表示缓冲区的内容已经被修改需要被重新写入磁盘</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line"><span class="type">int</span> valid;   <span class="comment">// has data been read from disk? 已经从磁盘读取数据了吗</span></span><br><span class="line"><span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">uint dev;</span><br><span class="line">uint blockno;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">uint refcnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>bget</strong> (kernel&#x2F;bio.c:59) 扫描 buffer 链表，寻找给定设备号和扇区号来查找缓冲区 (kernel&#x2F;bio.c:65-73)。如果存在，<strong>bget</strong> 就会获取该 buffer 的 sleep-lock。然后 <strong>bget</strong> 返回被锁定的 buffer</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev. 在 buf 缓存中查找设备 dev 上的数据块</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer. 如果没有找到，则分配一个缓冲区</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer. 在任何一种情况下，都返回已加锁的缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is the block already cached? 数据块是否已经被缓存</span></span><br><span class="line"><span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line"> <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">   b-&gt;refcnt++;</span><br><span class="line">   release(&amp;bcache.lock);</span><br><span class="line">   acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not cached. 没有被缓存</span></span><br><span class="line"><span class="comment">// Recycle the least recently used (LRU) unused buffer. 回收最近最少使用（LRU）的未使用缓冲区</span></span><br><span class="line"><span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line"> <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">   b-&gt;dev = dev;</span><br><span class="line">   b-&gt;blockno = blockno;</span><br><span class="line">   b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">   b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">   release(&amp;bcache.lock);</span><br><span class="line">   acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果给定的扇区没有缓存的 buffer，<strong>bget</strong> 必须生成一个，可能会使用一个存放不同扇区的 buffer，它再次扫描 buffer 链表，寻找没有被使用的 buffer(<strong>b-&gt;refcnt &#x3D; 0</strong>)；任何这样的 buffer 都可以使用。bget 修改 buffer 元数据，记录新的设备号和扇区号，并获得其 sleep-lock。请注意，<strong>b-&gt;valid &#x3D; 0</strong> 可以确保 bread 从磁盘读取块数据，而不是错误地使用 buffer 之前的内容</p>
</li>
<li><p>请注意，每个磁盘扇区最多只能有一个 buffer，以确保写操作对读取者可见，也因为文件系统需要使用 buffer 上的锁来进行同步。<strong>bget</strong> 通过从第一次循环检查块是否被缓存，第二次循环来生成一个相应的 buffer（通过设置 <strong>dev</strong>、<strong>blockno</strong> 和 <strong>refcnt</strong>），在进行这两步操作时，需要一直持有 <strong>bache.lock</strong> 。持有 <strong>bache.lock</strong> 会保证上面两个循环在整体上是原子的</p>
</li>
<li><p><strong>bget</strong> 在 <strong>bcache.lock</strong> 保护的临界区之外获取 buffer 的 sleep-lock 是安全的，因为非零的 <strong>b-&gt;refcnt</strong> 可以防止缓冲区被重新用于不同的磁盘块（只要保证我们获得了正确的磁盘块对应的缓冲区，假如此时有一个中断导致磁盘块对应缓冲区中的内容被修改，都是被允许的）。sleep-lock 保护的是块的缓冲内容的读写，而 bcache.lock 保护被缓存块的信息</p>
</li>
<li><p>如果所有 buffer 都在使用，那么太多的进程同时在执行文件相关的系统调用，bget 就会 <strong>panic</strong>。一个更好的处理方式可能是睡眠，直到有 buffer 空闲，尽管这时有可能出现死锁</p>
</li>
<li><p>一旦 <strong>bread</strong> 读取了磁盘内容（如果需要的话）并将缓冲区返回给它的调用者，调用者就独占该 buffer，可以读取或写入数据。如果调用者修改了 buffer，它必须在释放 buffer 之前调用 <strong>bwrite</strong> 将修改后的数据写入磁盘。<strong>bwrite</strong> (kernel&#x2F;bio.c:107) 调用 <strong>virtio_disk_rw</strong> 与磁盘硬件交互</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked. 将b的内容写入磁盘，必须持有锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line"> panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>当调用者处理完一个 buffer 后，必须调用 <strong>brelse</strong> 来释放它。(<strong>brelse</strong> 这个名字是 <strong>b-release</strong> 的缩写，虽然很神秘，但值得学习，它起源于 Unix，在 BSD、Linux 和 Solaris 中也有使用。) </p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release a locked buffer. 释放一个已锁定的缓冲区</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list. 将其移动到最近使用列表的头部</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line"> panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">acquire(&amp;bcache.lock);</span><br><span class="line">b-&gt;refcnt--;</span><br><span class="line"><span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123; <span class="comment">// refcnt==0代表它很可能将会被LRU替换,所以移至链表头来延迟替换,同时加速再次使用时的查找</span></span><br><span class="line"> <span class="comment">// no one is waiting for it.</span></span><br><span class="line"> b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line"> b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line"> b-&gt;next = bcache.head.next;</span><br><span class="line"> b-&gt;prev = &amp;bcache.head;</span><br><span class="line"> bcache.head.next-&gt;prev = b;</span><br><span class="line"> bcache.head.next = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>brelse</strong> (kernel&#x2F;bio.c:117) 释放 sleep-lock，并将该 buffer 移动到链表的头部 (kernel&#x2F;bio.c:128-133)。移动 buffer 会使链表按照 buffer 最近使用的时间（最近释放）排序，链表中的第一个 buffer 是最近使用的，最后一个是最早使用的</li>
<li><strong>bget</strong> 中的两个循环利用了这一点，在最坏的情况下，获取已缓存 buffer 的扫描必须处理整个链表，由于数据局部性，先检查最近使用的缓冲区（从 <strong>bcache.head</strong> 开始，通过 <strong>next</strong> 指针）将减少扫描时间。扫描选取可使用 buffer 的方法是通过从后向前扫描（通过 <strong>prev</strong> 指针）选取最近使用最少的缓冲区</li>
</ul>
</li>
</ul>
<h2 id="Logging-layer"><a href="#Logging-layer" class="headerlink" title="Logging layer"></a>Logging layer</h2><ul>
<li><p>文件系统设计中最有趣的问题之一是崩溃恢复。这个问题的出现是因为许多文件系统操作涉及到对磁盘的多次写入，如果只执行了部分写操作，然后发生崩溃可能会使磁盘上的文件系统处于不一致的状态。例如，假设在文件截断（将文件的长度设置为零并释放其内容块）时发生崩溃。根据磁盘写入的顺序，可能会留下一个引用空闲内容块的inode，也可能会留下一个已分配但没有被引用的内容块</p>
</li>
<li><p>后面的这种情况相对来说好一点，但是如果一个 inode 指向被释放的块，很可能在重启后造成严重的问题。重启后，内核可能会将该块分配给另一个文件，现在我们有两个不同的文件无意中指向了同一个块。如果 xv6 支持多用户，这种情况可能是一个安全问题，因为旧文件的所有者能够读写新文件，即使该文件被另一个用户所拥有</p>
</li>
<li><p>xv6 通过简单的日志系统来解决文件系统操作过程中崩溃带来的问题。xv6 的系统调用不直接写磁盘上的文件系统数据结构。相反，它将写入的数据记录在磁盘上的日志中。一旦系统调用记录了全部的写入数据，它就会在磁盘上写一个特殊的提交记录，表明该日志包含了一个完整的操作。这时，系统调用就会将日志中的写入数据写到磁盘上相应的位置。在执行完成后，系统调用将磁盘上的日志清除</p>
</li>
<li><p>如果系统崩溃并重启，文件系统会在启动过程中恢复自己。如果日志被标记为包含一个完整的操作，那么恢复代码就会将写入的内容复制到它们在磁盘文件系统中的相应位置。如果日志未被标记为包含完整的操作，则恢复代码将忽略并清除该日志</p>
</li>
<li><p>为什么 xv6 的日志系统可以解决文件系统操作过程中的崩溃问题？如果崩溃发生在操作提交之前，那么磁盘上的日志将不会被标记为完成，恢复代码将忽略它，磁盘的状态就像操作根本没有开始一样。如果崩溃发生在操作提交之后，那么恢复代码会重新执行写操作，可能会重复执行之前的写操作。不管是哪种情况，日志都会使写与崩溃为原子的，即恢复后，所有操作的写入内容，要么都在磁盘上，要么都不在</p>
</li>
</ul>
<h2 id="Log-design"><a href="#Log-design" class="headerlink" title="Log design"></a>Log design</h2><ul>
<li><p>日志贮存在一个固定位置，由 <strong>superblock</strong> 指定。它由一个 header 块组成，后面是一连串的更新块副本（日志块）。header 块包含一个扇区号数组，其中的每个扇区号都对应一个日志块<a href="#ftn1">[1]</a>，header 还包含日志块的数量。磁盘上 header 块中的数量要么为零，表示日志中没有事务，要么为非零，表示日志中包含一个完整的提交事务，并有指定数量的日志块。xv6 在事务提交时会修改  header 块，将日志块复制到文件系统后，会将数量设为零。因此，一个事务中途的崩溃将导致日志 header 块中的计数为零；提交后的崩溃的计数为非零</p>
</li>
<li><p>为了应对崩溃，每个系统调用都包含一个原子写序列。为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写操作累积到一个事务中。因此，一次提交可能涉及多个完整系统调用的写入。为了避免一个系统调用被分裂到不同的事务中，只有在没有文件系统相关的系统调用正在进行时，日志系统才会提交</p>
</li>
<li><p>将几个事务一起提交的方法被称为组提交（group commit）。组提交可以减少磁盘操作的次数，因为它将提交的固定成本分摊在了多个操作上。组提交可以让文件系统同时执行更多的并发写，也可以让磁盘在一次磁盘轮转中把它们全部写入。xv6 的 virtio 驱动不支持这种批处理，但 xv6 的文件系统实现了这种方式</p>
</li>
<li><p>xv6 在磁盘上划出固定的空间来存放日志。在一个事务中，系统调用所写的块总数必须适应这个空间的大小。这将导致两个后果：</p>
<ul>
<li>1、系统调用写入的日志大小必须小于日志空间的大小。这对大多数系统调用来说都不是问题，但有两个系统调用可能会写很多块，<strong>write</strong> 和 <strong>unlink</strong>。大文件的 write 可能会写很多数据块和 bitmap 块，以及一个 inode 块；取消链接一个大文件可能会写很多 bitmap 块和一个 inode。xv6 的 <strong>write</strong> 系统调用将大的写操作分解成多个小的写操作，以适应在日志空间的大小，而 <strong>unlink</strong> 不会引起问题，因为 xv6 文件系统只使用一个位图块</li>
<li>2、日志空间有限的另一个后果是，日志系统只会在确定了系统调用的写操作可以适应剩余日志空间之后，才会开始执行该系统调用</li>
</ul>
</li>
</ul>
<h2 id="Code-logging"><a href="#Code-logging" class="headerlink" title="Code: logging"></a>Code: logging</h2><ul>
<li>系统调用中一般用法如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">...</span><br><span class="line">bp = bread(...);</span><br><span class="line">bp-&gt;data[...] = ...;</span><br><span class="line">log_write(bp);</span><br><span class="line">...</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>begin_op</strong> (kernel&#x2F;log.c:126) 会一直等到日志系统没有 commiting，并且有足够的日志空间来容纳这次调用的写。<strong>log.outstanding</strong> 统计当前系统调用的数量，可以通过 <strong>log.outstanding</strong> 乘以 <strong>MAXOPBLOCKS</strong> 来计算已使用的日志空间。自增 <strong>log.outstanding</strong> 既能预留空间，又能防止该系统调用期间进行提交。该代码假设每次系统调用最多写入 <strong>MAXOPBLOCKS</strong> 个块</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple logging that allows concurrent FS system calls. 简单的日志系统，允许并发的文件系统调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A log transaction contains the updates of multiple FS system </span></span><br><span class="line"><span class="comment">// calls. The logging system only commits when there are</span></span><br><span class="line"><span class="comment">// no FS system calls active. Thus there is never</span></span><br><span class="line"><span class="comment">// any reasoning required about whether a commit might</span></span><br><span class="line"><span class="comment">// write an uncommitted system call&#x27;s updates to disk.</span></span><br><span class="line"><span class="comment">// 一个日志事务包含多个文件系统（FS）系统调用的更新</span></span><br><span class="line"><span class="comment">// 日志系统只在没有活跃的FS系统调用时提交</span></span><br><span class="line"><span class="comment">// 因此，永远不需要考虑一个提交操作是否可能会将未提交的系统调用的更新写入磁盘</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A system call should call begin_op()/end_op() to mark</span></span><br><span class="line"><span class="comment">// its start and end. Usually begin_op() just increments</span></span><br><span class="line"><span class="comment">// the count of in-progress FS system calls and returns.</span></span><br><span class="line"><span class="comment">// But if it thinks the log is close to running out, it</span></span><br><span class="line"><span class="comment">// sleeps until the last outstanding end_op() commits.</span></span><br><span class="line"><span class="comment">// 一个系统调用应该通过调用begin_op()/end_op()来标记其开始和结束</span></span><br><span class="line"><span class="comment">// 通常，begin_op()只是增加正在进行的FS系统调用的计数并返回</span></span><br><span class="line"><span class="comment">// 但是，如果它认为日志即将用尽，它会等待直到最后一个未完成的end_op()提交</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The log is a physical re-do log containing disk blocks. 日志是一个物理重做日志，包含磁盘块</span></span><br><span class="line"><span class="comment">// The on-disk log format: 磁盘上的日志格式</span></span><br><span class="line"><span class="comment">//   header block, containing block #s for block A, B, C, ... 头部块，包含块A、B、C等的块号</span></span><br><span class="line"><span class="comment">//   block A 块A</span></span><br><span class="line"><span class="comment">//   block B 块B</span></span><br><span class="line"><span class="comment">//   block C 块C</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">// Log appends are synchronous. 日志追加是同步的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Contents of the header block, used for both the on-disk header block</span></span><br><span class="line"><span class="comment">// and to keep track in memory of logged block# before commit.</span></span><br><span class="line"><span class="comment">// 头部块的内容，既用于磁盘上的头部块，也用于在内存中跟踪提交前记录的块号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> start;	<span class="comment">// 日志块开始的块号</span></span><br><span class="line">  <span class="type">int</span> size;		<span class="comment">// 日志块数量</span></span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// how many FS sys calls are executing. 有多少文件系统（FS）系统调用正在执行</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// in commit(), please wait. 在提交（commit）过程中，请稍候</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXOPBLOCKS  10  <span class="comment">// max # of blocks any FS op writes</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// called at the start of each FS system call. 在每个文件系统（FS）系统调用开始时被调用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">begin_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;</span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">// this op might exhaust log space; wait for commit. 这个操作可能会耗尽日志空间；等待提交</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>log_write</strong> (kernel&#x2F;log.c:214) 是 <strong>bwrite</strong> 的代理。它将扇区号记录在内存中，在磁盘上的日志中使用一个槽，并自增 <strong>buffer.refcnt</strong> 防止该 <strong>buffer</strong> 被重用。在提交之前，块必须留在缓存中，即该缓存的副本是修改的唯一记录；在提交之后才能将其写入磁盘上的位置；该次修改必须对其他读可见。 注意，当一个块在一个事务中被多次写入时，他们在日志中的槽是相同的。这种优化通常被称为 <strong>absorption</strong> (吸收)。例如，在一个事务中，包含多个文件的多个 inode 的磁盘块被写多次，这是常见的情况。通过将几次磁盘写 <strong>吸收</strong> 为一次，文件系统可以节省日志空间，并且可以获得更好的性能，因为只有一份磁盘块的副本必须写入磁盘</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOGSIZE (MAXOPBLOCKS*3) <span class="comment">// max data blocks in on-disk log</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller has modified b-&gt;data and is done with the buffer. </span></span><br><span class="line"><span class="comment">// 调用者已经修改了b-&gt;data，并且完成了对缓冲区的操作</span></span><br><span class="line"><span class="comment">// Record the block number and pin in the cache by increasing refcnt. </span></span><br><span class="line"><span class="comment">// 通过增加refcnt（引用计数）来在缓存中记录块号和固定（锁定）该块</span></span><br><span class="line"><span class="comment">// commit()/write_log() will do the disk write. commit()/write_log()将会执行磁盘写入操作</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// log_write() replaces bwrite(); a typical use is: log_write()替换了bwrite(); 一个典型的使用场景是</span></span><br><span class="line"><span class="comment">//   bp = bread(...)</span></span><br><span class="line"><span class="comment">//   modify bp-&gt;data[]</span></span><br><span class="line"><span class="comment">//   log_write(bp)</span></span><br><span class="line"><span class="comment">//   brelse(bp)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">log_write</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorption 日志吸收</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno; <span class="comment">// 如果没有匹配项，此时i==log.ln.n，记录一个新块号</span></span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log? 增加一个新的块到日志</span></span><br><span class="line">    bpin(b);</span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>end_op</strong> (kernel&#x2F;log.c:146) 首先递减 <strong>log.outstanding</strong>。如果计数为零，则通过调用 <strong>commit()</strong> 来提交当前事务</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the end of each FS system call. 在每个文件系统（FS）系统调用的末尾被调用</span></span><br><span class="line"><span class="comment">// commits if this was the last outstanding operation. 如果这是最后一个挂起的操作，则提交更改</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// begin_op() may be waiting for log space, begin_op() 可能正在等待日志空间</span></span><br><span class="line">    <span class="comment">// and decrementing log.outstanding has decreased </span></span><br><span class="line">    <span class="comment">// 并且减少 log.outstanding 的值已经降低了预留空间的数量</span></span><br><span class="line">    <span class="comment">// the amount of reserved space.</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    <span class="comment">// call commit w/o holding locks, since not allowed </span></span><br><span class="line">    <span class="comment">// 调用提交操作时不持有锁，因为不允许在持有锁的情况下进入睡眠状态</span></span><br><span class="line">    <span class="comment">// to sleep with locks.</span></span><br><span class="line">    commit();</span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log 将缓存中修改过的数据块写入日志</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit 将头部信息写入磁盘——实际提交</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations 现在，将写入操作安装到原始位置</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log 从日志中擦除事务信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy modified blocks from cache to log.  将缓存中修改过的数据块复制到日志中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block 读日志块到缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block （这个修改块已经在缓存中了）</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">    brelse(from);</span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked. 将b的内容写入磁盘，必须持有锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write in-memory log header to disk. 将内存中的日志头部信息写入磁盘</span></span><br><span class="line"><span class="comment">// This is the true point at which the 这是当前事务真正提交的时刻</span></span><br><span class="line"><span class="comment">// current transaction commits.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data); <span class="comment">// 所以第一个日志块的addr部分是日志头</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf); <span class="comment">// 只有完全更新了buf后才会write到磁盘，所以不会出现log.lh.n更新了，但log.lh.block[i]没有更新</span></span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy committed blocks from log to their home location </span></span><br><span class="line"><span class="comment">// 将已提交的数据块从日志复制到它们的主位置（或原始位置）</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">install_trans</span><span class="params">(<span class="type">int</span> recovering)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// read log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// read dst</span></span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="comment">// copy block to dst</span></span><br><span class="line">    bwrite(dbuf);  <span class="comment">// write dst to disk</span></span><br><span class="line">    <span class="keyword">if</span>(recovering == <span class="number">0</span>)</span><br><span class="line">      bunpin(dbuf);</span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bunpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Commit</strong> 分为四个阶段：</p>
<ul>
<li>1、<strong>write_log()</strong> (kernel&#x2F;log.c:178) 将事务中修改的每个块从 buffer 缓存中复制到磁盘上的日志槽中</li>
<li>2、 <strong>write_head()</strong> (kernel&#x2F;log.c:102) 将 header 块写到磁盘上，就表明已提交，为提交点，写完日志后的崩溃，会导致在重启后重新执行日志</li>
<li>3、<strong>install_trans</strong> (kernel&#x2F;log.c:69) 从日志中读取每个块，并将其写到文件系统中对应的位置</li>
<li>4、最后修改日志块计数为 0，并写入日志空间的 header 部分。这必须在下一个事务开始之前修改，这样崩溃就不会导致重启后的恢复使用这次的 header 和下次的日志块</li>
</ul>
</li>
<li><p><strong>recover_from_log</strong> (kernel&#x2F;log.c:116) 是在 <strong>initlog</strong> (kernel&#x2F;log.c:55) 中调用的，而 <strong>initlog</strong> 是在第一个用户进程运行 (kernel&#x2F;proc.c:539) 之前, 由 <strong>fsinit</strong>(kernel&#x2F;fs.c:42) 调用的。它读取日志头，如果日志头显示日志中包含一个已提交的事务，则会像 <strong>end_op</strong> 那样执行日志</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ROOTDEV 1 	<span class="comment">// device number of file system root disk</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A fork child&#x27;s very first scheduling by scheduler() </span></span><br><span class="line"><span class="comment">// 当调度器（scheduler）首次调度一个由fork创建的子进程时，它将切换到forkret函数执行</span></span><br><span class="line"><span class="comment">// will swtch to forkret.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Still holding p-&gt;lock from scheduler.</span></span><br><span class="line">  release(&amp;myproc()-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    <span class="comment">// File system initialization must be run in the context of a</span></span><br><span class="line">    <span class="comment">// regular process (e.g., because it calls sleep), and thus cannot</span></span><br><span class="line">    <span class="comment">// be run from main().</span></span><br><span class="line">    <span class="comment">// 文件系统的初始化必须在常规进程的上下文中运行(例如,因为它调用了sleep函数),因此不能从main()函数中直接运行</span></span><br><span class="line">    <span class="comment">// 由于文件系统的初始化可能涉及到一些需要等待或延迟,这些操作不能在程序的主入口点（即main()函数）中直接执行</span></span><br><span class="line">    <span class="comment">// 因为main()函数通常期望立即返回，以允许程序继续执行其他任务或结束</span></span><br><span class="line">    fsinit(ROOTDEV);</span><br><span class="line"></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ensure other cores(核心) see first=0.</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init fs</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fsinit</span><span class="params">(<span class="type">int</span> dev)</span> &#123;</span><br><span class="line">  readsb(dev, &amp;sb); <span class="comment">// sb is superblock</span></span><br><span class="line">  <span class="keyword">if</span>(sb.magic != FSMAGIC)</span><br><span class="line">    panic(<span class="string">&quot;invalid file system&quot;</span>);</span><br><span class="line">  initlog(dev, &amp;sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the super block.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">readsb</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  bp = bread(dev, <span class="number">1</span>);	<span class="comment">// 磁盘的第一个块</span></span><br><span class="line">  memmove(sb, bp-&gt;data, <span class="keyword">sizeof</span>(*sb)); <span class="comment">// 磁盘第一个块的addr部分就是superblock</span></span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlog</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> logheader) &gt;= BSIZE)</span><br><span class="line">    panic(<span class="string">&quot;initlog: too big logheader&quot;</span>);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;<span class="built_in">log</span>.lock, <span class="string">&quot;log&quot;</span>);</span><br><span class="line">  <span class="built_in">log</span>.start = sb-&gt;logstart;</span><br><span class="line">  <span class="built_in">log</span>.size = sb-&gt;nlog; <span class="comment">// sb-&gt;nlog是日志块的数量</span></span><br><span class="line">  <span class="built_in">log</span>.dev = dev;</span><br><span class="line">  recover_from_log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  read_head();</span><br><span class="line">  install_trans(<span class="number">1</span>); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  write_head(); <span class="comment">// clear the log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the log header from disk into the in-memory log header</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">read_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">lh</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">log</span>.lh.n = lh-&gt;n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="built_in">log</span>.lh.block[i] = lh-&gt;block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>一个使用了日志的例子是 filewrite (kernel&#x2F;file.c:135)。这个事务看起来像这样：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">ilock(f-&gt;ip);</span><br><span class="line">r = writei(f-&gt;ip, ...);</span><br><span class="line">iunlock(f-&gt;ip);</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段代码被包裹在一个循环中，它将大的写分解成每次只有几个扇区的单独事务，以避免溢出日志空间。调用 <strong>writei</strong> 写入许多块作为这个事务的一部分：文件的 inode，一个或多个 bitmap 块，以及一些数据块</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write to file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">ret = pipewrite(f-&gt;pipe, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line"><span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">ret = devsw[f-&gt;major].write(<span class="number">1</span>, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line"><span class="comment">// write a few blocks at a time to avoid exceeding </span></span><br><span class="line"><span class="comment">// 一次写入几个块以避免超过日志事务的最大大小，这包括i节点、间接块、分配块,以及对于非对齐写入的2个额外块</span></span><br><span class="line"><span class="comment">// the maximum log transaction size, including</span></span><br><span class="line"><span class="comment">// i-node, indirect block, allocation blocks,</span></span><br><span class="line"><span class="comment">// and 2 blocks of slop for non-aligned writes.</span></span><br><span class="line"><span class="comment">// this really belongs lower down, since writei() </span></span><br><span class="line"><span class="comment">// 这实际上应该放在更低层，因为writei()可能正在写入像控制台这样的设备</span></span><br><span class="line"><span class="comment">// might be writing a device like the console.</span></span><br><span class="line"><span class="comment">// -1-1-2代表可能写的块inode-间接块-bitmap-?(也有可能是因为(10-3)/2=3.5,额外-1取整),/2是给logblock预留空间</span></span><br><span class="line"><span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE; </span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line"><span class="type">int</span> n1 = n - i;</span><br><span class="line"><span class="keyword">if</span>(n1 &gt; max) <span class="comment">// 每次最多写入max字节</span></span><br><span class="line">  n1 = max;</span><br><span class="line"></span><br><span class="line">begin_op();</span><br><span class="line">ilock(f-&gt;ip);</span><br><span class="line"><span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">  f-&gt;off += r;</span><br><span class="line">iunlock(f-&gt;ip);</span><br><span class="line">end_op();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r != n1)&#123;</span><br><span class="line">  <span class="comment">// error from writei</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">i += r;</span><br><span class="line">&#125;</span><br><span class="line">ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">panic(<span class="string">&quot;filewrite&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Code-Block-allocator"><a href="#Code-Block-allocator" class="headerlink" title="Code: Block allocator"></a>Code: Block allocator</h2><ul>
<li><p>文件和目录存储在磁盘块中，必须从空闲池中分配，xv6 的块分配器在磁盘上维护一个 bitmap，每个块对应一个位。0 表示对应的块是空闲的，1 表示正在使用中。程序 mkfs 设置引导扇区、超级块、日志块、inode 块和位图块对应的位。</p>
</li>
<li><p>块分配器提供了两个函数：<strong>balloc</strong> 申请一个新的磁盘块，<strong>bfree</strong> 释放一个块</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 1024  <span class="comment">// block size</span></span></span><br><span class="line"><span class="comment">// Bitmap bits per block</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPB           (BSIZE*8)</span></span><br><span class="line"><span class="comment">// Block of free map containing bit for block b 包含数据块b的比特的空闲映射块</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BBLOCK(b, sb) ((b)/BPB + sb.bmapstart)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a zeroed disk block. 分配一个已清零的磁盘块</span></span><br><span class="line"><span class="comment">// returns 0 if out of disk space. 如果磁盘空间不足，则返回0</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">balloc</span><span class="params">(uint dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> b, bi, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">bp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(b = <span class="number">0</span>; b &lt; sb.size; b += BPB)&#123;</span><br><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line"><span class="keyword">for</span>(bi = <span class="number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123; <span class="comment">// 一个bitmap块可以确定8*1024个块是否空闲</span></span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>); <span class="comment">// 确定到位</span></span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)&#123;  <span class="comment">// Is block free? 确定到字节</span></span><br><span class="line">    bp-&gt;data[bi/<span class="number">8</span>] |= m;  <span class="comment">// Mark block in use.</span></span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">  bzero(dev, b + bi);</span><br><span class="line">  <span class="keyword">return</span> b + bi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">brelse(bp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;balloc: out of blocks\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>balloc</strong> (kernel&#x2F;fs.c:71) 会有一个循环遍历每一个块，从块 0 开始，直到 <strong>sb.size</strong>，即文件系统中的块数</li>
<li>它寻找一个位为 0 的空闲块。如果 <strong>balloc</strong> 找到了这样一个块，它就会更新 bitmap 并返回该块</li>
<li>为了提高效率，这个循环被分成两部分。外循环读取 bitmap 的一个块，内循环检查块中的所有 BPB 位。如果两个进程同时试图分配一个块，可能会发生竞争，但 buffer 缓存只允许块同时被一个进程访问，这就避免了这种情况的发生</li>
</ul>
</li>
<li><p><strong>bfree</strong> (kernel&#x2F;fs.c:90) 找到相应的 bitmap 块并清除相应的位。<strong>bread</strong> 和 <strong>brelse</strong> 暗含的独占性避免了显式锁定</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a disk block. 释放一个磁盘块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"><span class="type">int</span> bi, m;</span><br><span class="line"></span><br><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">bi = b % BPB;	</span><br><span class="line">m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">log_write(bp);</span><br><span class="line">brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>与本章其余部分描述的大部分代码一样，<strong>balloc</strong> 和 <strong>bfree</strong> 必须在事务中被调用</p>
</li>
</ul>
<h2 id="Inode-layer"><a href="#Inode-layer" class="headerlink" title="Inode layer"></a>Inode layer</h2><ul>
<li><p>术语 inode 有两种相关的含义。1、指的是磁盘上的数据结构，其中包含了文件的大小和数据块号的列表；2、指的是内存中的 inode，它包含了磁盘上 inode 的副本以及内核中需要的其他信息</p>
</li>
<li><p>磁盘上的 inode 被放置在磁盘的一个连续区域。每一个 inode 的大小都是一样的，所以，给定一个数字 n，很容易找到磁盘上的第 n 个 inode。事实上，这个数字 n，被称为 inode 号或 i-number，在实现中就是通过这个识别 inode 的</p>
</li>
<li><p>结构体 <strong>dinode</strong>(kernel&#x2F;fs.h:32) 定义了磁盘上的 inode</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line"><span class="type">short</span> type;           <span class="comment">// File type 文件类型</span></span><br><span class="line"><span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only) 主设备号（仅对T_DEVICE类型有效）</span></span><br><span class="line"><span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only) 次设备号（仅对T_DEVICE类型有效）</span></span><br><span class="line"><span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system 在文件系统中链接到此inode的链接数</span></span><br><span class="line">uint size;            <span class="comment">// Size of file (bytes) 文件大小（字节）</span></span><br><span class="line">uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses 数据块地址数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>type</strong> 字段区分了文件、目录和特殊文件（设备）。type 为 0 表示该 inode 是空闲的</li>
<li><strong>nlink</strong> 字段统计引用这个 inode 的目录项的数量，当引用数为 0 时就释放磁盘上的 inode 及其数据块</li>
<li><strong>size</strong> 字段记录了文件中内容的字节数</li>
<li><strong>addrs</strong> 数组记录了持有文件内容的磁盘块的块号</li>
</ul>
</li>
<li><p>内核将在使用的 inode 保存在内存中；结构体 <strong>inode</strong> (kernel&#x2F;file.h:17) 是磁盘 <strong>dinode</strong> 的拷贝。内核只在有指针指向 inode 才会储存</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in-memory copy of an inode 内存中inode的复制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">uint dev;           <span class="comment">// Device number 设备号</span></span><br><span class="line">uint inum;          <span class="comment">// Inode number indoe号</span></span><br><span class="line"><span class="type">int</span> ref;            <span class="comment">// Reference count  引用计数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here 保护这里以下的所有内容</span></span><br><span class="line"><span class="type">int</span> valid;          <span class="comment">// inode has been read from disk? indoe已经从磁盘中读出了吗</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> type;         <span class="comment">// copy of disk inode 磁盘inode的复制</span></span><br><span class="line"><span class="type">short</span> major;</span><br><span class="line"><span class="type">short</span> minor;</span><br><span class="line"><span class="type">short</span> nlink;</span><br><span class="line">uint size;</span><br><span class="line">uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>ref</strong> 字段为指向 inode 的指针的数量，如果引用数量减少到零，内核就会从内存中丢弃这个 inode</li>
<li><strong>iget</strong> 和 <strong>iput</strong> 函数引用和释放 inode，并修改引用计数。指向 inode 的指针可以来自文件描述符，当前工作目录，以及短暂的内核代码，如 <strong>exec</strong></li>
</ul>
</li>
<li><p>在 xv6 的 inode 代码中，有四种锁或类似锁的机制</p>
<ul>
<li><strong>icache.lock</strong> 保证了一个 inode 在缓存只有一个副本，以及缓存 inode 的 <strong>ref</strong> 字段计数正确</li>
<li>每个内存中的 inode 都有一个包含 sleep-lock 的锁字段，它保证了可以独占访问 inode 的其他字段（如文件长度）以及 inode 的文件或目录内容块的。一个 inode 的 <strong>ref</strong> 如果大于 0，则会使系统将该 inode 保留在缓存中，而不会重用该 inode</li>
<li>最后，每个 inode 都包含一个 <strong>nlink</strong> 字段 (在磁盘上，缓存时会复制到内存中)，该字段统计链接该 inode 的目录项的数量；如果一个 inode 的链接数大于零，xv6 不会释放它</li>
</ul>
</li>
<li><p><strong>iget()</strong> 返回的 <strong>inode</strong> 指针在调用 iput() 之前都是有效的；inode 不会被删除，指针所引用的内存也不会被另一个 inode 重新使用</p>
<ul>
<li><strong>iget()</strong> 提供了对 inode 的非独占性访问，因此可以有许多指针指向同一个 inode</li>
<li>文件系统代码中的许多部分都依赖于 <strong>iget()</strong> 的这种行为，既是为了保持对 inode 的长期引用 (如打开的文件和当前目录)，也是为了防止竞争，同时避免在操作多个 inode 的代码中出现死锁 (如路径名查找)</li>
</ul>
</li>
<li><p>inode 缓存只缓存被指针指向的 inode。它的主要工作其实是同步多个进程的访问，缓存是次要的。如果一个 inode 被频繁使用，如果不被 inode 缓存保存，buffer 缓存可能会把它保存在内存中。inode 缓存是 <strong>write-through</strong> 的，这意味着缓存的 inode 被修改，就必须立即用 <strong>iupdate</strong> 把它写入磁盘</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">inode</span>[<span class="title">NINODE</span>];</span></span><br><span class="line">&#125; itable;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Code-Inodes"><a href="#Code-Inodes" class="headerlink" title="Code: Inodes"></a>Code: Inodes</h2><ul>
<li><p>要创建一个新的 inode (例如，当创建一个文件时)，xv6 会调用 **ialloc **(kernel&#x2F;fs.c:196)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inodes per block. 一个块多少个indoe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPB           (BSIZE / sizeof(struct dinode))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Block containing inode i 包含inode i的块（i/IPB 确定inode i 位于块偏移量)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate an inode on device dev. 在设备 dev 上分配一个inode</span></span><br><span class="line"><span class="comment">// Mark it as allocated by  giving it type type. 通过赋予它类型 type 来标记为已分配</span></span><br><span class="line"><span class="comment">// Returns an unlocked but allocated and referenced inode, 返回一个未加锁但已分配且被引用的inode</span></span><br><span class="line"><span class="comment">// or NULL if there is no free inode. 如果没有空闲的inode，则返回NULL</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">ialloc</span><span class="params">(uint dev, <span class="type">short</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> inum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line"> bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line"> dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB; <span class="comment">// 确定inodes块中inum inode的位置</span></span><br><span class="line"> <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// a free inode</span></span><br><span class="line">   <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));</span><br><span class="line">   dip-&gt;type = type;</span><br><span class="line">   log_write(bp);   <span class="comment">// mark it allocated on the disk 在磁盘上标记它为已分配</span></span><br><span class="line">   brelse(bp);</span><br><span class="line">   <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line"> &#125;</span><br><span class="line"> brelse(bp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ialloc: no inodes\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>ialloc</strong> 类似于 <strong>balloc</strong>：它遍历磁盘上的  inode ，寻找一个被标记为空闲的 inode</li>
<li>当它找到后，它会修改该 inode 的 <strong>type</strong> 字段来使用它，最后调用 <strong>iget</strong> (kernel&#x2F;fs.c:210) 来从 inode 缓存中返回一个条目</li>
<li>由于一次只能有一个进程持有对 <strong>bp:ialloc</strong> 的引用，所以可以确保其他进程不会同时看到 inode 是可用的并使用它</li>
</ul>
</li>
<li><p><strong>Iget</strong> (kernel&#x2F;fs.c:243) 在 inode 缓存中寻找一个带有所需设备号和 inode 号码的 active 条目 (ip-&gt;ref &gt; 0)。如果它找到了，它就返回一个新的对该 inode 的引用 (kernel&#x2F;fs.c:252-256)。当 <strong>iget</strong> 扫描时，它会记录第一个空槽的位置 (kernel&#x2F;fs.c:257- 258)，当它需要分配一个缓存条目时，它会使用这个空槽</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the inode with number inum on device dev </span></span><br><span class="line"><span class="comment">// 在设备dev上找到编号为inum的inode，并返回其内存中的副本</span></span><br><span class="line"><span class="comment">// and return the in-memory copy. Does not lock 此操作不会锁定inode，也不会从磁盘读取它</span></span><br><span class="line"><span class="comment">// the inode and does not read it from disk.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">iget</span><span class="params">(uint dev, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is the inode already in the table?</span></span><br><span class="line">empty = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ip = &amp;itable.inode[<span class="number">0</span>]; ip &lt; &amp;itable.inode[NINODE]; ip++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">   ip-&gt;ref++;</span><br><span class="line">   release(&amp;itable.lock);</span><br><span class="line">   <span class="keyword">return</span> ip;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// Remember empty slot.</span></span><br><span class="line">   empty = ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recycle an inode entry. 回收一个inode条目</span></span><br><span class="line"><span class="keyword">if</span>(empty == <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;iget: no inodes&quot;</span>);</span><br><span class="line"></span><br><span class="line">ip = empty;</span><br><span class="line">ip-&gt;dev = dev;</span><br><span class="line">ip-&gt;inum = inum;</span><br><span class="line">ip-&gt;ref = <span class="number">1</span>;</span><br><span class="line">ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">release(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>在读写 inode 的元数据或内容之前，代码必须使用 <strong>ilock</strong> 锁定它。<strong>Ilock</strong>(kernel&#x2F;fs.c:289) 使用 sleep-lock 来锁定。一旦 <strong>ilock</strong> 锁定了 inode，它就会根据自己的需要从磁盘（更有可能是 buffer 缓存）读取 inode。函数 <strong>iunlock</strong> (kernel&#x2F;fs.c:317) 释放睡眠锁，这会唤醒正在等待该睡眠锁的进程</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock the given inode. 锁定给定的inode</span></span><br><span class="line"><span class="comment">// Reads the inode from disk if necessary. 如果需要，则从磁盘读取inode</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ilock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line"> panic(<span class="string">&quot;ilock&quot;</span>);</span><br><span class="line"></span><br><span class="line">acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line"> bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line"> dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line"> ip-&gt;type = dip-&gt;type;</span><br><span class="line"> ip-&gt;major = dip-&gt;major;</span><br><span class="line"> ip-&gt;minor = dip-&gt;minor;</span><br><span class="line"> ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line"> ip-&gt;size = dip-&gt;size;</span><br><span class="line"> memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line"> brelse(bp);</span><br><span class="line"> ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)</span><br><span class="line">   panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock the given inode. 解锁给定的inode</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iunlock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ip == <span class="number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line"> panic(<span class="string">&quot;iunlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Iput</strong> (kernel&#x2F;fs.c:333) 通过递减引用次数 (kernel&#x2F;fs.c:356) 释放指向 inode 的指针。如果递减后的引用数为 0，inode 缓存就会释放掉该 inode 在 inode 缓存中的槽位，该槽位就可以被其他 inode 使用</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Drop a reference to an in-memory inode. 释放对内存中inode的引用</span></span><br><span class="line"><span class="comment">// If that was the last reference, the inode table entry can </span></span><br><span class="line"><span class="comment">// 如果这是最后一个引用，那么inode表项可以被回收</span></span><br><span class="line"><span class="comment">// be recycled.</span></span><br><span class="line"><span class="comment">// If that was the last reference and the inode has no links </span></span><br><span class="line"><span class="comment">// 如果这是最后一个引用，并且inode没有任何链接指向它，则在磁盘上释放inode（及其内容）</span></span><br><span class="line"><span class="comment">// to it, free the inode (and its content) on disk.</span></span><br><span class="line"><span class="comment">// All calls to iput() must be inside a transaction in  </span></span><br><span class="line"><span class="comment">// 所有对iput()的调用都必须在事务内部进行,以防需要释放inode</span></span><br><span class="line"><span class="comment">// case it has to free the inode.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;ref == <span class="number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line"> <span class="comment">// inode has no links and no other references: truncate and free. </span></span><br><span class="line"> <span class="comment">// inode没有任何链接和其他引用：截断并释放</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// ip-&gt;ref == 1 means no other process can have ip locked, </span></span><br><span class="line"> <span class="comment">// ip-&gt;ref == 1 意味着没有其他进程可以锁定ip</span></span><br><span class="line"> <span class="comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span></span><br><span class="line"> <span class="comment">// 因此这个acquiresleep()调用不会阻塞（或导致死锁）</span></span><br><span class="line"> acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line"> release(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line"> itrunc(ip);</span><br><span class="line"> ip-&gt;type = <span class="number">0</span>;	<span class="comment">// 配合iupdate将磁盘上的inode标记为空闲</span></span><br><span class="line"> iupdate(ip);</span><br><span class="line"> ip-&gt;valid = <span class="number">0</span>;	<span class="comment">// 表示inode缓存空闲</span></span><br><span class="line"></span><br><span class="line"> releasesleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line"> acquire(&amp;itable.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ip-&gt;ref--;</span><br><span class="line">release(&amp;itable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果 <strong>iput</strong> 发现没有指针指向该 inode，并且没有任何目录项链接该 inode（不在任何目录中出现），那么该 inode 和它的数据块必须被释放。<strong>Iput</strong> 调用 <strong>itrunc</strong> 将文件截断为零字节，释放数据块；将 inode 类型设置为 0（未分配）；并将 inode 写入磁盘（kernel&#x2F;fs.c:338）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents). 截断inode（丢弃内容）</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">uint *a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">   bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">   ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line"> bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line"> a = (uint*)bp-&gt;data;</span><br><span class="line"> <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(a[j])</span><br><span class="line">     bfree(ip-&gt;dev, a[j]);</span><br><span class="line"> &#125;</span><br><span class="line"> brelse(bp);</span><br><span class="line"> bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line"> ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">iupdate(ip);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free a disk block. 释放一个磁盘块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"><span class="type">int</span> bi, m;</span><br><span class="line"></span><br><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">bi = b % BPB;	</span><br><span class="line">m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">log_write(bp);</span><br><span class="line">brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>iput</strong> 在释放 inode 的锁定协议是值得我们仔细研究</p>
<ul>
<li><p>一个危险是，一个并发线程可能会在 <strong>ilock</strong> 中等待使用这个 inode (例如，读取一个文件或列出一个目录)，但它没有意识到该 inode 可能被释放掉了。这种情况是不会发生，因为该 inode 的没有被目录项链接且 <strong>ip-&gt;ref</strong> 为 1，那么系统调用是没有这个指针的（如果有，<strong>ip-&gt;ref</strong> 应该为 2）。这一个引用是调用 iput 的线程所拥有的。的确，<strong>iput</strong> 会在其 <strong>icache.lock</strong> 锁定的临界区之外检查引用数是否为 1，但此时已知链接数为 0，所以没有线程会尝试获取新的引用</p>
</li>
<li><p>另一个主要的危险是，并发调用 <strong>ialloc</strong> 可能会使 <strong>iput</strong> 返回一个正在被释放的 inode。这种情况发生在 <strong>iupdate</strong> 写磁盘时 <strong>ip-&gt;type&#x3D;0</strong>。这种竞争是正常的，分配 inode 的线程会等待获取 inode 的睡眠锁，然后再读取或写入 inode，但此时 <strong>iput</strong> 就结束了（意思是：ialloc 可能返回一个正在释放磁盘块的 inode，但如果想要读写该 inode，就需要调用 ilock 获取 sleep-lock，但 ilock 此时正在被 iput 获取，ilock 获得锁后 iput 就结束了）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a modified in-memory inode to disk. 将修改后的内存中的inode复制到磁盘上</span></span><br><span class="line"><span class="comment">// Must be called after every change to an ip-&gt;xxx field </span></span><br><span class="line"><span class="comment">// 在对存储在磁盘上的ip-&gt;xxx字段进行任何更改后，必须调用此函数</span></span><br><span class="line"><span class="comment">// that lives on disk. </span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iupdate</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">dip-&gt;type = ip-&gt;type;</span><br><span class="line">dip-&gt;major = ip-&gt;major;</span><br><span class="line">dip-&gt;minor = ip-&gt;minor;</span><br><span class="line">dip-&gt;nlink = ip-&gt;nlink;</span><br><span class="line">dip-&gt;size = ip-&gt;size;</span><br><span class="line">memmove(dip-&gt;addrs, ip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">log_write(bp);</span><br><span class="line">brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p><strong>iput()</strong> 会写磁盘。这意味着任何使用文件系统的系统调用都会写磁盘，因为系统调用可能是最后一个对文件有引用的调用。甚至像 read() 这样看似只读的调用，最终也可能会调用 iput()。这又意味着，即使是只读的系统调用，如果使用了文件系统，也必须用事务来包装</p>
</li>
<li><p>崩溃发生在 <strong>iput()</strong> 中是相当棘手的。当文件的链接数降到零时，<strong>iput()</strong> 不会立即截断一个文件，因为一些进程可能仍然在内存中持有对 inode 的引用：一个进程可能仍然在对文件进行读写，因为它成功地打开了 inode。但是，如果崩溃发生在该文件的最后一个文件描述符释放时，那么该文件将被标记为已在磁盘上分配，但没有目录项指向它</p>
</li>
<li><p>文件系统处理这种情况的方法有两种。简单的解决方法是，是在重启后的恢复时，文件系统会扫描整个文件系统，寻找那些被标记为已分配的文件，但没有指向它们的目录项。如果有这样的文件存在，那么就可以释放这些文件</p>
</li>
<li><p>第二种解决方案不需要扫描文件系统。在这个解决方案中，文件系统在磁盘上（例如，在 <strong>superblock</strong> 中）记录链接数为 0 但引用数不为 0 的文件的 inode 的 inumber。如果文件系统在其引用计数达到 0 时删除该文件 。当文件的引用数为 0 时，文件系统会删除该文件，同时它更新磁盘上的列表，从列表（记录链接数为 0 但引用数不为 0 的 inode）中删除该 inode。恢复时，文件系统会释放列表中的任何文件</p>
</li>
<li><p>xv6 没有实现这两种解决方案，这意味着 inode 可能会在磁盘上被标记分配，即使它们不再使用。这意味着随着时间的推移，xv6 可能会面临磁盘空间耗尽的风险</p>
</li>
</ul>
<h2 id="Code-Inode-content"><a href="#Code-Inode-content" class="headerlink" title="Code: Inode content"></a>Code: Inode content</h2> <img src="/2024/07/09/xv6-book-chapter-8/Figure-8.3-17206131871326.png" class="" title="Figure-8.3">

<ul>
<li><p>磁盘上的 <strong>inode</strong>，即 <strong>dinode</strong> 结构体，包含一个 size 和一个块号数组（见图 8.3）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line"><span class="type">short</span> type;           <span class="comment">// File type 文件类型</span></span><br><span class="line"><span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only) 主设备号（仅对T_DEVICE类型有效）</span></span><br><span class="line"><span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only) 次设备号（仅对T_DEVICE类型有效）</span></span><br><span class="line"><span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system 在文件系统中链接到此inode的链接数</span></span><br><span class="line">uint size;            <span class="comment">// Size of file (bytes) 文件大小（字节）</span></span><br><span class="line">uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses 数据块地址数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>inode</strong> 数据可以在 <strong>dinode</strong> 的 <strong>addrs</strong> 数组中找到。开始的 <strong>NDIRECT</strong> 个数据块列在数组中的前 <strong>NDIRECT</strong> 个条目中，这些块被称为 <strong>直接块</strong>。接下来的 <strong>NINDIRECT</strong> 个数据块并没有列在 <strong>inode</strong> 中，而是列在叫做 <strong>间接块</strong> 的数据块中。<strong>addrs</strong> 数组中的最后一个条目给出了放置间接块的地址。因此，一个文件的前 <strong>12</strong> <strong>kB</strong> ( <strong>NDIRECT x BSIZE</strong>) 字节可以从 <strong>inode</strong> 中列出的块中加载，而接下来的 <strong>256</strong> <strong>kB</strong> ( <strong>NINDIRECT x BSIZE</strong>) 字节只能在查阅间接块后才能取出。对于磁盘这是一种不错的表示方式，但对客户机就有点复杂了</li>
<li>函数 <strong>bmap</strong> 包装了这种表示方式使得高层次的函数，如 <strong>readi</strong> 和 <strong>writei</strong> 可以更好的使用。<strong>Bmap</strong> 返回 inode <strong>ip</strong> 的第 <strong>bn</strong> 个数据块的磁盘块号。如果 <strong>ip</strong> 没有第 <strong>bn</strong> 个的数据块，<strong>bmap</strong> 就会分配一个</li>
</ul>
</li>
<li><p>函数 <strong>bmap</strong> (kernel&#x2F;fs.c:378) 从简单的情况开始：最前面的 <strong>NDIRECT</strong> 个块储存在 inode (kernel&#x2F;fs.c:383-387) 中，接下来的 <strong>NINDIRECT</strong> 个块放置在 <strong>ip-&gt;addrs[NDIRECT]</strong> 指向的的 <strong>间接块</strong> 中。<strong>bmap</strong> 读取间接块 (kernel&#x2F;fs.c:394)，然后从块内的正确的位置读取一个块号 (kernel&#x2F;fs.c:395)。如果块号超过了 <strong>NDIRECT+NINDIRECT</strong>，<strong>bmap</strong> 就会 <strong>panic</strong>；<strong>writei</strong> 会检查并防止这种情况(kernel&#x2F;fs.c:490)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip. 返回inode ip中第n个块的磁盘块地址</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.  如果不存在这样的块，则bmap分配一个新的块</span></span><br><span class="line"><span class="comment">// returns 0 if out of disk space. 如果磁盘空间不足，则返回0</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">uint addr, *a;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line"> <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">   addr = balloc(ip-&gt;dev);</span><br><span class="line">   <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   ip-&gt;addrs[bn] = addr;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line">bn -= NDIRECT;  <span class="comment">// 说明是间接块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line"> <span class="comment">// Load indirect block, allocating if necessary. 加载间接块，如果必要则进行分配</span></span><br><span class="line"> <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)&#123;</span><br><span class="line">   addr = balloc(ip-&gt;dev);</span><br><span class="line">   <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   ip-&gt;addrs[NDIRECT] = addr;</span><br><span class="line"> &#125;</span><br><span class="line"> bp = bread(ip-&gt;dev, addr);</span><br><span class="line"> a = (uint*)bp-&gt;data;</span><br><span class="line"> <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">   addr = balloc(ip-&gt;dev);</span><br><span class="line">   <span class="keyword">if</span>(addr)&#123;</span><br><span class="line">     a[bn] = addr;</span><br><span class="line">     log_write(bp);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> brelse(bp);</span><br><span class="line"> <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>bmap</strong> 根据需要分配块。<strong>ip-&gt;addrs[bn]</strong> 或间接条目为 0 时表示没有块。当 <strong>bmap</strong> 遇到 0 时，它会用新的块号来代替 0 (kernel&#x2F;fs.c:384-385) (kernel&#x2F;fs.c:392-393)</p>
</li>
<li><p><strong>itrunc</strong> 释放文件的块，将 inode 的大小重置为零。<strong>Itrunc</strong> (kernel&#x2F;fs.c:410) 首先释放 <strong>直接块</strong> (kernel&#x2F;fs.c:416-421)，然后释放 <strong>间接块</strong> 中指向的块 (kernel&#x2F;fs.c:426- 429)，最后释放 <strong>间接块</strong> 本身 (kernel&#x2F;fs.c:431-432)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents). 截断inode（丢弃内容）</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">uint *a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">   bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">   ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line"> bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line"> a = (uint*)bp-&gt;data;</span><br><span class="line"> <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(a[j])</span><br><span class="line">     bfree(ip-&gt;dev, a[j]);</span><br><span class="line"> &#125;</span><br><span class="line"> brelse(bp);</span><br><span class="line"> bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line"> ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>bmap 使得 readi 和 writei 可以很容易地获取一个 inode 的数据。Readi (kernel&#x2F;fs.c:456) 首先要确定偏移量和计数没有超过文件末端。从文件超出末尾开始的读会返回一个错误 (kernel&#x2F;fs.c:461-462)，而从文件末尾开始或读取过程中超出末尾的读会不会返回错误，只是返回的字节数会少于请求的字节数 (kernel&#x2F;fs.c:463-464)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read data from inode. 从inode读取数据</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="comment">// If user_dst==1, then dst is a user virtual address; 如果user_dst==1，则dst是一个用户虚拟地址</span></span><br><span class="line"><span class="comment">// otherwise, dst is a kernel address. 否则，dst是一个内核地址</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">readi</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">uint tot, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(off + n &gt; ip-&gt;size)</span><br><span class="line"> n = ip-&gt;size - off;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;</span><br><span class="line"> uint addr = bmap(ip, off/BSIZE); <span class="comment">// off/BSIZE表示第几个块</span></span><br><span class="line"> <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> bp = bread(ip-&gt;dev, addr);</span><br><span class="line"> <span class="comment">// 所以可以知道readi是从文件off偏移开始读取n个字节</span></span><br><span class="line"> m = min(n - tot, BSIZE - off%BSIZE);  <span class="comment">// 如果读取字节数大于一个块，则经过一轮循环后off是块大小的整数倍</span></span><br><span class="line"> <span class="keyword">if</span>(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="number">-1</span>) &#123; <span class="comment">//将磁盘块中的内容读到dst</span></span><br><span class="line">   brelse(bp);</span><br><span class="line">   tot = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> brelse(bp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>主循环会把文件中的每一个块的数据复制到 <strong>dst</strong> 中 (kernel&#x2F;fs.c:466-474)。<strong>writei</strong> (kernel&#x2F;fs.c:483) 与 <strong>readi</strong> 相同，但有三个不同：（1）、从文件末尾开始或越过文件末尾的写入会使文件增长，但不会超过文件的最大长度 (kernel&#x2F;fs.c:490-491)；（2）、循环将数据复制到缓冲区而不是 <strong>out</strong> (kernel&#x2F;fs.c:36)；（3）、如果写使文件增长了，<strong>writi</strong> 必须更新它的大小 (kernel&#x2F;fs.c:504-511)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write data to inode. 向inode写入数据</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="comment">// If user_src==1, then src is a user virtual address; 如果user_src==1，则src是一个用户虚拟地址</span></span><br><span class="line"><span class="comment">// otherwise, src is a kernel address. 否则，src是一个内核地址</span></span><br><span class="line"><span class="comment">// Returns the number of bytes successfully written. 返回成功写入的字节数</span></span><br><span class="line"><span class="comment">// If the return value is less than the requested n, 如果返回值小于请求写入的n个字节</span></span><br><span class="line"><span class="comment">// there was an error of some kind. 则表明发生了某种错误</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">writei</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_src, uint64 src, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">uint tot, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(off + n &gt; MAXFILE*BSIZE)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;</span><br><span class="line"> uint addr = bmap(ip, off/BSIZE);</span><br><span class="line"> <span class="keyword">if</span>(addr == <span class="number">0</span>)	<span class="comment">// 所以在off符合条件的情况下，发送错误的原因为磁盘空间不足</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> bp = bread(ip-&gt;dev, addr);</span><br><span class="line"> m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line"> <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">   brelse(bp);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> log_write(bp);</span><br><span class="line"> brelse(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(off &gt; ip-&gt;size)</span><br><span class="line"> ip-&gt;size = off;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write the i-node back to disk even if the size didn&#x27;t change </span></span><br><span class="line"><span class="comment">// 即使文件大小没有改变，也将i-node（索引节点）写回磁盘</span></span><br><span class="line"><span class="comment">// because the loop above might have called bmap() and added a new </span></span><br><span class="line"><span class="comment">// 因为上面的循环可能已经调用了bmap()并向ip-&gt;addrs[]中添加了一个新的块</span></span><br><span class="line"><span class="comment">// block to ip-&gt;addrs[].</span></span><br><span class="line">iupdate(ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>readi</strong> 和 <strong>writei</strong> 开始都会检查 <strong>ip-&gt;type &#x3D;&#x3D; T_DEV</strong>。这种情况处理的是数据不在文件系统中的特殊设备；我们将在文件描述符层中再讨论这种情况</p>
</li>
<li><p>函数 <strong>stati</strong> (kernel&#x2F;fs.c:442) 将 inode 元数据复制到 <strong>stat</strong> 结构体中，通过 <strong>stat</strong> 系统调用暴露给用户程序</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"><span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">uint ino;    <span class="comment">// Inode number</span></span><br><span class="line"><span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line"><span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy stat information from inode. 从inode复制状态信息</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">stati</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="keyword">struct</span> stat *st)</span></span><br><span class="line">&#123;</span><br><span class="line">st-&gt;dev = ip-&gt;dev;</span><br><span class="line">st-&gt;ino = ip-&gt;inum;</span><br><span class="line">st-&gt;type = ip-&gt;type;</span><br><span class="line">st-&gt;nlink = ip-&gt;nlink;</span><br><span class="line">st-&gt;size = ip-&gt;size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Code-directory-layer"><a href="#Code-directory-layer" class="headerlink" title="Code: directory layer"></a>Code: directory layer</h2><ul>
<li><p>目录的实现机制和文件很类似。它的 <strong>inode</strong> 类型是 <strong>T_DIR</strong>，它的数据是一个目录项的序列。每个条目是一个结构体 <strong>dirent</strong> (kernel&#x2F;fs.h:56)，它包含一个名称和一个 inode 号。名称最多包含 <strong>DIRSIZ</strong> (14) 个字符，较短的名称以 <strong>NULL</strong> (0) 结束。inode 号为 0 的目录项是空闲的</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="comment">// 目录是一个文件,它包含一系列的dirent结构体（确实很特殊，是inode，a含的一系列dirent在addr指向的块中）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">ushort inum;</span><br><span class="line"><span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>函数 <strong>dirlookup</strong> (kernel&#x2F;fs.c:527) 在一个目录中搜索一个带有给定名称的条目</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">namecmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *t)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strncmp</span>(s, t, DIRSIZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look for a directory entry in a directory.  在目录中查找一个目录项</span></span><br><span class="line"><span class="comment">// If found, set *poff to byte offset of entry.  如果找到，将目录项的字节偏移量设置到*poff中</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">dirlookup</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint *poff)</span></span><br><span class="line">&#123;</span><br><span class="line">uint off, inum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dp-&gt;type != T_DIR)</span><br><span class="line"> panic(<span class="string">&quot;dirlookup not DIR&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line"> <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">   panic(<span class="string">&quot;dirlookup read&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line"> <span class="keyword">if</span>(namecmp(name, de.name) == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="comment">// entry matches path element 条目与路径元素匹配</span></span><br><span class="line">   <span class="keyword">if</span>(poff)</span><br><span class="line">     *poff = off;</span><br><span class="line">   inum = de.inum;</span><br><span class="line">   <span class="keyword">return</span> iget(dp-&gt;dev, inum);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>如果找到了，它返回一个指向相应未上锁的 inode 的指针，并将 <strong>poff</strong> 设置为目录中条目的字节偏移量，以便调用者想要编辑它</li>
<li>如果 dirlookup 找到一个对应名称的条目，则更新 *poff，并返回一个通过 iget 获得的未被锁定的 inode。Dirlookup 是 iget 返回未锁定的 inode 的原因</li>
<li>调用者已经锁定了 dp，所以如果查找的是 <strong>“.”</strong> ，当前目录的别名，在返回之前试图锁定 inode，就会试图重新锁定 dp 而死锁。(还有更复杂的死锁情况，涉及到多个进程和 <strong>“..”</strong>，父目录的别名；<strong>“.”</strong> 不是唯一的问题。) 调用者可以先解锁 dp，然后再锁定 ip，保证一次只持有一个锁</li>
</ul>
</li>
<li><p>函数 <strong>dirlink</strong> (kernel&#x2F;fs.c:554) 会在当前目录 dp 中创建一个新的目录项，通过给定的名称和 inode 号</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write a new directory entry (name, inum) into the directory dp. </span></span><br><span class="line"><span class="comment">// 在目录 dp 中写入一个新的目录项（名称，inum）</span></span><br><span class="line"><span class="comment">// Returns 0 on success, -1 on failure (e.g. out of disk blocks).</span></span><br><span class="line"><span class="comment">// 成功时返回0,失败时返回-1 (例如,磁盘块不足)</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dirlink</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> off;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that name is not present. 检查名称是否不存在</span></span><br><span class="line"><span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123; <span class="comment">// 返回非0表示名称存在</span></span><br><span class="line"> iput(ip);	<span class="comment">// 减少ip引用</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look for an empty dirent. 寻找一个空的条目项</span></span><br><span class="line"><span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line"> <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">   panic(<span class="string">&quot;dirlink read&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">de.inum = inum;</span><br><span class="line"><span class="comment">// 如果一直都没有找到dirent，此时off==dp-&gt;size(也就是dp末尾)，那么writei会在末尾创建一个新的dirent</span></span><br><span class="line"><span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de)) </span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>如果名称已经存在，dirlink 将返回一个错误 (kernel&#x2F;fs.c:560- 564)</li>
<li>主循环读取目录项，寻找一个未使用的条目。当它找到一个时，它会提前跳出循环  (kernel&#x2F;fs.c:538-539)，并将 <strong>off</strong> 设置为该可用条目的偏移量。否则，循环结束时，将 <strong>off</strong> 设置为 <strong>dp-&gt;size</strong>。不管是哪种方式，<strong>dirlink</strong> 都会在偏移量 <strong>off</strong> 的位置添加一个新的条目到目录中 (kernel&#x2F;fs.c:574-577)</li>
</ul>
</li>
</ul>
<h2 id="Code-Path-names"><a href="#Code-Path-names" class="headerlink" title="Code: Path names"></a>Code: Path names</h2><ul>
<li><p>查找路径名会对每一个节点调用一次 <strong>dirlookup</strong>。Namei (kernel&#x2F;fs.c:661) 解析路径并返回相应的 inode。函数 <strong>nameiparent</strong> 是 <strong>namei</strong> 的一个变种：它返回相应 inode 的父目录 inode，并将最后一个元素复制到 <strong>name</strong> 中。这两个函数都通过调用 <strong>namex</strong> 来实现</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> name[DIRSIZ];</span><br><span class="line"><span class="keyword">return</span> namex(path, <span class="number">0</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> namex(path, <span class="number">1</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Namex</strong> (kernel&#x2F;fs.c:626) 首先确定路径解析从哪里开始。如果路径以斜线开头，则从根目录开始解析；否则，从当前目录开始解析 (kernel&#x2F;fs.c:630-633)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ROOTINO  1   <span class="comment">// root i-number</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOTDEV 1    <span class="comment">// device number of file system root disk</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look up and return the inode for a path name. 根据路径名查找并返回对应的inode（索引节点）</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final </span></span><br><span class="line"><span class="comment">// 如果parent参数不为0，则返回该路径的父目录的inode，并将路径中的最后一个元素复制到name中</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes. </span></span><br><span class="line"><span class="comment">// 其中name必须有足够的空间来存储DIRSIZ个字节的数据</span></span><br><span class="line"><span class="comment">// Must be called inside a transaction since it calls iput(). </span></span><br><span class="line"><span class="comment">// 因为该函数调用了iput()（释放inode或进行其他与inode相关的清理操作），所以它必须在事务（transaction）的上下文中被调用</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"> ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123; <span class="comment">// 这里应该name已经为path中当前父目录inode需要查找的name了</span></span><br><span class="line"> ilock(ip);</span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">   iunlockput(ip);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">   <span class="comment">// Stop one level early.</span></span><br><span class="line">   iunlock(ip);</span><br><span class="line">   <span class="keyword">return</span> ip;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">   iunlockput(ip);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> iunlockput(ip);</span><br><span class="line"> ip = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nameiparent)&#123; <span class="comment">// 能走到这里说明没有进行一轮循环</span></span><br><span class="line"> iput(ip);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>然后它使用 <strong>skipelem</strong> 来遍历路径中的每个元素 (kernel&#x2F;fs.c:635)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy the next path element from path into name. 从path中复制下一个路径元素到name中</span></span><br><span class="line"><span class="comment">// Return a pointer to the element following the copied one. 返回指向已复制元素之后的元素的指针</span></span><br><span class="line"><span class="comment">// The returned path has no leading slashes, 返回的路径没有前导斜杠</span></span><br><span class="line"><span class="comment">// so the caller can check *path==&#x27;\0&#x27; to see if the name is the last one. </span></span><br><span class="line"><span class="comment">// 因此调用者可以检查*path==&#x27;\0&#x27;来查看name是否是最后一个</span></span><br><span class="line"><span class="comment">// If no name to remove, return 0. 如果没有要移除的名称，则返回0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a/bb/c&quot;, name) = &quot;bb/c&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;///a//bb&quot;, name) = &quot;bb&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a&quot;, name) = &quot;&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;&quot;, name) = skipelem(&quot;////&quot;, name) = 0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>*</span><br><span class="line"><span class="title function_">skipelem</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *s;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"> path++;</span><br><span class="line"><span class="keyword">if</span>(*path == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">s = path;</span><br><span class="line"><span class="keyword">while</span>(*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="number">0</span>) <span class="comment">// 直到path=&#x27;/0&#x27;或path==&#x27;/&#x27;</span></span><br><span class="line"> path++;</span><br><span class="line">len = path - s;</span><br><span class="line"><span class="keyword">if</span>(len &gt;= DIRSIZ)</span><br><span class="line"> memmove(name, s, DIRSIZ);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"> memmove(name, s, len);</span><br><span class="line"> name[len] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"> path++;</span><br><span class="line"><span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>循环的每次迭代都必须在当前 inode <strong>ip</strong> 中查找 <strong>name</strong></p>
</li>
<li><p>迭代的开始是锁定 <strong>ip</strong> 并检查它是否是一个目录。如果不是，查找就会失败 (kernel&#x2F;fs.c:636-640)。(锁定 <strong>ip</strong> 是必要的，不是因为 <strong>ip-&gt;type</strong> 可能会改变，而是因为在 <strong>ilock</strong> 运行之前，不能保证 ip-&gt;type 已经从磁盘载入)</p>
</li>
<li><p>如果调用的是 <strong>nameiparent</strong>，而且这是最后一个路径元素，按照之前 <strong>nameiparent</strong> 的定义，循环应该提前停止，最后一个路径元素已经被复制到 name 中，所以 <strong>namex</strong> 只需要返回解锁的 ip (kernel&#x2F;fs.c:641-645)</p>
</li>
<li><p>最后，循环使用 <strong>dirlookup</strong> 查找路径元素，并通过设置 <strong>ip</strong> &#x3D; <strong>next</strong> 为下一次迭代做准备 (kernel&#x2F;fs.c:646-651)</p>
</li>
<li><p>当循环遍历完路径元素时，它返回 <strong>ip</strong></p>
</li>
</ul>
</li>
<li><p><strong>namex</strong> 可能需要很长的时间来完成：它可能会涉及几个磁盘操作，通过遍历路径名得到的目录的 inode 和目录块（如果它们不在 buffer 缓存中）。xv6 经过精心设计，如果一个内核线程对 <strong>namex</strong> 的调用阻塞在磁盘 I&#x2F;O 上，另一个内核线程查找不同的路径名可以同时进行。<strong>namex</strong> 分别锁定路径中的每个目录，这样不同目录的查找就可以并行进行</p>
</li>
<li><p>这种并发性带来了一些挑战。例如，当一个内核线程在查找一个路径名时，另一个内核线程可能正在取消链接一个目录，这会改变目录数。一个潜在的风险是，可能一个查找线程正在搜索的目录可能已经被另一个内核线程删除了，而它的块已经被另一个目录或文件重用了</p>
</li>
<li><p>xv6 避免了这种竞争。例如，在 <strong>namex</strong> 中执行 <strong>dirlookup</strong> 时，查找线程会持有目录的锁，<strong>dirlookup</strong> 返回一个使用 <strong>iget</strong> 获得的 inode。<strong>iget</strong> 会增加 inode 的引用次数。只有从 <strong>dirlookup</strong> 收到 inode 后，<strong>namex</strong> 才会释放目录上的锁。现在另一个线程可能会从目录中取消链接 inode，但 xv6 还不会删除 inode，因为 inode 的引用数仍然大于零</p>
</li>
<li><p>另一个风险是死锁。例如，当查找 <strong>“. “</strong> 时，next 指向的 inode 与 <strong>ip</strong> 相同。在释放对 <strong>ip</strong> 的锁之前锁定 next 会导致死锁。为了避免这种死锁，<strong>namex</strong> 在获得对 next 的锁之前就会解锁目录。这里我们再次看到为什么 <strong>iget</strong> 和 <strong>ilock</strong> 之间的分离是很重要的（如果 iget 直接返回加锁的 inode 的话，我们根本没有机会释放锁，在获得锁，可能造成死锁）</p>
</li>
</ul>
<h2 id="File-descriptor-layer"><a href="#File-descriptor-layer" class="headerlink" title="File descriptor layer"></a>File descriptor layer</h2><ul>
<li><p>Unix 接口很酷的一点是：Unix 中的大部分资源都是以文件的形式来表示的。包括控制台、管道等设备，当然还有真实的文件。文件描述符层就是实现这种统一性的一层</p>
</li>
<li><p>xv6 给每个进程提供了自己的打开文件表，或者说文件描述符表，就像我们在第一章中看到的那样。每个打开的文件由一个结构体 <strong>file</strong> (kernel&#x2F;file.h:1) 表示，它包装 inode 或管道，也包含一个 I&#x2F;O 偏移量</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line"><span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line"><span class="type">char</span> readable;</span><br><span class="line"><span class="type">char</span> writable;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line"><span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>每次调用 <strong>open</strong> 都会创建一个新的打开文件（一个新的结构体 file），如果多个进程独立打开同一个文件，那么不同的 <strong>file</strong> 实例会有不同的 I&#x2F;O 偏移量</li>
<li>另一方面，一个打开的文件（同一个结构文件）可以在一个进程的文件表中出现多次，也可以在多个进程的文件表中出现。如果一个进程使用 <strong>open</strong> 打开文件，然后使用 <strong>dup</strong> 创建别名，或者使用 <strong>fork</strong> 与子进程共享文件，就会出现这种情况</li>
<li>引用计数可以跟踪特定打开文件的引用数量</li>
<li>一个文件的打开方式可以为读，写，或者读写。通过 <strong>readable</strong> 和 <strong>writable</strong> 来指明</li>
</ul>
</li>
<li><p>系统中所有打开的文件都保存在一个全局文件表中，即 <strong>ftable</strong>。文件表的功能有: 分配文件 (<strong>filealloc</strong>)、创建重复引用 (<strong>fileup</strong>)、释放引用 (<strong>fileclose</strong>)、读写数据 (<strong>fileeread</strong> 和 <strong>filewrite</strong>)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>前三个函数应该比较熟悉了，就不过多的讨论</p>
<ul>
<li><p><strong>Filealloc</strong> (kernel&#x2F;file.c:30) 扫描文件表，寻找一个未引用的文件 (f-&gt;ref &#x3D;&#x3D; 0)，并返回一个新的引用</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filealloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;ftable.lock);</span><br><span class="line"><span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">   f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">   release(&amp;ftable.lock);</span><br><span class="line">   <span class="keyword">return</span> f;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">release(&amp;ftable.lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>fileup</strong> (kernel&#x2F;file.c:48) 增加引用计数</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increment ref count for file f.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filedup</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;ftable.lock);</span><br><span class="line"><span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line"> panic(<span class="string">&quot;filedup&quot;</span>);</span><br><span class="line">f-&gt;ref++;</span><br><span class="line">release(&amp;ftable.lock);</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>fileclose</strong> (kernel&#x2F;file.c:60) 减少引用计数。当一个文件的引用数达到 0 时，<strong>fileclose</strong> 会根据类型释放底层的管道或 inode</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.) </span></span><br><span class="line"><span class="comment">// 关闭文件f（减少引用计数，当计数达到0时关闭文件）</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;ftable.lock);</span><br><span class="line"><span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line"> panic(<span class="string">&quot;fileclose&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> release(&amp;ftable.lock);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ff = *f;</span><br><span class="line">f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">f-&gt;type = FD_NONE;</span><br><span class="line">release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line"> pipeclose(ff.pipe, ff.writable);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line"> begin_op();</span><br><span class="line"> iput(ff.ip);</span><br><span class="line"> end_op();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>函数 <strong>filestat</strong>、<strong>fileread</strong> 和 <strong>filewrite</strong> 实现了对文件的统计、读和写操作</p>
<ul>
<li><p>filestat (kernel&#x2F;file.c:88) 只允许对 inodes 进行操作，并调用 <strong>stati</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.  获取文件f的元数据</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat. </span></span><br><span class="line"><span class="comment">// addr是一个用户虚拟地址，指向一个stat结构体</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line"> ilock(f-&gt;ip);</span><br><span class="line"> stati(f-&gt;ip, &amp;st);</span><br><span class="line"> iunlock(f-&gt;ip);</span><br><span class="line"> <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>fileread</strong> 和 <strong>filewrite</strong> 首先检查打开模式是否允许该操作，然后再调用管道或 inode 的相关实现。如果文件代表一个 inode，<strong>fileread</strong> 和 <strong>filewrite</strong> 使用 I&#x2F;O 偏移量作为本次操作的偏移量，然后前移偏移量（kernel&#x2F;file.c:122- 123）（kernel&#x2F;file.c:153-154）。pipes 没有偏移量的概念</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map major device number to device functions. 将主设备号映射到设备功能</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> &#123;</span></span><br><span class="line"><span class="type">int</span> (*read)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*write)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> <span class="title">devsw</span>[<span class="title">NDEV</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read from file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line"> r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line"> <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line"> ilock(f-&gt;ip);</span><br><span class="line"> <span class="keyword">if</span>((r = readi(f-&gt;ip, <span class="number">1</span>, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">   f-&gt;off += r;</span><br><span class="line"> iunlock(f-&gt;ip);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> panic(<span class="string">&quot;fileread&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write to file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line"> ret = pipewrite(f-&gt;pipe, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line"> <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> ret = devsw[f-&gt;major].write(<span class="number">1</span>, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line"> <span class="comment">// write a few blocks at a time to avoid exceeding </span></span><br><span class="line"> <span class="comment">// 一次写入几个块以避免超过日志事务的最大大小，这包括i节点、间接块、分配块,以及对于非对齐写入的2个额外块</span></span><br><span class="line"> <span class="comment">// the maximum log transaction size, including</span></span><br><span class="line"> <span class="comment">// i-node, indirect block, allocation blocks,</span></span><br><span class="line"> <span class="comment">// and 2 blocks of slop for non-aligned writes.</span></span><br><span class="line"> <span class="comment">// this really belongs lower down, since writei() </span></span><br><span class="line"> <span class="comment">// 这实际上应该放在更低层，因为writei()可能正在写入像控制台这样的设备</span></span><br><span class="line"> <span class="comment">// might be writing a device like the console.</span></span><br><span class="line"> <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">   <span class="type">int</span> n1 = n - i;</span><br><span class="line">   <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">     n1 = max;</span><br><span class="line"></span><br><span class="line">   begin_op();</span><br><span class="line">   ilock(f-&gt;ip);</span><br><span class="line">   <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">     f-&gt;off += r;</span><br><span class="line">   iunlock(f-&gt;ip);</span><br><span class="line">   end_op();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(r != n1)&#123;</span><br><span class="line">     <span class="comment">// error from writei</span></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   i += r;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> panic(<span class="string">&quot;filewrite&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>回想一下 inode 的函数需要调用者处理锁的相关操作（kernel&#x2F;file.c:94-96）（kernel&#x2F;file.c:121-124）（kernel&#x2F;file.c:163-166）。inode 加锁附带了一个不错的作用，那就是读写偏移量是原子式更新的，这样多个进程写一个文件时，自己写的数据就不会被其他进程所覆盖，尽管他们的写入可能最终会交错进行</p>
</li>
</ul>
</li>
</ul>
<h2 id="Code-System-calls"><a href="#Code-System-calls" class="headerlink" title="Code: System calls"></a>Code: System calls</h2><ul>
<li><p>有了更低层提供的函数，大多数系统调用的实现都是比较简单的（kernel&#x2F;sysfile.c）。有几个调用值得仔细研究一下</p>
</li>
<li><p>函数 <strong>sys_link</strong> 和 <strong>sys_unlink</strong> 可以编辑目录，创建或删除对 inodes 的引用。它们是使用事务的另一个很好的例子</p>
<ul>
<li><p><strong>sys_link</strong>  (kernel&#x2F;sysfile.c:120) 首先获取它的参数，两个字符串 <strong>old</strong> 和 <strong>new</strong> (kernel&#x2F;sysfile.c:125) 。假设 <strong>old</strong> 存在并且不是一个目录 (kernel&#x2F;sysfile.c:129-132)，<strong>sys_link</strong> 会递增它的 <strong>ip-&gt;nlink</strong> 计数。然后 <strong>sys_link</strong> 调用 <strong>nameiparent</strong> 找到 new (kernel&#x2F;sysfile.c:145) 的父目录和最终路径元素，并创建一个指向 <strong>old</strong> 的 inode 的新目录项 (kernel&#x2F;sysfile.c:148)。新的父目录必须存在，并且和现有的 inode 在同一个设备上，inode 号只在同一个磁盘上有意义。如果出现这样的错误，<strong>sys_link</strong> 必须返回并减少 <strong>ip-&gt;nlink</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the path new as a link to the same inode as old. 创建一个名为new的路径，该路径作为与old相同的inode的链接</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>, *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argstr(<span class="number">0</span>, old, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, new, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">begin_op();</span><br><span class="line"><span class="keyword">if</span>((ip = namei(old)) == <span class="number">0</span>)&#123;</span><br><span class="line"> end_op();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ilock(ip);</span><br><span class="line"><span class="keyword">if</span>(ip-&gt;type == T_DIR)&#123;</span><br><span class="line"> iunlockput(ip);</span><br><span class="line"> end_op();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ip-&gt;nlink++;</span><br><span class="line">iupdate(ip);</span><br><span class="line">iunlock(ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((dp = nameiparent(new, name)) == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">goto</span> bad;</span><br><span class="line">ilock(dp);</span><br><span class="line"><span class="keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> iunlockput(dp);</span><br><span class="line"> <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line">iunlockput(dp);</span><br><span class="line">iput(ip);</span><br><span class="line"></span><br><span class="line">end_op();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">ilock(ip);</span><br><span class="line">ip-&gt;nlink--;</span><br><span class="line">iupdate(ip);</span><br><span class="line">iunlockput(ip);</span><br><span class="line">end_op();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>事务简化了这个函数的实现，因为它需要更新多个磁盘块，但我们不必担心做这些事情的顺序。它们要么全部成功，要么都不成功。例如，如果没有事务，在创建链接之前更新 <strong>ip-&gt;nlink</strong>，会使文件系统暂时处于不安全的状态，中间的崩溃可能会造成破坏。有了事务，我们就不用担心这个问题了</p>
</li>
<li><p><strong>sys_link</strong> 为一个现有的 inode 创建一个新的名字。而函数 <strong>create</strong> (kernel&#x2F;sysfile.c:242) 为一个新的 inode 创建一个新的名字</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">create</span><span class="params">(<span class="type">char</span> *path, <span class="type">short</span> type, <span class="type">short</span> major, <span class="type">short</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">dp</span>;</span></span><br><span class="line"><span class="type">char</span> name[DIRSIZ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((dp = nameiparent(path, name)) == <span class="number">0</span>) <span class="comment">// 找父目录inode</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ilock(dp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123; <span class="comment">// 是否已经存在</span></span><br><span class="line"> iunlockput(dp);</span><br><span class="line"> ilock(ip);</span><br><span class="line"> <span class="keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE)) <span class="comment">// 是文件或设备</span></span><br><span class="line">   <span class="keyword">return</span> ip;</span><br><span class="line"> iunlockput(ip);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="number">0</span>)&#123; <span class="comment">// 不存在就创建新的inode</span></span><br><span class="line"> iunlockput(dp);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ilock(ip);</span><br><span class="line">ip-&gt;major = major;</span><br><span class="line">ip-&gt;minor = minor;</span><br><span class="line">ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">iupdate(ip);  <span class="comment">// 更新磁盘块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(type == T_DIR)&#123;  <span class="comment">// Create . and .. entries. 如果创建目录，在新的目录inode中创建. ..两个目录项</span></span><br><span class="line"> <span class="comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span></span><br><span class="line"> <span class="keyword">if</span>(dirlink(ip, <span class="string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="number">0</span> || dirlink(ip, <span class="string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>) <span class="comment">// 在父目录inode中创建name目录项</span></span><br><span class="line"> <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(type == T_DIR)&#123;</span><br><span class="line"> <span class="comment">// now that success is guaranteed:</span></span><br><span class="line"> dp-&gt;nlink++;  <span class="comment">// for &quot;..&quot;</span></span><br><span class="line"> iupdate(dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iunlockput(dp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ip;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line"><span class="comment">// something went wrong. de-allocate ip.</span></span><br><span class="line">ip-&gt;nlink = <span class="number">0</span>;</span><br><span class="line">iupdate(ip);</span><br><span class="line">iunlockput(ip);</span><br><span class="line">iunlockput(dp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>它是三个文件创建相关的系统调用的综合：使用 O_CREATE 标志的 open 创建一个新的普通文件，<strong>mkdir</strong> 创建一个新的目录，以及 mkdev 创建一个新的设备文件</li>
<li>和 <strong>sys_link</strong> 一样，<strong>create</strong> 也是通过调用 <strong>nameiparent</strong> 来获取父目录的 inode。然后调用  <strong>dirlookup</strong> 来检查名称是否已经存在 (kernel&#x2F;sysfile.c:252)</li>
<li>如果名称存在，create 的行为取决于它被用于哪个系统调用：<strong>open</strong>，<strong>mkdir</strong>，<strong>mkdev</strong> 的语义不同</li>
<li>如果 <strong>create</strong> 是由 <strong>open</strong> 使用的 (<strong>type &#x3D;&#x3D; T_FILE</strong>)，如果能根据该名字存在且为普通文件，那么打开就会成功，所以 <strong>create</strong> 也会成功 (kernel&#x2F;sysfile.c:256)。否则，就会报错（kernel&#x2F;sysfile.c:257-258）</li>
<li>如果这个名字不存在， <strong>create</strong> 就会用 <strong>ialloc</strong> 分配一个新的 inode (kernel&#x2F;sysfile.c:261)</li>
<li>如果新的 inode 是一个目录，<strong>create</strong> 会在该目录添加条目 “.” 和 “..”</li>
<li>最后，现在数据已经被正确地初始化了，<strong>create</strong> 可以把它链接到父目录中 (kernel&#x2F;sysfile.c:274)。和 <strong>sys_link</strong> 一样，create 同时拥有两个 inode 锁：<strong>ip</strong> 和 <strong>dp</strong>。没有死锁的可能性，因为 inode <strong>ip</strong> 是新分配的：系统中没有其他进程会持有 <strong>ip</strong> 的锁并尝试锁住dp</li>
</ul>
</li>
<li><p>使用 <strong>create</strong>，很容易实现 <strong>sys_open</strong>、<strong>sys_mkdir</strong> 和 <strong>sys_mknod</strong>。<strong>sys_open</strong> (kernel&#x2F;sysfile.c:287) 是其中最复杂的，因为创建一个新文件只是它做的一小部分</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file descriptor for the given file. 为给定的文件分配一个文件描述符</span></span><br><span class="line"><span class="comment">// Takes over file reference from caller on success. 如果成功，则从调用者处接管文件引用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fdalloc</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line">   p-&gt;ofile[fd] = f;</span><br><span class="line">   <span class="keyword">return</span> fd;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> path[MAXPATH];</span><br><span class="line"><span class="type">int</span> fd, omode;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">argint(<span class="number">1</span>, &amp;omode);  <span class="comment">// 取得位模式</span></span><br><span class="line"><span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span>) <span class="comment">// 路径名</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">begin_op();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(omode &amp; O_CREATE)&#123; <span class="comment">// O_CREATE打开就create</span></span><br><span class="line"> ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">   end_op();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123; <span class="comment">// 否则就去找有没有对应的inode</span></span><br><span class="line">   end_op();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ilock(ip); <span class="comment">// namei必须锁定inode</span></span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123; <span class="comment">// 打开的inode是目录的话，在能以只读打开</span></span><br><span class="line">   iunlockput(ip);</span><br><span class="line">   end_op();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123; <span class="comment">// 是设备的话</span></span><br><span class="line"> iunlockput(ip);</span><br><span class="line"> end_op();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123; <span class="comment">// 在文件表，描述符表中分配</span></span><br><span class="line"> <span class="keyword">if</span>(f)</span><br><span class="line">   fileclose(f);</span><br><span class="line"> iunlockput(ip);</span><br><span class="line"> end_op();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class="line"> f-&gt;type = FD_DEVICE;</span><br><span class="line"> f-&gt;major = ip-&gt;major;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> f-&gt;type = FD_INODE;</span><br><span class="line"> f-&gt;off = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">f-&gt;ip = ip;</span><br><span class="line">f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class="line">f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123; <span class="comment">// 清空文件对应磁盘块</span></span><br><span class="line"> itrunc(ip);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iunlock(ip);</span><br><span class="line">end_op();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>如果 <strong>open</strong> 的打开模式包含为 <strong>O_CREATE</strong>，它就会调用 <strong>create</strong> (kernel&#x2F;sysfile.c:301)。否则，它会调用 <strong>namei</strong> (kernel&#x2F;sysfile.c:307)</li>
<li><strong>create</strong> 会返回一个锁定的 inode，但 <strong>namei</strong> 不会，所以 <strong>sys_open</strong> 必须锁定 inode</li>
<li>这比较有一个方便的地方是目录只会以读打开，而不是写</li>
<li>假设 inode 是通过某种方式获得的，sys_open 会分配一个文件和一个文件描述符 (kernel&#x2F;sysfile.c:325)，然后设置 file 相关的字段 (kernel&#x2F;sysfile.c:337- 94 342)。注意，没有其他进程可以访问这个部分初始化的文件，因为它只在当前进程的表中</li>
</ul>
</li>
<li><p>第 7 章在我们还没有文件系统之前就研究了管道的实现。函数 <strong>sys_pipe</strong> 通过提供创建管道对的方法将管道实现与文件系统连接起来。它的参数是一个指针，该指针指向一个长度为 2 的 int 类型数组，它将在这里记录两个新的文件描述符。然后它分配管道并装入文件描述符</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 fdarray; <span class="comment">// user pointer to array of two integers 指向包含两个整数的数组的用户指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">rf</span>, *<span class="title">wf</span>;</span></span><br><span class="line"><span class="type">int</span> fd0, fd1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">argaddr(<span class="number">0</span>, &amp;fdarray);</span><br><span class="line"><span class="keyword">if</span>(pipealloc(&amp;rf, &amp;wf) &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">fd0 = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>((fd0 = fdalloc(rf)) &lt; <span class="number">0</span> || (fd1 = fdalloc(wf)) &lt; <span class="number">0</span>)&#123; <span class="comment">// 分配两个文件描述符</span></span><br><span class="line"> <span class="keyword">if</span>(fd0 &gt;= <span class="number">0</span>)</span><br><span class="line">   p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line"> fileclose(rf);</span><br><span class="line"> fileclose(wf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(copyout(p-&gt;pagetable, fdarray, (<span class="type">char</span>*)&amp;fd0, <span class="keyword">sizeof</span>(fd0)) &lt; <span class="number">0</span> ||</span><br><span class="line">  copyout(p-&gt;pagetable, fdarray+<span class="keyword">sizeof</span>(fd0), (<span class="type">char</span> *)&amp;fd1, <span class="keyword">sizeof</span>(fd1)) &lt; <span class="number">0</span>)&#123; </span><br><span class="line"> p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line"> p-&gt;ofile[fd1] = <span class="number">0</span>;</span><br><span class="line"> fileclose(rf);</span><br><span class="line"> fileclose(wf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="type">char</span> data[PIPESIZE];</span><br><span class="line">uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line"><span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line"><span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipealloc</span><span class="params">(<span class="keyword">struct</span> file **f0, <span class="keyword">struct</span> file **f1)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pi</span>;</span></span><br><span class="line"></span><br><span class="line">pi = <span class="number">0</span>;</span><br><span class="line">*f0 = *f1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((*f0 = filealloc()) == <span class="number">0</span> || (*f1 = filealloc()) == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span>((pi = (<span class="keyword">struct</span> pipe*)kalloc()) == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">goto</span> bad;</span><br><span class="line">pi-&gt;readopen = <span class="number">1</span>;</span><br><span class="line">pi-&gt;writeopen = <span class="number">1</span>;</span><br><span class="line">pi-&gt;nwrite = <span class="number">0</span>;</span><br><span class="line">pi-&gt;nread = <span class="number">0</span>;</span><br><span class="line">initlock(&amp;pi-&gt;lock, <span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">(*f0)-&gt;type = FD_PIPE;</span><br><span class="line">(*f0)-&gt;readable = <span class="number">1</span>;</span><br><span class="line">(*f0)-&gt;writable = <span class="number">0</span>;</span><br><span class="line">(*f0)-&gt;pipe = pi;</span><br><span class="line">(*f1)-&gt;type = FD_PIPE;</span><br><span class="line">(*f1)-&gt;readable = <span class="number">0</span>;</span><br><span class="line">(*f1)-&gt;writable = <span class="number">1</span>;</span><br><span class="line">(*f1)-&gt;pipe = pi;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line"><span class="keyword">if</span>(pi)</span><br><span class="line"> kfree((<span class="type">char</span>*)pi);</span><br><span class="line"><span class="keyword">if</span>(*f0)</span><br><span class="line"> fileclose(*f0);</span><br><span class="line"><span class="keyword">if</span>(*f1)</span><br><span class="line"> fileclose(*f1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><ul>
<li><p>实际操作系统中的 buffer 缓存要比 xv6 的复杂得多，但它有同样的两个目的：缓存和同步访问磁盘。xv6 的 buffer 缓存和 V6 是一样的，使用简单的最近最少使用（LRU）抛弃策略；可以实现许多更复杂的策略，每种策略都对某些情况有好处，而对其它情况没有好处。更高效的 LRU 缓存不使用链表，而使用哈希表进行查找，使用堆进行 LRU 抛弃。现代的 buffer 缓存通常与虚拟内存系统集成在一起，以支持内存映射的文件</p>
</li>
<li><p>xv6 的日志系统效率低下。提交不能与文件系统系统调用同时发生。系统会记录整个块，即使一个块中只有几个字节被改变。它执行同步的日志写入，一次写一个块，每一个块都可能需要整个磁盘旋转时间。真正的日志系统可以解决所有这些问题</p>
</li>
<li><p>日志不是提供崩溃恢复的唯一方法。早期的文件系统在重启期间使用 scavenger（例如 UNIX fsck 程序）来检查每个文件和目录以及块和 inode 空闲列表，寻找并解决不一致的地方。对于大型文件系统来说，清扫可能需要几个小时的时间，而且在某些情况下，这种方式要想获得的数据一致性，其系统调用必须是一致性的。从日志中恢复要快得多，而且在崩溃时，系统调用是原子的</p>
</li>
<li><p>xv6 使用了与早期 UNIX 相同的 inodes 和目录的基本磁盘布局；这个方案多年来仍在使用。BSD 的 UFS&#x2F;FFS 和 Linux 的 ext2&#x2F;ext3 使用基本相同的数据结构。文件系统布局中最低效的部分是目录，在每次查找过程中需要对所有磁盘块进行线性扫描。当目录只有几个磁盘块时，这是合理的，但对于有许多文件的目录来说是昂贵的。微软 Windows 的 NTFS，Mac OS X 的 HFS，以及 Solaris 的 ZFS，将目录实现为磁盘上块的平衡树。这很复杂，但可以保证目录查找的时间复杂度是对数级的</p>
</li>
<li><p>xv6 对磁盘故障的处理很朴素：如果磁盘操作失败，xv6 就会 <strong>panic</strong>。这是否合理取决于硬件：如果一个操作系统位于特殊的硬件之上，这种硬件会使用冗余来掩盖故障，也许操作系统看到故障的频率很低，以至于直接 <strong>panic</strong> 是可以的。另一方面，使用普通磁盘的操作系统应该使用更加优雅的方式来处理异常，这样一个文件中一个块的丢失就不会影响文件系统其他部分的使用</p>
</li>
<li><p>xv6 要求文件系统固定在单一磁盘设备上，而且大小不能改变。随着大型数据库和多媒体文件对存储要求越来越高，操作系统正在开发消除每个文件系统一个磁盘瓶颈的方法。基本的方法是将许多磁盘组合成一个逻辑磁盘。硬件解决方案（如 RAID）仍然是最流行的，但目前的趋势是尽可能地在软件中实现这种逻辑。这些软件实现通常允许丰富的功能，如在运行时通过快速添加或删除磁盘来增长或缩小逻辑设备。当然，一个能够快速增长或收缩的存储层需要一个能够做到同样的文件系统：xv6 使用的固定大小的 inode 块阵列在这样的环境中不能很好地工作。将磁盘管理与文件系统分离可能是最简洁的设计，但由于两者之间复杂的接口，使得有些系统，如 Sun 公司的 ZFS，将两者直接结合起来</p>
</li>
<li><p>xv6 的文件系统缺乏现代文件系统的许多其他功能，例如，它缺乏对快照和增量备份的支持</p>
</li>
<li><p>现代 Unix 系统允许用与磁盘存储相同的系统调用来访问许多种类的资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口，如 &#x2F;proc。与 xv6 在 fileread 和 filewrite 中的 if 语句，这些系统通常给每个打开的文件一个函数指针表，每个代表一个操作，调用函数指针来调用该 inode 的实现调用。网络文件系统和用户级文件系统提供了将这些调用变成网络 RPC 的函数，并在返回前等待响应</p>
</li>
</ul>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li><p>为什么 <strong>balloc</strong> 需要 <strong>panic</strong>？xv6 能恢复吗？</p>
</li>
<li><p>为什么 <strong>ialloc</strong> 需要 <strong>panic</strong>？xv6 能恢复吗？</p>
</li>
<li><p>为什么 <strong>filealloc</strong> 用完文件后不 <strong>panic</strong>？为什么这种情况比较常见，而值得处理？</p>
</li>
<li><p>假设在执行 <strong>sys_link</strong> 时，另一个进程在 <strong>iunlock(ip)</strong> 和 <strong>dirlink</strong> 之间解除链接该 <strong>ip</strong> 对应的文件。链接会被正确创建吗？为什么？</p>
</li>
<li><p><strong>create</strong> 调用了四次函数（一个 <strong>ialloc</strong>，三次 <strong>dirlink</strong>），它需要这些函数成功返回。如果任何一个不成功，<strong>create</strong> 调用就会 <strong>panic</strong>。为什么这可以接受？为什么这四个调用不能有一个失败呢？</p>
</li>
<li><p><strong>sys_chdir</strong> 在 <strong>iput(cp-&gt;cwd)</strong> 之前调用 **iunlock(ip)**，这可能会尝试锁定 <strong>cp-&gt;cwd</strong>，但将 <strong>iunlock(ip)</strong> 推迟到 <strong>iput</strong> 之后不会造成死锁。为什么不会呢？</p>
</li>
<li><p>实现 <strong>lseek</strong> 系统调用。<strong>lseek</strong> 还需要你修改 <strong>filewrite</strong>，如果 <strong>lseek</strong> 设置超过 <strong>f-&gt;ip-&gt;size</strong>，则在文件中用零来填补空缺</p>
</li>
<li><p>给 <strong>open</strong> 增加 O_TRUNC 和 O_APPEND，使 &gt; 和 &gt;&gt; 操作符在 shell 中可以使用</p>
</li>
<li><p>修改文件系统使其支持符号链接</p>
</li>
<li><p>修改文件系统使其支持命名管道</p>
</li>
<li><p>修改文件系统和 VM 使其支持 memory-map 文件（内存映射文件）</p>
</li>
</ol>
<hr>
<ol>
<li><a name="ftn1"></a>扇区号表明该日志块，应该写入的位置。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/07/07/6-S081-Lab7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/07/6-S081-Lab7/" class="post-title-link" itemprop="url">Lab network driver</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-07 17:31:16" itemprop="dateCreated datePublished" datetime="2024-07-07T17:31:16+08:00">2024-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-08 16:54:59" itemprop="dateModified" datetime="2024-07-08T16:54:59+08:00">2024-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>Lab Guidance：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/labs/net.html">Lab: networking (mit.edu)</a></li>
<li>在这个实验中，你将为网络接口卡（NIC）编写 xv6 设备驱动程序</li>
<li>在开始前，复习 xv6 book 的第 5 章：“中断和设备驱动程序” 可能是对你有帮助的</li>
<li>在主 xv6 目录中键入：<code>git fetch &amp;&amp; git checkout net &amp;&amp; make clean</code> 获取实验的 xv6 源码</li>
</ul>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><ul>
<li>你将使用名为 E1000 的网络设备来处理网络通信<ul>
<li>对于 xv6（以及你编写的驱动程序），E1000 看起来像一个连接到真实以太局域网的真实硬件。事实上，与你的驱动程序交谈的 E1000 是 qemu 提供的模拟，连接到同样由 qemu 模拟的局域网</li>
<li>在这个模拟的局域网上，xv6 的 IP 地址为 10.0.2.15，qemu 还安排运行 qemu 的计算机出现在 IP 地址为 10.0.2.2 的局域网上。当 xv6 使用 E1000 将数据包发送到 10.0.2.2 时，qemu 将数据包发送到 运行 qemu 的真实计算机上的相关应用程序</li>
</ul>
</li>
<li>你将要使用 qemu 的 “用户模式网络堆栈”，我们已经更新了 Makefile，以启用 qemu 的用户模式网络堆栈和 E1000 网卡<ul>
<li>Makefile 将 qemu 配置为将所有传入和传出的数据包记录到实验目录中的 <code>packets.pcap</code> 文件中，查看这些记录以确认 xv6 正在传输和接收你期望的数据包可能会有所帮助</li>
<li>要显示记录的数据包请输入：<code>tcpdump -XXnr packets.pcap</code></li>
</ul>
</li>
<li>我们已经将一些文件添加到实验的 xv6 目录中<ul>
<li><code>kernel/e1000.c</code> 包含 E1000 的初始化代码以及传输和接收数据包的空功能，你将填写这些功能</li>
<li><code>kernel/e1000_dev.h</code> 包含 E1000 定义的寄存器和标志位</li>
<li><code>kernel/net.c</code> 和 <code>kernel/net.h</code> 包含一个简单的网络堆栈，可以实现 IP、UDP、ARP 协议。还包含用于保存数据包的数据结构，称为 <code>mbuf</code></li>
<li><code>kernel/pci.c</code> 包含在 xv6 启动时在 PCI 总线上搜索 E1000 的代码</li>
</ul>
</li>
</ul>
<h1 id="Your-job"><a href="#Your-job" class="headerlink" title="Your job"></a>Your job</h1><ul>
<li>你的工作是在 <code>kernel/e1000.c</code> 中完成 <code>e1000_transmit()</code> 和 <code>e1000_recv()</code>，以便驱动程序可以传输和接收数据包</li>
<li>当 <code>make grade</code> 说你通过了所有测试时表示完成</li>
<li>在编写代码时，参考 Intel E1000 软件开发人员手册：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/readings/8254x_GBe_SDM.pdf">8254x Family of Gigabit Ethernet Controllers Software Developer’s Manual (mit.edu)</a> 可能是有帮助的</li>
</ul>
<h1 id="e1000-init"><a href="#e1000-init" class="headerlink" title="e1000_init"></a>e1000_init</h1><ul>
<li><p>在 <code>e1000.c</code> 中为你提供的 <code>e1000_init()</code> 将 E1000 配置为读取从 RAM 传输的数据包，并将接收的数据包写入 RAM</p>
<ul>
<li>这种技术被称为 DMA，用户直接内存访问，指的是 E1000 硬件直接向&#x2F;从 RAM 写入&#x2F;读取数据包</li>
</ul>
</li>
<li><p>由于数据包的突发到达速度可能比驱动程序处理它们的速度块，<code>e1000_init()</code> 为 E1000 提供了多个缓冲区，E1000 可以将数据包写入其中</p>
<ul>
<li>E1000 要求这些缓冲区有 RAM 中的 “描述符” 数组来描述。每个 “描述符” 在 RAM 中包含一个地址，E1000 可以在其中写入接收到的数据包。<code>struct rx_desc</code> 描述了 “描述符” 的格式</li>
<li>这样的 “描述符” 数组称为接收环或接收队列。这是一个圆形的环，当网卡或驱动程序到达末尾时，它会返回到开头</li>
<li><code>e1000_init()</code> 使用 <code>mbufalloc()</code> 分配 mbuf 数据包缓冲区分配给 E1000 用于 DMA（直接内存访问）</li>
</ul>
</li>
<li><p>还有一个传输环，驱动程序应该将它希望 E1000 发送的数据包放入其中</p>
<ul>
<li><code>e1000_init()</code> 将两个环的大小配置为 <code>RX_RING_SIZE</code> 和 <code>TX_RING_SIZE</code></li>
</ul>
</li>
<li><p>除了在 RAM 中读取和写入 “描述符” 环外，你的驱动程序还需要通过其内存映射控制寄存器与 E1000 进行交互，以检测什么时候接收的数据包是可用的，去通知 E1000，驱动程序已经用要发送的数据包填充了一些传输 “描述符”</p>
<ul>
<li>全局变量 <code>regs</code> 持有指向 E1000 第一个控制寄存器的指针。你的驱动程序可用通过将 <code>regs</code> 索引为数组来获取其他寄存器</li>
<li>你需要特别使用 <code>E1000_RDT</code> 和 <code>E1000_TDT</code></li>
</ul>
</li>
<li><p>经过上述描述后，我们不难发现：</p>
<ul>
<li><p>传输 &#x2F; 接收数据包时都有相应的 “描述符” 数组，称为传输环 &#x2F; 接收环，也就是代码中的 <code>tx_ring</code> 和 <code>rx_ring</code></p>
</li>
<li><p>传输环 &#x2F; 接收 “描述符” 的类型分别是 <code>tx_desc</code> 和 <code>rx_desc</code>，在 <code>kernel/e1000_dev.h</code> 中定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [E1000 3.3.3]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  uint64 addr;</span><br><span class="line">  uint16 length;</span><br><span class="line">  uint8 cso;</span><br><span class="line">  uint8 cmd;</span><br><span class="line">  uint8 status;</span><br><span class="line">  uint8 css;</span><br><span class="line">  uint16 special;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述符格式 [E1000 3.2.3]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  uint64 addr;       <span class="comment">/* Address of the descriptor&#x27;s data buffer 描述符数据缓冲区的地址 */</span></span><br><span class="line">  uint16 length;     <span class="comment">/* Length of data DMAed into data buffer 数据缓冲区中通过DMA传输的数据长度 */</span></span><br><span class="line">  uint16 csum;       <span class="comment">/* Packet checksum 数据包校验和 */</span></span><br><span class="line">  uint8 status;      <span class="comment">/* Descriptor status 描述符状态*/</span></span><br><span class="line">  uint8 errors;      <span class="comment">/* Descriptor Errors 描述符错误 */</span></span><br><span class="line">  uint16 special;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传输环 &#x2F; 接收环也都有关联的数据包缓冲区数组，也就是代码中的 <code>tx_mbufs</code> 和 <code>rx_mbufs</code></p>
</li>
<li><p>数据包缓冲区的类型为 <code>mbuf</code>，在 <code>kernel/net.h</code> 中定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>  *<span class="title">next</span>;</span> <span class="comment">// the next mbuf in the chain 链表中下一个mbuf</span></span><br><span class="line">  <span class="type">char</span>         *head; <span class="comment">// the current start position of the buffer 缓冲区的当前起始位置</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> len;   <span class="comment">// the length of the buffer 缓冲区长度</span></span><br><span class="line">  <span class="type">char</span>         buf[MBUF_SIZE]; <span class="comment">// the backing store 缓冲区</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>e1000_init()</code> 接收 E1000 寄存器映射的内存地址，初始化 <code>regs</code>，通过数组索引的方式读取 E1000 相关寄存器中的值</p>
</li>
<li><p>我们主要关注 <code>e1000_init()</code> 中初始化传输&#x2F;接收 ”描述符“ 数组，以及关联的数据包缓冲区数组的相关操作</p>
</li>
<li><p>发送数据包时，驱动程序将需要传输的 mbuf 关联到 <code>tx_ring</code> 的某个位置 ，等待 E1000 完成传输。<code>tx_mbufs</code> 的作用是保存指向需要传输的 mbuf 的指针，当传输完成时释放 mbufs。所以 <code>tx_mbufs</code> 没有 <code>mbufalloc</code> 且和 <code>tx_ring</code> 没有建立关联，在传输过程中才逐渐建立联系</p>
</li>
<li><p>初始化传输时，涉及的 E1000 寄存器定义如下（定义在 <code>kernel/e1000_dev.h</code> 中）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_TDBAL    (0x03800/4)  <span class="comment">/* TX Descriptor Base Address Low TX描述符基地址 - RW */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_TDLEN    (0x03808/4)  <span class="comment">/* TX Descriptor Length TX 描述符长度 - RW */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_TDH      (0x03810/4)  <span class="comment">/* TX Descriptor Head TX 描述符头部 - RW */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_TDT      (0x03818/4)  <span class="comment">/* TX Descripotr Tail TX 描述符尾部 - RW */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Transmit Descriptor status definitions 发送描述符状态定义 [E1000 3.3.3.2] */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_TXD_STAT_DD    0x00000001 <span class="comment">/* Descriptor Done 描述符完成 */</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接收数据包时，驱动程序（其实是中断处理程序调用的）直接将数据包 DMA 到与 <code>rx_ring</code> 相关联的缓冲区 <code>rx_mbufs</code> 的某个位置。<code>rx_mbufs</code> 的作用是接收数据包。所以 <code>rx_mbufs</code> 需要 <code>mbufalloc</code> 且和 <code>rx_ring</code> 关联</p>
</li>
<li><p>初始化接收时，涉及的 E1000 寄存器定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define <span class="title function_">E1000_RADV</span>     <span class="params">(<span class="number">0x0282C</span>/<span class="number">4</span>)</span>  <span class="comment">/* RX Interrupt Absolute Delay Timer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_RDH      (0x02810/4)  <span class="comment">/* RX Descriptor Head - RW */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_RDT      (0x02818/4)  <span class="comment">/* RX Descriptor Tail - RW */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_RDLEN    (0x02808/4)  <span class="comment">/* RX Descriptor Length - RW */</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>e1000_init()</code> 的部分实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TX_RING_SIZE 16</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> <span class="title">tx_ring</span>[<span class="title">TX_RING_SIZE</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(16)));</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">tx_mbufs</span>[<span class="title">TX_RING_SIZE</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_RING_SIZE 16</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> <span class="title">rx_ring</span>[<span class="title">RX_RING_SIZE</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(16)));</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">rx_mbufs</span>[<span class="title">RX_RING_SIZE</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// remember where the e1000&#x27;s registers live. 记住e1000寄存器的位置</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> uint32 *regs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// called by pci_init(). 被 pci_init() 调用</span></span><br><span class="line"><span class="comment">// xregs is the memory address at which the </span></span><br><span class="line"><span class="comment">// e1000&#x27;s registers are mapped.</span></span><br><span class="line"><span class="comment">// xregs 是 e1000 寄存器的映射所在的内存地址</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_init</span><span class="params">(uint32 *xregs)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  initlock(&amp;e1000_lock, <span class="string">&quot;e1000&quot;</span>);</span><br><span class="line"></span><br><span class="line">  regs = xregs;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// [E1000 14.5] Transmit initialization 传输初始化</span></span><br><span class="line">  <span class="built_in">memset</span>(tx_ring, <span class="number">0</span>, <span class="keyword">sizeof</span>(tx_ring));</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TX_RING_SIZE; i++) &#123;</span><br><span class="line">    tx_ring[i].status = E1000_TXD_STAT_DD;</span><br><span class="line">    tx_mbufs[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  regs[E1000_TDBAL] = (uint64) tx_ring; </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">sizeof</span>(tx_ring) % <span class="number">128</span> != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;e1000&quot;</span>);</span><br><span class="line">  regs[E1000_TDLEN] = <span class="keyword">sizeof</span>(tx_ring);</span><br><span class="line">  regs[E1000_TDH] = regs[E1000_TDT] = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// [E1000 14.4] Receive initialization 接收初始化</span></span><br><span class="line">  <span class="built_in">memset</span>(rx_ring, <span class="number">0</span>, <span class="keyword">sizeof</span>(rx_ring));</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RX_RING_SIZE; i++) &#123;</span><br><span class="line">    rx_mbufs[i] = mbufalloc(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rx_mbufs[i])</span><br><span class="line">      panic(<span class="string">&quot;e1000&quot;</span>);</span><br><span class="line">    rx_ring[i].addr = (uint64) rx_mbufs[i]-&gt;head;</span><br><span class="line">  &#125;</span><br><span class="line">  regs[E1000_RDBAL] = (uint64) rx_ring;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">sizeof</span>(rx_ring) % <span class="number">128</span> != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;e1000&quot;</span>);</span><br><span class="line">  regs[E1000_RDH] = <span class="number">0</span>;</span><br><span class="line">  regs[E1000_RDT] = RX_RING_SIZE - <span class="number">1</span>;</span><br><span class="line">  regs[E1000_RDLEN] = <span class="keyword">sizeof</span>(rx_ring);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="e1000-transmit"><a href="#e1000-transmit" class="headerlink" title="e1000_transmit"></a>e1000_transmit</h1><ul>
<li><p>当 net.c 中的网络堆栈需要发送数据包时，它会通过保存要发送数据包的 mbuf 调用 <code>e1000_transmit()</code></p>
<ul>
<li>你的传输代码必须将指向数据包指针放在传输环的 ”描述符“ 中。<code>struct tx_desc</code> 描述了 ”描述符“ 的格式</li>
<li>你需要保证每个 mbuf 最终被释放，但只有在 E1000  完成数据包传输后（E1000 在描述符中设置 <code>E1000_TXD_STAT_DD</code> 位来指示这一点）</li>
</ul>
</li>
<li><p>一些提示</p>
<ul>
<li>首先，通过读取 <code>E1000_TDT</code> 控制寄存器，向 E1000 询问它期望的下一个数据包的 <code>tx_ring</code> 的索引</li>
<li>检查 <code>tx_ring</code> 是否溢出。如果 <code>E1000_TDT</code> 索引的 ”描述符“ 中没有设置 <code>E1000_TXD_STAT_DD</code>，则 E1000 尚未完成先前的传输请求，返回错误</li>
<li>使用 <code>mbuffree()</code> 释放从该 “描述符” 传输的 mbuf（如果有的话）</li>
<li>填写 ”描述符“。<code>m-&gt;head</code> 指向内存中数据包内容，<code>m-&gt;len</code> 是数据包长度。设置必要的 cmd 标志。存放一个指向 mbuf 的指针，以便稍后释放</li>
<li>最后，通过向 <code>E1000_TDT</code> modulo（<code>%</code>）<code>TX_RING_SIZE</code> 加一来更新环的位置</li>
<li>如果 <code>e1000_transmit()</code> 成功将 mbuf 添加到环中，返回 0。失败时，返回 -1，以便调用者知道释放 mbuf</li>
</ul>
</li>
<li><p>经过上述描述，我们不难了解到：</p>
<ul>
<li><p>网络堆栈需要发送数据包时，总是将需要传输的 mbuf 关联到相关 “描述符” ，等待 E1000 完成传输。<code>tx_mbufs</code> 的作用是保存指向需要传输的 mbuf 的指针，当传输完成时释放 mbufs</p>
</li>
<li><p><code>E1000_TDT</code> 寄存器存储着我们期望的使用的 <code>tx_ring</code> 索引，然而索引到的 <code>tx_desc</code> ”描述符“ 并非总是有效的</p>
</li>
<li><p>提示中提醒我们需要检查是否溢出，然而即使 <code>tx_ring</code> 是一个环形数组，我们也不需要（不能）通过 <code>(index+1)%TX_RING_SIZE == regs[E1000_TDH]</code> 来检查是否溢出。这种检查方式默认环形数组预留一个空位用于检查是否满了，但我们并不了解环形数组真正完整的工作流程，我们通过以下方式检查是否 “溢出”</p>
</li>
<li><p>当 “描述符” 的 <code>status</code> 没有被设置为 <code>E1000_TXD_STAT_DD</code> 时，表示当前 “描述符” 的 <code>addr</code> 指向的缓冲区还没有传输完，也就表示 “溢出” 了</p>
</li>
<li><p><code>mbuffree()</code> 释放 “描述符” 传输的 mbuf 时，并不是释放 “描述符” 的 <code>addr</code> 指向的缓冲区位置，而是在上一次（或某一次）预留在 <code>tx_mbufs</code> 中的指针指向的 mbuf。如果查看 <code>kernel/net.h</code> 和 <code>kernel/net.c</code> 中的 <code>mbufalloc()</code>，我们发现 <code>m-&gt;head</code> 指向的只是 mbuf 中 <code>buf</code> 的某个位置，而 <code>mbuffree()</code> 需要指向 mbuf 的指针以释放整个 mbuf</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>  *<span class="title">next</span>;</span> <span class="comment">// the next mbuf in the chain 链表中下一个mbuf</span></span><br><span class="line">  <span class="type">char</span>         *head; <span class="comment">// the current start position of the buffer 缓冲区的当前起始位置</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> len;   <span class="comment">// the length of the buffer 缓冲区长度</span></span><br><span class="line">  <span class="type">char</span>         buf[MBUF_SIZE]; <span class="comment">// the backing store 缓冲区</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocates a packet buffer.</span></span><br><span class="line"><span class="keyword">struct</span> mbuf *</span><br><span class="line"><span class="title function_">mbufalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> headroom)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (headroom &gt; MBUF_SIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  m = kalloc();</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  m-&gt;next = <span class="number">0</span>;</span><br><span class="line">  m-&gt;head = (<span class="type">char</span> *)m-&gt;buf + headroom;</span><br><span class="line">  m-&gt;len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(m-&gt;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(m-&gt;buf));</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置必要的 cmd 标志时，如果查看 <code>kernel/e1000_dev.h</code>，我们发现官方只提供了两个 cmd 标志的定义，所以我们不难推测这两个标志就是必要的 cmd 标志。当然所有 cmd 标志的含义都可以在 Intel E1000 开发人员手册的 3.3.3.1 节中找到详细描述，有兴趣的同学可以自行查阅</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Transmit Descriptor command definitions 传输描述符命令定义 [E1000 3.3.3.1] */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_TXD_CMD_EOP    0x01 <span class="comment">/* End of Packet */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_TXD_CMD_RS     0x08 <span class="comment">/* Report Status */</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>tx_mbufs</code> 的相应索引处保存 mbuf 以便下一次释放，和通过 <code>mbuffree()</code> 释放之前 “描述符” 传输的 mbuf 形成了对应</p>
</li>
<li><p>当然，由于 xv6 可能在多个进程中并发的使用 E1000，<code>tx_ring</code> 和 <code>tx_mbufs</code> 都是临界资源，对于它们的访问都需要加锁</p>
</li>
</ul>
</li>
<li><p>解决方案如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// mbuf 包含了一个以太网帧；将其编程到 TX 描述符环中，以便 e1000 网络接口卡可以发送它</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into </span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">// 存储一个指针，以便在发送后释放该 mbuf</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="type">int</span> index = regs[E1000_TDT];</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> ((tx_ring[index].status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (tx_mbufs[index] != <span class="number">0</span>) &#123;</span><br><span class="line">    mbuffree(tx_mbufs[index]);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  tx_ring[index].addr = (uint64)m-&gt;head;</span><br><span class="line">  tx_ring[index].length = m-&gt;len;</span><br><span class="line">  tx_ring[index].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line">  tx_mbufs[index] = m;</span><br><span class="line">    </span><br><span class="line">  regs[E1000_TDT] = (index+<span class="number">1</span>)%TX_RING_SIZE;</span><br><span class="line">    </span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="e1000-recv"><a href="#e1000-recv" class="headerlink" title="e1000_recv"></a>e1000_recv</h1><ul>
<li><p>当 E1000 从以太网接收每个数据包时，它将数据包 DMAs 到下一个接收环 “描述符” 中 <code>addr</code> 指向的内存</p>
<ul>
<li>如果 E1000 中断尚未挂起，则 E1000 要求 PLIC 在启用中断后立即交付一个中断</li>
<li>你的 <code>e1000_recv()</code> 代码必须扫描接收环，并通过调用 <code>net_rx()</code> 将每个新数据包的 mbuf 发送到网络堆栈</li>
<li>然后你需要分配一个新的 mbuf 并将其放入 “描述符” 中，这样当 E1000 再次到达接收环的该点时，它会找到一个新的缓冲区，用于 DMA 一个新的数据包</li>
</ul>
</li>
<li><p>一些提示</p>
<ul>
<li>首先，通过获取 <code>E1000_RDT</code> 控制寄存器并加一 modulo（<code>%</code>）<code>RX_RING_SIZE</code>，向 E1000 询问下一个等待接收数据包的环索引</li>
<li>通过检测 “描述符” 的 <code>status</code> 部分的 <code>E1000_RXD_STAT_DD</code> 位来检查新数据包是否可用用。如果不可用，就停下来</li>
<li>将 mbuf 的 <code>m-&gt;len</code> 更新为 “描述符” 中报告的长度。使用 <code>net_rx()</code> 将 mbuf 传递到网络堆栈</li>
<li>使用 <code>mbufalloc()</code> 分配一个新的 mbuf 来替换刚刚 <code>net_rx()</code> 的 mbuf</li>
<li>将其数据指针（<code>m-&gt;head</code>）编程到 “描述符” 中，将 “描述符” 的状态位清零</li>
<li>最终，将 <code>E1000_RDT</code> 寄存器更新位最后一个处理的环 “描述符” 的索引</li>
<li><code>e1000_init()</code> 用 mbufs 初始化接收环，你可用看看它是如何做到这一点的，也许可用借用代码</li>
<li>在某些时候，达到的数据包总数将超过环形大小（16），确保你的代码可用处理这一点</li>
</ul>
</li>
<li><p>经过上述描述，我们可以了解到：</p>
<ul>
<li><p>E1000 从以太网接收数据包时，总是直接将数据包 DMA 到与 “描述符” 相关联的缓冲区 <code>rx_mbufs</code> 中，然后产生一个中断，在中断处理程序中调用 <code>e1000_recv()</code>，通过 <code>net_rx()</code> 将缓冲区中的数据包发送到网络堆栈。<code>rx_mbufs</code> 的作用是接收数据包</p>
</li>
<li><p><code>E1000_RDT</code> 寄存器存储的是我们之前最后处理的数据包的环索引，+1 后才是下一个等待接收的数据包环索引</p>
</li>
<li><p>为了处理达到的数据包总数可能超过环形大小（16）的情况，我们使用循环，在每次循环中处理一个可用的数据包并重新分配一个新的 mbuf，不会积压到 <code>rx_mbufs</code></p>
</li>
<li><p>退出循环时将 <code>E1000_RDT</code> 设置为最后处理的 “描述符” 索引，和最开始的 +1 相呼应</p>
</li>
<li><p>为什么不加锁：因为 <code>e1000_recv()</code> 只会被中断处理程序 <code>e1000_intr()</code> 调用，即使在多核处理器的情况下，同一个中断处理程序也仅在一个核心上运行，且不会并发运行，所以不需要加锁（加锁后会产生死锁，这是因为调用 <code>e1000_transmit()</code> 在传输数据包时可能被中断，从而调用 <code>e1000_recv()</code>，<code>e1000_transmit()</code> 是持有锁的，如果 <code>e1000_recv()</code> 也需要这把锁，就会造成死锁）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_intr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// tell the e1000 we&#x27;ve seen this interrupt; 通知 e1000 我们已经看到了这个中断</span></span><br><span class="line">  <span class="comment">// without this the e1000 won&#x27;t raise any 如果不这样做，e1000 将不会触发任何未来的中断</span></span><br><span class="line">  <span class="comment">// further interrupts.</span></span><br><span class="line">  regs[E1000_ICR] = <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line">  e1000_recv();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>解决方案如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000 检查从 e1000 接收到的数据包</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()). </span></span><br><span class="line">  <span class="comment">// 为每个数据包创建并传递一个 mbuf（使用 net_rx() 函数）</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">int</span> index = (regs[E1000_RDT]+<span class="number">1</span>)%RX_RING_SIZE;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((rx_ring[index].status &amp; E1000_RXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    rx_mbufs[index]-&gt;len = rx_ring[index].length;</span><br><span class="line">    net_rx(rx_mbufs[index]);</span><br><span class="line">      </span><br><span class="line">    rx_mbufs[index] = mbufalloc(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rx_mbufs[index])</span><br><span class="line">      panic(<span class="string">&quot;e1000&quot;</span>);</span><br><span class="line">    rx_ring[index].addr = (uint64)rx_mbufs[index]-&gt;head;</span><br><span class="line">    rx_ring[index].status = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    index = (index+<span class="number">1</span>)%RX_RING_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  regs[E1000_RDT] = (index<span class="number">-1</span>)%RX_RING_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li>一个窗口中 <strong>make server</strong></li>
</ul>
<img src="/2024/07/07/6-S081-Lab7/image-20240708164415800.png" class="" title="image-20240708164415800">

<ul>
<li>一个窗口中 <strong>make clean &amp;&amp; make qemu &amp;&amp; nettests</strong></li>
</ul>
<img src="/2024/07/07/6-S081-Lab7/image-20240708164538219.png" class="" title="image-20240708164538219">

<ul>
<li><strong>tcpdump -XXnr packets.pcap</strong></li>
</ul>
<img src="/2024/07/07/6-S081-Lab7/image-20240708164935515.png" class="" title="image-20240708164935515">

<ul>
<li><strong>make grade</strong></li>
</ul>
<img src="/2024/07/07/6-S081-Lab7/image-20240708164630676.png" class="" title="image-20240708164630676">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/121437373">MIT 6.S081] Lab 11: networking_c版本的e1000网卡实现-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16277647.html">MIT6.S081-Lab7 Lab Networking 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/07/01/6-S081-Lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/01/6-S081-Lab6/" class="post-title-link" itemprop="url">Lab Multithreading</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-01 17:29:10" itemprop="dateCreated datePublished" datetime="2024-07-01T17:29:10+08:00">2024-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-03 17:12:06" itemprop="dateModified" datetime="2024-07-03T17:12:06+08:00">2024-07-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>Lab Guidance：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/labs/thread.html">Lab: Multithreading (mit.edu)</a></p>
</li>
<li><p>这个实验让你熟悉多线程，你将在用户级线程包中实现线程之间的切换，使用多个线程来加快程序速度，并实现 barrier</p>
</li>
<li><p>你应该确保你已经阅读了 xv6 book 的第 7 章：<code>&quot;Scheduling&quot;</code>，并研究了相关代码（<code>kernel/proc.c</code>，<code>kernel/swtch.S</code>）</p>
</li>
<li><p>在开始前，请键入：<code>git stash &amp;&amp; git fetch &amp;&amp; git checkout thread &amp;&amp; make clean</code></p>
</li>
</ul>
<h1 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h1><ul>
<li><p>在本次任务中，你将为用户级线程系统设计上下文切换机制，然后实现它</p>
</li>
<li><p>你的 xv6 中有两个文件 <code>user/uthread.c</code> 和 <code>user/uthread_switch.S</code>，以及 Makefile 中构建 uthread 程序的规则</p>
</li>
<li><p><code>user/uthread.c</code> 中包含大部分用户及线程包和三个简单测试线程的代码，线程包缺少一些创建线程和在线程之间切换的代码</p>
</li>
<li><p>你的工作是想出一个方法来创建线程，保存&#x2F;恢复寄存器，以便在线程之间切换。当你完成后，你可以通过 <code>uthread</code> 进行测试</p>
</li>
<li><p>一些提示</p>
<ul>
<li>你需要将代码添加到 <code>user/uthread.c</code> 中的 <code>thread_create()</code> 和 <code>thread_schedule()</code>，以及 <code>user/thread_switch.S</code> 中的 <code>thread_switch()</code></li>
<li><code>thread_schedule()</code> 调度一个线程后，这个线程在自己的线程栈上执行传递给 <code>thread_create()</code> 的函数</li>
<li><code>thread_switch()</code> 的目的是保存&#x2F;恢复寄存器，实现切换线程</li>
<li>你必须决定保存&#x2F;恢复哪些寄存器（调用者寄存器）；在哪里保存寄存器（修改 <code>struct thread</code> 可能是一个好的方法）</li>
<li>你可以将需要的任何参数传递给 <code>thread_switch()</code>，以便从线程 t 切换到 nexthread</li>
</ul>
</li>
<li><p>为了保存相关寄存器，模仿 <code>kernel/proc.h</code> 中的 <code>struct context</code>，在 <code>user/uthread.c</code> 中添加一个上下文结构体，并将它添加到 <code>struct thread</code> 中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack  线程栈*/</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE 线程状态*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span> <span class="comment">// 线程上下文</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>uthread_create()</code> 中添加代码<ul>
<li><code>thread_create()</code> 遍历线程组，找到一个 <code>FREE</code> 线程，将设置为 <code>RUNNABLE</code> 线程。我们的任务是在之后调度到这个线程时，在这个线程的线程栈上运行传递的函数 <code>func</code></li>
<li>为了在这个线程的线程栈上运行传递的函数，令线程上下文中的栈指针 <code>sp</code> 指向线程栈的栈顶，<code>+ STACK_SIZE</code> 是因为栈由上向下增长</li>
<li>为了在通过 <code>thread_switch()</code> 切换到这个线程后，可以返回到函数 <code>func</code> 被中断的位置继续运行，令线程上下文中的 <code>ra</code> 寄存器存储 <code>func</code> 函数指针的值（函数地址），<code>ra</code> 寄存器存储的是返回的地址</li>
<li>所以 <code>uthread_create()</code> 只是将传递的函数绑定到一个 <code>FREE</code> 线程上，并将这个线程设为 <code>RUNNABLE</code>，函数并没有真正的运行</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在 <code>user/thread_switch.S</code> 中添加代码</p>
<ul>
<li><code>thread_switch()</code> 由于需要保存&#x2F;恢复寄存器，所以需要汇编实现</li>
<li>它的作用是保存一个线程的上下文，恢复另一个线程的上下文，从而实现切换线程</li>
<li>它的实现和 <code>kernel/swtch.S</code> 中内核线程的上下文切换一样</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">	.text</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">         * save the old thread&#x27;s registers,</span><br><span class="line">         * restore the new thread&#x27;s registers.</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">	.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">	/* YOUR CODE HERE */</span><br><span class="line">	sd ra, 0(a0)</span><br><span class="line">	sd sp, 8(a0)</span><br><span class="line">	sd s0, 16(a0)</span><br><span class="line">	sd s1, 24(a0)</span><br><span class="line">	sd s2, 32(a0)</span><br><span class="line">	sd s3, 40(a0)</span><br><span class="line">	sd s4, 48(a0)</span><br><span class="line">	sd s5, 56(a0)</span><br><span class="line">	sd s6, 64(a0)</span><br><span class="line">	sd s7, 72(a0)</span><br><span class="line">	sd s8, 80(a0)</span><br><span class="line">	sd s9, 88(a0)</span><br><span class="line">	sd s10, 96(a0)</span><br><span class="line">	sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">	ld ra, 0(a1)</span><br><span class="line">	ld sp, 8(a1)</span><br><span class="line">	ld s0, 16(a1)</span><br><span class="line">	ld s1, 24(a1)</span><br><span class="line">	ld s2, 32(a1)</span><br><span class="line">	ld s3, 40(a1)</span><br><span class="line">	ld s4, 48(a1)</span><br><span class="line">	ld s5, 56(a1)</span><br><span class="line">	ld s6, 64(a1)</span><br><span class="line">	ld s7, 72(a1)</span><br><span class="line">	ld s8, 80(a1)</span><br><span class="line">	ld s9, 88(a1)</span><br><span class="line">	ld s10, 96(a1)</span><br><span class="line">	ld s11, 104(a1)</span><br><span class="line"></span><br><span class="line">	ret    /* return to ra */</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在 <code>uthread_schedule()</code> 中添加代码</p>
<ul>
<li><code>uthread_schedule()</code> 遍历线程组，找到一个 <code>RUNNABLE</code> 线程，进行切换。我们的任务就仅仅是调用 <code>thread_switch()</code> 来进行线程切换</li>
<li><code>uthread_schedule()</code> 和 <code>kernel/proc.c</code> 中的 <code>scheduler()</code> 的作用很像</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>, *<span class="title">next_thread</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find another runnable thread. */</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br><span class="line">  t = current_thread + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_THREAD; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt;= all_thread + MAX_THREAD)</span><br><span class="line">      t = all_thread;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;state == RUNNABLE) &#123;</span><br><span class="line">      next_thread = t;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next_thread == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread_schedule: no runnable threads\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    thread_switch((uint64)&amp;t-&gt;context, (uint64)&amp;current_thread-&gt;context);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在测试之前，让我们来看一下 <code>main()</code> 的实现流程<ul>
<li>首先调用 <code>thread_init()</code> 初始化线程组中的第一个线程</li>
<li>之后通过 <code>thread_create()</code> 创建三个分别和测试函数 <code>thread_a/b/c</code> 绑定的 <code>RUNNABLE</code> 线程</li>
<li>将当前线程，也就是第一个线程设置为 <code>FREE</code>，防止之后被调度</li>
<li>通过 <code>thread_schedule()</code> 遍历线程组，找到一个 <code>RUNNABLE</code> 线程进行切换<ul>
<li>通过 <code>thread_schedule()</code> 中的 <code>thread_switch()</code> 切换线程返回后，第一次回返回到 <code>thread_a</code></li>
<li>在 <code>thread_a</code> 中，输出 <code>start</code>，如果还有没有输出 <code>start</code> 的测试函数线程，通过 <code>thread_yield()</code> 进行调度</li>
<li>由于 <code>thread_schedule()</code> 总是从当前线程之后开始遍历线程组，所以之后依次调度到 <code>thread_b</code>，<code>thread_c</code>，待它们都输出过 <code>start</code> 后，又调度到了 <code>thread_a</code></li>
<li><code>thread_a</code> 继续输出累计值，每输出一次就通过 <code>thread_yield()</code> 进行调度，直到输出到 99，其他测试函数线程也是一样</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">  a_started = b_started = c_started = <span class="number">0</span>;</span><br><span class="line">  a_n = b_n = c_n = <span class="number">0</span>;</span><br><span class="line">  thread_init();</span><br><span class="line">  thread_create(thread_a);</span><br><span class="line">  thread_create(thread_b);</span><br><span class="line">  thread_create(thread_c);</span><br><span class="line">  current_thread-&gt;state = FREE;</span><br><span class="line">  thread_schedule();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// main() is thread 0, which will make the first invocation to</span></span><br><span class="line">  <span class="comment">// thread_schedule(). It needs a stack so that the first thread_switch() can</span></span><br><span class="line">  <span class="comment">// save thread 0&#x27;s state.</span></span><br><span class="line">  current_thread = &amp;all_thread[<span class="number">0</span>];</span><br><span class="line">  current_thread-&gt;state = RUNNING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_a</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;thread_a started\n&quot;</span>);</span><br><span class="line">  a_started = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b_started == <span class="number">0</span> || c_started == <span class="number">0</span>)</span><br><span class="line">    thread_yield();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread_a %d\n&quot;</span>, i);</span><br><span class="line">    a_n += <span class="number">1</span>;</span><br><span class="line">    thread_yield();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;thread_a: exit after %d\n&quot;</span>, a_n);</span><br><span class="line"></span><br><span class="line">  current_thread-&gt;state = FREE;</span><br><span class="line">  thread_schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  current_thread-&gt;state = RUNNABLE;</span><br><span class="line">  thread_schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; uthread</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240701211537718.png" class="" title="image-20240701211537718">

<ul>
<li><strong>.&#x2F;grade-lab-thread uthread</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240701211829481.png" class="" title="image-20240701211829481">

<h1 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h1><ul>
<li><p>在本次任务中，你将要使用散列表探索线程和锁的并行编程。你应该在具有多个内核的真实 Linux 计算机上执行此任务（不是 xv6 和 qemu）</p>
</li>
<li><p>此任务使用 UNIX pthread 线程库，你可以通过 <code>man pthreads</code> 查看相关信息</p>
</li>
<li><p>文件 <code>notxv6/ph.c</code> 中包含一个简单的哈希表，如果从单个线程使用，该哈希表是正确的，但从多个线程使用时不正确</p>
</li>
<li><p>你可以在主 xv6 目录下键入 <code>make ph &amp;&amp; ./ph 1</code>（1 表示指定在哈希表上执行 put 和 get 操作的线程数），运行一段时间后，它将输出以下结果</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100000 puts, 3.991 seconds, 25056 puts/second</span><br><span class="line">0: 0 keys missing</span><br><span class="line">100000 gets, 3.981 seconds, 25118 gets/second</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你尝试 <code>./ph 2</code>，虽然输出显示它获得了并行加速，但本应该在哈希表中的 keys 却大量消失</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100000 puts, 1.885 seconds, 53044 puts/second</span><br><span class="line">1: 16579 keys missing</span><br><span class="line">0: 16579 keys missing</span><br><span class="line">200000 gets, 4.322 seconds, 46274 gets/second</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一些提示</p>
<ul>
<li><p>你应该看看 <code>notxv6/ph.c</code> 中的 <code>put()</code> 和 <code>insert()</code></p>
</li>
<li><p>为了避免这种情况，请在 <code>put</code> 中加入锁定和解锁语句，相关的 phtread 调用如下。当你的代码通过了 <code>ph_safe</code> 测试时，你就完成了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;            <span class="comment">// declare a lock</span></span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>); <span class="comment">// initialize the lock</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);       <span class="comment">// acquire lock</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);     <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在某些情况下，并发 <code>put()</code> 在散列表中读取或写入的内存没有重叠，因此不需要锁来保护，修改 <code>ph.c</code> 以利用这种情况来获得并行加速（每个哈希桶一个锁是一个好方法）。当你的代码通过了 <code>ph_fast</code> 测试时，你就完成了</p>
</li>
</ul>
</li>
<li><p>在开始前，我们先来仔细看一下 <code>ph.c</code> 代码的执行过程，分析为什么会发生在多线程环境下 keys 大量 “消失”</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> *tha;</span><br><span class="line">  <span class="type">void</span> *value;</span><br><span class="line">  <span class="type">double</span> t1, t0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s nthreads\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nthread = atoi(argv[<span class="number">1</span>]);  <span class="comment">// 线程数</span></span><br><span class="line">  tha = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * nthread);</span><br><span class="line">  srandom(<span class="number">0</span>);</span><br><span class="line">  assert(NKEYS % nthread == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NKEYS; i++) &#123;</span><br><span class="line">    keys[i] = random();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// first the puts</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  t0 = now();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_create(&amp;tha[i], <span class="literal">NULL</span>, put_thread, (<span class="type">void</span> *) (<span class="type">long</span>) i) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_join(tha[i], &amp;value) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  t1 = now();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d puts, %.3f seconds, %.0f puts/second\n&quot;</span>,</span><br><span class="line">         NKEYS, t1 - t0, NKEYS / (t1 - t0));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// now the gets</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  t0 = now();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_create(&amp;tha[i], <span class="literal">NULL</span>, get_thread, (<span class="type">void</span> *) (<span class="type">long</span>) i) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_join(tha[i], &amp;value) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  t1 = now();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d gets, %.3f seconds, %.0f gets/second\n&quot;</span>,</span><br><span class="line">         NKEYS*nthread, t1 - t0, (NKEYS*nthread) / (t1 - t0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>main()</code> 首先根据传入的参数来创建线程，并且保证 <code>NKEYS % nthread == 0</code></p>
<ul>
<li>这是因为在之后我们会发现，<code>NKEYS</code> 是我们需要处理的 keys 数组的大小，如果 <code>NKEYS</code> 可以整除线程数，那么就可以保证每个线程处理的 keys 数组的范围大小相同，且每个线程只处理自己范围内的 keys 数组的值，而不越界影响其他线程</li>
<li>将需要处理的 keys 数组中的 key 值初始化为随机数，这说明 keys 数组中的 key 值可能相等，也可能不相等，这就为之后的 <strong>竞争</strong> 埋下了伏笔</li>
</ul>
</li>
<li><p>调用 <code>now()</code> 获得当前时间，这是为了之后计算 <code>put()</code> 的运行速度做准备，计算 <code>get()</code> 时也是如此</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span></span><br><span class="line"><span class="title function_">now</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"> gettimeofday(&amp;tv, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">return</span> tv.tv_sec + tv.tv_usec / <span class="number">1000000.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在循环中调用 <code>phtread_create()</code> 创建 nthread 个线程执行 <code>put_thread()</code></p>
<ul>
<li><code>phtread_create()</code> 中的最后一个参数是传递给 <code>put_thread()</code> 的参数，表示 thread number（第几个线程）</li>
</ul>
</li>
<li><p><code>put_thread()</code> 通过传入的参数 thread number 来确定当前线程处理的 keys 数组的范围（<code>b*n + i</code>），调用 <code>put()</code> 将键值对 <code>[keys[b*n + i], n]</code> 插入到哈希表中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">put_thread</span><span class="params">(<span class="type">void</span> *xa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>) (<span class="type">long</span>) xa; <span class="comment">// thread number</span></span><br><span class="line">  <span class="type">int</span> b = NKEYS/nthread;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">    put(keys[b*n + i], n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>put()</code> 根据传入的 key 确定是哪个哈希桶，遍历这个哈希桶找到是否有对应的 key，如果有就更新 value，否则就调用 <code>insert()</code> 将一个新的键值对插入这个哈希桶中<ul>
<li>发现了吗，这里存在一个数据竞争，因为 keys 数组中的 key 都是随机数，如果两个线程处理的 key 值相同，但由于它们的 thread number（需要插入的 value 值）是一定不同的，当他们同时来到 <code>put()</code> 且同时找到相同的 <code>e</code> 时，<code>e-&gt;value = value</code> 的行为是不可预测的，但这并不会导致 key 的消失，所以真正的罪魁祸首是 <code>insert()</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET; <span class="comment">// 根据key确定哈希桶</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(e)&#123;  </span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>insert()</code> 采用头插法的方式将一个新的键值对插入到哈希桶的顶部<ul>
<li>由于 keys 数组中的 key 值都是随机数，所以两个不同的线程可能正在处理同一个 key，如果两个线程同时来到这里，那么此时哈希桶的头部键值对（<code>table[i]</code>，这里是 <code>*p</code>）是相同的，<code>e-&gt;next = n; *p = e;</code> 的行为是无法预测的</li>
<li>如果两个线程先后执行 <code>e-&gt;next = n;</code>，之后又先后执行 <code>*p = e</code>，那么先执行 <code>*p = e</code> 的线程插入的键值对就会丢失。这就是为什么在多线程环境下大量 key 消失的原因</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">insert</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="keyword">struct</span> entry **p, <span class="keyword">struct</span> entry *n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry));</span><br><span class="line">  e-&gt;key = key;</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  e-&gt;next = n;</span><br><span class="line">  *p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>回到 <code>main()</code>，在循环中调用 <code>pthread_join()</code> 等待所有创建的线程结束，最后输出 <code>put</code> 的运行速率</p>
</li>
<li><p>之后测试 <code>get</code> 的运行速率也是大同小异</p>
</li>
<li><p>同样是在循环中调用 <code>phtread_create()</code> 创建 nthread 个线程执行 <code>get_thread()</code>，传入参数 thread number</p>
</li>
<li><p><code>get_phtread()</code> 的作用就是统计哈希表中有多少个键值对消失，由于 <code>get_thread</code> 和 <code>get</code> 都有没有涉及对临界值（也就是共享变量哈希表）的修改操作，所以不会造成竞争，也就不需要锁的保护</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">get_thread</span><span class="params">(<span class="type">void</span> *xa)</span>  <span class="comment">// get_thread的作用就是检测哈希表中有多少缺失的键值对</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>) (<span class="type">long</span>) xa; <span class="comment">// thread number</span></span><br><span class="line">  <span class="type">int</span> missing = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NKEYS; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> get(keys[i]);</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="number">0</span>) missing++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: %d keys missing\n&quot;</span>, n, missing);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> entry*</span><br><span class="line"><span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;  <span class="comment">// 确定哈希桶</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>notxv6/ph.c</code>，让它可以在多线程环境中安全且快速的运行的方法就很明显了，我们只需要在 <code>put()</code> 中加锁就可以了</li>
<li>根据提示，不同线程在操作不同的哈希桶时，每个线程写入的内存并不会重叠，所以就不会造成竞争。每个哈希桶一个锁是个很好的解决方案</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock[NBUCKET];</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>main()</code> 中初始化所有的锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> *tha;</span><br><span class="line">  <span class="type">void</span> *value;</span><br><span class="line">  <span class="type">double</span> t1, t0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s nthreads\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nthread = atoi(argv[<span class="number">1</span>]);  <span class="comment">// 线程数</span></span><br><span class="line">  tha = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * nthread);</span><br><span class="line">  srandom(<span class="number">0</span>);</span><br><span class="line">  assert(NKEYS % nthread == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NKEYS; i++) &#123;</span><br><span class="line">    keys[i] = random();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;lock[i], <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>put()</code>，在调用 <code>insert()</code> 时加上对应哈希桶的锁，<code>insert()</code> 返回后解锁<ul>
<li>这里不是在 <code>if(e) &#123;...&#125;</code> 之前之后加锁解锁是很有必要的，<code>e-&gt;value = value</code> 并不会使键值对丢失，缩小加锁的范围也可以一定程度上提高并行速度</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123; </span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(e)&#123;  </span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    pthread_mutex_lock(&amp;lock[i]);</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    pthread_mutex_unlock(&amp;lock[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.&#x2F;grade-lab-thread ph_safe</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240703152158708.png" class="" title="image-20240703152158708">

<ul>
<li><strong>.&#x2F;grade-lab-thread ph_fast</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240703152327038.png" class="" title="image-20240703152327038">

<h1 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h1><ul>
<li>在本次任务中，你将要实现一个 barrier：应用程序中的一个点，所有参与的线程必须等待，直到所有其它参与的线程也达到该点</li>
<li>你将要使用 pthread 条件变量。你应该在真正的计算机上完成此任务（不是 xv6 和 qemu）</li>
<li>文件 <code>notxv6/barrier.c</code> 包含一个 broken barrier。在主 xv6 目录中键入 <code>make barrier &amp;&amp; ./barrier 2</code>（2 指定了在 barrier 上同步的线程数），它会产生如下输出</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make barrier</span><br><span class="line">./barrier 2</span><br><span class="line">barrier: notxv6/barrier.c:42: thread: Assertion `i == t&#x27; failed.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>断言触发的原因是：一个线程在另一个线程到达 barrier 之前离开了 barrier。我们期望的行为是：每个线程在 barrier 中被阻塞，直到所有线程都到达 barrier（调用 barrier）</p>
</li>
<li><p>你的目标是实现所需要的 barrier 行为，除了在上一个任务中看到的锁原语外，你还需要以下新的 pthread 原语</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  <span class="comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span></span><br><span class="line">pthread_cond_broadcast(&amp;cond);     <span class="comment">// wake up every thread sleeping on cond</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们已经给你提供了 <code>barrier_init()</code> 及 <code>struct barrier</code>，你的工作是实现 <code>barrier()</code>。确保你的解决方案通过 <code>barrier</code> 测试</p>
</li>
<li><p>有一些问题使得问题复杂化</p>
<ul>
<li>你需要处理我们每一轮都会调用的一连串的 <code>barrier</code> 调用。<code>barrier.round</code> 记录当前是哪一轮，每次所有线程都达到 <code>barrier</code> 时，你都应该增加 <code>barrier.round</code></li>
<li>你必须处理一个线程在其他线程还未达到 <code>barrier</code> 之前 “循环赛跑” 的情况。<code>barrier.nthread</code> 记录了当前一轮已经达到 <code>barrier</code> 的线程数。确保当前一轮所有线程还未达到 <code>barrier</code> 时，已经达到的线程 “在一个循环中赛跑” 时并不会增加 <code>barrier.nthread</code></li>
</ul>
</li>
<li><p>在开始之前，我们看一下 <code>notxv6/barrier.c</code> 的运行流程</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> *tha;</span><br><span class="line">  <span class="type">void</span> *value;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">double</span> t1, t0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s nthread\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  nthread = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  tha = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * nthread);</span><br><span class="line">  srandom(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  barrier_init();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_create(&amp;tha[i], <span class="literal">NULL</span>, thread, (<span class="type">void</span> *) i) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_join(tha[i], &amp;value) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;OK; passed\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>main()</code> 根据传入参数初始化 <code>nthread</code> 以记录需要同步的线程数，分配 nthread 个线程的空间</li>
<li>调用 <code>barrier_init()</code> 初始化共享变量 <code>bstate</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">barrier</span> &#123;</span></span><br><span class="line">  <span class="type">pthread_mutex_t</span> barrier_mutex;</span><br><span class="line">  <span class="type">pthread_cond_t</span> barrier_cond;</span><br><span class="line">  <span class="type">int</span> nthread;      <span class="comment">// Number of threads that have reached this round of the barrier</span></span><br><span class="line">  <span class="type">int</span> round;     <span class="comment">// Barrier round</span></span><br><span class="line">&#125; bstate;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">barrier_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(pthread_mutex_init(&amp;bstate.barrier_mutex, <span class="literal">NULL</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(pthread_cond_init(&amp;bstate.barrier_cond, <span class="literal">NULL</span>) == <span class="number">0</span>);</span><br><span class="line">  bstate.nthread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在循环中调用 <code>pthread_create()</code> 创建 nthread 个线程执行 <code>thread()</code>，传入参数 thread number（第几个线程）</li>
<li><code>thread()</code> 在每次循环中，检查当前记录的轮数 <code>bstate.round</code> 是否和循环的轮数 <code>i</code> 匹配，不相等就会触发断言<ul>
<li>由于可能有多个线程，所以我们对 <code>barrier()</code> 期望是：一个线程调用 <code>barrier()</code> 后会被阻塞，只有其他所有可能的线程都调用 <code>barrier()</code> 后，递增 <code>bstate.round</code> 以记录轮数，所有线程才可以离开 <code>barrier()</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">thread</span><span class="params">(<span class="type">void</span> *xa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> n = (<span class="type">long</span>) xa;</span><br><span class="line">  <span class="type">long</span> delay;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> t = bstate.round;</span><br><span class="line">    assert (i == t);</span><br><span class="line">    barrier();</span><br><span class="line">    usleep(random() % <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>barrier()</code> 就是本次任务中我们需要实现的方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>回到 <code>main()</code>，在循环中调用 <code>pthread_join()</code> 等待所有创建的线程结束。最后输出 <code>OK; passed</code></li>
<li>在实现 <code>barrier()</code> 时，我的第一次实现如下所示<ul>
<li>之后觉得这样的写法不仅 “臃肿”，而且 <code>while</code> 的作用也不能说是没有，只能说是毫无用处，好像仅仅是为了应和提示中的 “在循环中赛跑”</li>
<li>然而真实情况就是它根本就没有循环，一个线程调用 <code>pthread_cond_wait()</code> 后就陷入了睡眠，当所有线程达到时被 <code>pthread_cond_broadcast()</code> 唤醒后，它会和其他线程争抢锁，没有抢到锁时确实可能会陷入 “循环赛跑”，但这也持续不了多久，毕竟其他线程很快就会释放锁并退出 <code>barrier</code>，“循环赛跑” 会严重浪费 CPU 时间，远不如睡眠来的实在</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  ++bstate.nthread;</span><br><span class="line">  <span class="keyword">while</span> (bstate.nthread != nthread) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">    pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ++bstate.round;</span><br><span class="line">  bstate.nthread = <span class="number">0</span>;</span><br><span class="line">  pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为了实现的更加 “优雅”，<code>barrier()</code> 最终的实现版本如下<ul>
<li>在修改临界区 <code>bstate</code> 之前获得锁，如果递增 <code>bstate.nthread</code> 时发现所有的线程还未到达 <code>barrier</code>，那就释放锁并陷入睡眠</li>
<li>如果递增 <code>bstate.round</code> 时发现所有线程均已达到 <code>barrier</code>，那就重置 <code>bstate.nthread</code> 且递增 <code>bstate.round</code> 以记录轮数，唤醒所有线程，释放锁</li>
<li>其他被唤醒的线程争抢锁，抢到锁的线程释放锁后退出 <code>barrier</code>，其他线程也是如此</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  <span class="keyword">if</span> (++bstate.nthread != nthread) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    ++bstate.round;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.&#x2F;barrier 2</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240703165743645.png" class="" title="image-20240703165743645">

<ul>
<li><strong>.&#x2F;grade-lab-thread barrier</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240703170504808.png" class="" title="image-20240703170504808">

<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make grade</strong></li>
</ul>
<img src="/2024/07/01/6-S081-Lab6/image-20240703171141481.png" class="" title="image-20240703171141481">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/121430791">MIT 6.S081] Lab 7: Multithreading_lab7: multithreading-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16222393.html">MIT6.S081-Lab6 Lab Multithreading 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/23/xv6-book-chapter-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/23/xv6-book-chapter-7/" class="post-title-link" itemprop="url">xv6 book chapter 7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-23 17:43:02" itemprop="dateCreated datePublished" datetime="2024-06-23T17:43:02+08:00">2024-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-06 18:44:16" itemprop="dateModified" datetime="2024-07-06T18:44:16+08:00">2024-07-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><ul>
<li>任何操作系统运行的进程数量都可能超过计算机的 CPU 数量，因此需要制定一个方案，在各进程之间分时共享 CPU<ul>
<li>理想情况下，这种共享对用户进程是透明的。一种常见的方法是通过将进程复用到硬件 CPU 上，给每个进程提供它有自己的虚拟 CPU 的假象。本章解释 xv6 如何实现这种复用</li>
</ul>
</li>
</ul>
<h2 id="Multiplexing-多路复用"><a href="#Multiplexing-多路复用" class="headerlink" title="Multiplexing 多路复用"></a>Multiplexing 多路复用</h2><ul>
<li><p>xv6 通过在两种情况下将 CPU 从一个进程切换到另一个进程来实现复用</p>
<ul>
<li>首先，xv6 的 <strong>sleep</strong> 和 <strong>wakeup</strong> 机制会进行切换，这会发生在进程等待设备或管道 I&#x2F;O，或等待子进程退出，或在 <strong>sleep</strong> 系统调用中等待</li>
<li>其次，xv6 周期性地强制切换，以应对长时间不进行 sleep 操作的计算进程</li>
<li>这种复用造成了每个进程都有自己的 CPU 的假象，就像 xv6 使用内存分配器和硬件页表造成每个进程都有自己的内存的假象一样</li>
</ul>
</li>
<li><p>实现复用会有一些挑战</p>
<ul>
<li>首先，如何从一个进程切换到另一个进程？虽然上下文切换的想法很简单，但在 xv6 的实现中上下文切换却是最不透明的代码之一</li>
<li>第二，如何以对用户进程透明的方式进行强制切换？xv6 采用标准通用的方式，用定时器中断来驱动上下文切换</li>
<li>第三，许多 CPU 可能会在进程间并发切换，需要设计一个锁来避免竞争</li>
<li>第四，当进程退出时，必须释放进程的内存和其他资源，但进程本身不能完全释放掉所有的资源，比如它不能在使用内核栈的同时释放自己的内核栈</li>
<li>第五，多核机器的每个内核必须记住它正在执行的进程，这样系统调用才能修改相应进程的内核状态</li>
<li>最后，<strong>sleep</strong> 和 <strong>wakeup</strong> 允许一个进程放弃 CPU，并睡眠等待某一事件，并允许另一个进程将睡眠的进程唤醒。需要注意一些竞争可能会使唤醒丢失</li>
<li>xv6 试图尽可能简单地解决这些问题，尽管如此，实际代码还是很棘手</li>
</ul>
</li>
</ul>
<h2 id="Code-Context-switching-上下文切换"><a href="#Code-Context-switching-上下文切换" class="headerlink" title="Code: Context switching 上下文切换"></a>Code: Context switching 上下文切换</h2><img src="/2024/06/23/xv6-book-chapter-7/Figure-7.1.png" class="" title="Figure-7.1">

<ul>
<li><p>图 7.1 概述了从一个用户进程切换到另一个用户进程所涉及的步骤：用户-内核的切换（通过系统调用或中断）到旧进程的内核线程，上下文（context）切换到当前 CPU 的调度器线程，上下文（context）切换到新进程的内核线程，以及 trap 返回到用户级进程</p>
<ul>
<li>xv6 调度器在每个 CPU 上有一个专门的线程 (保存了寄存器和栈)，因为调度器在旧进程的内核栈上执行是不安全的：因为其他核心可能会唤醒该进程并运行它，而在两个不同的核心上使用相同的栈将是一场灾难</li>
<li>在本节中，我们将研究在内核线程和调度线程之间切换的机制</li>
</ul>
</li>
<li><p>从一个线程切换到另一个线程，需要保存旧线程的 CPU 寄存器，并恢复新线程之前保存的寄存器；栈指针和 pc 被保存和恢复，意味着 CPU 将切换栈和正在执行的代码</p>
</li>
<li><p>函数 <strong>swtch</strong> 执行内核线程切换的保存和恢复。<strong>swtch</strong> 并不直接知道线程，它只是保存和恢复寄存器组，称为 **上下文(context)**。当一个进程要放弃 CPU 的时候，进程的内核线程会调用 <strong>swtch</strong> 保存自己的上下文并返回到调度器上下文</p>
<ul>
<li><p>每个上下文都包含在一个结构体 <strong>context(kernel&#x2F;proc.h:2)</strong> 中，它本身包含在进程的结构体 <strong>proc</strong> 或 CPU 的结构体 <strong>cpu</strong> 中</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">uint64 ra;</span><br><span class="line">uint64 sp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// callee-saved</span></span><br><span class="line">uint64 s0;</span><br><span class="line">uint64 s1;</span><br><span class="line">uint64 s2;</span><br><span class="line">uint64 s3;</span><br><span class="line">uint64 s4;</span><br><span class="line">uint64 s5;</span><br><span class="line">uint64 s6;</span><br><span class="line">uint64 s7;</span><br><span class="line">uint64 s8;</span><br><span class="line">uint64 s9;</span><br><span class="line">uint64 s10;</span><br><span class="line">uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line"><span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line"><span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line"><span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line"><span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line"><span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line"><span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line"><span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>swtch</strong> 有两个参数：<strong>struct context old</strong> 和 <strong>struct context new</strong>。它将当前的寄存器保存在 old 中，从 new 中加载寄存器，然后返回</p>
</li>
</ul>
</li>
<li><p>让我们跟随一个进程通过 <strong>swtch</strong> 进入 <strong>scheduler</strong>。我们在第 4 章看到，在中断结束时，有一种情况是 <strong>usertrap</strong> 调用 <strong>yield</strong></p>
</li>
<li><p><strong>yield</strong> 又调用 <strong>sched</strong>，<strong>sched</strong> 调用 <strong>swtch</strong> 将当前上下文保存在 <strong>p-&gt;context</strong> 中，并切换到之前保存在 <strong>cpu-&gt;scheduler</strong> 中的调度器上下文（kernel&#x2F;proc.c:509）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Give up the CPU for one scheduling round.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">acquire(&amp;p-&gt;lock);</span><br><span class="line">p-&gt;state = RUNNABLE;</span><br><span class="line">sched();</span><br><span class="line">release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Switch to scheduler.  Must hold only p-&gt;lock </span></span><br><span class="line"><span class="comment">// 切换到调度器。必须仅持有 p-&gt;lock 并且已经改变了 proc-&gt;state</span></span><br><span class="line"><span class="comment">// and have changed proc-&gt;state. Saves and restores</span></span><br><span class="line"><span class="comment">// intena because intena is a property of this</span></span><br><span class="line"><span class="comment">// kernel thread, not this CPU. It should</span></span><br><span class="line"><span class="comment">// 保存并恢复 intena，因为 intena 是这个内核线程的属性，而不是这个 CPU 的属性</span></span><br><span class="line"><span class="comment">// be proc-&gt;intena and proc-&gt;noff, but that would</span></span><br><span class="line"><span class="comment">// break in the few places where a lock is held but</span></span><br><span class="line"><span class="comment">// there&#x27;s no process.</span></span><br><span class="line"><span class="comment">// 它应该是 proc-&gt;intena 和 proc-&gt;noff，但那样会在少数几个地方出问题，在那些地方持有锁但没有进程</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> intena;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!holding(&amp;p-&gt;lock))	<span class="comment">// 此时必须持有进程锁</span></span><br><span class="line"> panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)	<span class="comment">// push_off()仅有一层，说明acquire只被调用一次，没有其他进程争抢这把锁</span></span><br><span class="line"> panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;state == RUNNING)	<span class="comment">// 当前进程的状态不能是running</span></span><br><span class="line"> panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(intr_get())			<span class="comment">// 中断必须是关闭的</span></span><br><span class="line"> panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">intena = mycpu()-&gt;intena;	<span class="comment">// 获得新线程的中断状态</span></span><br><span class="line">swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">mycpu()-&gt;intena = intena; <span class="comment">// 保存中断状态（这里是新线程的还是旧线程的，应该是新线程的，因为swtch后就已经切换上下文不在这里执行了，当重新返回到旧线程时回到这里再次保存新线程的中断状态）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>swtch(kernel&#x2F;swtch.S:3)</strong> 只保存 callee-saved（被调用者保存）寄存器，caller-saved（调用者保存）寄存器由调用的 C 代码保存在堆栈上 (如果需要)。<strong>swtch</strong> 知道 <strong>struct context</strong> 中每个寄存器字段的偏移量。它不保存 pc。相反，<strong>swtch</strong> 保存了 ra 寄存器<a href="#ftn1">[1]</a>，它保存了 <strong>swtch</strong> 应该返回的地址</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># Context switch</span><br><span class="line">#</span><br><span class="line">#   void swtch(struct context *old, struct context *new);</span><br><span class="line"># </span><br><span class="line"># Save current registers in old. Load from new.	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">     sd ra, 0(a0)</span><br><span class="line">     sd sp, 8(a0)</span><br><span class="line">     sd s0, 16(a0)</span><br><span class="line">     sd s1, 24(a0)</span><br><span class="line">     sd s2, 32(a0)</span><br><span class="line">     sd s3, 40(a0)</span><br><span class="line">     sd s4, 48(a0)</span><br><span class="line">     sd s5, 56(a0)</span><br><span class="line">     sd s6, 64(a0)</span><br><span class="line">     sd s7, 72(a0)</span><br><span class="line">     sd s8, 80(a0)</span><br><span class="line">     sd s9, 88(a0)</span><br><span class="line">     sd s10, 96(a0)</span><br><span class="line">     sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">     ld ra, 0(a1)</span><br><span class="line">     ld sp, 8(a1)</span><br><span class="line">     ld s0, 16(a1)</span><br><span class="line">     ld s1, 24(a1)</span><br><span class="line">     ld s2, 32(a1)</span><br><span class="line">     ld s3, 40(a1)</span><br><span class="line">     ld s4, 48(a1)</span><br><span class="line">     ld s5, 56(a1)</span><br><span class="line">     ld s6, 64(a1)</span><br><span class="line">     ld s7, 72(a1)</span><br><span class="line">     ld s8, 80(a1)</span><br><span class="line">     ld s9, 88(a1)</span><br><span class="line">     ld s10, 96(a1)</span><br><span class="line">     ld s11, 104(a1)</span><br><span class="line"></span><br><span class="line">     ret</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>现在，<strong>swtch</strong> 从新的上下文中恢复寄存器，新的上下文中保存着前一次 <strong>swtch</strong> 所保存的寄存器值。当 <strong>swtch</strong> 返回时，它返回到被恢复的 ra 寄存器所指向的指令，也就是新线程之前调用 <strong>swtch</strong> 的指令。此外，它还会返回新线程的堆栈</li>
</ul>
</li>
<li><p>在我们的例子中，<strong>sched</strong> 调用 <strong>swtch</strong> 切换到 <strong>cpu-&gt;scheduler</strong>，即 CPU 调度器的上下文。这个上下文已经被 <strong>scheduler</strong> 对 <strong>swtch</strong> 的调用所保存 (kernel&#x2F;proc.c:475)。当我们跟踪的 <strong>swtch</strong> 返回时，它不是返回到 <strong>sched</strong> 而是返回到 <strong>scheduler</strong>，它的栈指针指向当前 CPU 的调度器栈</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler. 							每个CPU的进程调度器</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up. 	每个CPU在设置好自己之后都会调用scheduler()</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing: 	调度器永不返回。它会持续循环执行以下操作：</span></span><br><span class="line"><span class="comment">//  - choose a process to run.					选择一个进程来运行</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.		切换到该进程以开始执行</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control	最终，该进程会通过切换（swtch）将控制权交还给调度器</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> <span class="comment">// The most recent process to run may have had interrupts</span></span><br><span class="line"> <span class="comment">// turned off; enable them to avoid a deadlock if all</span></span><br><span class="line"> <span class="comment">// 最近运行的进程可能已经关闭了中断；为了避免所有进程都在等待而导致的死锁，需要开启它们</span></span><br><span class="line"> <span class="comment">// processes are waiting.</span></span><br><span class="line"> intr_on();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">   acquire(&amp;p-&gt;lock);</span><br><span class="line">   <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">     <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">     <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">     <span class="comment">// 切换到选中的进程。进程的任务是在释放其锁，然后在跳转回这里之前重新获取锁</span></span><br><span class="line">     <span class="comment">// before jumping back to us.</span></span><br><span class="line">     p-&gt;state = RUNNING;</span><br><span class="line">     c-&gt;proc = p;</span><br><span class="line">     swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Process is done running for now.</span></span><br><span class="line">     <span class="comment">// 进程现在已完成运行。在返回之前，它应该已经改变了其 p-&gt;state（进程状态）</span></span><br><span class="line">     <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">     c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   release(&amp;p-&gt;lock);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>补充说明（不在翻译内容中）：</p>
</li>
<li><p>根据 xv6 的源代码，xv6 中只有两处调用 switch：</p>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;scheduler);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    swtch(&amp;c-&gt;scheduler, &amp;p-&gt;context);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可以看出这里没有两个用户进程之间的直接切换，只有用户进程和调度器线程之间的切换</strong>：xv6 中要主动让出 cpu 的进程都是通过调用 exit&#x2F;sleep&#x2F;yield，间接调用 sched，从而实现切换到调度器线程，再由调度器线程选出并切换到一个 runnable</li>
</ul>
<h2 id="Code-Scheduling-调度"><a href="#Code-Scheduling-调度" class="headerlink" title="Code: Scheduling 调度"></a>Code: Scheduling 调度</h2><ul>
<li><p>上一节研究了 <strong>swtch</strong> 的底层细节，现在我们把 <strong>swtch</strong> 作为一个给定的条件，研究从一个进程的内核线程通过调度器切换到另一个进程</p>
<ul>
<li><p>调度器以 CPU 特殊线程（每个 CPU 各一个）的形式存在，线程运行 <strong>scheduler</strong> 函数。这个函数负责选择下一步运行哪个进程</p>
</li>
<li><p>一个想要放弃 CPU 的进程，必须获取自己的进程锁 <strong>p-&gt;lock</strong>，释放它所持有的其他锁，更新自己的状态（<strong>p-&gt;state</strong>），然后调用 <strong>sched</strong>。<strong>yield</strong> (kernel&#x2F;proc.c:515) 遵循这个规则，我们稍后要研究的 <strong>sleep</strong> 和 <strong>exit</strong> 也同样遵循这个规则。<strong>sched</strong> 对这些条件进行仔细检查 (kernel&#x2F;proc.c:499-504)，然后再检查这些条件的含义：既然锁被持有，就应该禁用中断。最后，<strong>sched</strong> 调用 <strong>swtch</strong> 将当前上下文保存在 p-&gt;context 中，并切换到 cpu-&gt;scheduler 中 <strong>scheduler</strong> 的上下文。swtch 在 <strong>scheduler</strong> 堆栈上返回，<strong>scheduler</strong> 继续 for 循环，找到一个要运行的进程，切换到它，然后循环重复</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> intena;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!holding(&amp;p-&gt;lock))	<span class="comment">// 此时必须持有进程锁</span></span><br><span class="line"> panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)	<span class="comment">// push_off()仅有一层，说明acquire只被调用一次，没有其他进程争抢这把锁</span></span><br><span class="line"> panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;state == RUNNING)	<span class="comment">// 当前进程的状态不能是running</span></span><br><span class="line"> panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(intr_get())			<span class="comment">// 中断必须是关闭的</span></span><br><span class="line"> panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">intena = mycpu()-&gt;intena;	<span class="comment">// 获得新线程的中断状态(其实这里是调度器的中断状态，也就是中断打开)</span></span><br><span class="line">swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">mycpu()-&gt;intena = intena; <span class="comment">// 保存调度器的中断状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>我们刚刚看到 xv6 在调用 <strong>swtch</strong> 的过程中持有 <strong>p-&gt;lock</strong>：<strong>swtch</strong> 的调用者必须已经持有锁，并把锁的控制权移交给切换到的代码。这种约定对于锁来说是不寻常的；一般来说获得锁的线程也要负责释放锁，这样才容易保证正确性。对于上下文切换来说，有必要打破这个约定，因为 <strong>p-&gt;lock</strong> 保护了进程的状态和 <strong>context</strong> 字段上的 <strong>不变量（invariant）</strong>，而这些不变量在 <strong>swtch</strong> 执行时是不正确的。如果 <strong>p-&gt;lock</strong> 在 <strong>swtch</strong> 过程中不被持有，可能会出现问题的一个情况：在 <strong>yield</strong> 将其状态设置为 <strong>RUNNABLE</strong> 之后，但在 <strong>swtch</strong> 切换到新的栈之前，其他 CPU 可能会运行这个进程。结果就是两个 CPU 运行在同一个栈上，这显然是错误的</p>
</li>
<li><p>一个内核线程在 <strong>sched</strong> 中放弃它的 CPU，并且切换到 <strong>scheduler</strong> 的同一个位置，而 <strong>scheduler</strong>（几乎）总是切换到之前调用 <strong>sched</strong> 的某个内核线程。因此，如果把 xv6 切换线程的行号打印出来，就会观察到下面的结果：(kernel&#x2F;proc.c:475)，(kernel&#x2F;proc.c:509)，(kernel&#x2F;proc.c:475)，(kernel&#x2F;proc.c:509)，等等</p>
<ul>
<li>在两个线程之间发生这种样式化切换的程序有时被称为 <strong>协程（coroutine）</strong>；在这个例子中，<strong>sched</strong> 和 <strong>scheduler</strong> 是彼此的 <strong>coroutines</strong></li>
</ul>
</li>
<li><p>有一种情况是调度器对 <strong>swtch</strong> 的调用没有以 <strong>sched</strong> 结束（意思是没有回到之前进程调用 sched 结束的位置）。当一个新进程第一次被调度时，它从 <strong>forkret</strong> 开始（kernel&#x2F;proc.c:527）。<strong>forkret</strong> 的存在是为了释放 <strong>p-&gt;lock</strong>；否则，新进程需要从 <strong>usertrapret</strong> 开始</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A fork child&#x27;s very first scheduling by scheduler()</span></span><br><span class="line"><span class="comment">// will swtch to forkret.</span></span><br><span class="line"><span class="comment">// scheduler()对一个fork子进程的第一次调度将会swtch到forkret</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Still holding p-&gt;lock from scheduler. 仍然持有来自调度器的进程锁</span></span><br><span class="line">release(&amp;myproc()-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (first) &#123;</span><br><span class="line"> <span class="comment">// File system initialization must be run in the context of a</span></span><br><span class="line"> <span class="comment">// regular process (e.g., because it calls sleep), and thus cannot</span></span><br><span class="line"> <span class="comment">// be run from main().</span></span><br><span class="line"> <span class="comment">// 文件系统初始化必须在常规进程的上下文中运行（例如，因为它调用了sleep），因此不能从main()函数中运行</span></span><br><span class="line"> fsinit(ROOTDEV);</span><br><span class="line"></span><br><span class="line"> first = <span class="number">0</span>; <span class="comment">// first为静态局部变量，所以fsinit只能执行一次</span></span><br><span class="line"> <span class="comment">// ensure other cores see first=0. 确保其他核心看到 first=0</span></span><br><span class="line"> __sync_synchronize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>scheduler(kernel&#x2F;proc.c:457)</strong> 运行了一个简单的循环：找到一个可以运行进程，运行它，直到它让出 CPU，一直重复。调度器在进程表上循环寻找一个可运行的进程，即 p-&gt;state &#x3D;&#x3D; RUNNABLE 的进程。一旦找到这样的进程，它就会设置 CPU 当前进程变量 c-&gt;proc 指向该进程，将该进程标记为 RUNNING，然后调用 <strong>swtch</strong> 开始运行它 (kernel&#x2F;proc.c:470- 475)</p>
</li>
<li><p>你可以这样理解调度代码结构，它执行一组关于进程的不变量，并且每当这些不变量不正确时，就持有 <strong>p-&gt;lock</strong></p>
<ul>
<li>一个不变量是，如果一个进程正在运行，那么定时中断导致的 yield 必须能够安全的让他让出 cpu；这意味着 CPU 寄存器必须持有该进程的寄存器值（即 <strong>swtch</strong> 没有将它们移到上下文中），并且 <strong>c-&gt;proc</strong> 必须指向该进程</li>
<li>另一个不变量是，如果一个进程是 <strong>RUNNABLE</strong> 的，那么对于一个空闲的 CPU 调度器来说，运行它必须是安全的；这意味<ul>
<li>（1）<strong>p-&gt;context</strong> 必须拥有进程的寄存器（即它们实际上并不在真实的寄存器中，swtch 将它们移动到上下文中）   </li>
<li>（2）没有 CPU 在进程的内核栈上执行 </li>
<li>（3）也没有 CPU 的 c-&gt;proc 指向该进程。请注意，当 p-&gt;lock 被持有时，这些属性往往不正确</li>
</ul>
</li>
</ul>
</li>
<li><p>维护上述不变量是 xv6 经常在一个线程中获取 <strong>p-&gt;lock</strong>，然后在另一个线程中释放它的原因（例如在 <strong>yield</strong> 中获取，在 <strong>schedululer</strong> 中释放）</p>
<ul>
<li>一旦 <strong>yield</strong> 开始修改一个正在运行的进程的状态，使其成为 <strong>RUNNABLE</strong>，锁必须一直保持，直到不变量被恢复：最早正确的释放点是在调度器（运行在自己的堆栈上）清除 <strong>c-&gt;proc</strong> 之后</li>
<li>同样，一旦调度器开始将一个 <strong>RUNNABLE</strong> 进程转换为 <strong>RUNNING</strong>，锁就不能被释放，直到内核线程完成运行（在 <strong>swtch</strong> 之后，例如在 <strong>yield</strong> 中）</li>
</ul>
</li>
<li><p><strong>p-&gt;lock</strong> 也保护其他的东西：<strong>exit</strong> 和 <strong>wait</strong> 之间的相互作用，避免丢失唤醒的机制（见第 7.5 节），以及避免避免退出进程和读写其状态的其他进程之间的竞争（例如，<strong>exit</strong> 系统调用查看 <strong>p-&gt;pid</strong> 并设置 **p-&gt;killed (kernel&#x2F;proc.c:611)**。值得思考的是，是否可以将 <strong>p-&gt;lock</strong> 的不同功能拆分开来，这样既清晰，也可能提高性能</p>
</li>
</ul>
<h2 id="Code-mycpu-and-myproc"><a href="#Code-mycpu-and-myproc" class="headerlink" title="Code: mycpu and myproc"></a>Code: mycpu and myproc</h2><ul>
<li><p>xv6 经常需要一个指向当前进程 <strong>proc</strong> 的指针。在单核处理器上，可以用一个全局变量指向当前的 <strong>proc</strong>。这在多核机器上是行不通的，因为每个核都执行不同的进程。解决这个问题的方法是利用每个核都有自己的一组寄存器的事实；我们可以使用其中的一个寄存器来帮助查找每个核的信息</p>
</li>
<li><p>xv6 为每个 CPU 维护了一个 <strong>cpu</strong> 结构体 (kernel&#x2F;proc.h:22)，它记录了当前在该 CPU 上运行的进程 (如果有的话)，为 CPU 的调度线程保存的寄存器，以及管理中断禁用所需的嵌套自旋锁的计数</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line"><span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line"><span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>函数 <strong>mycpu</strong> (kernel&#x2F;proc.c:60) 返回一个指向当前 CPU 结构体 <strong>cpu</strong> 的指针。RISC-V 对 CPU 进行编号，给每个 CPU 一个 <strong>hartid</strong>。xv6 确保每个 CPU 的 <strong>hartid</strong> 在内核中被存储在该 CPU 的 <strong>tp</strong> 寄存器中。这使得 <strong>mycpu</strong> 可以使用 <strong>tp</strong> 对 <strong>cpu</strong> 结构体的数组进行索引，从而找到正确的 cpu</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return this CPU&#x27;s cpu struct.</span></span><br><span class="line"><span class="comment">// Interrupts must be disabled.</span></span><br><span class="line"><span class="keyword">struct</span> cpu*</span><br><span class="line"><span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id = cpuid();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[id];</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Must be called with interrupts disabled,</span></span><br><span class="line"><span class="comment">// to prevent race with process being moved</span></span><br><span class="line"><span class="comment">// to a different CPU.</span></span><br><span class="line"><span class="comment">// 必须在禁用中断的情况下调用，以防止进程被移动到不同CPU的竞态条件</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cpuid</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id = r_tp();</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>确保一个 CPU 的 <strong>tp</strong> 始终保持 CPU 的 hartid 是有一点复杂的</p>
<ul>
<li><p><strong>mstart</strong> 在 CPU 启动的早期设置 <strong>tp</strong> 寄存器，此时 CPU 处于机器模式 (kernel&#x2F;start.c:46)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line"><span class="type">int</span> id = r_mhartid();</span><br><span class="line">w_tp(id);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>usertrapret</strong> 将 <strong>tp</strong> 寄存器保存在 trampoline 页中，因为用户进程可能会修改 tp 寄存器。最后，当从用户空间进入内核时，<strong>uservec</strong> 会恢复保存的 tp（trapframe 中的 tp 加载到 tp 寄存器）(kernel&#x2F;trampoline.S:70)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">		# ...</span><br><span class="line">     # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">     ld tp, 32(a0)</span><br><span class="line">   	# ...</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>编译器保证永远不使用 tp 寄存器。如果 RISC-V 允许 xv6 直接读取当前的 hartid 会更方便，但这只允许在机器模式下读取，而不允许在管理模式下读取</p>
</li>
</ul>
</li>
<li><p>cpuid 和 mycpu 的返回值很容易错：如果定时器中断，导致线程让出 CPU，然后转移到不同的 CPU 上，之前返回的值将不再正确。为了避免这个问题，xv6 要求调用者禁用中断，只有在使用完返回的 cpu 结构后才启用中断。(即为了避免这个问题，调用 cpuid 和 mycpu 时，需要禁用中断)</p>
</li>
<li><p><strong>myproc</strong> (kernel&#x2F;proc.c:68) 函数返回当前 CPU 上运行的进程的 <strong>proc</strong> 指针。<strong>myproc</strong> 禁用中断，调用 <strong>mycpu</strong>，从 <strong>struct</strong> <strong>cpu</strong> 中获取当前进程指针 (<strong>c-&gt;proc</strong>)，然后启用中断。即使启用了中断，<strong>myproc</strong> 的返回值也可以安全使用：如果定时器中断将调用进程移到了另一个的 CPU 上，它的 <strong>proc</strong> 结构指针将保持不变</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the current struct proc *, or zero if none.</span></span><br><span class="line"><span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">push_off();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">pop_off();</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Sleep-and-wakeup"><a href="#Sleep-and-wakeup" class="headerlink" title="Sleep and wakeup"></a>Sleep and wakeup</h2><ul>
<li><p>调度和锁有助于让一个进程对另一个进程的不可见，但到目前为止，我们还没有帮助进程进行交互的抽象。人们发明了许多机制来解决这个问题</p>
<ul>
<li>xv6 使用了一种叫做睡眠和唤醒的机制，它允许一个进程睡眠并等待事件，另一个进程在该事件发生后将其唤醒</li>
<li>睡眠和唤醒通常被称为 <strong>序列协调（sequence coordination）</strong> 或 <strong>条件同步（conditional synchronization）</strong> 机制</li>
</ul>
</li>
<li><p>为了说明这一点，让我们考虑一个叫做 <strong>信号量（semaphore）</strong>[4] 的同步机制，它协调生产者和消费者</p>
<ul>
<li>信号量维护一个计数并提供两个操作。V 操作（针对生产者）增加计数。P 操作（针对消费者）等待，直到计数非零，然后将其递减并返回</li>
<li>如果只有一个生产者线程和一个消费者线程，而且它们在不同的 CPU 上执行，编译器也没有太过激进的优化，那么这个实现是正确的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count += <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面的实现是代价很大。如果生产者很少生产，消费者将把大部分时间花在 while 循环中，希望得到一个非零的计数</p>
<ul>
<li>消费者的 CPU 可以通过反复 <strong>轮询(polling)</strong> <strong>s-&gt;count</strong> 可以找到比 <strong>忙碌等待(busy waiting)</strong> 更有效的工作</li>
<li>避免 <strong>忙碌等待</strong> 需要一种方法，让消费者让出 CPU，只有在 <strong>V</strong> 增加计数后才恢复</li>
</ul>
</li>
<li><p>这里是朝着这个方向迈出的一步，虽然他不能完全解决这个问题。让我们想象一对调用，<strong>sleep</strong> 和 <strong>wakeup</strong>，其工作原理如下</p>
<ul>
<li><strong>Sleep(chan)</strong> 睡眠 <strong>chan</strong> 上，<strong>chan</strong> 可以为任意值，称为 <strong>等待通道(wait channel)<strong>。</strong>Sleep</strong> 使调用进程进入睡眠状态，释放 CPU 进行其他工作</li>
<li><strong>Wakeup(chan)</strong> 唤醒所有在 <strong>chan</strong> 上 <strong>sleep</strong> 的进程（如果有的话），使它们的 <strong>sleep</strong> 调用返回。如果没有进程在 <strong>chan</strong> 上等待，则 <strong>wakeup</strong> 不做任何事情</li>
<li>我们修改信号量实现，以使用 <strong>sleep</strong> 和 <strong>wakeup</strong>（修改处用注释标注）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count += <span class="number">1</span>;</span><br><span class="line">  wakeup(s);			<span class="comment">// 修改</span></span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    sleep(s);			<span class="comment">// 修改</span></span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>P 现在放弃 CPU 而不是自旋，这是一个不错的改进。然而，事实证明，像这样设计 <strong>sleep</strong> 和 <strong>wakeup</strong> 并不是一件容易的事，因为它会遇到所谓的丢失唤醒问题</p>
<ul>
<li>假设执行 P 的 <strong>s-&gt;count &#x3D;&#x3D; 0</strong> 这一行时。当 P 在 <strong>sleep</strong> 之前，V 在另一个 CPU 上运行：它将 <strong>s-&gt;count</strong> 改为非零，并调用 <strong>wakeup</strong>，<strong>wakeup</strong> 发现没有进程在睡眠，因此什么也不做。现在 P 继续执行：它调用 <strong>sleep</strong> 并进入睡眠状态。这就造成了一个问题：P 正在 <strong>sleep</strong>，等待一个已经发生的 V 调用。除非我们运气好，生产者再次调用 V，否则消费者将永远等待，即使计数是非零</li>
</ul>
</li>
<li><p>这个问题的根源在于，在错误的时刻运行的 V 违反了 P 只在 <code>s-&gt;count==0</code> 时休眠的不变量。保护这个不变量的一个不正确的方法是将锁获取（修改用注释标注）移动到 P 中，这样它对计数的检查和对 sleep 的调用是原子的：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	acquire(&amp;s-&gt;lock);</span><br><span class="line">	s-&gt;count += <span class="number">1</span>;</span><br><span class="line">	wakeup(s);</span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	acquire(&amp;s-&gt;lock);		<span class="comment">// 修改</span></span><br><span class="line">	<span class="keyword">while</span>(s-&gt;count == <span class="number">0</span>)</span><br><span class="line">		sleep(s);</span><br><span class="line">	s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>人们可能希望这个版本的 P 能够避免丢失的唤醒，因为锁会阻止 V 在 <strong>s-&gt;count &#x3D;&#x3D; 0</strong> 和 sleep 之间执行。它做到了这一点，但它也会死锁。P 在 <strong>sleep</strong> 时保持着锁，所以 V 将永远阻塞在等待锁的过程中</p>
</li>
<li><p>我们将通过改变 <strong>sleep</strong> 的接口来修正前面的方案：调用者必须将 <strong>条件锁(condition lock)</strong> 传递给 <strong>sleep</strong>，这样在调用进程被标记为 <strong>SLEEPING</strong> 并在 chan 上等待后，它就可以释放锁。锁将强制并发的 V 等待直到 P 将自己置于 <strong>SLEEPING</strong> 状态，这样 <strong>wakeup</strong> 就会发现 <strong>SLEEPING</strong> 的消费者并将其唤醒。一旦消费者再次被唤醒，<strong>sleep</strong> 就会重新获得锁，然后再返回。我们新的正确的睡眠&#x2F;唤醒方案是可用的，如下所示（修改用注释标注）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	acquire(&amp;s-&gt;lock);</span><br><span class="line">	<span class="keyword">while</span>(s-&gt;count == <span class="number">0</span>)</span><br><span class="line">		sleep(s, &amp;s-&gt;lock);	<span class="comment">// 修改</span></span><br><span class="line">	s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>P 持有 <strong>s-&gt;lock</strong> 会阻止了 V 在 P 检查 <strong>c-&gt;count</strong> 和调用 <strong>sleep</strong> 之间试图唤醒它。但是，请注意，我们需要 <strong>sleep</strong> 来原子地释放 <strong>s-&gt;lock</strong> 并使消费者进程进入 <strong>SLEEPING</strong> 状态</li>
</ul>
<h2 id="Code-Sleep-and-wakeup"><a href="#Code-Sleep-and-wakeup" class="headerlink" title="Code: Sleep and wakeup"></a>Code: Sleep and wakeup</h2><ul>
<li><p>让我们看看 <strong>sleep (kernel&#x2F;proc.c:548)</strong> 和 <strong>wakeup (kernel&#x2F;proc.c:582)</strong> 的实现。其基本思想是让 <strong>sleep</strong> 将当前进程标记为 <strong>SLEEPING</strong>，然后调用 <strong>sched</strong> 让出 <strong>CPU</strong>；<strong>wakeup</strong> 则寻找给定的 <strong>等待通道</strong> 上睡眠的进程，并将其标记为 <strong>RUNNABLE</strong></p>
<ul>
<li><strong>sleep</strong> 和 <strong>wakeup</strong> 的调用者可以使用任何方便的数字作为 <strong>channel</strong>。xv6 经常使用参与等待的内核数据结构的地址</li>
</ul>
</li>
<li><p><strong>Sleep</strong> 首先获取 **p-&gt;lock (kernel&#x2F;proc.c:559)**。现在进入睡眠状态的进程同时持有 <strong>p-&gt;lock</strong> 和 <strong>lk</strong>。在调用者 (在本例中为 P) 中，持有 <strong>lk</strong> 是必要的：它保证了没有其他进程 (在本例中，运行 V 的进程) 可以调用 **wakeup(chan)**。现在 <strong>sleep</strong> 持有 <strong>p-&gt;lock</strong>，释放 <strong>lk</strong> 是安全的：其他进程可能会调用 **wakeup(chan)**，但 <strong>wakeup</strong> 会等待获得 <strong>p-&gt;lock</strong>，因此会等到 <strong>sleep</strong> 将进程状态设置为 <strong>SLEEPING</strong>，使 <strong>wakeup</strong> 不会错过 <strong>sleep</strong> 的进程</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Atomically release lock and sleep on chan. 原子的释放锁并睡眠在chan上</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened. 获得锁当被唤醒时</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to 必须获得进程锁是为了改变当前进程的状态和调用sched(放弃CPU)</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be  一旦我们拥有进程锁，我们可以保证不会错过任何唤醒</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),  唤醒需要进程锁</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.  所以现在释放lk锁是安全的</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">  release(lk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep. 进入睡眠</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up. 清理</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock. 重新获得初始的锁</span></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  acquire(lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>有一个复杂情况：如果 <strong>lk</strong> 和 <strong>p-&gt;lock</strong> 是同一个锁，如果 <strong>sleep</strong> 仍试图获取 <strong>p-&gt;lock</strong>，就会和自己死锁。但是如果调用 <strong>sleep</strong> 的进程已经持有 <strong>p-&gt;lock</strong>，那么它就不需要再做任何事情来避免错过一个并发的 <strong>wakeup</strong>。这样的情况发生在，<strong>wait (kernel&#x2F;proc.c:582)</strong> 调用 <strong>sleep</strong> 并持有 <strong>p-&gt;lock</strong> 时（没看懂）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exit the current process.  Does not return.</span></span><br><span class="line"><span class="comment">// An exited process remains in the zombie state</span></span><br><span class="line"><span class="comment">// until its parent calls wait().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for a child process to exit and return its pid.</span></span><br><span class="line"><span class="comment">// Return -1 if this process has no children.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">wait</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pp</span>;</span></span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(pp = proc; pp &lt; &amp;proc[NPROC]; pp++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(pp-&gt;parent == p)&#123;</span><br><span class="line">        <span class="comment">// make sure the child isn&#x27;t still in exit() or swtch().</span></span><br><span class="line">        acquire(&amp;pp-&gt;lock);</span><br><span class="line"></span><br><span class="line">        havekids = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pp-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          <span class="comment">// Found one.</span></span><br><span class="line">          pid = pp-&gt;pid;</span><br><span class="line">          <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;pp-&gt;xstate,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(pp-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            release(&amp;pp-&gt;lock);</span><br><span class="line">            release(&amp;wait_lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          freeproc(pp);</span><br><span class="line">          release(&amp;pp-&gt;lock);</span><br><span class="line">          release(&amp;wait_lock);</span><br><span class="line">          <span class="keyword">return</span> pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;pp-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don&#x27;t have any children.</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || killed(p))&#123;</span><br><span class="line">      release(&amp;wait_lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Wait for a child to exit.</span></span><br><span class="line">    sleep(p, &amp;wait_lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>现在 <strong>sleep</strong> 持有 <strong>p-&gt;lock</strong>，而没有其他的锁，它可以通过记录它睡眠的 <strong>channel</strong>，将进程状态设置 <strong>SLEEPING</strong>，并调用 <strong>sched</strong> (kernel&#x2F;proc.c:564-567) 来使进程进入睡眠状态。稍后我们就会明白为什么在进程被标记为 <strong>SLEEPING</strong> 之前，<strong>p-&gt;lock</strong> 不会被释放（由调度器）</p>
</li>
<li><p>在某些时候，一个进程将获取条件锁（V 操作会先获得条件锁 lk，再调用 wakeup），设置睡眠等待的条件，并调用 <strong>wakeup(chan)<strong>。重要的是，</strong>wakeup</strong> 是在持有条件锁<a href="#ftn2">[2]</a>的情况下被调用的</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan. 唤醒所有在chan上睡眠的进程</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.  必须在没有任何进程锁时才能被调用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p != myproc())&#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>Wakeup</strong> 循环浏览进程表<strong>（kernel&#x2F;proc.c:582）</strong>。它获取每个被检查的进程的 <strong>p-&gt;lock</strong>，因为它可能会修改该进程的状态，也因为 <strong>p-&gt;sleep</strong> （这里应该是 p-&gt;lock 吧）确保 <strong>sleep</strong> 和 <strong>wakeup</strong> 不会相互错过。当 <strong>wakeup</strong> 发现一个进程处于状态为 <strong>SLEEPING</strong> 并有一个匹配的 <strong>chan</strong> 时，它就会将该进程的状态改为 <strong>RUNNABLE</strong>。下一次调度器运行时，就会看到这个进程已经准备好运行了</li>
</ul>
</li>
<li><p>为什么 <strong>sleep</strong> 和 <strong>wakeup</strong> 的锁规则能保证睡眠的进程不会错过 <strong>wakeup</strong>？<strong>sleep</strong> 进程从检查条件之前到标记为 <strong>SLEEPING</strong> 之后的这段时间里，持有条件锁或它自己的 <strong>p-&gt;lock</strong> 或两者都持有。调用 <strong>wakeup</strong> 的进程在 <strong>wakeup</strong> 的循环中持有这两个锁。因此，唤醒者要么在消费者检查条件之前使条件为真；要么唤醒者的 <strong>wakeup</strong> 在消费者被标记为 <strong>SLEEPING</strong> 之后检查它。 无论怎样，<strong>wakeup</strong> 就会看到这个睡眠的进程，并将其唤醒（除非有其他事情先将其唤醒）</p>
</li>
<li><p>有时会出现多个进程在同一个 <strong>channel</strong> 上睡眠的情况；例如，有多个进程从管道中读取数据。调用一次 <strong>wakeup</strong> 就会把它们全部唤醒。其中一个进程将首先运行，并获得 <strong>sleep</strong> 参数传递的锁，（就管道而言）读取数据都会在管道中等待。其他进程会发现，尽管被唤醒了，但没有数据可读。从他们的角度来看，唤醒是 “虚假的“，他们必须再次睡眠。出于这个原因，<strong>sleep</strong> 总是在一个检查条件的循环中被调用</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	acquire(&amp;s-&gt;lock);</span><br><span class="line">	<span class="keyword">while</span>(s-&gt;count == <span class="number">0</span>)</span><br><span class="line">		sleep(s, &amp;s-&gt;lock);	</span><br><span class="line">	s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果两次使用 <strong>sleep&#x2F;wakeup</strong> 不小心选择了同一个通道，也不会有害：它们会看到虚假的唤醒，上面提到的循环允许发生这种情况。<strong>sleep</strong>&#x2F;<strong>wakeup</strong> 的魅力很大程度上在于它既是轻量级的（不需要创建特殊的数据结构来充当睡眠通道），又提供了一层间接性（调用者不需要知道他们正在与哪个具体的进程交互）</p>
</li>
</ul>
<h2 id="Code-Pipes"><a href="#Code-Pipes" class="headerlink" title="Code: Pipes"></a>Code: Pipes</h2><ul>
<li><p>一个使用 <strong>sleep</strong> 和 <strong>wakeup</strong> 来同步生产者和消费者的更复杂的例子是 xv6 的管道实现。我们在第 1 章看到了管道的接口：写入管道一端的字节被复制到内核缓冲区，然后可以从管道的另一端读取。未来的章节将研究管道如何支持文件描述符，但我们现在来看一下 <strong>pipewrite</strong> 和 <strong>piperead</strong> 的实现吧</p>
</li>
<li><p>每个管道由一个结构体 <strong>pipe</strong> 表示，它包含一个锁和一个数据缓冲区。<strong>nread</strong> 和 <strong>nwrite</strong> 两个字段统计从缓冲区读取和写入的字节总数。缓冲区呈环形：<strong>buf[PIPESIZE-1]</strong> 之后写入的下一个字节是 **buf[0]**。计数不呈环形。这个约定使得实现可以区分满缓冲区 (<strong>nwrite &#x3D;&#x3D; nread+PIPESIZE</strong>) 和空缓冲区 (<strong>nwrite &#x3D;&#x3D; nread</strong>)，但这意味着对缓冲区的索引必须使用 **buf[nread % PIPESIZE]**，而不是使用 <strong>buf[nread]</strong> (<strong>nwrite</strong> 也是如此)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">  uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">  uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">  <span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">  <span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>假设对 <strong>piperead</strong> 和 <strong>pipewrite</strong> 的调用同时发生在两个不同的 CPU 上</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipewrite</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;readopen == <span class="number">0</span> || killed(pr))&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123; <span class="comment">//DOC: pipewrite-full</span></span><br><span class="line">      wakeup(&amp;pi-&gt;nread);</span><br><span class="line">      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">char</span> ch;</span><br><span class="line">      <span class="keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;pi-&gt;nread);</span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>Pipewrite</strong> <strong>(kernel&#x2F;pipe.c:77)</strong> 首先获取管道的锁，它保护了计数、数据和相关的不变式。然后，<strong>Piperead</strong> <strong>(kernel&#x2F;pipe.c:103)</strong> 也试图获取这个锁，但是不会获取成功。它在 <strong>acquire(kernel&#x2F;spinlock.c:22)</strong> （acquire 是自旋锁）中循环，等待锁的到来</li>
<li>当 <strong>piperead</strong> 等待时，<strong>pipewrite</strong> 会循环写，依次将每个字节添加到管道中 (kernel&#x2F;pipe.c:95)。在这个循环中，可能会发生缓冲区被填满的情况 (kernel&#x2F;pipe.c:85)。在这种情况下，<strong>pipewrite</strong> 调用 <strong>wakeup</strong> 来提醒所有睡眠中的 reader 有数据在缓冲区中等待，然后在 <strong>&amp;pi-&gt;nwrite</strong> 上 <strong>sleep</strong>，等待 reader 从缓冲区中取出一些字节。<strong>Sleep</strong> 函数内会释放 <strong>pi-&gt;lock</strong>，然后 <strong>pipwrite</strong> 进程睡眠</li>
</ul>
</li>
<li><p>现在 <strong>pi-&gt;lock</strong> 可用了，<strong>piperead</strong> 设法获取它并进入它的临界区：它发现 <strong>pi-&gt;nread !&#x3D; pi-&gt;nwrite (kernel&#x2F;pipe.c:110)</strong>  (<strong>pipewrite</strong> 进入睡眠状态是由于 <strong>pi-&gt;nwrite &#x3D;&#x3D; pi-&gt;nread+PIPESIZE (kernel&#x2F;pipe.c:85)</strong>)，所以它进入 for 循环，将数据从管道中复制出来 <strong>(kernel&#x2F;pipe.c:117)<strong>，并按复制的字节数增加 <strong>nread</strong>。现在又可写了，所以 <strong>piperead</strong> 在返回之前调用 <strong>wakeup (kernel&#x2F;pipe.c:124)</strong> 来唤醒在睡眠的 writer。</strong>Wakeup</strong> 找到一个在 <strong>&amp;pi-&gt;nwrite</strong> 上睡眠的进程，这个进程正在运行 <strong>pipewrite</strong>，但在缓冲区填满时停止了。它将该进程标记为 <strong>RUNNABLE</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">piperead</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="comment">// 只有缓冲区空且有人想写的时候，才会睡眠以等待写进程唤醒</span></span><br><span class="line">  <span class="keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="comment">//DOC: pipe-empty</span></span><br><span class="line">    <span class="keyword">if</span>(killed(pr))&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="comment">//DOC: piperead-sleep	</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">//DOC: piperead-copy</span></span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];</span><br><span class="line">    <span class="keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;pi-&gt;nwrite);  <span class="comment">//DOC: piperead-wakeup</span></span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>管道代码对 reader 和 writer 分别使用不同的睡眠 <strong>channel</strong>（<strong>pi-&gt;nread</strong> 和 <strong>pi-&gt;nwrite</strong>）；这可能会使系统在有多个 reader 和 writer 等待同一个管道的情况下更有效率（如果使用相同的条件变量，满的时候写进程可能唤醒另一个写进程）。管道代码在循环内 sleep，检查 sleep 条件；如果有多个 reader 和 writer，除了第一个被唤醒的进程外，其他进程都会看到条件仍然是假的，然后再次睡眠</p>
</li>
</ul>
<h2 id="Code-Wait-exit-and-kill"><a href="#Code-Wait-exit-and-kill" class="headerlink" title="Code: Wait, exit, and kill"></a>Code: Wait, exit, and kill</h2><ul>
<li><p><strong>sleep</strong> 和 <strong>wakeup</strong> 可以用于许多种需要等待的情况。在第 1 章中介绍的一个有趣的例子是，一个子进程的 <strong>exit</strong> 和其父进程的 <strong>wait</strong> 之间的交互</p>
<ul>
<li>在子进程退出的时候，父进程可能已经在 <strong>wait</strong> 中睡眠了，也可能在做别的事情；在后一种情况下，后续的 <strong>wait</strong> 调用必须观察子进程的退出，也许是在它调用 <strong>exit</strong> 之后很久。xv6 在 <strong>wait</strong> 观察到子进程退出之前，记录子进程退出的方式是让 <strong>exit</strong> 将调用进程设置为 <strong>ZOMBIE</strong> 状态，在那里停留，直到父进程的 <strong>wait</strong> 注意到它，将子进程的状态改为 <strong>UNUSED</strong>，然后复制子进程的退出状态，并将子进程的进程 ID 返回给父进程</li>
<li>如果父进程比子进程先退出，父进程就把子进程交给 <strong>init</strong> 进程，而 <strong>init</strong> 进程则循环的调用 <strong>wait</strong>；这样每个子进程都有一个 “父进程” 来清理</li>
<li>主要的实现挑战是父进程和子进程的 <strong>wait</strong> 和 <strong>exit</strong>，以及 <strong>exit</strong> 和 <strong>exit</strong> 之间可能出现竞争和死锁的情况</li>
</ul>
</li>
<li><p><strong>Wait</strong> 使用 <strong>调用进程</strong> 的 <strong>p-&gt;lock</strong> 作为条件锁（这里其实就是一个全局锁 wait_lock，可能由于 xv6 版本的原因，2023 版和之前并不相同），以避免唤醒丢失，它在开始时获取该锁<strong>（kernel&#x2F;proc.c:398）</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helps ensure that wakeups of wait()ing 有助于确保等待（wait）中的父进程（或线程）的唤醒操作不会丢失</span></span><br><span class="line"><span class="comment">// parents are not lost. helps obey the 有助于在使用 p-&gt;parent 时遵守内存模型</span></span><br><span class="line"><span class="comment">// memory model when using p-&gt;parent.</span></span><br><span class="line"><span class="comment">// must be acquired before any p-&gt;lock. 必须在获取任何 p-&gt;lock 之前获取它</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">wait_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for a child process to exit and return its pid.</span></span><br><span class="line"><span class="comment">// Return -1 if this process has no children.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">wait</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pp</span>;</span></span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(pp = proc; pp &lt; &amp;proc[NPROC]; pp++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(pp-&gt;parent == p)&#123;</span><br><span class="line">        <span class="comment">// make sure the child isn&#x27;t still in exit() or swtch().</span></span><br><span class="line">        acquire(&amp;pp-&gt;lock);</span><br><span class="line"></span><br><span class="line">        havekids = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pp-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          <span class="comment">// Found one.</span></span><br><span class="line">          pid = pp-&gt;pid;</span><br><span class="line">          <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;pp-&gt;xstate,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(pp-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            release(&amp;pp-&gt;lock);</span><br><span class="line">            release(&amp;wait_lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          freeproc(pp);</span><br><span class="line">          release(&amp;pp-&gt;lock);</span><br><span class="line">          release(&amp;wait_lock);</span><br><span class="line">          <span class="keyword">return</span> pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;pp-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don&#x27;t have any children.</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || killed(p))&#123;</span><br><span class="line">      release(&amp;wait_lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Wait for a child to exit.</span></span><br><span class="line">    sleep(p, &amp;wait_lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>然后它扫描进程表。如果它发现一个处于 <strong>ZOMBIE</strong> 状态的子进程，它释放这个子进程的资源和它的 <strong>proc</strong> 结构，将子进程的退出状态复制到提供给 <strong>wait</strong> 的地址 (如果它不是 0)，并返回子进程的 ID</li>
<li>如果 <strong>wait</strong> 找到了子进程但没有一个退出，它调用 <strong>sleep</strong> 等待其中一个子进程退出 **(kernel&#x2F;proc.c:445)**，然后再次扫描。这里，在 <strong>sleep</strong> 中释放的条件锁是等待进程的 <strong>p-&gt;lock</strong>，也就是上面提到的特殊情况</li>
<li>请注意，<strong>wait</strong> 经常持有两个锁；它在试图获取任何子锁之前，会先获取自己的锁；因此 xv6 的所有锁都必须遵守相同的锁顺序（父进程的锁，然后是子进程的锁），以避免死锁</li>
</ul>
</li>
<li><p><strong>Wait</strong> 会查看每个进程的 <strong>np-&gt;parent</strong> 来寻找它的子进程。它使用 <strong>np-&gt;parent</strong> 而不持有 <strong>np-&gt;lock</strong>，这违反了共享变量必须受锁保护的通常规则。但是 <strong>np</strong> 有可能是当前进程的祖先，在这种情况下，获取 <strong>np-&gt;lock</strong> 可能会导致死锁，因为这违反了上面提到的顺序。在这种情况下，在没有锁的情况下检查 <strong>np-&gt;parent</strong> 似乎是安全的；一个进程的父进程字段只有 “父亲“ 改变，所以如果 <strong>np-&gt;parent&#x3D;&#x3D;p</strong> 为真，除非当前进程改变它，否则该值就不会改变</p>
</li>
<li><p><strong>Exit (kernel&#x2F;proc.c:333)</strong> 记录退出状态，释放一些资源，将所有子进程交给 <strong>init</strong> 进程，在父进程处于等待状态时唤醒它，将 <strong>调用进程</strong> 标记为 <strong>zombie</strong>，并永久放弃 CPU</p>
<ul>
<li>最后的序列有点棘手。退出的进程必须持有父进程的锁（这里为全局锁 wait_lock），同时将自己状态设置为 <strong>ZOMBIE</strong> 并唤醒父进程，因为父进程的锁是条件锁，可以防止在等待中丢失 <strong>wakeup</strong>。子进程也必须持有自己的 <strong>p-&gt;lock</strong>，否则父进程可能会看到它的状态为 <strong>ZOMBIE</strong>，并在它还在运行时释放它</li>
<li>锁的获取顺序对避免死锁很重要：因为 <strong>wait</strong> 在子锁之前获取父锁，所以 <strong>exit</strong> 必须使用相同的顺序</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exit the current process.  Does not return.</span></span><br><span class="line"><span class="comment">// An exited process remains in the zombie state</span></span><br><span class="line"><span class="comment">// until its parent calls wait().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == initproc)</span><br><span class="line">    panic(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Close all open files.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[fd])&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> p-&gt;ofile[fd];</span><br><span class="line">      fileclose(f);</span><br><span class="line">      p-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  iput(p-&gt;cwd);</span><br><span class="line">  end_op();</span><br><span class="line">  p-&gt;cwd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give any children to init.</span></span><br><span class="line">  reparent(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parent might be sleeping in wait().</span></span><br><span class="line">  wakeup(p-&gt;parent);</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  p-&gt;xstate = status;</span><br><span class="line">  p-&gt;state = ZOMBIE;</span><br><span class="line"></span><br><span class="line">  release(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Jump into the scheduler, never to return.</span></span><br><span class="line">  sched();</span><br><span class="line">  panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass p&#x27;s abandoned children to init.</span></span><br><span class="line"><span class="comment">// Caller must hold wait_lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">reparent</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(pp = proc; pp &lt; &amp;proc[NPROC]; pp++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pp-&gt;parent == p)&#123;</span><br><span class="line">      pp-&gt;parent = initproc;</span><br><span class="line">      wakeup(initproc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Exit</strong> 调用了一个专门的唤醒函数 <strong>wakeup1</strong>，它只唤醒父函数，而且只有父进程在 <strong>wait</strong> 中睡眠的情况下才会去唤醒它**(kernel&#x2F;proc.c:598)**</p>
<ul>
<li>在将自己的状态设置为 <strong>ZOMBIE</strong> 之前，唤醒父进程可能看起来并不正确，但这是安全的：尽管 <strong>wakeup1</strong> 可能会导致父进程运行，但 <strong>wait</strong> 中的循环不能检查子进程，直到子进程的 <strong>p-&gt;lock</strong> 被调度器释放为止，所以 <strong>wait</strong> 不能查看退出的进程，直到 <strong>exit</strong> 将其状态设置为 <strong>ZOMBIE</strong> 之后 <strong>(kernel&#x2F;proc.c:386)</strong></li>
<li>（由于版本原因，在 2023 版中，wakeup 将父进程的状态设置为 RUNNABLE 后，被调度返回到 sleep 时，会尝试获取 wait_lock，所以只有在子进程设置好状态且释放 wait_lock 后，父进程才能重新回到 wait 循环中。当然，后边提到的调度释放子进程的 p-&gt;lock 也是一个保障）</li>
<li>所以 exit 做的就是释放一些资源，并设置为僵尸状态（不可以运行），等待父进程的 wait 释放它的其他资源，这是因为子进程调用 exit 时，它还在运行，所以它并不能直接释放一些关键资源，比如堆栈，只能等待父进程在 wait 中释放</li>
<li>下文将要提到的 kill 也是如此，它可能正在做一些重要操作，更新一些重要的数据结构，不能只更新一半就被终止，所以 kill 也不能直接摧毁一个进程，它能做的也仅仅是设置一个 flag，等待关键操作完成后返回到 trap，trap 中发现 flag 并调用 exit，最终由它的父进程的 wait 释放关键资源</li>
</ul>
</li>
<li><p><strong>exit</strong> 允许一个进程自行终止，而 <strong>kill（kernel&#x2F;proc.c:611）</strong> 则允许一个进程请求另一个进程终止</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kill the process with the given pid. 杀死具有给定pid的进程</span></span><br><span class="line"><span class="comment">// The victim won&#x27;t exit until it tries to return 受害者进程不会立即退出，直到它尝试返回到用户空间</span></span><br><span class="line"><span class="comment">// to user space (see usertrap() in trap.c). </span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid == pid)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING)&#123;</span><br><span class="line">        <span class="comment">// Wake process from sleep().</span></span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>如果让 <strong>kill</strong> 直接摧毁进程，那就太复杂了，因为相应进程可能在另一个 CPU 上执行，也许正处于更新内核数据结构的敏感序列中</p>
</li>
<li><p>因此，kill 的作用很小：它只是设置进程的 <strong>p-&gt;killed</strong>，如果它在 <strong>sleep</strong>，则 <strong>wakeup</strong> 它（在 2023 版本中，会直接设置 RUNNABLE 状态）。最终，进程会进入或离开内核，这时如果 <strong>p-&gt;killed</strong> 被设置，<strong>usertrap</strong> 中的代码会调用 <strong>exit</strong>。如果进程在用户空间运行，它将很快通过进行系统调用或因为定时器（或其他设备）中断而进入内核</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">    <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>如果进程处于睡眠状态，<strong>kill</strong> 调用 <strong>wakeup</strong> 会使进程从睡眠中返回。这是潜在的危险，因为正在等待的条件可能不为真。然而，xv6 对 <strong>sleep</strong> 的调用总是被包裹在一个 <strong>while</strong> 循环中，在 <strong>sleep</strong> 返回后重新检测条件</p>
<ul>
<li>一些对 <strong>sleep</strong> 的调用也会在循环中检测 <strong>p-&gt;killed</strong>，如果设置了 <strong>p-&gt;killed</strong>，则离开当前活动。只有当这种离开是正确的时候才会这样做。例如，管道读写代码如果设置了 <strong>killed</strong> 标志就会返回；最终代码会返回到 <strong>trap</strong>，<strong>trap</strong> 会再次检查标志并退出</li>
</ul>
</li>
<li><p>一些 xv6 <strong>sleep</strong> 循环没有检查 <strong>p-&gt;killed</strong>，因为代码处于多步骤系统调用的中间，而这个调用应该是原子的。virtio 驱动 <strong>(kernel&#x2F;virtio_disk.c:242)</strong> 就是一个例子：它没有检查 <strong>p-&gt;killed</strong>，因为磁盘操作可能是一系列写操作中的一个，而这些写操作都是为了让文件系统处于一个正确的状态而需要的。一个在等待磁盘 I&#x2F;O 时被杀死的进程不会退出，直到它完成当前的系统调用和 <strong>usertrap</strong> 看到 <strong>killed</strong> 的标志</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">virtio_disk_rw</span><span class="params">(<span class="keyword">struct</span> buf *b, <span class="type">int</span> write)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Wait for virtio_disk_intr() to say request has finished.</span></span><br><span class="line">  <span class="keyword">while</span>(b-&gt;disk == <span class="number">1</span>) &#123;</span><br><span class="line">    sleep(b, &amp;disk.vdisk_lock);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<ul>
<li>所以它的意思是：一个进程可能 sleep 等待磁盘 I&#x2F;O，这个操作是必须的，所以这时 kill 即使设置了 flag 并且唤醒这个 sleep，这个进程也不能退出，回到 trap，所以这类 xv6 sleep 循环中是没有 p-&gt;killed 检查的，因为它们不想退出，而是当完成必须的所有磁盘 I&#x2F;O 后再退出</li>
</ul>
</li>
</ul>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><ul>
<li><p>xv6 调度器实现了一个简单的调度策略，它依次运行每个进程。这种策略被称为 <strong>轮询调度(round robin)</strong></p>
<ul>
<li>真正的操作系统实现了更复杂的策略，例如，允许进程有优先级。这个策略是，一个可运行的高优先级进程将被调度器优先于一个可运行的低优先级进程</li>
<li>这些策略可能会很快变得复杂，因为经常有相互竞争的目标：例如，操作者可能还想保证公平性和高吞吐量</li>
<li>此外，复杂的策略可能会导致不尽人意的交互，如 <strong>优先级倒置(priority inversion)</strong> 和 **护航现象(convoys)**。当低优先级和高优先级进程共享一个锁时，就会发生优先级倒置，当低优先级进程获得锁时，就会阻止高优先级进程的进展。当许多高优先级进程都在等待一个获得共享锁的低优先级进程时，就会形成一个长长的等待进程的车队；一旦护航现象形成，就会持续很长时间</li>
<li>为了避免这类问题，在复杂的调度器中需要额外的机制</li>
</ul>
</li>
<li><p><strong>sleep</strong> 和 <strong>wakeup</strong> 是一种简单有效的同步方法，但还有很多其他的方法。在所有这些方法中，第一个挑战是避免我们在本章开头看到的丢失唤醒问题</p>
<ul>
<li>最初的 Unix 内核的 <strong>sleep</strong> 只是禁用了中断，这已经足够了，因为 Unix 运行在单 CPU 系统上。因为 xv6 运行在多处理器上，所以它增加了一个显式的 <strong>sleep</strong> 锁。FreeBSD 的 <strong>msleep</strong> 采用了同样的方法。Plan 9 的 <strong>sleep</strong> 使用了一个回调函数，它在进入睡眠前保持调度锁的情况下运行；这个函数的作用是在最后一刻检查 <strong>sleep</strong> 情况，以避免 <strong>wakeup</strong> 丢失。Linux 内核的 <strong>sleep</strong> 使用一个显式的进程队列，称为等待队列，而不是等待通道；队列有自己的内部锁</li>
</ul>
</li>
<li><p>在 <strong>wakeup</strong> 过程中扫描整个进程链表，寻找相匹配的 <strong>chan</strong> 的进程，效率很低。一个更好的解决方案是用一个数据结构代替 <strong>sleep</strong> 和 <strong>wakeup</strong> 中的 <strong>chan</strong>，该结构上存放着 <strong>sleep</strong> 的进程列表，比如 Linux 的等待队列</p>
<ul>
<li>Plan 9 的 <strong>sleep</strong> 和 <strong>wakeup</strong> 将该结构称为 rendezvous point 或 Rendez。许多线程库将同一个结构称为条件变量；在这种情况下，sleep 和 wakeup 的操作被称为 <strong>wait</strong> 和 <strong>signal</strong></li>
<li>所有这些机制都有相同的机制：睡眠条件被睡眠过程中原子地释放的锁保护</li>
</ul>
</li>
<li><p><strong>wakeup</strong> 唤醒了所有在某个特定 <strong>channel</strong> 上等待的进程，可能很多进程都在等待这个特定 <strong>channel</strong>。操作系统会调度所有这些进程，它们会争相检查睡眠条件。以这种方式行事的进程有时被称为 <strong>惊群效应（thundering herd）</strong>，最好避免这种情况。大多数条件变量都有两个唤醒的基元：信号（signal），唤醒一个进程；广播（broadcast），唤醒所有等待的进程</p>
</li>
<li><p>信号量通常用于同步。count 通常对应于类似于管道缓冲区中可用的字节数或一个进程拥有的僵尸子进程的数量。使用显式计数作为抽象的一部分，可以避免丢失 <strong>wakeup</strong> 的问题：有一个显式的计数，说明已经发生的唤醒次数。该计数还避免了 “虚假的” 唤醒和 <strong>惊群效应</strong> 问题</p>
</li>
<li><p>终止进程和清理进程在 xv6 中引入了很多复杂性。在大多数操作系统中，它甚至更加复杂，因为，假设被杀进程可能 <strong>trap</strong> 在内核中睡眠，而解除它的堆栈需要很多仔细的编程。许多操作系统使用显式的异常处理机制来解除堆栈，比如 <strong>longjmp</strong><a href="#ftn3">[3]</a>。此外，还有其他一些事件可以导致一个睡眠进程被唤醒，即使它正在等待的事件还没有发生。例如，当一个 Unix 进程处于睡眠状态时，另一个进程可能会向它发送一个 <strong>signal</strong>。在这种情况下，该进程将从中断的系统调用中返回，返回值为 -1，错误代码设置为 <strong>EINTR</strong>。应用程序可以检查这些值并决定做什么。xv6 不支持信号，也就不会出现这种复杂性</p>
</li>
<li><p>xv6 对 <strong>kill</strong> 的支持并不完全令人满意：有些 <strong>sleep</strong> 循环可能应该检查 <strong>p-&gt;killed</strong>。一个相关的问题是，即使是检查 <strong>p-&gt;killed</strong> 的 <strong>sleep</strong> 循环，在 <strong>sleep</strong> 和 <strong>kill</strong> 之间也会有一个竞争；<strong>kill</strong> 可能会设置 <strong>p-&gt;killed</strong>，并试图唤醒被杀进程，唤醒时刻发生在循环检查 <strong>p-&gt;killed</strong> 之后， 但在它调用 <strong>sleep</strong> 之前，就会发生。如果这个问题发生了，被杀进程不会注意到 <strong>p-&gt;killed</strong>，直到它所等待的条件发生。这可能会晚很多（例如，当 virtio 驱动返回一个被杀进程正在等待的磁盘块时），也可能永远不会发生（例如，如果被杀进程正在等待来自控制台的输入，但用户没有键入任何输入）</p>
</li>
<li><p>真正的操作系统会在常数时间内用显式的空闲列表来寻找空闲的进程，而不是在 allocproc 中进行线性时间的搜索；xv6 为了简单起见，使用了线性扫描的方式</p>
</li>
</ul>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li>Sleep 必须检查 lk !&#x3D; &amp; p-&gt;lock 以避免死锁 **(kernel&#x2F;proc.c:558-561)**。假设一种特殊情况通过将</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">     acquire(&amp;p-&gt;lock);</span><br><span class="line">     release(lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">release(lk);</span><br><span class="line">acquire(&amp;p-&gt;lock);</span><br></pre></td></tr></table></figure>

<p>这样会破坏 sleep 吗，怎样破坏</p>
<ol start="2">
<li><p>大部分进程退出时，资源清理可以通过 <strong>exit</strong> 或 <strong>wait</strong> 来完成。事实证明，关闭打开的文件一定要在<strong>exit</strong>中进行。为什么？答案和管道有关</p>
</li>
<li><p>在 xv6 中实现信号量而不使用 <strong>sleep</strong> 和 <strong>wakeup</strong> (但可以使用 <strong>spin</strong> <strong>locks</strong>)。在 xv6 中用信号量替换 <strong>sleep</strong> 和 <strong>wakeup</strong> 的使用。判断结果</p>
</li>
<li><p>修正上面提到的 <strong>kill</strong> 和 <strong>sleep</strong> 之间的竞争，使得发生在被杀进程睡眠循环检查 p-&gt;killed 之后，在它调用 sleep 之前的 kill 会使得被杀进程放弃当前系统调用</p>
</li>
<li><p>设计一个方案，让每一个睡眠循环都检查 <strong>p-&gt;killed</strong>，这样，在 <strong>virtio</strong> 驱动中的进程如果被其他进程杀死，就可以从 <strong>while</strong> 循环中快速返回</p>
</li>
<li><p>修改 xv6，当从一个进程的内核线程切换到另一个进程时，只使用一次上下文切换，而不是先切换到调度线程，再切换到另一个进程。使用一次上下文切换，产生的线程需要自己选择下一个线程，并调用 <strong>swtch</strong>。面临的挑战将是如何防止多个内核意外执行同一个线程；如何正确地进行锁定；以及如何避免死锁</p>
</li>
<li><p>修改 xv6 的调度器，当没有进程可运行时，使用 RISC-V <strong>WFI</strong>（等待中断）指令。尽量保证只要有可运行的进程等待运行，就不会有核心通过 WFI 进行暂停</p>
</li>
<li><p>锁 <strong>p-&gt;lock</strong> 保护了很多不变式，当看到某段被 <strong>p-&gt;lock</strong> 保护的 xv6 代码时，可能很难弄清楚保护了那个不变式。通过将 <strong>p-&gt;lock</strong> 拆分成几个锁，设计一个更简洁的方案</p>
</li>
</ol>
<hr>
<ol>
<li><p><a name="ftn1"></a>ra寄存器: 函数 return 地址</p>
</li>
<li><p><a name="ftn2"></a>严格地说，只是在 <strong>acquire</strong> 之后 <strong>wakeup</strong> 就足够了(也就是说，可以在 <strong>release</strong> 之后调用 <strong>wakeup</strong>)</p>
</li>
<li><p><a name="ftn3"></a>一种异常处理方式，可以去 google 下</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/22/xv6-book-chapter-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/22/xv6-book-chapter-6/" class="post-title-link" itemprop="url">xv6 book chapter 6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-22 19:43:55" itemprop="dateCreated datePublished" datetime="2024-06-22T19:43:55+08:00">2024-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-06 11:00:37" itemprop="dateModified" datetime="2024-07-06T11:00:37+08:00">2024-07-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><ul>
<li><p>大多数内核，包括 xv6，都会交错执行多个任务。一种实现交错执行任务的方式是多处理器架构：硬件系统具有多个 CPU 独立执行，如 xv6 的 RISC-V</p>
<ul>
<li>这些 CPU 共享物理 RAM，xv6 利用共享来维护所有 CPU 读写的数据结构。这种共享带来了一种可能性，即一个 CPU 读取一个数据结构，而另一个 CPU 正在中途更新它，甚至多个 CPU 同时更新同一个数据</li>
<li>如果不仔细设计，这种并行访问很可能产生不正确的结果或破坏数据结构。即使在单处理器上，内核也可能在多个线程之间切换 CPU，导致它们的执行交错</li>
<li>最后，如果中断发生的时间不对，一个设备中断处理程序可能会修改与一些可中断代码相同的数据，从而破坏数据</li>
<li>并发一词指的是由于多处理器并行、线程切换或中断而导致多个指令流交错的情况</li>
</ul>
</li>
<li><p>内核中充满了并发访问的数据。例如，两个 CPU 可以同时调用 <code>kalloc</code>，从而并发地从空闲内存链表的头部 push。内核设计者喜欢允许大量的并发，因为它可以通过并行来提高性能，提高响应速度。然而，结果是内核设计者花了很多精力来让自己确认这些存在的并发是正确的</p>
<ul>
<li>有很多方法可以写出正确的代码，有些方法比其他方法更简单。以并发下的正确性为目标的策略，以及支持这些策略的抽象，被称为并发控制技术</li>
</ul>
</li>
<li><p>根据不同的情况，xv6 使用了很多并发控制技术，且还有更多的可能尚未被实现。本章重点介绍一种广泛使用的技术:锁（lock）</p>
<ul>
<li>锁提供了互斥的功能，确保一次只有一个 CPU 可以持有一个特定的锁。如果程序员为每个共享数据项关联一个锁，并且代码在使用某项时总是持有关联的锁，那么该项每次只能由一个 CPU 使用。在这种情况下，我们说锁保护了数据项</li>
<li>虽然锁是一种简单易懂的并发控制机制，但其也带来了性能降低的缺点，因为锁将并发操作串行化了</li>
</ul>
</li>
<li><p>本章的其余部分解释了为什么 xv6 需要锁、xv6 如何实现它们以及如何使用它们</p>
</li>
</ul>
<h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><img src="/2024/06/22/xv6-book-chapter-6/Figure-6.1.png" class="" title="Figure-6.1">

<ul>
<li><p>作为我们为什么需要锁的一个例子，考虑两个进程在两个不同的 CPU 上调用 <code>wait</code>，<code>wait</code> 释放子进程的内存。因此，在每个 CPU上，内核都会调用 <code>kfree</code> 来释放子进程的内存页</p>
<ul>
<li><p>内核分配器维护了一个链表: <code>kalloc()</code> (kernel&#x2F;kalloc.c:69) 从空闲页链表中 pop 一页内存，<code>kfree()</code> (kernel&#x2F;kalloc.c:47) 将一页 push 空闲链表中</p>
</li>
<li><p>为了达到最好的性能，我们可能希望两个父进程的 <code>kfree</code> 能够并行执行，而不需要任何一个进程等待另一个进程，但是考虑到 xv6 的 <code>kfree</code> 实现，这是不正确的</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>图 6.1 更详细地说明了这种设置：链表在两个 CPU 共享的内存中，CPU 使用加载和存储指令操作链表。(在现实中，处理器有缓存，但在概念上，多处理器系统的行为就像有一个单一的共享内存一样)。如果没有并发请求，你可能会实现如下的链表 push 操作:</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span> =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">	l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">list</span> = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/06/22/xv6-book-chapter-6/Figure-6.2.png" class="" title="Figure-6.2">

<ul>
<li><p>如果单独执行，这个实现是正确的。但是，如果多个副本同时执行，代码就不正确。如果两个 CPU 同时执行 <code>push</code>，那么两个 CPU 可能都会执行图 6.1 所示的第 15 行，然后其中一个才执行第 16 行，这就会产生一个不正确的结果，如图 6.2 所示</p>
<ul>
<li>这样就会出现两个 list 元素，将 next 设为 list 的前值。当对 list 的两次赋值发生在第 16 行时，第二次赋值将覆盖第一次赋值;第一次赋值中涉及的元素将丢失</li>
</ul>
</li>
<li><p>第 16 行的丢失更新是竞争条件 (race condition) 的一个例子。竞争条件是指同时访问一个内存位置，并且至少有一次访问是写的情况</p>
<ul>
<li>竞争通常是一个错误的标志，要么是丢失更新 (如果访问是写)，要么是读取一个不完全更新的数据结构。竞争的结果取决于所涉及的两个 CPU 的确切时间，以及它们的内存操作如何被内存系统排序，这可能会使竞争引起的错误难以重现和调试</li>
<li>例如，在调试 <code>push</code> 时加入 <code>print</code> 语句可能会改变执行的时机，足以使竞争消失</li>
</ul>
</li>
<li><p>避免竞争的通常方法是使用锁。锁确保了相互排斥，因此一次只能有一个 CPU 执行 <code>push</code> 的哪一行;这就使得上面的情况不可能发生。上面代码的正确 <code>lock</code> 版本只增加了几行代码</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span>=</span><span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locklist</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push</span> <span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">	l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">	acquire(&amp;listlock);</span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">list</span> = l;</span><br><span class="line">    release(&amp;listlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>acquire</code> 和 <code>release</code> 之间的指令序列通常被称为临界区。这里的锁保护 <code>list</code></p>
</li>
<li><p>当我们说锁保护数据时，我们真正的意思是 <strong>锁保护了一些适用于数据的不变量(invariant)的集合</strong>。不变量是数据结构的属性，这些属性在不同的操作中得到维护</p>
<ul>
<li>通常情况下，一个操作的正确行为取决于操作开始时的不变量是否为真。操作可能会暂时违反不变量，但在结束前必须重新建立不变量</li>
<li>例如，在链表中，不变性是：“ list 指向列表中的第一个元素，并且每个元素的下一个字段指向下一个元素”。push 的实现暂时违反了这一不变性：在第 17 行，l 指向下一个链表元素 list，但 list 还没有指向 l（在第 18 行重新建立）</li>
<li>我们上面所研究的竞争条件之所以会发生，是因为第二个 CPU 执行了依赖于列表不变式的代码，而它们被（暂时）违反了</li>
<li>正确使用锁可以确保每次只有一个 CPU 可以对关键部分的数据结构进行操作，因此当数据结构的不变式不成立时，没有 CPU 会执行数据结构操作</li>
</ul>
</li>
<li><p>你可以把锁看成是把并发的关键部分序列化，使它们一次只运行一个，从而保存不变性（假设关键部分孤立地正确）。你也可以认为由同一个锁保护的关键部分是相互原子的 (atomic)，因此每个关键部分只看到来自更早的关键部分的完整变化，而永远不会看到部分完成的更新</p>
</li>
<li><p>虽然正确使用锁可以使不正确的代码变得正确，但锁限制了性能。例如，如果两个进程同时调用 kfree，锁会将两个调用序列化，我们在不同的 CPU 上运行它们不会获得任何好处</p>
<ul>
<li>我们说，如果多个进程同时想要同一个锁，就会发生冲突，或者说锁经历了争夺。内核设计的一个主要挑战是避免锁的争夺。</li>
<li>xv6 在这方面做得很少，但是复杂的内核会专门组织数据结构和算法来避免锁争用</li>
<li>在列表的例子中，一个内核可能会维护每个CPU 的空闲列表，只有当 CPU 的列表是空的，并且它必须从另一个 CPU 偷取内存时，才会接触另一个 CPU 的空闲列表。其他用例可能需要更复杂的设计</li>
</ul>
</li>
<li><p>锁的位置对性能也很重要。例如，在 <code>push</code> 中把 <code>acquisition</code> 移动到较早的位置也是正确的：将 <code>acquisition</code> 的调用移动到第 13 行之前是可以的。然而，这可能会降低性能，因为这样的话，对 <code>malloc</code> 的调用也会被序列化</p>
<ul>
<li>下面的 “使用锁” 一节提供了一些关于在哪里插入 <code>acquisition</code> 和 <code>release</code> 调用的指南</li>
</ul>
</li>
</ul>
<h2 id="代码：锁"><a href="#代码：锁" class="headerlink" title="代码：锁"></a>代码：锁</h2><ul>
<li>xv6 有两种类型的锁: 自旋锁 (spinlock) 和睡眠锁 (sleeplock)。我们先说说自旋锁<ul>
<li>xv6 将自旋锁表示为一个结构体 <code>spinlock</code> (kernel&#x2F;spinlock.h:2)。该结构中重要的字段是 <code>locked</code>，当锁可获得时，<code>locked</code> 为零，当锁被持有时，<code>locked</code> 为非零。从逻辑上讲，xv6 获取锁的的代码类似于:</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span><span class="comment">//doesnotwork!</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		<span class="keyword">if</span>(lk-&gt;locked == <span class="number">0</span>)&#123;</span><br><span class="line">			lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>不幸的是，这种实现并不能保证多处理器上的相互排斥。可能会出现这样的情况: 两个 CPU 同时到达 if 语句，看到 <code>lk-&gt;locked</code> 为零，然后都通过设置 <code>lk-&gt;locked=1</code> 来抢夺锁</p>
<ul>
<li>此时，两个不同的 CPU 持有锁，这就违反了互斥属性。我们需要的是让第 25 行和第 26 行作为一个原子 (即不可分割) 步骤来执行</li>
</ul>
</li>
<li><p>由于锁被广泛使用，多核处理器通常提供了一些原子版的指令</p>
<ul>
<li>在 RISC-V 上，这条指令是 <code>amoswapr,a</code>。<code>amoswap</code> 读取内存地址 <code>a</code> 处的值，将寄存器 <code>r</code> 的内容写入该地址，并将其读取的值放入 <code>r</code> 中，也就是说，它将寄存器的内容和内存地址进行了交换。它原子地执行这个序列，使用特殊的硬件来防止任何其他 CPU 使用读和写之间的内存地址</li>
</ul>
</li>
<li><p>xv6 的 <code>acquire</code> (kernel&#x2F;spinlock.c:22) 使用了可移植的 C 库调用 <code>__sync_lock_test_and_set</code>，它本质上为 <code>amoswap</code> 指令;返回值是 <code>lk-&gt;locked</code> 的旧 (被交换出来的) 内容</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock. 禁用中断避免死锁</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))	<span class="comment">// 检查当前CPU是否已经持有了这个锁，中断必须是关闭的</span></span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">// 在RISC-V中，sync_lock_test_and_set转换为一个原子的交换</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">  <span class="comment">// 告诉C编译器和处理器不要移动（重新排序）加载（loads）或存储（stores）操作在这一点之后</span></span><br><span class="line">  <span class="comment">// 以确保关键部分的内存引用严格地在获取锁之后发生</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，这会发出一个fence指令</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  <span class="comment">// 记录关于锁获取的信息，以便进行holding()和调试</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether this cpu is holding the lock. 检查当前CPU是否已经持有了这个锁，中断必须是关闭的</span></span><br><span class="line"><span class="comment">// Interrupts must be off.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">holding</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span></span><br><span class="line"><span class="comment">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span></span><br><span class="line"><span class="comment">// push_off/pop_off与intr_off()/intr_on()类似</span></span><br><span class="line"><span class="comment">// 但它们是配对的：需要两次pop_off()才能撤销两次push_off()的效果</span></span><br><span class="line"><span class="comment">// are initially off, then push_off, pop_off leaves them off.</span></span><br><span class="line"><span class="comment">// 另外，如果中断最初是关闭的，那么执行 push_off 和 pop_off 后，它们仍然保持关闭状态</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> old = intr_get();</span><br><span class="line"></span><br><span class="line">  intr_off();</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting. push_off()的嵌套深度</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>acquire</code> 函数循环交换，重试 (旋转) 直到获取了锁。每一次迭代都会将 1 交换到 <code>lk-&gt;locked</code> 中，并检查之前的值;如果之前的值为 0，那么我们已经获得了锁，并且交换将 <code>lk-&gt;locked</code> 设置为 1。如果之前的值是 1，那么其他 CPU 持有该锁，而我们原子地将 1 换成 <code>lk-&gt;locked</code> 并没有改变它的值</li>
</ul>
</li>
<li><p>一旦锁被获取，<code>acquire</code> 就会记录获取该锁的 CPU，这方便调试。<code>lk-&gt;cpu</code> 字段受到锁的保护，只有在持有锁的时候才能改变</p>
</li>
<li><p>函数 <code>release</code> (kernel&#x2F;spinlock.c:47) 与 <code>acquire</code> 相反:它清除 <code>lk-&gt;cpu</code> 字段，然后释放锁</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))	<span class="comment">// 检查当前CPU是否没有持有锁，中断必须是关闭的</span></span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// 告诉C编译器和CPU不要将加载或存储操作移动到这一点之后</span></span><br><span class="line">  <span class="comment">// 以确保在临界区内的所有存储操作在释放锁之前对其他CPU可见</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// 并且临界区内的加载操作严格在释放锁之前发生</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，这会生成一个fence指令</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0. 释放锁，等价于 lk-&gt;locked = 0 </span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard </span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// 这段代码不使用C语言的赋值操作，因为C标准暗示赋值操作可能会用多个存储指令来实现</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，sync_lock_release会转化为一个原子交换操作:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pop_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="keyword">if</span>(intr_get()) <span class="comment">// 中断必须是关闭的，否则就panic</span></span><br><span class="line">    panic(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena) <span class="comment">// 0层嵌套的pop_off()及在调用push_off()之前，中断是开启的</span></span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>从概念上讲，释放只需要给 <code>lk-&gt;locked</code> 赋值为 0</li>
<li>C 标准允许编译器用多条存储指令来实现赋值，所以 C 赋值对于并发代码来说可能是非原子性的</li>
<li>相反，<code>release</code> 使用 C 库函数 <code>__sync_lock_release</code> 执行原子赋值。这个函数也是使用了 RISC-V 的 <code>amoswap</code> 指令</li>
</ul>
</li>
</ul>
<h2 id="代码：使用锁"><a href="#代码：使用锁" class="headerlink" title="代码：使用锁"></a>代码：使用锁</h2><ul>
<li><p>xv6 在很多地方使用锁来避免竞赛条件。如上所述，<code>kalloc</code> (kernel&#x2F;kalloc.c:69) 和 <code>kfree</code> (kernel&#x2F;kalloc.c:47) 就是一个很好的例子</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>试着练习 1 和 2 看看如果这些函数省略了锁会发生什么事情。你可能会发现，很难触发不正确的行为，这说明很难可靠地测试代码是否没有锁定错误和竞争。xv6 有一些竞争也不是不可能的</li>
</ul>
</li>
<li><p>使用锁的一个难点是决定使用多少个锁，以及每个锁应该保护哪些数据和不变量。有几个基本原则</p>
<ul>
<li>首先，任何时候，当一个 CPU 可以在另一个 CPU 读或写变量的同时写入变量时，都应该使用锁来防止这两个操作重叠</li>
<li>第二，记住锁保护不变量：如果一个不变量涉及多个内存位置，通常需要用一个锁保护所有的位置，以确保不变式得到维护</li>
</ul>
</li>
<li><p>上面的规则说了什么时候需要锁，但没有说什么时候不需要锁，为了效率，不要锁太多，因为锁会降低并行性。如果并行性不重要，那么可以安排只有一个进程，而不用担心锁的问题</p>
<ul>
<li>一个简单的内核可以在多处理器上做到这一点，它有一个单一的锁，这个锁必须在进入内核时获得，并在退出内核时释放（尽管系统调用，如管道读取或等待会带来一个问题）。许多单处理器操作系统已经被改造成使用这种方法在多处理器上运行，有时被称为 “大内核锁”，但这种方法牺牲了并行性：内核中一次只能执行一个 CPU</li>
<li>如果内核做任何繁重的计算，那么使用一组更大的更细粒度的锁，这样内核可以同时在多个 CPU 上执行，效率会更高</li>
</ul>
</li>
<li><p>作为粗粒度锁的一个例子，xv6 的 kalloc.c 分配器有一个单一的空闲列表，由一个单一的锁构成。如果不同 CPU 上的多个进程试图同时分配页面，那么每个进程都必须通过在 <code>acquire</code> 中旋转来等待轮到自己。旋转会降低性能，因为这不是有用的工作</p>
<ul>
<li>如果争夺锁浪费了相当一部分 CPU 时间，也许可以通过改变分配器的设计来提高性能，使其拥有多个空闲列表，每个列表都有自己的锁，从而实现真正的并行分配（该分配器在 lockinglab 中会被重写——译者注）</li>
</ul>
</li>
<li><p>作为细粒度锁的一个例子，xv6 为每个文件都有一个单独的锁，这样操作不同文件的进程往往可以不用等待对方的锁就可以进行</p>
<ul>
<li>如果想让进程模拟写入同一文件的不同区域，文件锁方案可以做得更细。最终，锁的粒度决定需要由性能测量以及复杂性考虑来驱动</li>
<li>在后续的章节解释 xv6 的每个部分时，会提到 xv6 使用锁来处理并发性的例子。作为预览，图 6.3 列出了 xv6 中所有的锁。</li>
</ul>
</li>
</ul>
<img src="/2024/06/22/xv6-book-chapter-6/Figure-6.3.png" class="" title="Figure-6.3">

<h2 id="死锁和锁的顺序"><a href="#死锁和锁的顺序" class="headerlink" title="死锁和锁的顺序"></a>死锁和锁的顺序</h2><ul>
<li><p>如果一个穿过内核的代码路径必须同时持有多个锁，那么所有的代码路径以相同的顺序获取这些锁是很重要的。如果他们不这样做，就会有死锁的风险</p>
<ul>
<li>假设线程 T1 执行代码 path1 并获取锁 A，线程 T2 执行代码 path2 并获取锁 B，接下来 T1 会尝试获取锁 B，T2 会尝试获取锁 A，这两次获取都会无限期地阻塞，因为在这两种情况下，另一个线程都持有所需的锁，并且不会释放它，直到它的获取返回</li>
<li>为了避免这样的死锁，所有的代码路径必须以相同的顺序获取锁。对全局锁获取顺序的需求意味着锁实际上是每个函数规范的一部分: 调用者调用函数的方式必须使锁按照约定的顺序被获取</li>
</ul>
</li>
<li><p>由于 sleep 的工作方式 (见第 7 章)，xv6 有许多长度为 2 的锁序链，涉及到进程锁 ( <code>structproc</code> 中的锁)</p>
<ul>
<li><p>例如，<code>consoleintr</code> (kernel&#x2F;console.c:138) 是处理格式化字符的中断流程。当一个新数据到达时，任何正在等待控制台（终端，即 cmd）输入的进程都应该被唤醒。为此，<code>consoleintr</code> 在调用 <code>wakeup</code> 时持有 <code>cons.lock</code>，以获取进程锁来唤醒它。因此，全局避免死锁的锁顺序包括了 <code>cons.lock</code> 必须在任何进程锁之前获取的规则</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the console input interrupt handler. 控制台输入中断处理程序</span></span><br><span class="line"><span class="comment">// uartintr() calls this for input character. 输入一个字符时uartintr()调用它</span></span><br><span class="line"><span class="comment">// do erase/kill processing, append to cons.buf, 处理退格/删除操作，追加字符到cons.buf</span></span><br><span class="line"><span class="comment">// wake up consoleread() if a whole line has arrived. 唤醒consoleread()如果一整行到达</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;P&#x27;</span>)</span>:  <span class="comment">// Print process list.</span></span><br><span class="line">    <span class="title function_">procdump</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;U&#x27;</span>)</span>:  <span class="comment">// Kill line.</span></span><br><span class="line">    <span class="title function_">while</span><span class="params">(cons.e != cons.w &amp;&amp;</span></span><br><span class="line"><span class="params">          cons.buf[(cons.e<span class="number">-1</span>) % INPUT_BUF_SIZE] != <span class="string">&#x27;\n&#x27;</span>)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;H&#x27;</span>)</span>: <span class="comment">// Backspace</span></span><br><span class="line">  <span class="keyword">case</span> &#x27;\x7f&#x27;: <span class="comment">// Delete key</span></span><br><span class="line">    <span class="title function_">if</span><span class="params">(cons.e != cons.w)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)&#123;</span><br><span class="line">      c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// echo back to the user.</span></span><br><span class="line">      consputc(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;</span><br><span class="line">        <span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line">        <span class="comment">// has arrived.</span></span><br><span class="line">        cons.w = cons.e;</span><br><span class="line">        wakeup(&amp;cons.r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>文件系统代码包含 xv6 最长的锁链。例如，创建一个文件需要同时持有目录的锁、新文件的 inode 的锁、磁盘块缓冲区的锁、磁盘驱动器的 <code>vdisk_lock</code> 和调用进程的 <code>p-&gt;lock</code>。为了避免死锁，文件系统代码总是按照上一句提到的顺序获取锁</p>
</li>
</ul>
</li>
<li><p>遵守全局避免死锁的顺序可能会非常困难。有时锁的顺序与逻辑程序结构相冲突，例如，也许代码模块 M1 调用模块 M2，但锁的顺序要求 M2 中的锁在 M1 中的锁之前被获取</p>
<ul>
<li>有时锁的身份并不是事先知道的，也许是因为必须持有一个锁才能发现接下来要获取的锁的身份。这种情况出现在文件系统中，因为它在路径名中查找连续的组件，也出现在 <code>wait</code> 和 <code>exit</code> 的代码中，因为它们搜索进程表寻找子进程</li>
<li>最后，死锁的危险往往制约着人们对锁方案的细化程度，因为更多的锁往往意味着更多的死锁机会。避免死锁是内核实现的重要需求</li>
</ul>
</li>
</ul>
<h2 id="锁与中断处理"><a href="#锁与中断处理" class="headerlink" title="锁与中断处理"></a>锁与中断处理</h2><ul>
<li><p>一些 xv6 自旋锁保护的数据会被线程和中断处理程序两者使用。例如，<code>clockintr</code> 定时器中断处理程序可能会在内核线程读取<code>sys_sleep</code> (kernel&#x2F;sysproc.c:64) 中的 <code>ticks</code> 的同时，递增 <code>ticks</code> (kernel&#x2F;trap.c:163)。锁 <code>tickslock</code> 将保护两次临界区</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;n);</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>自旋锁和中断的相互作用带来了一个潜在的危险。假设 <code>sys_sleep</code> 持有 <code>tickslock</code>，而它的 CPU 接收到一个时钟中断。<code>clockintr</code> 会尝试获取 <code>tickslock</code>，看到它被持有，并等待它被释放。在这种情况下，<code>tickslock</code> 永远不会被释放：只有<code>sys_sleep</code> 可以释放它，但 <code>sys_sleep</code> 不会继续运行，直到 <code>clockintr</code> 返回。所以 CPU 会死锁，任何需要其他锁的代码也会冻结</p>
</li>
<li><p>为了避免这种情况，如果一个中断处理程序使用了自旋锁，CPU 决不能在启用中断的情况下持有该锁。xv6 则采用了更加保守的策略：当一个 CPU 获取任何锁时，xv6 总是禁用该 CPU 上的中断。中断仍然可能发生在其他 CPU 上，所以一个中断程序获取锁会等待一个线程释放自旋锁，但它们不在同一个 CPU 上</p>
</li>
<li><p>xv6 在 CPU 没有持有自旋锁时重新启用中断;它必须做一点记录来应对嵌套的临界区</p>
<ul>
<li><p><code>acquire</code> 调用 <code>push_off</code> (kernel&#x2F;spinlock.c:89) 和 <code>release</code> 调用 <code>pop_off</code> (kernel&#x2F;spinlock.c:100) 来跟踪当前 CPU 上锁的嵌套级别。当该计数达到零时，<code>pop_off</code> 会恢复最外层临界区开始时的中断启用状态</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting. push_off()的嵌套深度</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span></span><br><span class="line"><span class="comment">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span></span><br><span class="line"><span class="comment">// push_off/pop_off与intr_off()/intr_on()类似</span></span><br><span class="line"><span class="comment">// 但它们是配对的：需要两次pop_off()才能撤销两次push_off()的效果</span></span><br><span class="line"><span class="comment">// are initially off, then push_off, pop_off leaves them off.</span></span><br><span class="line"><span class="comment">// 另外，如果中断最初是关闭的，那么执行 push_off 和 pop_off 后，它们仍然保持关闭状态</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> old = intr_get();</span><br><span class="line"></span><br><span class="line">  intr_off();</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pop_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="keyword">if</span>(intr_get()) <span class="comment">// 中断必须是关闭的，否则就panic</span></span><br><span class="line">    panic(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena) <span class="comment">// 0层嵌套的pop_off()及在调用push_off()之前，中断是开启的</span></span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>intr_off</code> 和 <code>intr_on</code> 函数分别执行 RISC-V 指令来禁用和启用中断</p>
</li>
</ul>
</li>
<li><p>在设置 <code>lk-&gt;locked</code> 之前，严格调用 <code>push_off</code> 是很重要的 (kernel&#x2F;spinlock.c:28)。如果两者反过来，那么在启用中断的情况下，锁会有一个窗口 (未锁到的位置)，在未禁止中断时持有锁。在这种情况下，一个时机恰到好处的时钟中断会使系统死锁</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>同样，释放锁后才调用 <code>pop_off</code> 也很重要 (kernel&#x2F;spinlock.c:66)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="指令与存储的顺序"><a href="#指令与存储的顺序" class="headerlink" title="指令与存储的顺序"></a>指令与存储的顺序</h2><ul>
<li><p>人们很自然地认为程序是按照源代码语句出现的顺序来执行的。然而，许多编译器和 CPU 为了获得更高的性能，会不按顺序执行代码</p>
<ul>
<li>如果一条指令需要很多周期才能完成，CPU 可能会提前发出该指令，以便与其他指令重叠，避免 CPU 停顿。例如，CPU 可能会注意到在一个串行序列中，指令 A 和 B 互不依赖。CPU 可能先启动指令 B，这是因为它的输入在 A 的输入之前已经准备好了，或者是为了使 A 和 B 的执行重叠</li>
<li>编译器可以执行类似的重新排序，在一条语句的指令之前发出另一条语句的指令，由于它们原来的顺序</li>
</ul>
</li>
<li><p>编译器和 CPU 在对指令重新排序时遵循相应规则，以确保它们不会改变正确编写的串行代码的结果。然而，这些规则确实允许重排，从而改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU 的指令排序规则规则称为内存模型 (memory model)</p>
</li>
<li><p>例如，在这段 <code>push</code> 的代码中，如果编译器或 CPU 将第 4 行对应的存储移到第 6 行释放后的某个点，那将是一场灾难</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">l-&gt;data = data;</span><br><span class="line">acquire(&amp;listlock);</span><br><span class="line">l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">release(&amp;listlock);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果发生这样的重排，就会有一个指令执行的窗口。在这个窗口中，另一个 CPU 可以获取锁并观察更新的链表，但看到的是一个未初始化的 <code>list-&gt;next</code></p>
</li>
<li><p>为了告诉硬件和编译器不要执行这样的 re-ordering，xv6 在 <code>acquire</code> (kernel&#x2F;spinlock.c:22) 和 <code>release</code> (kernel&#x2F;spinlock.c:47) 中都使用了 <code>__sync_synchronize()</code>。<code>__sync_synchronize()</code> 是一个内存屏障 (memory barrier): 它告诉编译器和 CPU 不要在越过屏障重新排列任何的内存读写操作。<code>acquire</code> 和 <code>release</code> 中的屏障几乎在所有重要的情况下都会强制锁定顺序，因为 xv6 在访问共享数据的周围使用锁。第 9 章讨论了一些例外情况</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock. 禁用中断避免死锁</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))	<span class="comment">// 检查当前CPU是否已经持有了这个锁，中断必须是关闭的</span></span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">// 在RISC-V中，sync_lock_test_and_set转换为一个原子的交换</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">  <span class="comment">// 告诉C编译器和处理器不要将（重新排序）加载（loads）或存储（stores）操作移动到这一点之后</span></span><br><span class="line">  <span class="comment">// 以确保关键部分的内存引用严格地在获取锁之后发生</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，这会发出一个fence指令</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  <span class="comment">// 记录关于锁获取的信息，以便进行holding()和调试</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))	<span class="comment">// 检查当前CPU是否没有持有锁，中断必须是关闭的</span></span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// 告诉C编译器和CPU不要将加载或存储操作移动到这一点之后</span></span><br><span class="line">  <span class="comment">// 以确保在临界区内的所有存储操作在释放锁之前对其他CPU可见</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// 并且临界区内的加载操作严格在释放锁之前发生</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，这会生成一个fence指令</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0. 释放锁，等价于 lk-&gt;locked = 0 </span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard </span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// 这段代码不使用C语言的赋值操作，因为C标准暗示赋值操作可能会用多个存储指令来实现</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">// 在RISC-V上，sync_lock_release会转化为一个原子交换操作:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="睡眠锁"><a href="#睡眠锁" class="headerlink" title="睡眠锁"></a>睡眠锁</h2><ul>
<li><p>有时 xv6 需要长时间保持一个锁。例如，文件系统（第 8 章）在磁盘上读写文件内容时，会保持一个文件的锁定，这些磁盘操作可能需要几十毫秒。如果另一个进程想获取一个自旋锁，那么保持那么长的时间会导致浪费，因为第二个进程在等待锁的同时会浪费 CPU 很长时间</p>
<ul>
<li>自旋锁的另一个缺点是，一个进程在保留自旋锁的同时不能释放 CPU 并将自身转变为就绪态；我们希望做到这一点，以便在拥有自旋锁的进程等待磁盘时，其他进程可以使用 CPU</li>
<li>在持有自旋锁时释放 CPU 是非法的，因为如果第二个线程再试图获取自旋锁，可能会导致死锁；由于 <code>acquire</code> 并不能释放 CPU，第二个进程的等待可能会阻止第一个进程运行和释放锁。在持有锁的同时释放 CPU 也会违反在持有自旋锁时中断必须关闭的要求</li>
<li>因此，我们希望有一种锁，在等待获取的同时让 CPU 可以进行别的工作，并在锁被持有时允许释放 CPU，同时开放中断</li>
</ul>
</li>
<li><p>xv6 以睡眠锁 (sleeplock) 的形式提供了这样的锁。<code>acquiresleep</code> (kernel&#x2F;sleeplock.c:22) 在等待时产生 CPU，使用的技术将在第 7 章解释</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Long-term locks for processes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span> <span class="comment">// spinlock protecting this sleep lock</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="type">int</span> pid;           <span class="comment">// Process holding lock</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;lk-&gt;lk);</span><br><span class="line"><span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line"> sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line">lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  wakeup(lk);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user read()s from the console go here.</span></span><br><span class="line"><span class="comment">// copy (up to) a whole input line to dst.</span></span><br><span class="line"><span class="comment">// user_dist indicates whether dst is a user</span></span><br><span class="line"><span class="comment">// or kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">uint target;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">target = n;</span><br><span class="line">acquire(&amp;cons.lock);</span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> <span class="comment">// wait until interrupt handler has put some</span></span><br><span class="line"> <span class="comment">// input into cons.buffer.</span></span><br><span class="line"> <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">   <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">     release(&amp;cons.lock);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> c = cons.buf[cons.r++ % INPUT_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(c == C(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file</span></span><br><span class="line">   <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">     <span class="comment">// Save ^D for next time, to make sure</span></span><br><span class="line">     <span class="comment">// caller gets a 0-byte result.</span></span><br><span class="line">     cons.r--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line"> cbuf = c;</span><br><span class="line"> <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> dst++;</span><br><span class="line"> --n;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">   <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">   <span class="comment">// the user-level read().</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">release(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> target - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>在高层次上，睡眠锁有一个由 <code>spinlock</code> 保护的锁定字段，<code>acquiresleep</code> 调用 <code>sleep</code> 原子性地让渡 CPU 并释放 <code>spinlock</code>。结果就是，在 <code>acquireleep</code> 等待的时候，其他线程可以执行</li>
</ul>
</li>
<li><p>因为睡眠锁使中断处于启用状态，所以它们不能用于中断处理程序中。由于 <code>acquiresleep</code> 可能会释放 CPU，所以睡眠锁不能在自旋锁的核心代码中使用（尽管自旋锁可以在睡眠锁的核心代码中使用）</p>
</li>
<li><p>自旋锁最适合于短的关键部分，因为等待它们会浪费 CPU 时间；睡眠锁对长的操作很有效</p>
</li>
</ul>
<h2 id="现实世界"><a href="#现实世界" class="headerlink" title="现实世界"></a>现实世界</h2><ul>
<li><p>尽管对并发基元和并行进行了多年的研究，但使用锁进行编程仍然具有挑战性。通常最好是将锁隐藏在更高级别的构造中，比如同步队列，尽管 xv6 没有这样做</p>
<ul>
<li>如果您使用锁编程，明智的做法是使用一个试图识别竞争条件的工具，因为很容易错过一个需要锁的不变式</li>
</ul>
</li>
<li><p>大多数操作系统都支持 POSIX 线程（Pthreads），它允许一个用户进程在不同的 CPU 上有多个线程同时运行。Pthreads 对用户级锁、屏障等都有支持</p>
<ul>
<li>支持 Pthreads 需要操作系统的支持。例如，应该是如果一个 pthread 在系统调用中阻塞，同一进程的另一个 pthread 应该可以在该 CPU 上运行。又比如，如果一个 pthread 改变了它的进程的地址空间（比如映射或取消映射内存），内核必须安排运行同一进程线程的其他 CPU 更新它们的硬件页表以反映地址空间的变化</li>
</ul>
</li>
<li><p>可以在没有原子指令的情况下实现锁，但成本很高，大多数操作系统都使用原子指令</p>
</li>
<li><p>如果许多 CPU 试图同时获取同一个锁，那么锁的成本会很高。如果一个 CPU 的本地缓存中有一个锁，而另一个 CPU 必须获取该锁，那么更新持有该锁的缓存行的原子指令必须将该行从一个 CPU 的缓存中移到另一个 CPU 的缓存中，并且可能使缓存行的任何其他副本无效。从另一个 CPU 的缓存中获取缓存单元的代价可能比从本地缓存中获取行的代价高出一个数量级</p>
</li>
<li><p>为了避免与锁相关的代价，许多操作系统使用无锁数据结构和算法。例如，可以实现像本章开头那样的链接列表，在列表搜索过程中不需要锁，只需要一条原子指令就可以在列表中插入一个项目</p>
<ul>
<li>不过，无锁编程比有锁编程更复杂，例如，必须担心指令和内存的重新排序问题。用锁编程已经很难了，所以 xv6 避免了无锁编程的额外复杂性</li>
</ul>
</li>
</ul>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li>删去 <code>kalloc</code> (kernel&#x2F;kalloc.c:69) 中对 acquire 和 release 的调用。这似乎会给调用 kalloc 的内核代码带来问题。你觉得会发生什么？当你运行 xv6 时，和你想的一样吗？运行 <code>usertests</code> 的时候呢？如果你没有看到问题，为什么没有呢？看看你是否可以通过在 kalloc 的关键部分插入 dummy loops 来引发问题</li>
<li>假设你在 <code>kfree</code> 中注释了锁 (在恢复 <code>kalloc</code> 的锁之后)。现在可能出了什么问题？<code>kfree</code> 中缺少锁是否比 kalloc 中缺少锁的危害小？</li>
<li>如果两个 CPU 同时调用 <code>kalloc</code>，其中一个就要等待另一个，这对性能不利。修改 <code>kalloc.c</code>，使其具有更多的并行性，这样不同 CPU 对 <code>kalloc</code> 的同时调用就可以进行，而不需要等待对方</li>
<li>使用大多数操作系统都支持的 POSIX 线程 (Pthreads) 编写一个并行程序。例如，实现一个并行哈希表，并测量 put&#x2F;get 操作的数量是否随着核心数的增加而增加</li>
<li>在 xv6 中实现 Pthreads 的一个子集。即实现用户级线程库，使一个用户进程可以有 1 个以上的线程，并安排这些线程可以在不同的 CPU 上并行运行。提出一个设计，正确处理线程进行阻塞系统调用和改变其共享地址空间的问题</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/20/6-S081-Lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/20/6-S081-Lab5/" class="post-title-link" itemprop="url">Lab Copy on-write</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-20 16:39:25" itemprop="dateCreated datePublished" datetime="2024-06-20T16:39:25+08:00">2024-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-22 23:13:11" itemprop="dateModified" datetime="2024-06-22T23:13:11+08:00">2024-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>Lab Guidance：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/labs/cow.html">Lab: Copy-on-Write Fork for xv6 (mit.edu)</a></p>
</li>
<li><p>虚拟内存提供了一种程度的间接性：内核可以通过将 PTE 标记为无效或只读来拦截内存引用，从而导致页面错误，并且可以通过修改 PTE 来更改地址的含义</p>
</li>
<li><p>计算机系统中有句谚语：任何系统问题都可以通过间接层来解决</p>
</li>
<li><p>在开始前，输入：<code>git fetch &amp;&amp; git checkout cow &amp;&amp; make clean</code> 来切换到 cow 分支</p>
</li>
</ul>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ul>
<li>xv6 中的 <code>fork()</code> 系统调用将父进程的所有用户空间内存复制到子进程中，如果父进程很大，复制可以需要很长时间，更糟糕的是：子进程中，<code>fork()</code> 后面通常是 <code>exec()</code>，它丢弃了复制的内存，通常不使用大部分内存</li>
<li>另一方面，如果父进程和子进程使用一个复制页面，并且他们中的一个或两个都写它，复制确实是需要的</li>
</ul>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li>你实现写时复制（COW）<code>fork()</code> 的目标是推迟分配和复制物理内存页面，直到真正需要副本</li>
<li>COW <code>fork()</code> 仅为子进程创建一个页表，用户内存的 PTE 指向父级物理页面。COW <code>fork()</code> 将父进程和子进程中的所有用户 PTE 标记为只读。当任一进程尝试写这些 COW 页面之一时，CPU 将强制出现页面错误。内核页面错误处理程序检测此情况，为发生错误的进程分配一个物理内存页面，将原始页面复制到新页面，并修改发生错误进程中的相关 PTE 以引用新页面，PTE 标记为可写。当页面错误处理程序返回时，用户进程将能够写页面的副本了。</li>
<li>COW <code>fork()</code> 使释放实现用户内存的物理页面变得有些棘手。给定的物理页面可以被多个进程的页表引用，并且只有在最后一个引用消失时才应释放。在像 xv6 这样的简单内核中，这种记录相当简单明了，但在真正的内核中，这可能很难正确</li>
</ul>
<h1 id="Implement-copy-on-write-fork"><a href="#Implement-copy-on-write-fork" class="headerlink" title="Implement copy-on-write fork"></a>Implement copy-on-write fork</h1><ul>
<li><p>你的任务是在 xv6 内核中实现写时复制 <code>fork()</code>。如果你修改后的内核成功执行了 <code>cowtest</code> 和 <code>usertests</code>，则通过</p>
</li>
<li><p>这是一个合理的 attack 计划</p>
<ul>
<li>修改 <code>uvmcopy()</code> 以将父进程的物理页面映射到子进程，而不是分配的新的页面。对于设置了 PTE_W 的页面，在子进程和父进程的 PTE 中清除 PTE_W</li>
<li>修改 <code>usertrap()</code> 以识别页面错误。当最初的可写入 COW 页面上发生页面错误时，使用 <code>kalloc()</code> 分配一个新页面，将旧页面复制到新页面，并在设置 PTE_W 的 PTE 中设置新页面。最初只读的页面（没有 PTE_W，如文本段中的页面）应保持只读状态，并在父进程和子进程之间共享；试图写此类页面的进程应该被终止</li>
<li>确保每个物理页面在最后一次 PTE 引用消失时释放——但不是之前。做到这一点的一个好方法是为每个物理页面保留引用该页面的 “引用计数”。当 <code>kalloc()</code> 分配页面时，将页面的引用计数设置为 1。当 <code>fork()</code> 导致共享页面时，增加页面的引用计数，每次任何进程将页面从其页面表中删除时，都会减少页面的引用计数。<code>kfree()</code> 仅当其引用计数为零时，才将页面放回到空闲链表中。将这些计数保留在固定大小的整数数组中是可以的。你必须制定一个如何索引数组以及如何选择其大小的方案。例如，你可以将页面的物理地址除以 4096 对数组进行索引，并通过 <code>kalloc.c</code> 中的 <code>kinit()</code> 为数组提供等于空闲链表中页面的最高物理地址的大小。随意修改 <code>kalloc.c</code>（例如，<code>kalloc()</code> 和 <code>kfree()</code>）以保持引用计数</li>
<li>修改 <code>copyout()</code>，以便在遇到 COW 页面时使用与页面错误系统的方案</li>
</ul>
</li>
<li><p>一些提示</p>
<ul>
<li>对于每个 PTE，有一种记录它是否是 COW 映射的方法可能是有用的。你可以使用 RISC-V 中的 RSW（保留给软件）位</li>
<li><code>usertests</code> 探索了 <code>cowtest</code> 不测试的场景，所以不要忘记检查所有的测试是否通过</li>
<li>对页表标志有用的一些宏定义在 <code>kernel/riscv.h</code> 的末尾</li>
<li>如果发生 COW 页面错误，并且没有可用的内存，则应该终止进程</li>
</ul>
</li>
</ul>
<img src="/2024/06/20/6-S081-Lab5/image-20240622211042467.png" class="" title="image-20240622211042467">

<ul>
<li>在 <code>kernel/riscv.h</code> 中添加 <code>PTE_COW</code> 来标记这是一个 COW 页面</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L &lt;&lt; 4) <span class="comment">// user can access</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8) <span class="comment">// COW</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/vm.c</code> 中，修改 <code>uvmcopy()</code> 将父进程的物理内存映射到子进程的页表中，需要注意的是：<ul>
<li>只有 PTE 拥有 PTE_W 时才消除 PTE_W，添加 PTE_COW。PTE 没有 PTE_W 时有两种情况，第一种是已经是 COW 页面了，第二种是只读页面</li>
<li>在将可写页面设置为 COW 页面时有一个逻辑上的细节。当一个 PTE 拥有 PTE_W 时，将父进程的 PTE  消除 PTE_W，添加 PTE_COW，之后子进程 <code>(mappages(new, i, PGSIZE, pa, flags)</code> 映射时，由于父进程 PTE 的 <code>flags</code> 已经更新，所以子进程的相关页面也是 COW 页面了。不仅更新了父进程的可写页面为 COW 页面，之后子进程的相关也是 COW 页面了</li>
<li>映射成功后，通过 <code>add_refcount(pa)</code> （之后讨论方法的具体实现及细节）增加对应页面的引用计数</li>
<li>发生错误 <code>goto err</code> 时，调用了 <code>uvmunmap(new, 0, i / PGSIZE, 1)</code>，第四个参数为 1 表示取消映射且 <code>kfree()</code> 映射的物理内存，这也是与引用计数相关的细节，之后再讨论</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given a parent process&#x27;s page table, copy 给定一个父进程的页表，复制其内存到子进程的页表中</span></span><br><span class="line"><span class="comment">// its memory into a child&#x27;s page table.</span></span><br><span class="line"><span class="comment">// Copies both the page table and the 复制页表和物理内存</span></span><br><span class="line"><span class="comment">// physical memory.</span></span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure. 成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="comment">// frees any allocated pages on failure. 如果失败，释放任何已分配的页面</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_W) != <span class="number">0</span>) &#123;</span><br><span class="line">      *pte |= PTE_COW;</span><br><span class="line">      *pte &amp;= (~PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span> (mappages(new, i, PGSIZE, pa, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: mappages error&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    add_refcount(pa);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err:</span><br><span class="line">    uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 <code>copyout()</code> 和发生页面错误时 <code>usertrap()</code> 的处理方案相同，所以创建一个方法来解决，需要注意的是：<ul>
<li><code>va &gt; MAXVA</code> 中的 <code>MAXVA</code> 真的值得注意，不要写成 <code>MAXARG</code>（因为它，我重新写了整个实验！）</li>
<li>如果 PTE 没有 PTE_W，也没有 PTE_COW 时，说明它是一个最初的只读页面，不能写。此时 <code>usertrap()</code> 会终止写一个只读页面而造成 page fault 的进程；<code>copyout()</code> 也是一样（<code>usertests</code> 的 <code>copyout</code> 测试了它，由于这个条件没写，Debug 很久，又重新写了一次实验！！）</li>
<li>如果 PTE 没有 PTE_W，或者没有 PTE_COW，此时 PTE 是一个最初的可写页面。最后 PTE 就只能是 COW 页面了</li>
<li>如果 COW 页面的引用计数为 1，那么添加 PTE_W，消除 PTE_COW，重新变为最初的可写页面</li>
<li><code>(mappages(pagetable, PGROUNDDOWN(va), PGSIZE, pa1, flags)</code> 失败时需要 <code>kfree()</code>，当然也和引用计数有关</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">handler_COW</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa0, pa1, flags;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pte == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_U) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pa0 = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_COW) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_W) != <span class="number">0</span> || (*pte &amp; PTE_COW) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> pa0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_refcount(pa0) == <span class="number">1</span>) &#123;</span><br><span class="line">    *pte &amp;= (~PTE_COW);</span><br><span class="line">    *pte |= PTE_W;</span><br><span class="line">    <span class="keyword">return</span> pa0;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (get_refcount(pa0) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    panic(<span class="string">&quot;handle_COW: refcount &lt;= 0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((pa1 = (uint64)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  flags = PTE_FLAGS(*pte);</span><br><span class="line">  flags |= PTE_W;</span><br><span class="line">  flags &amp;= (~PTE_COW);</span><br><span class="line">  memmove((<span class="type">void</span> *)pa1, (<span class="type">void</span> *)pa0, PGSIZE);</span><br><span class="line">  uvmunmap(pagetable, PGROUNDDOWN(va), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, PGROUNDDOWN(va), PGSIZE, pa1, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *)pa1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pa1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/vm.c</code> 中，修改 <code>copyout()</code>，在遇到 COW 页面时采用上述方案</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user. 从内核复制到用户空间</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table. 复制len字节从src到给定的页表中的虚拟地址dstva</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.  返回0表示成功，-1表示失败</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="comment">// printf(&quot;here &quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    </span><br><span class="line">    pa0 = handler_COW(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/defs.h</code> 中添加 <code>handler_COW</code> 以便在 <code>usertrap()</code> 中调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm.c</span></span><br><span class="line">uint64          <span class="title function_">handler_COW</span><span class="params">(<span class="type">pagetable_t</span> pagatable, uint64 va)</span>;</span><br></pre></td></tr></table></figure>

<style>.jkziokfqwnqx{zoom: 67%;}</style><img src="/2024/06/20/6-S081-Lab5/image-20240622221123530.png" class="jkziokfqwnqx" alt="image-20240622221123530">

<ul>
<li><code>kernel/trap.c</code> 中，修改 <code>usertrap()</code> 处理由于写 COW 页面而造成的 page fault。如果写一个只读页面，立即终止这个进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">    <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span>(handler_COW(p-&gt;pagetable, va) == <span class="number">0</span>)&#123;  </span><br><span class="line">      setkilled(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">      setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/kalloc.c</code> 中创建相关结构体和方法，实现引用计数，需要注意的是：<ul>
<li>由于记录引用计数的数组属于临界资源，所以需要锁来实现互斥访问</li>
<li>由于 <code>refcount</code> 结构体变量是全局变量，所以引用计数数组中所有元素初始值为 0</li>
<li><code>PHYSTOP</code> 是物理内存地址的最大值，<code>KERNBASE</code> 是物理内存地址的最小值，在 <code>kernel/memlayout.h</code> 中定义</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[(PHYSTOP - KERNBASE) / PGSIZE];</span><br><span class="line">&#125; refcount;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_refcount</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || pa &gt;= PHYSTOP) &#123;</span><br><span class="line">    panic(<span class="string">&quot;add_refcount: index error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint64 ret;</span><br><span class="line">  pa = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  ret = ++refcount.<span class="built_in">array</span>[pa];</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_refcount</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || pa &gt;= PHYSTOP) &#123;</span><br><span class="line">    panic(<span class="string">&quot;sub_refcount: index error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pa = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  ret = --refcount.<span class="built_in">array</span>[pa];</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_refcount</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || pa &gt;= PHYSTOP) &#123;</span><br><span class="line">    panic(<span class="string">&quot;get_refcount: index error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pa = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  ret = refcount.<span class="built_in">array</span>[pa];</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kinit()</code> 初始化锁（好像并不需要，因为锁的初始值就是 0）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;refcount.lock, <span class="string">&quot;refcount&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kfree()</code>，每次调用 <code>kfree()</code> 时都会减少引用计数，只有引用计数为 0 时才真正释放物理内存，需要注意的是：<ul>
<li>经过之前的修改，每个进程在将页面从页表中删除时，都会调用 <code>kfree()</code> 释放映射的物理内存，因此最终在 <code>kfree()</code> 中减少引用计数是合理的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sub_refcount((uint64)pa) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kalloc()</code> 在分配页面时，将引用计数设置为 1，需要注意的是：<ul>
<li>只有分配成功时才设置引用计数，由于引用计数初始值为 0，加一后为 1</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r) &#123;</span><br><span class="line">    add_refcount((uint64)r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>freerange()</code>，一个回马枪，需要注意的是：<ul>
<li><code>kinit()</code> 调用了 <code>freerange()</code>，<code>freerange()</code> 对每个物理页面调用了 <code>kfree()</code> 将其添加到空闲链表</li>
<li>由于引用计数初始值都为 0，减一后不等于 0 会导致无法添加，加一保证了页面可以添加到空闲链表</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE) &#123;</span><br><span class="line">    add_refcount((uint64)p);</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/defs.h</code> 中添加相关函数原型，以便在其他文件中调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="type">int</span>             <span class="title function_">add_refcount</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">sub_refcount</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">get_refcount</span><span class="params">(uint64 pa)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; cowtest &amp;&amp; usertests</strong></li>
</ul>
<img src="/2024/06/20/6-S081-Lab5/image-20240622230114645.png" class="" title="image-20240622230114645">

<img src="/2024/06/20/6-S081-Lab5/image-20240622230857574.png" class="" title="image-20240622230857574">

<ul>
<li><strong>make grade</strong></li>
</ul>
<img src="/2024/06/20/6-S081-Lab5/image-20240622231107743.png" class="" title="image-20240622231107743">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/121418548">MIT 6.S081] Lab 6: Copy-on-Write Fork for xv6_xv6 lab cow-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16170379.html">MIT6.S081-Lab5 COW 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://ttzytt.com/2022/07/xv6_lab6_record/index.html">MIT 6.s081] Xv6 Lab6 COW 实验记录 | tzyt的博客 (ttzytt.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.expoli.tech/articles/2023/07/25/[MIT-6.s081]-Lab:-Copy-on-Write-Fork-for-xv6-experiment-record#d40c70a00c7e45e59250f5f9d4c99297">MIT 6.s081] Lab: Copy-on-Write Fork for xv6 实验记录 | 糖醋鱼的小破站 (expoli.tech)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/644779152">MIT 6.828 LAB 5 COW 代码与debug - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cstardust.github.io/2022/11/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab6-cow/">操作系统-xv6-lab6-cow | 不落辰 (cstardust.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/traver/p/15778370.html">MIT 6.S081 操作系统 LAB6:Copy-on-Write - traver - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
