<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yiweiboi.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yiweiBoi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yiweiboi.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="post-title-link" itemprop="url">代码随想录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-16 09:07:05" itemprop="dateCreated datePublished" datetime="2024-01-16T09:07:05+08:00">2024-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-25 11:07:57" itemprop="dateModified" datetime="2024-01-25T11:07:57+08:00">2024-01-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>全面：YiweiBoi</p>
<p>用户名：yiweiboi</p>
<p>密码：woainimen1314</p>
<h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43031092/article/details/105322677">Markdown如何实现多文档之间的跳转_markdown 跳转其他md文件-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_77285173/article/details/130189857">在hexo博客中插入图片的方法_hexo 博客添加图片-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_43401436/article/details/107191688">hexo博客中插入图片失败——解决思路及个人最终解决办法_hexo无法插入图片-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://acacac13.top/2021/04/25/OvertimeOfHexo-d/">解决hexo d 报超时的问题 - Blog Of AC (acacac13.top)</a></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><a href="./LeetCode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md">二分查找</a></p>
<p><a href="./LeetCode-27-%E7%A7%BB%E5%87%BA%E5%85%83%E7%B4%A0.md">移出元素</a></p>
<p><a href="./LeetCode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.md">有序数组的平方</a></p>
<p><a href="./LeetCode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.md">长度最小的子数组</a></p>
<p><a href="./LeetCode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52.md">螺旋矩阵2</a></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><a href="./LeetCode-203-%E7%A7%BB%E5%87%BA%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.md">移出链表元素</a></p>
<p><a href="./LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md">反转链表</a></p>
<p><a href="./LeetCode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.md">两两交换链表中的结点</a></p>
<p><a href="./LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.md">删除链表的倒数第N个结点</a></p>
<p><a href="./LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9802-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.md">链表相交</a></p>
<p><a href="./LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.md">环形链表2</a></p>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p><a href="./LeetCode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.md">有效的字母异位词</a></p>
<p><a href="./LeetCode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.md">两个数组的交集</a></p>
<p><a href="./LeetCode-202-%E5%BF%AB%E4%B9%90%E6%95%B0.md">快乐数</a></p>
<p><a href="./LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md">两数之和</a></p>
<p><a href="./LeetCode-454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A02.md">四数相加2</a></p>
<p><a href="./LeetCode-383-%E8%B5%8E%E9%87%91%E4%BF%A1.md">赎金信</a></p>
<p><a href="./LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.md">三数之和</a></p>
<p><a href="./LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.md">四数之和</a></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><a href="./LeetCode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.md">反转字符串</a></p>
<p><a href="./LeetCode-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22.md">反转字符串2</a></p>
<p><a href="./LeetCode-151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D.md">反转字符串中的单词</a></p>
<p><a href="./LeetCode-28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87.md">找出字符串中第一个匹配项的下标</a></p>
<p><a href="./LeetCode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.md">重复的子字符串</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/29/KMP%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/29/KMP%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">KMP算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-29 23:11:20" itemprop="dateCreated datePublished" datetime="2023-11-29T23:11:20+08:00">2023-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-15 16:10:47" itemprop="dateModified" datetime="2024-01-15T16:10:47+08:00">2024-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="KMP算法详解"><a href="#KMP算法详解" class="headerlink" title="KMP算法详解"></a>KMP算法详解</h1><ul>
<li><p>KMP算法常用来在一个字符串中匹配另一个字符串，它的核心是通过构建一个next数组，通过next数组中对应的值来快速跳转到下一个需要比较节点的位置！（原来是LeetCode28的题解的延申，这里把它独立出来方便查阅）</p>
<ul>
<li><p>首先我们要明白为什么要使用KMP算法，我们可以通过比较暴力算法和KMP算法在匹配过程中的区别：</p>
<ul>
<li>暴力算法：当原串和匹配串不匹配时，原串指针重新移动到<strong>发起点</strong>的下一个位置，匹配串的指针重新回到发起点</li>
<li>KMP算法：当原串和匹配串不匹配时，原串指针不动，匹配串检测是否有<strong>相同的前缀和后缀</strong>，如果有的话，移动到<strong>前缀的下一个位置</strong>，否则重新回到发起点</li>
</ul>
</li>
<li><p>此时，我们就需要理解什么是前缀、后缀以及什么是相同前后缀：</p>
<ul>
<li>前缀：<code>aaa*****bc</code>，那么当前字符串的前缀就是<code>aaa</code></li>
<li>后缀：同理，当前字符串的后缀就是<code>bc</code></li>
<li>相同前后缀：可以很明显的看出当前字符串没有相同的前后缀，如果字符串为<code>aaa****aa</code>，那么此时相同前后缀即为<code>aa</code></li>
</ul>
</li>
<li><p>到这里，我们就已经明白了为什么KMP算法效率更高了！</p>
<ul>
<li>在匹配过程中，暴力算法总是将原串指针移动到发起点的下一个位置，而KMP算法则保证了原串指针不会回溯，始终坚定的向前走</li>
<li>并且暴力算法的匹配串指针也总是回到发起点，而KMP算法的匹配串指针可以根据是否有相同前后缀来确定移动位置</li>
</ul>
</li>
<li><p>可能有同学要问：<strong>为什么KMP算法需要将匹配串指针移动到前缀的下一个位置呢？原串指针为什么可以保持始终前进呢？</strong></p>
<ul>
<li>假设原串为<code>abeababeabf</code>，匹配串为<code>abeabf</code></li>
<li>当第一次不匹配时，即原串中&#x3D;<code>abeaba</code>部分的字符<code>a</code>和匹配串<code>abeabf</code>中的字符<code>f</code>不匹配</li>
<li>此时匹配串<code>abeab</code>部分的相同前后缀为<code>ab</code>，我们观察原串和匹配串，由于相同前后缀，<strong>我们可以省去原串（<code>abeab</code>部分）中后缀<code>ab</code>和匹配串中（<code>abeab</code>部分）的前缀<code>ab</code>的比较</strong>，而直接从匹配串中字符<code>e</code>（前缀的下一个位置）和原串中不匹配字符<code>a</code>（后缀的下一个位置）进行比较，而不移动原串指针（讲的好乱！！！）</li>
<li>如果还还不匹配，检查匹配串中<code>ab</code>部分是否有相同前后缀，我们发现没有相同前后缀，那么此时重新从发起点进行比较</li>
</ul>
</li>
<li><p>为了不去重复的扫描匹配串（子串）中是否有相同前后缀，以及需要移动到的位置（前缀的下一个位置），我们显然可以通过预处理得到<strong>next数组</strong>，数组中每一个位置的元素值都为该下标应该跳转的目标位置</p>
</li>
<li><p><strong>同时我们发现，对于匹配串的任意一个位置而言，该位置的跳转目标位置与原串无关！</strong>举一个例子：<code>abcabd</code>中字符<code>d</code>的跳转位置一定是<code>c</code>，而与原串无关</p>
</li>
<li><p>如何通过预处理得到next数组呢？如何在时间复杂度为O（n）的基础上进行构建呢？</p>
<ul>
<li>设置两个指针，<strong>i从0开始，j从1开始，将<code>next[0]</code>初始化为0</strong></li>
<li><strong>如果<code>nums[i] == nums[j]</code>，令next[j] &#x3D; i + 1（将j的回溯位置设置为i + 1，即前缀的下一个位置），i和j同时后移</strong></li>
<li><strong>如果<code>nums[i] != nums[j]</code>，令nums[i] &#x3D; nums[j - 1]（进行回溯，回溯位置为j - 1中前缀的下一个位置），直到nums[i] &#x3D; nums[j] 或则 i &#x3D;&#x3D; 0，如果i &#x3D;&#x3D; 0还不相等，令nums[j] &#x3D; 0，i不变，j向后移</strong></li>
</ul>
</li>
<li><p>next数组的实际实现细节如下：</p>
<ul>
<li><p><strong>我们发现如果i位置发生不匹配，那么i指针回溯的位置是next[i - 1]，而在编程过程中，为了解题方便，我们通常将next数组后移一位，即i指针回溯的位置为next[i]</strong></p>
<ul>
<li>怎么实现将next数组后移一位呢？很简单：我们通过先移动再赋值的方式实现，将当前位置的相同前缀下一个位置赋值给当前位置的下一个位置！</li>
</ul>
</li>
<li><p><strong>可能有同学有一些疑问：为什么要将next[0]初始化为-1呢？</strong>其实这里并没有什么特殊含义，只是为了编程方便！</p>
</li>
<li><p>如果我们将next[0]初始化为0，可能会有如下判断语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (array[i] == array[j]) &#123; </span><br><span class="line">    i++;</span><br><span class="line">    j++;</span><br><span class="line">    next[j] = i; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 我们还需要在array[i] != array[j]时再判断i是否已经为0</span></span><br><span class="line">        j++;</span><br><span class="line">        next[j] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = next[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果我们将next[0]初始化为-1，我们就可能有如下判断语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == -<span class="number">1</span> || array[i] == array[j]) &#123; </span><br><span class="line">    i++;</span><br><span class="line">    j++;</span><br><span class="line">    next[j] = i; <span class="comment">// 如果array[i] != array[j]，i就会回溯到-1，直接通过第一个判断语句将next[j]赋值为0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    i = next[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可能有些同学又有一些疑问：<strong>为什么i从-1开始，j从0开始呢？</strong></li>
<li>如果i从0开始，j从1开始，由于我们先移动再赋值的策略，<strong>我们会跳过next[1]的赋值</strong>（虽然next[1]的值无论如何都是0，而Java数组中每个元素初始值都为0，影响不大），当然我们也可以显示的将next[1]赋值为0，但你懂的…</li>
<li>而如果i从-1开始，j从0开始，我们就不会跳过next[1]位置的赋值，<strong>而且i &#x3D;&#x3D; -1恰好是需要将 j（其实是j + 1） 赋值为0的标志</strong>，所以我们就可以顺理成章的在循环中将next[1]赋值为0，而不用额外显示赋值！很高级！！！</li>
</ul>
</li>
</ul>
</li>
<li><p>具体构建next数组实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建next数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getNext(<span class="type">char</span>[] array) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果t == -1，说明回溯到底了，当前位置i还是没有相同前后缀，通过t++、i++将i+1的回溯位置设置为0</span></span><br><span class="line">        <span class="comment">// 如果array[t] == array[i]，说明发现相同前后缀，通过t++、i++将i+1的回溯位置设置为t+1，即前缀的下一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span> || array[i] == array[j]) &#123; </span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[j] = i; <span class="comment">// 先移动再赋值，将next数组后移一位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则进行回溯</span></span><br><span class="line">            i = next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KMP算法实现代码如下：（构建next数组省略了）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] mainString = haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] subString = needle.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = getNext(subString);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; subString.length &amp;&amp; i &lt; mainString.length) &#123;</span><br><span class="line">            <span class="comment">// 如果j=-1,说明主串需要进一位再重新和子串的第一个位置开始比较</span></span><br><span class="line">            <span class="comment">// 如果相等,i++，j++,继续比较下一个</span></span><br><span class="line">            <span class="comment">// 如果不相等,j根据next表找到回溯点继续和i比较</span></span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || subString[j] == mainString[i]) &#123; </span><br><span class="line">                <span class="keyword">if</span> (j == subString.length - <span class="number">1</span>) &#123; <span class="comment">// 此时最后一个字符已经比较完成</span></span><br><span class="line">                    <span class="keyword">return</span> begin; <span class="comment">// 其实不用begin记录，直接返回i - j也可以</span></span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">                begin = i - j; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/23/LeetCode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/23/LeetCode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">LeetCode.459.重复的子字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-23 21:17:54" itemprop="dateCreated datePublished" datetime="2023-11-23T21:17:54+08:00">2023-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-16 11:58:17" itemprop="dateModified" datetime="2024-01-16T11:58:17+08:00">2024-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2023/11/23/LeetCode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/459.png" class="" title="image-20240115161254056">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// i指针指向子串的尾部</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// j指针指向原串中需要比较的位置</span></span><br><span class="line">        <span class="keyword">while</span> ((i + <span class="number">1</span>) * <span class="number">2</span> &lt;= ch.length) &#123; <span class="comment">// 子串长度需要小于等于原串长度的一半</span></span><br><span class="line">            j = i + <span class="number">1</span>; <span class="comment">// 更新比较位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; ch.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch[k] != ch[j]) <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">if</span> (k == i) k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j==ch.length，说明原串已经比较完了</span></span><br><span class="line">            <span class="comment">// k==0，说明子串也恰好比较完了，原串是子串的整数倍，防止原串比较完了但子串没有比较完的情况</span></span><br><span class="line">            <span class="comment">// 也可以判断ch.length%(i+1)==0，判断原串是否是子串的整数倍</span></span><br><span class="line">            <span class="keyword">if</span> (j == ch.length &amp;&amp; k == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li><p>可以很明显的看到，我上边的解法又是暴力算法，时间复杂度为O（n^2）！</p>
</li>
<li><p>通过看一些大佬的题解，发现这道题还有很多很有趣的解法，我会在下面一一列举！</p>
</li>
<li><p>移动匹配法：</p>
<ul>
<li><p>当一个字符串可以由重复子串构成时，如果当前字符串为s，那么对于s + s这样的字符串，其内部（不包含头尾）就一定也包含一个s！</p>
</li>
<li><p>假设字符串为<code>abcabc</code>，对于s + s字符串为<code>abcabcabcabc</code>，我们发现<code>abc(abcabc)abc</code>其内部有一个s，说明它可以由重复子串构成！</p>
</li>
<li><p>代码实现如下：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s + s;</span><br><span class="line">        <span class="keyword">return</span> str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>).contains(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于移动匹配法，我们也可以换一种思路去理解！</p>
<ul>
<li><p>对于一个可以由重复子串构成的字符串s，它可以经过有效次移动来重新得到它本身！</p>
</li>
<li><p>假设当前字符串为<code>abcabc</code>：</p>
<ul>
<li>一次移动：<code>cabcab</code>；二次移动：<code>bcabca</code>；三次移动：<code>abcabc</code>！匹配到字符串自己了！</li>
</ul>
</li>
<li><p>基于这个思想，我们可以经过至多length - 1次移动，如果还匹配不到，则不能由重复子串构成，但这样的效率很低</p>
</li>
<li><p>因此我们可以通过s + s这样的字符串，它包含了所有需要移动的字符串，比如对于字符串<code>abcabc</code>：</p>
<ul>
<li>s + s为<code>abcabcabcabc</code>，一次移动<code>abcab(cabcab)c</code>；两次移动：<code>abca(bcabca)bc</code>；三次移动：<code>abc(abcabc)abc</code>，匹配到了s！</li>
<li>移动的可能都包含在了s + s，匹配的过程就像一个滑动窗口一样！</li>
</ul>
</li>
</ul>
</li>
<li><p>KMP算法：</p>
<ul>
<li><p>是的你没有看错，KMP算法不仅可以用于匹配一个字符串中是否包含另一个字符串，也可以用来查看字符串是否可以由重复子串构成！</p>
</li>
<li><p>首先先回顾一下前后缀的定义：</p>
<ul>
<li>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</li>
<li>后缀是指不包含最后一个字符的所有以最后一个字符结尾的连续子串</li>
</ul>
</li>
<li><p>而对于可以由重复子串构成的字符串，我们应该知道：<strong>由重复子串构成的字符串中，这个字符串中最长相同前后缀不包含的子串就是最小重复子串！</strong></p>
<ul>
<li>假设字符串为<code>abababab</code>，它的最长相同前后缀为：<code>ababab</code>，那么最小重复子串为：<code>ab</code>！</li>
</ul>
</li>
<li><p>实现代码如下：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next = getNext(ch);</span><br><span class="line">        <span class="comment">// 如果拥有最长相同前后缀且最长前缀不包含的子串可以整除整个字符串长度，即表示可以由重复子串构成</span></span><br><span class="line">        <span class="keyword">return</span> next[ch.length - <span class="number">1</span>] != -<span class="number">1</span> &amp;&amp; ch.length % (ch.length - (next[ch.length - <span class="number">1</span>] + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(<span class="type">char</span>[] ch) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[ch.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; ch.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// if (i == -1 || ch[i] == ch[j]) &#123;</span></span><br><span class="line">            <span class="comment">//     i++;</span></span><br><span class="line">            <span class="comment">//     j++;</span></span><br><span class="line">            <span class="comment">//     next[j] = i;</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     i = next[i];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// 这个方法得到的next数组和以往的不太一样，之前的next数组中的元素值为当前下标需要回溯的位置(前缀的下一个位置)</span></span><br><span class="line">            <span class="comment">// 而这个方法得到的next数组中的元素值为当前下标对应的前缀的尾部</span></span><br><span class="line">            <span class="comment">// 而且这个next数组中对于没有相同前后缀回溯值位置为-1</span></span><br><span class="line">            <span class="comment">// 之前的情况是，没有相同前后缀的回溯位置为0</span></span><br><span class="line">            <span class="comment">// 这样做的目的是为了区分对于aa这种特殊情况，即使有相同前后缀，回溯位置也是0，无法和没有相同前后缀的字符串区分</span></span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">while</span> (i != -<span class="number">1</span> &amp;&amp; ch[i + <span class="number">1</span>] != ch[j]) i = next[i];</span><br><span class="line">            <span class="keyword">if</span> (ch[i + <span class="number">1</span>] == ch[j]) i++;</span><br><span class="line">            next[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其实对于KMP算法，我们还可以有另一种解题思路：<ul>
<li>因为KMP算法主要是为了查找一个字符串中是否包含另一个字符串，而对于s + s这样的字符串，我们去除首尾字符，使用KMP算法来查找内部是否包含了s</li>
<li>不仅运用了移动匹配法的基本思想：如果s可以由重复子串构成，那么s + s（除去首尾字符）一定可以包含了一个s！还结合了KMP算法的使用！</li>
<li>代码的实际实现就不列举了</li>
</ul>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="./KMP%E7%AE%97%E6%B3%95">KMP算法详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/22/LeetCode-28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/22/LeetCode-28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/" class="post-title-link" itemprop="url">LeetCode.28.找出字符串中第一个匹配项的下标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-22 21:26:44" itemprop="dateCreated datePublished" datetime="2023-11-22T21:26:44+08:00">2023-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-17 21:47:39" itemprop="dateModified" datetime="2024-01-17T21:47:39+08:00">2024-01-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2023/11/22/LeetCode-28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/28.png" class="" title="image-20240115160929756">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] hay = haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] nee = needle.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= hay.length - nee.length; i++) &#123; <span class="comment">// hay.length - nee.length防止下边的hay[i + j]越界且减少不必要的比较</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; nee.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hay[i + j] != nee[j]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == nee.length) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li><p>可以很明显的看到，这个写法是暴力算法，它的<em><em>时间复杂度为O（（m-n）</em> n）</em><em>，其中</em><strong>m为haystack的长度，n为needle的长度</strong></p>
</li>
<li><p>看了一些题解后，发现这道题可以使用<strong>KMP算法</strong>求解，接下来我会详细解释一下KMP算法的实现思路以及代码的具体实现！</p>
</li>
<li><p><strong>KMP算法详解：</strong></p>
<ul>
<li><p>首先我们要明白为什么要使用KMP算法，我们可以通过比较暴力算法和KMP算法在匹配过程中的区别：</p>
<ul>
<li>暴力算法：当原串和匹配串不匹配时，原串指针重新移动到<strong>发起点</strong>的下一个位置，匹配串的指针重新回到发起点</li>
<li>KMP算法：当原串和匹配串不匹配时，原串指针不动，匹配串检测是否有<strong>相同的前缀和后缀</strong>，如果有的话，移动到<strong>前缀的下一个位置</strong>，否则重新回到发起点</li>
</ul>
</li>
<li><p>此时，我们就需要理解什么是前缀、后缀以及什么是相同前后缀：</p>
<ul>
<li>前缀：<code>aaa*****bc</code>，那么当前字符串的前缀就是<code>aaa</code></li>
<li>后缀：同理，当前字符串的后缀就是<code>bc</code></li>
<li>相同前后缀：可以很明显的看出当前字符串没有相同的前后缀，如果字符串为<code>aaa****aa</code>，那么此时相同前后缀即为<code>aa</code></li>
</ul>
</li>
<li><p>到这里，我们就已经明白了为什么KMP算法效率更高了！</p>
<ul>
<li>在匹配过程中，暴力算法总是将原串指针移动到发起点的下一个位置，而KMP算法则保证了原串指针不会回溯，始终坚定的向前走</li>
<li>并且暴力算法的匹配串指针也总是回到发起点，而KMP算法的匹配串指针可以根据是否有相同前后缀来确定移动位置</li>
</ul>
</li>
<li><p>可能有同学要问：<strong>为什么KMP算法需要将匹配串指针移动到前缀的下一个位置呢？原串指针为什么可以保持始终前进呢？</strong></p>
<ul>
<li>假设原串为<code>abeababeabf</code>，匹配串为<code>abeabf</code></li>
<li>当第一次不匹配时，即原串中&#x3D;<code>abeaba</code>部分的字符<code>a</code>和匹配串<code>abeabf</code>中的字符<code>f</code>不匹配</li>
<li>此时匹配串<code>abeab</code>部分的相同前后缀为<code>ab</code>，我们观察原串和匹配串，由于相同前后缀，<strong>我们可以省去原串（<code>abeab</code>部分）中后缀<code>ab</code>和匹配串中（<code>abeab</code>部分）的前缀<code>ab</code>的比较</strong>，而直接从匹配串中字符<code>e</code>（前缀的下一个位置）和原串中不匹配字符<code>a</code>（后缀的下一个位置）进行比较，而不移动原串指针（讲的好乱！！！）</li>
<li>如果还还不匹配，检查匹配串中<code>ab</code>部分是否有相同前后缀，我们发现没有相同前后缀，那么此时重新从发起点进行比较</li>
</ul>
</li>
<li><p>为了不去重复的扫描匹配串（子串）中是否有相同前后缀，以及需要移动到的位置（前缀的下一个位置），我们显然可以通过预处理得到<strong>next数组</strong>，数组中每一个位置的元素值都为该下标应该跳转的目标位置</p>
</li>
<li><p><strong>同时我们发现，对于匹配串的任意一个位置而言，该位置的跳转目标位置与原串无关！</strong>举一个例子：<code>abcabd</code>中字符<code>d</code>的跳转位置一定是<code>c</code>，而与原串无关</p>
</li>
<li><p>如何通过预处理得到next数组呢？如何在时间复杂度为O（n）的基础上进行构建呢？</p>
<ul>
<li>设置两个指针，<strong>i从0开始，j从1开始，将<code>next[0]</code>初始化为0</strong></li>
<li><strong>如果<code>nums[i] == nums[j]</code>，令next[j] &#x3D; i + 1（将j的回溯位置设置为i + 1，即前缀的下一个位置），i和j同时后移</strong></li>
<li><strong>如果<code>nums[i] != nums[j]</code>，令nums[i] &#x3D; nums[j - 1]（进行回溯，回溯位置为j - 1中前缀的下一个位置），直到nums[i] &#x3D; nums[j] 或则 i &#x3D;&#x3D; 0，如果i &#x3D;&#x3D; 0还不相等，令nums[j] &#x3D; 0，i不变，j向后移</strong></li>
</ul>
</li>
<li><p>next数组的实际实现细节如下：</p>
<ul>
<li><p><strong>我们发现如果i位置发生不匹配，那么i指针回溯的位置是next[i - 1]，而在编程过程中，为了解题方便，我们通常将next数组后移一位，即i指针回溯的位置为next[i]</strong></p>
<ul>
<li>怎么实现将next数组后移一位呢？很简单：我们通过先移动再赋值的方式实现，将当前位置的相同前缀下一个位置赋值给当前位置的下一个位置！</li>
</ul>
</li>
<li><p><strong>可能有同学有一些疑问：为什么要将next[0]初始化为-1呢？</strong>其实这里并没有什么特殊含义，只是为了编程方便！</p>
</li>
<li><p>如果我们将next[0]初始化为0，可能会有如下判断语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (array[i] == array[j]) &#123; </span><br><span class="line">    i++;</span><br><span class="line">    j++;</span><br><span class="line">    next[j] = i; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 我们还需要在array[i] != array[j]时再判断i是否已经为0</span></span><br><span class="line">        j++;</span><br><span class="line">        next[j] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = next[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果我们将next[0]初始化为-1，我们就可能有如下判断语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == -<span class="number">1</span> || array[i] == array[j]) &#123; </span><br><span class="line">    i++;</span><br><span class="line">    j++;</span><br><span class="line">    next[j] = i; <span class="comment">// 如果array[i] != array[j]，i就会回溯到-1，直接通过第一个判断语句将next[j]赋值为0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    i = next[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可能有些同学又有一些疑问：<strong>为什么i从-1开始，j从0开始呢？</strong></li>
<li>如果i从0开始，j从1开始，由于我们先移动再赋值的策略，<strong>我们会跳过next[1]的赋值</strong>（虽然next[1]的值无论如何都是0，而Java数组中每个元素初始值都为0，影响不大），当然我们也可以显示的将next[1]赋值为0，但你懂的…</li>
<li>而如果i从-1开始，j从0开始，我们就不会跳过next[1]位置的赋值，<strong>而且i &#x3D;&#x3D; -1恰好是需要将 j（其实是j + 1） 赋值为0的标志</strong>，所以我们就可以顺理成章的在循环中将next[1]赋值为0，而不用额外显示赋值！很高级！！！</li>
</ul>
</li>
</ul>
</li>
<li><p>具体构建next数组实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建next数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getNext(<span class="type">char</span>[] array) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果t == -1，说明回溯到底了，当前位置i还是没有相同前后缀，通过t++、i++将i+1的回溯位置设置为0</span></span><br><span class="line">        <span class="comment">// 如果array[t] == array[i]，说明发现相同前后缀，通过t++、i++将i+1的回溯位置设置为t+1，即前缀的下一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span> || array[i] == array[j]) &#123; </span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[j] = i; <span class="comment">// 先移动再赋值，将next数组后移一位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则进行回溯</span></span><br><span class="line">            i = next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KMP算法实现代码如下：（构建next数组省略了）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] mainString = haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] subString = needle.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = getNext(subString);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; subString.length &amp;&amp; i &lt; mainString.length) &#123;</span><br><span class="line">            <span class="comment">// 如果j=-1,说明主串需要进一位再重新和子串的第一个位置开始比较</span></span><br><span class="line">            <span class="comment">// 如果相等,i++，j++,继续比较下一个</span></span><br><span class="line">            <span class="comment">// 如果不相等,j根据next表找到回溯点继续和i比较</span></span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || subString[j] == mainString[i]) &#123; </span><br><span class="line">                <span class="keyword">if</span> (j == subString.length - <span class="number">1</span>) &#123; <span class="comment">// 此时最后一个字符已经比较完成</span></span><br><span class="line">                    <span class="keyword">return</span> begin; <span class="comment">// 其实不用begin记录，直接返回i - j也可以</span></span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">                begin = i - j; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="KMP%E7%AE%97%E6%B3%95">KMP算法详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/21/LeetCode-151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/21/LeetCode-151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/" class="post-title-link" itemprop="url">LeetCode.151.反转字符串中的单词</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-21 21:28:23" itemprop="dateCreated datePublished" datetime="2023-11-21T21:28:23+08:00">2023-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-16 11:53:59" itemprop="dateModified" datetime="2024-01-16T11:53:59+08:00">2024-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2023/11/21/LeetCode-151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/151.png" class="" title="image-20240115160650140">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// StringBuilder线程不安全，但效率更高</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> ch.length - <span class="number">1</span>; <span class="comment">// 设置双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> ch.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果fast指针此时指向的是有效元素（大小写字符，数字）</span></span><br><span class="line">            <span class="keyword">if</span> ((ch[fast] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch[fast] &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch[fast] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch[fast] &lt;= <span class="string">&#x27;Z&#x27;</span>) || (ch[fast] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch[fast] &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (fast &gt;= <span class="number">0</span> &amp;&amp; ch[fast] != <span class="string">&#x27; &#x27;</span>) fast--; <span class="comment">// 在不越界的情况下，将fast移动至空格字符</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fast + <span class="number">1</span>; i &lt;= slow; i++) &#123; <span class="comment">// 将[fast + 1, slow]之间的字符（单词）追加到StringBuilder</span></span><br><span class="line">                    sb.append(ch[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(<span class="string">&quot; &quot;</span>); <span class="comment">// 在每个单词后边追加空格</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果fast此时是空格字符</span></span><br><span class="line">                <span class="keyword">while</span> (fast &gt;= <span class="number">0</span> &amp;&amp; ch[fast] == <span class="string">&#x27; &#x27;</span>) fast--; <span class="comment">// 在不越界的情况下，将fast移动至有效字符</span></span><br><span class="line">            &#125;</span><br><span class="line">            slow = fast; <span class="comment">// 更新slow</span></span><br><span class="line">        &#125;</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>); <span class="comment">// 删除最后多添加的一个空格</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li><p>思路分析：</p>
<ul>
<li><p>使用双指针法，因为要反转单词，我们需要从数组尾部向头部遍历，初始化两个指针到数组尾部</p>
</li>
<li><p>如果fast指针此时指向的是有效元素（字符或数字），fast不断向前移动，直到fast越界或者fast指向的是空格元素（无效元素）</p>
<ul>
<li>此时，fast指针可能有两种情况，fast指针 &lt; 0，越界了</li>
<li>fast指针指向了一个空格元素</li>
<li>但无论是越界还是指向了空格元素，此时我们已经读取到了一个完整的单词，范围为<code>[fast + 1, slow]</code></li>
<li>我们将这个单词追加到StringBuilder，同时在单词后追加一个空格</li>
</ul>
</li>
<li><p>如果fast指针此时指向的空格元素（无效元素），fast不断向前移动，直到fast越界或指向的是有效元素</p>
<ul>
<li>当然，此时fast同样有两种情况，如果fast越界，那么循环结束，数组读取完毕</li>
<li>如果fast指向的是有效元素，继续下一轮循环，继续读取单词</li>
</ul>
</li>
<li><p>每次循环的最后，我们需要更新slow，slow &#x3D; fast，每次更新slow同样有两种情况</p>
<ul>
<li>slow指向的是空格元素，那么下一轮循环中，fast将会跳过空格，同样更新slow</li>
<li>slow指向的是有效元素，那么下一轮循环中，开始读取单词</li>
<li>所以，我们保证了slow每次在读取单词时，它一定是指向一个单词的尾部，即保证了读取时，一个完整单词的范围始终为<code>[fast + 1， slow]</code></li>
</ul>
</li>
<li><p>读取完数组后，不要忘记删除最后一个单词后边多加的一个空格</p>
</li>
</ul>
</li>
<li><p>其实完全不需要这么麻烦！我们根本不需要使用两个指针，也不需要使用StringBuilder，代码如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] array = <span class="keyword">new</span> <span class="title class_">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; str[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i + <span class="number">1</span>; start &lt;= end; start++) &#123;</span><br><span class="line">                    array[j++] = str[start];</span><br><span class="line">                &#125;</span><br><span class="line">                array[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(array, <span class="number">0</span>, j - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查阅一些其他题解后，发现一种有趣的思路：1. 移除多余空格	2. 反转整个字符串	3. 反转每个单词，效果如下：</p>
<ul>
<li><p>源字符串为：<code>the sky is blue </code>	移除多余空格 : <code>the sky is blue</code></p>
</li>
<li><p>字符串反转：<code>eulb si yks eht</code>	单词反转：<code>blue is sky the</code></p>
</li>
<li><p>希望以后有时间再实现吧！！！</p>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/20/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/20/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">哈夫曼编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-20 22:08:50" itemprop="dateCreated datePublished" datetime="2023-11-20T22:08:50+08:00">2023-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-15 16:16:17" itemprop="dateModified" datetime="2024-01-15T16:16:17+08:00">2024-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>在创建哈夫曼树前，我们需要做一些准备，定义哈夫曼树上的节点类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanTreeNode</span> &#123; <span class="comment">// 哈夫曼树节点</span></span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">//权重</span></span><br><span class="line">    <span class="type">int</span> left; <span class="comment">// 左子节点位置</span></span><br><span class="line">    <span class="type">int</span> right; <span class="comment">// 右子节点位置</span></span><br><span class="line">    <span class="type">int</span> parent; <span class="comment">// 父节点位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HuffmanTreeNode</span><span class="params">(<span class="type">int</span> weight, <span class="type">char</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HuffmanTreeNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建哈夫曼数"><a href="#创建哈夫曼数" class="headerlink" title="创建哈夫曼数"></a>创建哈夫曼数</h1><ul>
<li>如何创建哈夫曼树？<ul>
<li>首先明确需要传入的参数，每个有效节点（叶子节点）的权值及data域</li>
<li>我们采用数组来顺序存储哈夫曼树上的节点，假设哈夫曼树有<strong>n</strong>个有效节点（叶子节点），那么根据二叉树的性质，它一定有<strong>2n - 1</strong>个节点（包含叶子节点），数组的前n个位置存放有效节点（叶子节点）</li>
<li>根据传入的权值数组和data域数组初始化好数组后，我们需要根据前n个有效节点（叶子节点）来逐渐创建哈夫曼树，建立它们和后边节点的父子关系，以及更新后边节点的权值大小（父节点权值为两个子节点权值之和）</li>
<li>我们从下标n（有效节点后的第一个节点）开始遍历数组，每次从数组前n个有效节点中选取两个权值最小的节点，将最小节点作为当前节点的左子节点，第二小节点作为当前节点的右子节点，<strong>除了设置权值外，不仅要更新父节点和两个子节点之间的关系，还要更新子节点和父节点之间的关系！</strong></li>
<li>遍历完成后，哈夫曼树就创建完成了！</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成哈夫曼树</span></span><br><span class="line"><span class="keyword">public</span> HuffmanTreeNode[] buildHuffmanTree(<span class="type">int</span>[] weight, <span class="type">char</span>[] ch) &#123;</span><br><span class="line">    <span class="comment">// n个叶子节点的哈夫曼树最终有2 * n - 1个节点</span></span><br><span class="line">    HuffmanTreeNode[] tree = <span class="keyword">new</span> <span class="title class_">HuffmanTreeNode</span>[weight.length * <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 根据权值数组创建并初始化哈夫曼树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; weight.length) &#123;</span><br><span class="line">            tree[i] = <span class="keyword">new</span> <span class="title class_">HuffmanTreeNode</span>(weight[i], ch[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tree[i] = <span class="keyword">new</span> <span class="title class_">HuffmanTreeNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从下标n开始逐渐创建哈夫曼树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> weight.length; i &lt; tree.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span>[] select = select(tree, <span class="number">0</span>, i); <span class="comment">// 选取两个最小权值节点，返回它们的下标</span></span><br><span class="line">        tree[select[<span class="number">0</span>]].parent = i; <span class="comment">// 设置两个子节点和父节点之间的关系</span></span><br><span class="line">        tree[select[<span class="number">1</span>]].parent = i;</span><br><span class="line">        tree[i].left = select[<span class="number">0</span>]; <span class="comment">// 设置父节点和子节点子之间的关系</span></span><br><span class="line">        tree[i].right = select[<span class="number">1</span>];</span><br><span class="line">        tree[i].weight = tree[select[<span class="number">0</span>]].weight + tree[select[<span class="number">1</span>]].weight; <span class="comment">// 设置父节点的权值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在前有效节点中选取两个最小权值节点：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在哈夫曼树中找到两个权值最低节点的下标(左闭右开)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] select(HuffmanTreeNode[] tree, <span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">    <span class="type">int</span>[] max = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;Integer.MAX_VALUE, Integer.MAX_VALUE&#125;;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[i].parent != <span class="number">0</span>) &#123; <span class="comment">// 如果父节点已经设置,则表示当前节点已经访问</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[i].weight &lt; max[<span class="number">0</span>]) &#123; <span class="comment">// 选取最小权值节点</span></span><br><span class="line">                max[<span class="number">0</span>] = tree[i].weight;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree[i].weight &lt; max[<span class="number">1</span>] &amp;&amp; tree[i].weight != max[<span class="number">0</span>]) &#123; <span class="comment">// 选取次小权值节点</span></span><br><span class="line">                max[<span class="number">1</span>] = tree[i].weight;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><ul>
<li>如何得到哈夫曼树对应的哈夫曼编码？<ul>
<li>首先需要明确的是，哈夫曼编码的个数是哈夫曼树中叶子节点（有效节点）的个数，因此我们需要传入的参数不仅有哈夫曼树，还有有效节点（叶子节点）的个数</li>
<li>哈夫曼编码通过二维数组进行存储，我们从第一个叶子节点开始遍历，遍历完所有叶子节点</li>
<li>在叶子节点的循环过程中，我们不断比较当前节点是父节点的左子节点还是右子节点，如果是左子节点编码为<strong>0</strong>，如果是右子节点编码为<strong>1</strong>（你也可以自己规定编码规则），直到根节点</li>
<li>因为是需要判断当父节点和当前节点之间的关系，所以我们需要创建两个变量<strong>cur和parent</strong>，并且我们注意到，我们是从叶子节点向上进行比较，所以编码也应该从后向前进行，所以<strong>start的初始值为n - 1</strong></li>
<li>遍历完成后，我们得到了这个哈夫曼树对应的哈夫曼编码！</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据得到的哈夫曼树构建哈夫曼编码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span>[][] getHuffmanCodes(HuffmanTreeNode[] tree, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">char</span>[][] codes = <span class="keyword">new</span> <span class="title class_">char</span>[n][]; <span class="comment">// 存放哈夫曼编码,大小是n,即哈夫曼树中叶子节点个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示循环过程中的当前节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示循环过程中当前节点的父节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cur = i;</span><br><span class="line">        parent = tree[cur].parent;</span><br><span class="line">        <span class="type">char</span>[] t = <span class="keyword">new</span> <span class="title class_">char</span>[n]; <span class="comment">// 临时数组,从后向前存储得到的哈夫曼编码</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> n - <span class="number">1</span>; <span class="comment">// 临时数组的开始索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录当前叶子节点哈夫曼编码长度</span></span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="number">0</span>) &#123; <span class="comment">// 找到访问到根节点</span></span><br><span class="line">            <span class="keyword">if</span> (tree[parent].left == cur) &#123; <span class="comment">// 左0</span></span><br><span class="line">                t[start--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右1</span></span><br><span class="line">                t[start--] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = parent;</span><br><span class="line">            parent = tree[parent].parent;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        codes[i] = <span class="keyword">new</span> <span class="title class_">char</span>[count];</span><br><span class="line">        <span class="comment">// 将临时数组中的哈夫曼编码拷贝到codes对应位置</span></span><br><span class="line">        System.arraycopy(t, n - count, codes[i], <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> codes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈夫曼解码"><a href="#哈夫曼解码" class="headerlink" title="哈夫曼解码"></a>哈夫曼解码</h1><ul>
<li>如何进行哈夫曼编码的解码？<ul>
<li>首先确定传入参数，要进行解码，我们需要哈夫曼树以及它对应的哈夫曼编码，根据每个有效节点（叶子节点）的哈夫曼编码在哈夫曼树上进行遍历，得到每个编码对应的有效节点（叶子节点）</li>
<li>我们进行哈夫曼编码时，<strong>是自下而上从叶子节点到根节点</strong>，解码的过程<strong>是自上而下从根节点到叶子节点</strong></li>
<li>遍历哈夫曼编码，对于每个编码，我们从根节点开始，如果当前编码是<strong>0</strong>，我们向左子节点遍历，如果是<strong>1</strong>，我们向右子节点遍历，直到当前编码遍历完为止，此时我们所处位置就是当前编码对应的叶子节点，完成解码</li>
<li>遍历所有的哈夫曼编码，将解码后的叶子节点的data域放入结果数组中，就完成解码了！</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过得到的哈夫曼编码解码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span>[] decode(<span class="type">char</span>[][] codes, HuffmanTreeNode[] tree) &#123;</span><br><span class="line">    <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[codes.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; codes.length; i++) &#123; <span class="comment">// 遍历哈夫曼编码</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> tree.length - <span class="number">1</span>; <span class="comment">// 从根节点位置开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; codes[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (codes[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 如果是0向左遍历</span></span><br><span class="line">                root = tree[root].left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是1向右遍历</span></span><br><span class="line">                root = tree[root].right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = tree[root].data; <span class="comment">// 将最终叶子节点的data域放入解码后的结果数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/20/LeetCode-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/20/LeetCode-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22/" class="post-title-link" itemprop="url">LeetCode.541.反转字符串2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-20 21:01:38" itemprop="dateCreated datePublished" datetime="2023-11-20T21:01:38+08:00">2023-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-16 11:58:41" itemprop="dateModified" datetime="2024-01-16T11:58:41+08:00">2024-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2023/11/20/LeetCode-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22/541.png" class="" title="image-20240115160435471">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= ch.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch.length - i &lt; k) &#123; <span class="comment">// 如果剩余字符少于k，将剩余字符全部反转</span></span><br><span class="line">                reverse(ch, i, ch.length - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则反转前k个（包含两种情况：1. 剩余字符小于2k大于k  2. 剩余字符大于2k</span></span><br><span class="line">                reverse(ch, i, i + k - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ch数组下标从i到j进行反转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> ch[i];</span><br><span class="line">            ch[i] = ch[j];</span><br><span class="line">            ch[j] = t;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li><p>在刚开始写这道题的时候，我犯了一个大错误：为了处理题目上的逻辑，每隔2k个字符的前k的字符，我甚至写了一堆逻辑代码还搞一个计数器来统计2k，再统计前k个字符，陷入了巨大的思维误区</p>
</li>
<li><p>想清楚了以后，其实只需要每次让下标移动2k，判断是根据范围判断反转区间就可以了</p>
</li>
<li><p><strong>因此，像这种需要一段一段的处理的情况，我们不要总想着将它细分为一步一步，这样只会陷入思维误区，让简单的事情变得麻烦！事倍功半！！！</strong></p>
</li>
<li><p>这道题还可以使用for循环进行处理，代码如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + k - <span class="number">1</span> &lt; ch.length) &#123; <span class="comment">// 如果剩余字符大于k，反转k个</span></span><br><span class="line">                reverse(ch, i, i + k - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果剩余字符小于k，反转全部</span></span><br><span class="line">                reverse(ch, i, ch.length - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ch数组下标从i到j进行反转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> ch[i];</span><br><span class="line">            ch[i] = ch[j];</span><br><span class="line">            ch[j] = t;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/20/LeetCode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/20/LeetCode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">LeetCode.344.反转字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-20 20:27:46" itemprop="dateCreated datePublished" datetime="2023-11-20T20:27:46+08:00">2023-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-16 11:56:46" itemprop="dateModified" datetime="2024-01-16T11:56:46+08:00">2024-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2023/11/20/LeetCode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/344.png" class="" title="image-20240115160305788">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> s[i];</span><br><span class="line">            s[i] = s[s.length - <span class="number">1</span> - i];</span><br><span class="line">            s[s.length - <span class="number">1</span> - i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li>当然，也可以使用双指针法进行求解，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = c;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/18/LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/18/LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/" class="post-title-link" itemprop="url">LeetCode.18.四数之和</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-18 21:47:12" itemprop="dateCreated datePublished" datetime="2023-11-18T21:47:12+08:00">2023-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-16 11:49:58" itemprop="dateModified" datetime="2024-01-16T11:49:58+08:00">2024-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2023/11/18/LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/18.png" class="" title="image-20240115160103101">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 对数组进行排序</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 对i进行去重</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 对j进行去重</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>; <span class="comment">// 创建左右指针</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] * <span class="number">1.0</span> + nums[j] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] * <span class="number">1.0</span> + nums[j] + nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(Arrays.asList(nums[i], nums[j], nums[left], nums[right])));</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++; <span class="comment">// 对left和right进行去重</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li><p>可以看到，我这次的解法还是基于三数之和的双指针法，只不过这次是四数之和，时间复杂度是O（n^3）!</p>
</li>
<li><p>这次的双指针法和三数之和比较的话，还是有很多小细节的：</p>
<ul>
<li>在对 <strong>i</strong> 进行去重时，我们不能再当<code>nums[i] &gt; target</code>时break了，因为在三数之和中，target是确定的为0的，而对于四数之和target不确定，比如<code>int[] nums = &#123;-4, -3, 0, 1&#125;; target = -6</code>，我们不能因为-4 &gt; -6就进行break</li>
<li>其实我们还可以在对 <strong>i</strong> 进行去重时进行另外的一些剪枝操作，当<code>nums[i] &gt; target &amp;&amp; nums[i] &gt; 0</code>时，我们就可以break了，因为数组排序后，我们每次都是向后寻找的，如果nums[i]已经大于0了，就不可能再找到等于target的四元组了</li>
<li>而相同的思路，对于 <strong>j</strong> 的去重，我们也可以加上当<code>nums[i] + nums[j] &gt; target &amp;&amp; nums[i] &gt; 0</code>时，可以continue</li>
<li>还有一点，因为官方在测试用例中添加了这样一个用例<code>int[] nums = &#123;1000000000，1000000000，1000000000，1000000000&#125;, target = -294967296</code>，导致int溢出，我之前的处理方式是 * 1.0进行浮点数运算来防止溢出，效率自然很低下，我们完全可以这样写<code>(long)nums[i] + nums[j] + nums[left] + nums[right]</code>，效率就有明显的提升了！</li>
</ul>
</li>
<li><p>加上一些剪枝操作后，代码入下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 对数组进行排序</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target &amp;&amp; nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 对i进行剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 对i进行去重</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] &gt; target &amp;&amp; nums[i] &gt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 对j进行剪枝</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 对j进行去重</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>; <span class="comment">// 创建左右指针</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>)nums[i] + nums[j] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>)nums[i] + nums[j] + nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(Arrays.asList(nums[i], nums[j], nums[left], nums[right])));</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++; <span class="comment">// 对left和right进行去重</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2023/11/17/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/17/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" class="post-title-link" itemprop="url">LeetCode.15.三数之和</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-17 22:02:18" itemprop="dateCreated datePublished" datetime="2023-11-17T22:02:18+08:00">2023-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-16 11:49:28" itemprop="dateModified" datetime="2024-01-16T11:49:28+08:00">2024-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><img src="/2023/11/17/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/15.1.png" class="" title="image-20240115155856662">

<img src="/2023/11/17/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/15.2.png" class="" title="image-20240115160011813">

<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 对数组进行升序排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果当前i元素已经大于0，那么后边的元素全为0，不可能构成三元组</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 对i进行去重，如果和前边的元素值相等，continue</span></span><br><span class="line">            Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">// 创建哈希表，用来对target进行去重</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123; <span class="comment">// j从i的下一个位置开始</span></span><br><span class="line">                <span class="comment">// if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; 这样的去重是错误的，因为可能会使得(0, 0, 0)这样的三元组漏掉</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">2</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] &amp;&amp; nums[j - <span class="number">1</span>] == nums[j - <span class="number">2</span>]) <span class="keyword">continue</span>; <span class="comment">// 对j进行去重，如果j前两个有效元素都和j相等，才可以continue</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span> - nums[i] - nums[j]; </span><br><span class="line">                <span class="keyword">if</span> (set.contains(target)) &#123; <span class="comment">// 如果哈希表中存在目标值</span></span><br><span class="line">                    list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(Arrays.asList(nums[i], nums[j], target))); <span class="comment">// 放入结果list</span></span><br><span class="line">                    set.remove(target); <span class="comment">// 对target进行去重，移出target</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    set.add(nums[j]); <span class="comment">// 否则添加j元素值。这是一种小技巧，不需要另外一个循环将元素值放入哈希表，而是在遍历过程中一边在哈希表中寻找，一边填充哈希表</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><ul>
<li><p>这道题我做了很久都没有做出来，主要是因为对于三元组的去重操作模糊不清晰，没有确定有效的去重方法。当然，这些都建立在我一开始没有对数组进行排序的情况下，在看了一些题解后，通过将数组进行升序排序，一些去重操作就变得比较容易理解了</p>
</li>
<li><p>思路分析：</p>
<ul>
<li><p>对数组进行升序排序</p>
</li>
<li><p>对于第一个for循环中的 <strong>i</strong> 进行去重</p>
<ul>
<li>当<code>nums[i] &gt; 0</code>时，因为是升序排序，后边的元素值都大于0，因为我们是从前向后进行构建三元组的，后边已经不可能在使得sum &#x3D; 0了</li>
<li>当<code>i &lt; 0 &amp;&amp; nums[i] == nums[i - 1]</code>，当当前元素值等于前一个元素值时continue，有一个小疑问？为什么不是<code>nums[i] == nums[i + 1]</code>时continue呢，因为这样的话会跳过一些诸如<code>(-1, -1, 2)</code>这样的三元组，我们需要和已经判断过的元素进行比较，这样就不会漏掉了</li>
</ul>
</li>
<li><p>对第二个for循环中的 <strong>j</strong> 进行去重</p>
<ul>
<li>当<code>j &gt; i + 2 &amp;&amp; nums[j] == nums[j - 1] &amp;&amp; nums[j - 1] == nums[j - 2]</code>，去重continue，可能又有同学要问，为什么不是<code>j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]</code>？因为这样的去重操作可能会使得(0, 0, 0)这样的三元组漏掉</li>
</ul>
</li>
<li><p>对第三个值<strong>target</strong>进行去重</p>
<ul>
<li>在第一个循环中创建一个哈希表作为辅助，在第二个for循环中查找哈希表中是否有target</li>
<li>如果有，就放入结果集合，在将哈希表中的target移除进行去重</li>
<li>如果没有，就将当前nums[j] 放入哈希表中</li>
<li>其实这是一个<strong>小技巧</strong>，在遍历的寻找target的过程中，不断的将哈希表进行填充，而不是再额外的通过一个for循环将需要的元素放入哈希表中</li>
</ul>
</li>
</ul>
</li>
<li><p>然而上边的代码效率较低，时间复杂度为O（n^2），通过看一些题解，还有另一种双指针法，代码如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 对数组进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 对i进行去重</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>; <span class="comment">// 设置左右指针</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123; </span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果sum太大，通过right左移使得sum减小</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果sum太小，通过left右移使得sum增大</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果sum = 0</span></span><br><span class="line">                    <span class="comment">// 不能先去重再将结果放入list，先进行下边的去重操作，可能会导致(0, 0, 0)这样的三元组漏掉</span></span><br><span class="line">                    list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(Arrays.asList(nums[i], nums[left], nums[right]))); <span class="comment">// 将当前结果放入结果list</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++; <span class="comment">// 对left进行去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--; <span class="comment">// 对right进行去重</span></span><br><span class="line">                    left++; <span class="comment">// 双指针进行收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>思路分析：</p>
<ul>
<li><p>对数组进行排序</p>
</li>
<li><p>对于第一个for循环中的 <strong>i</strong> 进行去重</p>
<ul>
<li>操作和之前一样，就不再说明了</li>
</ul>
</li>
<li><p>在for循环中设置左右指针，左指针 &#x3D; i + 1，右指针 &#x3D; nums.length - 1，sum &#x3D; nums[i] + nums[left] + nums[right]</p>
</li>
<li><p>通过while循环不断查找三元组，改变左右指针</p>
<ul>
<li>如果sum &lt; 0，通过left 左移使得 sum增大</li>
<li>如果sum &gt; 0，通过right 右移使得 sum减小</li>
<li>如果sum &#x3D;&#x3D; 0，将当前三元组放入结果集合，再对left 和 right进行去重操作<ul>
<li>通过<code>while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++</code>对left进行去重</li>
<li>通过<code>while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--</code>对right进行去重</li>
<li>去重以后，左右指针收缩</li>
</ul>
</li>
</ul>
</li>
<li><p>不能先去重，再将三元组放入结果集合，因为可能会导致(0, 0, 0)这样的三元组漏掉</p>
</li>
</ul>
</li>
<li><p>双指针法的时间复杂度为O（n^2），可能有同学要问了，为什么哈希表和双指针法的时间复杂度都是O（n ^2），<strong>为什么双指针法的效率更高呢？</strong></p>
</li>
<li><p>因为在使用哈希法通过使用两层for循环的时候，<strong>能做的去重操作很有限</strong>，虽然时间复杂度是O(n^2)，可是在leetcode上执行的时间依然比较长，而双指针法的去重操作则很有效，因此效率更高！</p>
</li>
<li><p>还有就是<strong>对于排序</strong>，为什么这道题可以使用双指针法呢，因为双指针法一定要排序，如果一道题需要排序的话，那么这道题可能就可以使用双指针法来进行求解！</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
