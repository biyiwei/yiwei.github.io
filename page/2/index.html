<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yiweiboi.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yiweiBoi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yiweiboi.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/05/xv6-book-chapter-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/05/xv6-book-chapter-4/" class="post-title-link" itemprop="url">xv6 book chapter 4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-05 20:02:43" itemprop="dateCreated datePublished" datetime="2024-06-05T20:02:43+08:00">2024-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-22 18:36:46" itemprop="dateModified" datetime="2024-06-22T18:36:46+08:00">2024-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h1><ul>
<li><p>有三种事件会导致 CPU 搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码</p>
<ul>
<li>一种情况是 <strong>系统调用</strong>，当用户程序执行 <strong>ecall</strong> 指令要求内核为其做某事时</li>
<li>另一种情况是 <strong>异常</strong>：一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址</li>
<li>第三种情况是设备 <strong>中断</strong>，当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时</li>
</ul>
</li>
<li><p>本书使用 <strong>trap</strong> 作为这些情况的通用术语</p>
<ul>
<li>通常，代码在执行时发生 trap，之后都会被恢复，而且不需要意识到发生了什么特殊的事情</li>
<li>也就是说，我们通常希望 trap 是透明的；这一点对于中断来说尤其重要，被中断的代码通常不会意识到会发生 trap</li>
<li>通常的顺序是：trap 迫使控制权转移到内核；内核保存寄存器和其他状态，以便恢复执行；内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；内核恢复保存的状态，并从 trap 中返回；代码从原来的地方恢复执行</li>
</ul>
</li>
<li><p>xv6 内核会处理所有的 trap</p>
<ul>
<li>这对于系统调用来说是很自然的</li>
<li>这对中断来说也是合理的，因为隔离要求用户进程不能直接使用设备，而且只有内核才有设备处理所需的状态</li>
<li>这对异常处理来说也是合理的，因为 xv6 响应所有来自用户空间的异常，并杀死该违规程序</li>
</ul>
</li>
<li><p>xv6 trap 处理分为四个阶段：</p>
<ul>
<li>RISC-V CPU 采取的硬件行为，为内核 C 代码准备的汇编入口，处理 trap 的 C 处理程序，以及系统调用或设备驱动服务</li>
<li>虽然三种 trap 类型之间的共性表明，内核可以用单一的代码入口处理所有的 trap，但事实证明，为三种不同的情况，即来自用户空间的 trap、来自内核空间的 trap 和定时器中断，设置单独的汇编入口和 C trap 处理程序会更方便的</li>
</ul>
</li>
</ul>
<h2 id="RISC-V-trap-machinery-RISC-V-陷阱处理机制"><a href="#RISC-V-trap-machinery-RISC-V-陷阱处理机制" class="headerlink" title="RISC-V trap machinery RISC-V 陷阱处理机制"></a>RISC-V trap machinery RISC-V 陷阱处理机制</h2><ul>
<li><p>每个 RISC-V CPU 都有一组控制寄存器，内核写入这些寄存器来告诉 CPU 如何处理 trap，内核可以通过读取这些寄存器来发现已经发生的 trap</p>
<ul>
<li>RISC-V 文档包含了完整的叙述[1]</li>
<li><code>riscv.h</code>（kernel&#x2F;riscv.h:1）包含了 xv6 使用的定义。这里是最重要的寄存器的概述</li>
</ul>
<ul>
<li><p><code>stvec</code>：内核在这里写下 trap 处理程序的地址；RISC-V 跳转到这里来处理 trap</p>
</li>
<li><p><code>sepc</code>：当 trap 发生时，RISC-V 会将程序计数器保存在这里（因为 <code>PC</code> 会被 <code>stvec</code> 覆盖）</p>
<ul>
<li><code>sret</code>（从 trap 中返回）指令将 <code>sepc</code> 复制到 <code>pc</code> 中。内核可以写 <code>sepc</code> 来控制 <code>sret</code> 的返回到哪里</li>
</ul>
</li>
<li><p><code>scause</code>：RISC -V 在这里放了一个数字，描述了 trap 的原因</p>
</li>
<li><p><code>sscratch</code>：内核在这里放置了一个值，在 trap 处理程序开始时可以方便地使用</p>
</li>
<li><p><code>sstatus</code>：<code>sstatus</code> 中的 <strong>SIE</strong> 位控制设备中断是否被启用，如果内核清除 <strong>SIE</strong>，RISC-V 将推迟设备中断，直到内核设置 <strong>SIE</strong></p>
<ul>
<li><strong>SPP</strong> 位表示 trap 是来自用户模式还是 supervisor 模式，并控制 <code>sret</code> 返回到什么模式</li>
</ul>
</li>
</ul>
</li>
<li><p>上述寄存器与在特权态模式下处理的 trap 有关，在用户模式下不能读或写</p>
<ul>
<li>对于机器模式下处理的 trap，有一组等效的控制寄存器；xv6 只在定时器中断的特殊情况下使用它们</li>
</ul>
</li>
<li><p>多核芯片上的每个 CPU 都有自己的一组这些寄存器，而且在任何时候都可能有多个 CPU 在处理一个 trap</p>
</li>
<li><p>当需要执行 trap 时，RISC-V 硬件对所有的 trap 类型（除定时器中断外）进行以下操作：</p>
<ul>
<li><p>如果该 trap 是设备中断，且 <code>sstatus</code> <strong>SIE</strong> 位为 0，则不执行以下任何操作</p>
</li>
<li><p>通过清除 SIE 来禁用中断</p>
</li>
<li><p>复制 <code>pc</code> 到 <code>sepc</code></p>
</li>
<li><p>将当前模式（用户态或特权态）保存在 <code>sstatus</code> 的 <strong>SPP</strong> 位</p>
</li>
<li><p>在 <code>scause</code> 设置该次 trap 的原因</p>
</li>
<li><p>将模式转换为特权态</p>
</li>
<li><p>将 <code>stvec</code> 复制到 <code>pc</code></p>
</li>
<li><p>从新的 <code>pc</code> 开始执行</p>
</li>
</ul>
</li>
<li><p>注意，CPU 不会切换到内核页表，不会切换到内核中的栈，也不会保存 pc 以外的任何寄存器</p>
<ul>
<li>内核软件必须执行这些任务</li>
<li>CPU 在 trap 期间做很少的工作的一个原因是为了给软件提供灵活性，例如，一些操作系统在某些情况下不需要页表切换，这可以提高性能</li>
</ul>
</li>
<li><p>你可能会想 CPU 的 trap 处理流程是否可以进一步简化</p>
<ul>
<li>例如，假设 CPU 没有切换程序计数器（pc）</li>
<li>那么 trap 可以切换到监督者模式时，还在运行用户指令。这些用户指令可以打破用户空间&#x2F;内核空间的隔离，例如通过修改 <code>satp</code> 寄存器指向一个允许访问所有物理内存的页表</li>
<li>因此，CPU 必须切换到内核指定的指令地址，即 <code>stvec</code></li>
</ul>
</li>
</ul>
<blockquote>
<p> 在进入 trampoline.S 之前，ecall 指令做了三件事情：</p>
<p> 保存用户 pc，将权限提升到内核模式，更改 pc 为 trampoline.S 的起始地址并跳转到 trampoline.S</p>
</blockquote>
<h2 id="Traps-from-user-space-来自用户空间的陷阱"><a href="#Traps-from-user-space-来自用户空间的陷阱" class="headerlink" title="Traps from user space 来自用户空间的陷阱"></a>Traps from user space 来自用户空间的陷阱</h2><ul>
<li><p>在用户空间执行时，如果用户程序进行了系统调用（<code>ecall</code> 指令），或者做了一些非法的事情，或者设备中断，都可能发生 trap</p>
<ul>
<li>来自用户空间的 trap 的处理路径是 <code>uservec</code>（kernel&#x2F;trampoline.S:16），然后是 <code>usertrap</code>（kernel&#x2F;trap.c:37）；返回时是<code>usertrapret</code>（kernel&#x2F;trap.c:90），然后是 <code>userret</code>（kernel&#x2F;trampoline.S:16）。</li>
</ul>
</li>
<li><p>来自用户代码的 trap 比来自内核的 trap 更具挑战性，因为 <code>satp</code> 指向的用户页表并不映射内核，而且栈指针可能包含一个无效甚至恶意的值</p>
</li>
<li><p>因为 RISC-V 硬件在 trap 过程中不切换页表，所以用户页表必须包含 <code>uservec</code> 的映射，即 <code>stvec</code> 指向的 trap 处理程序地址</p>
<ul>
<li><code>uservec</code> 必须切换 <code>satp</code>，使其指向内核页表；为了在切换后继续执行指令，<code>uservec</code> 必须被映射到内核页表与用户页表相同的地址</li>
</ul>
</li>
<li><p>xv6 用一个包含 <code>uservec</code> 的 trampoline 页来满足这些条件</p>
<ul>
<li>xv6 在内核页表和每个用户页表中的同一个虚拟地址上映射了 trampoline 页</li>
<li>这个虚拟地址就是 <code>TRAMPOLINE</code>（如我们在图 2.3 和图 3.3 中看到的）</li>
<li><code>trampoline.S</code> 中包含 trampoline 的内容，（执行用户代码时）<code>stvec</code> 设置为 <code>uservec</code>（kernel&#x2F;trampoline.S:16）。</li>
</ul>
</li>
<li><p>当 <code>uservec</code> 启动时，所有 32 个寄存器都包含被中断的代码所拥有的值</p>
<ul>
<li>但是 <code>uservec</code> 需要能够修改一些寄存器，以便设置 <code>satp</code> 和生成保存寄存器的地址</li>
<li>RISC-V 通过 <code>sscratch</code> 寄存器提供了帮助</li>
<li><code>uservec</code> 开始时的 <code>csrrw</code> 指令将 <code>a0</code> 和 <code>sscratch</code> 的内容互换</li>
<li>现在用户代码的 <code>a0</code> 被保存了；<code>uservec</code> 有一个寄存器（<code>a0</code>）可以使用；<code>a0</code> 包含了内核之前放在 <code>sscratch</code> 中的值。</li>
</ul>
</li>
<li><p><code>uservec</code> 的下一个任务是保存用户寄存器</p>
<ul>
<li><p>在进入用户空间之前，内核先设置 <code>sscratch</code> 指向该进程的 <code>trapframe</code>，这个 <code>trapframe</code> 可以保存所有用户寄存器（kernel&#x2F;proc.h:44）</p>
</li>
<li><p>因为 <code>satp</code> 仍然是指用户页表，所以 <code>uservec</code> 需要将 <code>trapframe</code> 映射到用户地址空间中</p>
</li>
<li><p>当创建每个进程时，xv6 为进程的 <code>trapframe</code> 分配一页内存，并将它映射在用户虚拟地址 <code>TRAPFRAME</code>，也就是 <code>TRAMPOLINE</code> 的下面</p>
</li>
<li><p>进程的 <code>p-&gt;trapframe</code> 也指向 <code>trapframe</code>，不过是指向它的物理地址[<a href="#_ftn1">1]</a>，这样内核可以通过内核页表来使用它</p>
</li>
</ul>
</li>
<li><p>因此，在交换 <code>a0</code> 和 <code>sscratch</code> 后，<code>a0</code> 将指向当前进程的 <code>trapframe</code></p>
<ul>
<li><code>uservec</code> 将在 <code>trapframe</code> 保存全部的寄存器，包括从 <code>sscratch</code> 读取的 <code>a0</code></li>
</ul>
</li>
<li><p><code>trapframe</code> 包含指向当前进程的内核栈、当前 CPU 的 hartid、<code>usertrap</code> 的地址和内核页表的地址的指针，<code>uservec</code> 将这些值设置到相应的寄存器中，并将 <code>satp</code> 切换到内核页表和刷新 TLB，然后调用 <code>usertrap</code></p>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">     # trap.c sets stvec to point here, so	trap.c设置的stvec指向这里</span><br><span class="line">     # traps from user space start here,		所以来自用户空间的陷阱从这里开始</span><br><span class="line">     # in supervisor mode, but with a		在监督者模式，但是有一个用户页表</span><br><span class="line">     # user page table.</span><br><span class="line">     #</span><br><span class="line"></span><br><span class="line">     # save user a0 in sscratch so			保存用户a0到sscratch以便a0可以被使用去到达TRAPFRAME</span><br><span class="line">     # a0 can be used to get at TRAPFRAME.</span><br><span class="line">     csrw sscratch, a0</span><br><span class="line"></span><br><span class="line">		# trap frame 陷阱帧，用于保存当前进程的重要信息</span><br><span class="line">     # each process has a separate p-&gt;trapframe memory area,	每个进程都有一个独立的p-&gt;trapframe内存区域</span><br><span class="line">     # but it&#x27;s mapped to the same virtual address			但是被映射到相同的虚拟地址</span><br><span class="line">     # (TRAPFRAME) in every process&#x27;s user page table.		（TRAPFRAME）在每个进程的用户页表中</span><br><span class="line">     li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">     # save the user registers in TRAPFRAME		保存用户寄存器在TRAPFRAME</span><br><span class="line">     sd ra, 40(a0)</span><br><span class="line">     sd sp, 48(a0)</span><br><span class="line">     sd gp, 56(a0)</span><br><span class="line">     sd tp, 64(a0)</span><br><span class="line">     sd t0, 72(a0)</span><br><span class="line">     sd t1, 80(a0)</span><br><span class="line">     sd t2, 88(a0)</span><br><span class="line">     sd s0, 96(a0)</span><br><span class="line">     sd s1, 104(a0)</span><br><span class="line">     sd a1, 120(a0)</span><br><span class="line">     sd a2, 128(a0)</span><br><span class="line">     sd a3, 136(a0)</span><br><span class="line">     sd a4, 144(a0)</span><br><span class="line">     sd a5, 152(a0)</span><br><span class="line">     sd a6, 160(a0)</span><br><span class="line">     sd a7, 168(a0)</span><br><span class="line">     sd s2, 176(a0)</span><br><span class="line">     sd s3, 184(a0)</span><br><span class="line">     sd s4, 192(a0)</span><br><span class="line">     sd s5, 200(a0)</span><br><span class="line">     sd s6, 208(a0)</span><br><span class="line">     sd s7, 216(a0)</span><br><span class="line">     sd s8, 224(a0)</span><br><span class="line">     sd s9, 232(a0)</span><br><span class="line">     sd s10, 240(a0)</span><br><span class="line">     sd s11, 248(a0)</span><br><span class="line">     sd t3, 256(a0)</span><br><span class="line">     sd t4, 264(a0)</span><br><span class="line">     sd t5, 272(a0)</span><br><span class="line">     sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# save the user a0 in p-&gt;trapframe-&gt;a0	保存用户a0在p-&gt;trapframe-&gt;a0</span><br><span class="line">     csrr t0, sscratch</span><br><span class="line">     sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">     # initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">     # 从 p-&gt;trapframe-&gt;kernel_sp 初始化内核栈指针</span><br><span class="line">     ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">     # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid </span><br><span class="line">     ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">     # load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap	初始化usertrap()的地址</span><br><span class="line">     ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">     # fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.	</span><br><span class="line">     # 从 p-&gt;trapframe-&gt;kernel_satp 获取内核页表地址</span><br><span class="line">     ld t1, 0(a0)</span><br><span class="line"></span><br><span class="line">     # wait for any previous memory operations to complete, so that</span><br><span class="line">     # they use the user page table.</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">     # install the kernel page table.	切换到内核页表</span><br><span class="line">     csrw satp, t1</span><br><span class="line"></span><br><span class="line">     # flush now-stale user entries from the TLB. 刷新TLB</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">     # jump to usertrap(), which does not return	跳转到usertrap()</span><br><span class="line">     jr t0</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">truct trapframe &#123;</span><br><span class="line"><span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table	</span></span><br><span class="line"><span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line"><span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line"><span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line"><span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line"><span class="comment">/*  40 */</span> uint64 ra;			  <span class="comment">// 上面这些与内核有关的寄存器在usertrapret返回到trampoline.S之前已经被设置</span></span><br><span class="line"><span class="comment">/*  48 */</span> uint64 sp;			  <span class="comment">// 需要注意的是：用户的a0和trapframe中的a0是不一样的</span></span><br><span class="line"><span class="comment">/*  56 */</span> uint64 gp;			  <span class="comment">// trapframe中的a0会被系统调用的返回值覆盖，返回到用户空间之前有被交换到a0</span></span><br><span class="line"><span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line"><span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line"><span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line"><span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line"><span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line"><span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line"><span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line"><span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line"><span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line"><span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line"><span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line"><span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line"><span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line"><span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line"><span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line"><span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line"><span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line"><span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line"><span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line"><span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line"><span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line"><span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line"><span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line"><span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line"><span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line"><span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line"><span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line"><span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>usertrap</code> 的作用是确定 trap 的原因，处理它，然后返回（kernel&#x2F; trap.c:37）</p>
<ul>
<li>如上所述，它首先改变 <code>stvec</code>，这样在内核中发生的 trap 将由 <code>kernelvec</code> 处理</li>
<li>它保存了 <code>sepc</code>（用户PC），这也是因为 <code>usertrap</code> 中可能会有一个进程切换，导致 <code>sepc</code> 被覆盖</li>
<li>如果 trap 是系统调用，<code>syscall</code> 会处理它；如果是设备中断，<code>devintr</code> 会处理；否则就是异常，内核会杀死故障进程</li>
<li><code>usertrap</code> 会把用户 <code>pc</code> 加 4，因为 RISC-V 在执行系统调用时，会留下指向 <code>ecall</code> 指令的程序指针<a href="#ftn2">[2]</a></li>
<li>在退出时，<code>usertrap</code> 检查进程是否已经被杀死或应该让出 CPU（如果这个 trap 是一个定时器中断）</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.  </span></span><br><span class="line"><span class="comment">// 处理一个来自用户空间的中断，异常，或系统调用</span></span><br><span class="line"><span class="comment">// called from trampoline.S   来自于trampoline.S的调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// send interrupts and exceptions to kerneltrap(), </span></span><br><span class="line"><span class="comment">// 因为我们现在处于内核中，将中断和异常发送到 kerneltrap() 函数处理</span></span><br><span class="line"><span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">w_stvec((uint64)kernelvec);	</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// save user program counter. 保存用户的程序计数器</span></span><br><span class="line">p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line"> <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(killed(p))</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// sepc points to the ecall instruction,  spec 指向ecall指令，但我们想要返回下一条指令</span></span><br><span class="line"> <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line"> p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// an interrupt will change sepc, scause, and sstatus, </span></span><br><span class="line"> <span class="comment">// 中断会改变 sepc、scause 和 sstatus 寄存器的值，所以只有在处理完这些寄存器之后，我们才启用中断</span></span><br><span class="line"> <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line"> intr_on(); <span class="comment">// 所以中断打开仅在处理syscall()时，从用户空间触发的中断是不允许嵌套的</span></span><br><span class="line"></span><br><span class="line"> syscall();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line"> <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line"> setkilled(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(killed(p))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line"> yield();</span><br><span class="line"></span><br><span class="line">usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>回到用户空间的第一步是调用 <code>usertrapret</code>（kernel&#x2F;trap.c:90）</p>
<ul>
<li><p>这个函数设置 RISC-V 控制寄存器，为以后用户空间 trap 做准备</p>
</li>
<li><p>这包括改变 <code>stvec</code> 来引用 <code>uservec</code>，准备 <code>uservec</code> 所依赖的 <code>trapframe</code> 字段，并将 <code>sepc</code> 设置为先前保存的用户程序计数器</p>
</li>
<li><p>最后，<code>usertrapret</code> 在用户页表和内核页表中映射的 trampoline 页上调用 <code>userret</code>，因为 <code>userret</code> 中的汇编代码会切换页表。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space 返回到用户空间</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// we&#x27;re about to switch the destination of traps from      </span></span><br><span class="line"><span class="comment">// 我们即将把陷阱（trap）的目的地从 kerneltrap() 切换到 usertrap()</span></span><br><span class="line"><span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until </span></span><br><span class="line"><span class="comment">// 所以在回到用户空间之前，先关闭中断直到返回到用户空间</span></span><br><span class="line"><span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">intr_off();</span><br><span class="line"></span><br><span class="line"><span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S </span></span><br><span class="line"><span class="comment">// 在trampoline.S中发送系统调用，中断，异常给uservec</span></span><br><span class="line">uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">w_stvec(trampoline_uservec);	<span class="comment">// 所以这里是在设置stvec为trampoline中的uservec，为下一次trap做准备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set up trapframe values that uservec will need when  </span></span><br><span class="line"><span class="comment">// 设置uservec将会需要的trapframe的值，当进程下一次陷入到内核中时</span></span><br><span class="line"><span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set up the registers that trampoline.S&#x27;s sret will use </span></span><br><span class="line"><span class="comment">// 设置寄存器，trampoline.S的sret将会使用去返回到用户空间</span></span><br><span class="line"><span class="comment">// to get to user space.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set S Previous Privilege mode to User. 模式置为用户模式，其实是设置返回到用户空间时的模式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode	这里设置返回后为用户模式</span></span><br><span class="line">x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode	且打开中断在用户模式中</span></span><br><span class="line">w_sstatus(x);	<span class="comment">// 是更新相关寄存器操作吗</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set S Exception Program Counter to the saved user pc. 设置sepc寄存器为epc，也就是epc+4</span></span><br><span class="line">w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tell trampoline.S the user page table to switch to.  告诉trampoline.S需要转换的用户页表</span></span><br><span class="line">uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line"><span class="comment">// 跳转到 trampoline.S 中的 userret，它位于内存顶部</span></span><br><span class="line"><span class="comment">// switches to the user page table, restores user registers, 用于切换到用户页表，恢复用户寄存器</span></span><br><span class="line"><span class="comment">// and switches to user mode with sret. 并使用 sret 指令切换到用户模式</span></span><br><span class="line">uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>usertrapret</code> 对 <code>userret</code> 的调用传递了参数 <code>a0</code>，<code>a1</code>， <code>a0</code> 指向 <code>TRAPFRAME</code>，<code>a1</code> 指向用户进程页表（kernel&#x2F;trampoline.S:88），<code>userret</code> 将 <code>satp</code> 切换到进程的用户页表</p>
<blockquote>
<p>可能由于版本不同了吧，这里只有一个参数，且 a0 指向的是用户进程页表</p>
</blockquote>
<ul>
<li>回想一下，用户页表同时映射了 trampoline 页和 <code>TRAPFRAME</code>，但没有映射内核的其他内容</li>
<li>同样，事实上，在用户页表和内核页表中，trampoline 页被映射在相同的虚拟地址上，这也是允许 <code>uservec</code> 在改变 <code>satp</code> 后继续执行的原因</li>
<li><code>userret</code> 将 <code>trapframe</code> 中保存的用户 <code>a0</code> 复制到 <code>sscratch</code> 中，为以后与 <code>TRAPFRAME</code> 交换做准备</li>
<li>从这时开始，<code>userret</code> 能使用的数据只有寄存器内容和 <code>trapframe</code> 的内容</li>
<li>接下来 <code>userret</code> 从 trapframe 中恢复保存的用户寄存器，对 <code>a0</code> 和 <code>sscratch</code> 做最后的交换，恢复用户 <code>a0</code> 并保存<code>TRAPFRAME</code>，为下一次 trap 做准备，并使用 <code>sret</code> 返回用户空间</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">userret:</span><br><span class="line">     # userret(pagetable)</span><br><span class="line">     # called by usertrapret() in trap.c to	被trap.c中的usertrapret()调用从内核返回到用户空间</span><br><span class="line">     # switch from kernel to user.</span><br><span class="line">     # a0: user page table, for satp.	</span><br><span class="line"></span><br><span class="line">     # switch to the user page table.</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line">     csrw satp, a0				# 好像被简化了，和之前的版本不一样，之前返回两个参数a0是trapframe，a1才是satp</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">     li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">     # restore all but a0 from TRAPFRAME</span><br><span class="line">     ld ra, 40(a0)</span><br><span class="line">     ld sp, 48(a0)</span><br><span class="line">     ld gp, 56(a0)</span><br><span class="line">     ld tp, 64(a0)</span><br><span class="line">     ld t0, 72(a0)</span><br><span class="line">     ld t1, 80(a0)</span><br><span class="line">     ld t2, 88(a0)</span><br><span class="line">     ld s0, 96(a0)</span><br><span class="line">     ld s1, 104(a0)</span><br><span class="line">     ld a1, 120(a0)</span><br><span class="line">     ld a2, 128(a0)</span><br><span class="line">     ld a3, 136(a0)</span><br><span class="line">     ld a4, 144(a0)</span><br><span class="line">     ld a5, 152(a0)</span><br><span class="line">     ld a6, 160(a0)</span><br><span class="line">     ld a7, 168(a0)</span><br><span class="line">     ld s2, 176(a0)</span><br><span class="line">     ld s3, 184(a0)</span><br><span class="line">     ld s4, 192(a0)</span><br><span class="line">     ld s5, 200(a0)</span><br><span class="line">     ld s6, 208(a0)</span><br><span class="line">     ld s7, 216(a0)</span><br><span class="line">     ld s8, 224(a0)</span><br><span class="line">     ld s9, 232(a0)</span><br><span class="line">     ld s10, 240(a0)</span><br><span class="line">     ld s11, 248(a0)</span><br><span class="line">     ld t3, 256(a0)</span><br><span class="line">     ld t4, 264(a0)</span><br><span class="line">     ld t5, 272(a0)</span><br><span class="line">     ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0</span><br><span class="line">     ld a0, 112(a0)</span><br><span class="line"></span><br><span class="line">     # return to user mode and user pc.</span><br><span class="line">     # usertrapret() set up sstatus and sepc.</span><br><span class="line">     sret</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Code-Calling-system-calls-调用系统调用"><a href="#Code-Calling-system-calls-调用系统调用" class="headerlink" title="Code: Calling system calls 调用系统调用"></a>Code: Calling system calls 调用系统调用</h2><ul>
<li>第 2 章以 <code>initcode.S</code> 调用 <code>exec</code> 系统调用结束（user&#x2F;initcode.S:11）<ul>
<li>让我们来看看用户调用是如何在内核中实现 <code>exec</code> 系统调用的</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  la a0, init</span><br><span class="line">  la a1, argv</span><br><span class="line">     li a7, SYS_exec</span><br><span class="line">     ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">  li a7, SYS_exit</span><br><span class="line">  ecall</span><br><span class="line">     jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">.string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">.long init</span><br><span class="line">.long 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>用户代码将 <code>exec</code> 的参数放在寄存器 <code>a0</code> 和 <code>a1</code> 中，并将系统调用号放在 <code>a7</code> 中。系统调用号与函数指针表 <code>syscalls</code> 数组（kernel&#x2F;syscall.c:108）中的项匹配<ul>
<li><code>ecall</code> 指令进入内核，执行 <code>uservec</code>、<code>usertrap</code>，然后执行 <code>syscall</code>，就像我们上面看到的那样</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An array mapping syscall numbers from syscall.h</span></span><br><span class="line"><span class="comment">// to the function that handles the system call.</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>syscall</code>（kernel&#x2F;syscall.c:133）从 trapframe 中的 <code>a7</code> 中得到系统调用号，并其作为索引在 <code>syscalls</code> 查找相应函数<ul>
<li>对于第一个系统调用 <code>exec</code>，<code>a7</code> 将为 <code>SYS_exec</code>（kernel&#x2F;syscall.h:8），这会让 <code>syscall</code> 调用 <code>exec</code> 的实现函数 <code>sys_exec</code></li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">num = p-&gt;trapframe-&gt;a7;</span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line"><span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line"><span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line"> p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">        p-&gt;pid, p-&gt;name, num);</span><br><span class="line"> p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>当系统调用函数返回时，<code>syscall</code> 将其返回值记录在 <code>p-&gt;trapframe-&gt;a0</code> 中<ul>
<li>用户空间的 <code>exec()</code> 将会返回该值，因为 RISC-V 上的 C 调用通常将返回值放在 <code>a0</code> 中</li>
<li>系统调用返回负数表示错误，0 或正数表示成功</li>
<li>如果系统调用号无效，<code>syscall</code> 会打印错误并返回 -1</li>
</ul>
</li>
</ul>
<h2 id="Code-System-call-arguments-系统调用参数"><a href="#Code-System-call-arguments-系统调用参数" class="headerlink" title="Code: System call arguments 系统调用参数"></a>Code: System call arguments 系统调用参数</h2><ul>
<li>内核的系统调用实现需要找到用户代码传递的参数<ul>
<li>因为用户代码调用系统调用的包装函数，参数首先会存放在寄存器中，这是 C 语言存放参数的惯例位置</li>
<li>内核 trap 代码将用户寄存器保存到当前进程的 trap frame 中，内核代码可以在那里找到它们</li>
<li>函数 <code>argint</code>、<code>argaddr</code> 和 <code>argfd</code> 从 trap frame 中以整数、指针或文件描述符的形式检索第 n 个系统调用参数</li>
<li>它们都调用 <code>argraw</code> 来获取保存的用户寄存器（kernel&#x2F;syscall.c:35）</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="keyword">switch</span> (n) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">&#125;</span><br><span class="line">panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>一些系统调用传递指针作为参数，而内核必须使用这些指针来读取或写入用户内存</p>
<ul>
<li>例如，<code>exec</code> 系统调用会向内核传递一个指向用户空间中的字符串的指针数组</li>
<li>这些指针带来了两个挑战</li>
<li>首先，用户程序可能是错误的或恶意的，可能会传递给内核一个无效的指针或一个旨在欺骗内核访问内核内存而不是用户内存的指针</li>
<li>第二，xv6 内核页表映射与用户页表映射不一样，所以内核不能使用普通指令从用户提供的地址加载或存储</li>
</ul>
</li>
<li><p>内核实现了安全地将数据复制到用户提供的地址或从用户提供的地址复制数据的函数</p>
<ul>
<li>例如 <code>fetchstr</code>（kernel&#x2F;syscall.c:25）</li>
<li>文件系统调用，如 <code>exec</code>，使用 <code>fetchstr</code> 从用户空间中检索字符串文件名参数</li>
<li><code>fetchstr</code> 调用 <code>copyinstr</code> 来做这些困难的工作</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nul-terminated string at addr from the current process.</span></span><br><span class="line"><span class="comment">// 在当前进程中的addr处，获得以null结尾的字符串</span></span><br><span class="line"><span class="comment">// Returns length of string, not including nul, or -1 for error.</span></span><br><span class="line"><span class="comment">// 返回字符串的长度，不包括null，-1表示error</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fetchstr</span><span class="params">(uint64 addr, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="keyword">if</span>(copyinstr(p-&gt;pagetable, buf, addr, max) &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>copyinstr</code>（kernel&#x2F;vm.c:406）将用户页表 <code>pagetable</code> 中的虚拟地址 <code>srcva</code> 复制到 <code>dst</code>，需指定最大复制字节数<ul>
<li>它使用 <code>walkaddr</code>（调用 <code>walk</code> 函数）在软件中模拟分页硬件的操作，以确定 <code>srcva</code> 的物理地址 <code>pa0</code></li>
<li><code>walkaddr</code>（kernel&#x2F;vm.c:109）检查用户提供的虚拟地址是否是进程用户地址空间的一部分，所以程序不能欺骗内核读取其他内存</li>
<li>类似的函数 <code>copyout</code>，可以将数据从内核复制到用户提供的地址</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.	复制以null结尾的字符串从用户空间到内核</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,	</span></span><br><span class="line"><span class="comment">// 复制字节从srcva虚拟地址到dst，在一个给定的页表中</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.	知道遇到 /0 或已经达到max</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.	返回0表示成功，-1</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 n, va0, pa0;</span><br><span class="line"><span class="type">int</span> got_null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">va0 = PGROUNDDOWN(srcva); <span class="comment">// #define PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1)) 作用是将srcva页对齐</span></span><br><span class="line">pa0 = walkaddr(pagetable, va0);</span><br><span class="line"><span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">n = PGSIZE - (srcva - va0);	<span class="comment">// 可以保证每次都处理一个页</span></span><br><span class="line"><span class="keyword">if</span>(n &gt; max)</span><br><span class="line">n = max;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *) (pa0 + (srcva - va0));`<span class="comment">// 得到srcva对应的物理地址</span></span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;	</span><br><span class="line"><span class="keyword">if</span>(*p == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">  *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  got_null = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  *dst = *p;</span><br><span class="line">&#125;</span><br><span class="line">--n;</span><br><span class="line">--max;</span><br><span class="line">p++;</span><br><span class="line">dst++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srcva = va0 + PGSIZE; <span class="comment">// 更新 srcva</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(got_null)&#123;	<span class="comment">// 检查是否遇到了/0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up a virtual address, return the physical address, 查找一个虚拟地址，返回物理地址</span></span><br><span class="line"><span class="comment">// or 0 if not mapped.	返回0表示没有映射</span></span><br><span class="line"><span class="comment">// Can only be used to look up user pages.	仅可以用于查找用户页面</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line">uint64 pa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pa = PTE2PA(*pte);</span><br><span class="line"><span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.  从内核复制到用户空间</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table. </span></span><br><span class="line"><span class="comment">// 从 src 复制 len 字节到给定页表中的虚拟地址 dstva</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.  成功时返回 0，错误时返回 -1</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 n, va0, pa0;</span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">va0 = PGROUNDDOWN(dstva);	<span class="comment">// 页对齐，不大于dstva且是PGSIZE的倍数</span></span><br><span class="line"><span class="keyword">if</span>(va0 &gt;= MAXVA)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> ||</span><br><span class="line"> (*pte &amp; PTE_W) == <span class="number">0</span>) <span class="comment">// pte没有找到 || 不是有效的 || 用户不可访问 || 不可写</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">pa0 = PTE2PA(*pte);	<span class="comment">// 这里是合理的，因为我们已经保证了va0是页对齐的了</span></span><br><span class="line">n = PGSIZE - (dstva - va0);	<span class="comment">// 保证每次处理一页</span></span><br><span class="line"><span class="keyword">if</span>(n &gt; len)</span><br><span class="line">n = len;</span><br><span class="line">memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);	<span class="comment">// 从src复制n个字节到dstva对应的物理地址</span></span><br><span class="line"></span><br><span class="line">len -= n;	<span class="comment">// 更新</span></span><br><span class="line">src += n;</span><br><span class="line">dstva = va0 + PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Traps-from-kernel-space-从内核空间触发的陷阱"><a href="#Traps-from-kernel-space-从内核空间触发的陷阱" class="headerlink" title="Traps from kernel space 从内核空间触发的陷阱"></a>Traps from kernel space 从内核空间触发的陷阱</h2><ul>
<li><p>xv6 根据用户还是内核代码正在执行，对 CPU 陷阱寄存器的配置略有不同行为</p>
<ul>
<li>当内核在 CPU 上执行时，内核将 <code>stvec</code> 指向 <code>kernelvec</code> 上的汇编代码（kernel&#x2F;kernelvec.S:10）</li>
<li>由于 xv6 已经在内核中，<code>kernelvec</code> 可以使用 <code>satp</code>，将其设置为内核页表，以及引用有效内核的堆栈指针</li>
<li><code>kernelvec</code> 保存所有寄存器，以便中断的代码最后可以在没有中断的情况下恢复</li>
</ul>
</li>
<li><p><code>kernelvec</code> 将寄存器保存在中断内核线程的堆栈上，因为寄存器值属于该线程，这是合理的</p>
<ul>
<li>如果 trap 导致切换到另一个线程—在这种情况下，trap 将实际返回到新线程的栈上，将中断线程保存的寄存器安全地保留在其堆栈上</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">kernelvec:</span><br><span class="line">     # make room to save registers.</span><br><span class="line">     addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">     # save the registers.</span><br><span class="line">     sd ra, 0(sp)</span><br><span class="line">     sd sp, 8(sp)</span><br><span class="line">     sd gp, 16(sp)</span><br><span class="line">     sd tp, 24(sp)</span><br><span class="line">     sd t0, 32(sp)</span><br><span class="line">     sd t1, 40(sp)</span><br><span class="line">     sd t2, 48(sp)</span><br><span class="line">     sd s0, 56(sp)</span><br><span class="line">     sd s1, 64(sp)</span><br><span class="line">     sd a0, 72(sp)</span><br><span class="line">     sd a1, 80(sp)</span><br><span class="line">     sd a2, 88(sp)</span><br><span class="line">     sd a3, 96(sp)</span><br><span class="line">     sd a4, 104(sp)</span><br><span class="line">     sd a5, 112(sp)</span><br><span class="line">     sd a6, 120(sp)</span><br><span class="line">     sd a7, 128(sp)</span><br><span class="line">     sd s2, 136(sp)</span><br><span class="line">     sd s3, 144(sp)</span><br><span class="line">     sd s4, 152(sp)</span><br><span class="line">     sd s5, 160(sp)</span><br><span class="line">     sd s6, 168(sp)</span><br><span class="line">     sd s7, 176(sp)</span><br><span class="line">     sd s8, 184(sp)</span><br><span class="line">     sd s9, 192(sp)</span><br><span class="line">     sd s10, 200(sp)</span><br><span class="line">     sd s11, 208(sp)</span><br><span class="line">     sd t3, 216(sp)</span><br><span class="line">     sd t4, 224(sp)</span><br><span class="line">     sd t5, 232(sp)</span><br><span class="line">     sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">     # call the C trap handler in trap.c</span><br><span class="line">     call kerneltrap</span><br><span class="line"></span><br><span class="line">     # restore registers.</span><br><span class="line">     ld ra, 0(sp)</span><br><span class="line">     ld sp, 8(sp)</span><br><span class="line">     ld gp, 16(sp)</span><br><span class="line">     # not tp (contains hartid), in case we moved CPUs</span><br><span class="line">     ld t0, 32(sp)</span><br><span class="line">     ld t1, 40(sp)</span><br><span class="line">     ld t2, 48(sp)</span><br><span class="line">     ld s0, 56(sp)</span><br><span class="line">     ld s1, 64(sp)</span><br><span class="line">     ld a0, 72(sp)</span><br><span class="line">     ld a1, 80(sp)</span><br><span class="line">     ld a2, 88(sp)</span><br><span class="line">     ld a3, 96(sp)</span><br><span class="line">     ld a4, 104(sp)</span><br><span class="line">     ld a5, 112(sp)</span><br><span class="line">     ld a6, 120(sp)</span><br><span class="line">     ld a7, 128(sp)</span><br><span class="line">     ld s2, 136(sp)</span><br><span class="line">     ld s3, 144(sp)</span><br><span class="line">     ld s4, 152(sp)</span><br><span class="line">     ld s5, 160(sp)</span><br><span class="line">     ld s6, 168(sp)</span><br><span class="line">     ld s7, 176(sp)</span><br><span class="line">     ld s8, 184(sp)</span><br><span class="line">     ld s9, 192(sp)</span><br><span class="line">     ld s10, 200(sp)</span><br><span class="line">     ld s11, 208(sp)</span><br><span class="line">     ld t3, 216(sp)</span><br><span class="line">     ld t4, 224(sp)</span><br><span class="line">     ld t5, 232(sp)</span><br><span class="line">     ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">     addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">     # return to whatever we were doing in the kernel.</span><br><span class="line">     sret</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>kernelvec</code> 在保存寄存器后跳转到 <code>kerneltrap</code>（kernel&#x2F;trap.c:134）</p>
<ul>
<li><code>kerneltrap</code> 是为两种类型的陷阱准备的：设备中断和异常	</li>
<li>它调用 <code>devintr</code>（kernel&#x2F;trap.c:177）来检查和处理前者</li>
<li>如果 trap 不是设备中断，那么它必须是异常，如果它发生在 xv6 内核中，则一定是一个致命错误；内核调用 <code>panic</code> 并停止执行</li>
</ul>
</li>
<li><p>如果由于计时器中断而调用了 <code>kerneltrap</code>，并且进程的内核线程正在运行（而不是调度程序线程），<code>kerneltrap</code> 调用 <code>yield</code> 让出 CPU，允许其他线程运行</p>
<ul>
<li>在某个时刻，其中一个线程将退出，并让我们的线程及其 <code>kerneltrap</code> 恢复</li>
<li>第 7 章解释了线程让出 CPU 控制权</li>
</ul>
</li>
<li><p>当 <code>kerneltrap</code> 的工作完成时，它需要返回到被中断的代码</p>
<ul>
<li>因为 <code>yield</code> 可能破坏保存的 <code>sepc</code> 和在 <code>sstatus</code> 中保存的之前的模式</li>
<li><code>kerneltrap</code> 在启动时保存它们。它现在恢复那些控制寄存器并返回到 <code>kernelvec</code>（kernel&#x2F;kernelvec.S:48）</li>
<li><code>kernelvec</code> 从堆栈恢复保存的寄存器并执行 <code>sret</code>，<code>sret</code> 将 <code>sepc</code> 复制到 <code>pc</code> 并恢复中断的内核代码</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,  </span></span><br><span class="line"><span class="comment">// 中断和异常从内核代码产生时，会通过 kernelvec 到达</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is. 无论当前的内核栈是什么</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">uint64 sepc = r_sepc(); <span class="comment">// 保存一些可能被修改的寄存器</span></span><br><span class="line">uint64 sstatus = r_sstatus();</span><br><span class="line">uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)  <span class="comment">// 如果是来自于用户模式，那太糟糕了</span></span><br><span class="line"> panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);  <span class="comment">// 此时中断不能打开</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;	<span class="comment">// 如果不是设备中断，只能是异常了</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line"> panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.  放弃CPU如果这是一个时钟中断</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line"> yield();</span><br><span class="line"></span><br><span class="line"><span class="comment">// the yield() may have caused some traps to occur, yield()可能造成一些陷阱的发生</span></span><br><span class="line"><span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction. </span></span><br><span class="line"><span class="comment">// 恢复陷阱寄存器以供kernelvec.S中的spec指令使用</span></span><br><span class="line">w_sepc(sepc);</span><br><span class="line">w_sstatus(sstatus);	<span class="comment">// 恢复这些可能被修改的寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>可以思考一下，如果因为时间中断，<code>kerneltrap</code> 调用了 <code>yield</code>，trap return 是如何发生的</p>
</li>
<li><p>当 CPU 从用户空间进入内核时，xv6 将 CPU 的 <code>stvec</code> 设置为 <code>kernelvec</code>；可以在 <code>usertrap</code>（kernel&#x2F;trap.c:29）中看到这一点</p>
<ul>
<li>内核运行但 <code>stvec</code> 被设置为 <code>uservec</code> 时，这期间有一个时间窗口，在这个窗口期，禁用设备中断是至关重要的</li>
<li>幸运的是，RISC-V 总是在开始使用 trap 时禁用中断，xv6 在设置 <code>stvec</code> 之前不会再次启用它们</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果不知道去哪里找到想要的函数，<code>kernel/defs.h</code> 是一个很好的选择</p>
</blockquote>
<h2 id="Page-fault-exceptions-缺页异常"><a href="#Page-fault-exceptions-缺页异常" class="headerlink" title="Page-fault exceptions 缺页异常"></a>Page-fault exceptions 缺页异常</h2><ul>
<li><p>xv6 对异常的响应是相当固定：如果一个异常发生在用户空间，内核就会杀死故障进程</p>
<ul>
<li>如果一个异常发生在内核中，内核就会 <strong>panic</strong>。真正的操作系统通常会以更有趣的方式进行响应</li>
</ul>
</li>
<li><p>举个例子，许多内核使用页面故障来实现 <strong>写时复制（copy-on-write，cow）fork</strong></p>
<ul>
<li>要解释写时复制 fork，可以想一想 xv6 的 <code>fork</code>，在第 3 章中介绍过</li>
<li><code>fork</code> 通过调用 <code>uvmcopy</code>（kernel&#x2F;vm.c:309）为子进程分配物理内存，并将父进程的内存复制到子程序中，使子进程拥有与父进程相同的内存内容</li>
<li>如果子进程和父进程能够共享父进程的物理内存，效率会更高。然而，直接实现这种方法是行不通的，因为父进程和子进程对共享栈和堆的写入会中断彼此的执行</li>
</ul>
</li>
<li><p>通过使用写时复制 fork，可以让父进程和子进程安全地共享物理内存，通过页面故障来实现</p>
<ul>
<li>当 CPU 不能将虚拟地址翻译成物理地址时，CPU 会产生一个页面故障异常（page-fault exception）</li>
<li>RISC-V 有三种不同的页故障：load 页故障（当加载指令不能翻译其虚拟地址时）、stote 页故障（当存储指令不能翻译其虚拟地址时）和指令页故障（当指令的地址不能翻译时）</li>
<li><code>scause</code> 寄存器中的值表示页面故障的类型，<code>stval</code> 寄存器中包含无法翻译的地址</li>
</ul>
</li>
<li><p><strong>COW</strong> fork 中的基本设计是父进程和子进程最初共享所有的物理页面，但将它们映射设置为只读</p>
<ul>
<li>因此，当子进程或父进程执行 store 指令时，RISC-V CPU 会引发一个页面故障异常</li>
<li>作为对这个异常的响应，内核会拷贝一份包含故障地址的页。然后将一个副本的读&#x2F;写映射在子进程地址空间，另一个副本的读&#x2F;写映射在父进程地址空间</li>
<li>更新页表后，内核在引起故障的指令处恢复故障处理</li>
<li>因为内核已经更新了相关的 PTE，允许写入，所以现在故障指令将正常执行</li>
</ul>
</li>
<li><p>这个 COW 设计对 <code>fork</code> 很有效，因为往往子程序在 fork 后立即调用 exec，用新的地址空间替换其地址空间</p>
<ul>
<li>在这种常见的情况下，子程序只会遇到一些页面故障，而内核可以避免进行完整的复制</li>
<li>此外，COW fork 是透明的：不需要对应用程序进行修改，应用程序就能受益</li>
</ul>
</li>
<li><p>页表和页故障的结合，将会有更多种有趣的可能性的应用</p>
<ul>
<li>另一个被广泛使用的特性叫做 **懒分配 (lazy allocation)**，它有两个部分</li>
<li>首先，当一个应用程序调用 <code>sbrk</code> 时，内核会增长地址空间，但在页表中把新的地址标记为无效</li>
<li>第二，当这些新地址中的一个出现页面故障时，内核分配物理内存并将其映射到页表中</li>
<li>由于应用程序经常要求获得比他们需要的更多的内存，所以懒分配是一个胜利：内核只在应用程序实际使用时才分配内存</li>
<li>像 COW fork 一样，内核可以对应用程序透明地实现这个功能</li>
</ul>
</li>
<li><p>另一个被广泛使用的利用页面故障的功能是从 <strong>磁盘上分页(paging from disk)</strong></p>
<ul>
<li>如果应用程序需要的内存超过了可用的物理 RAM，内核可以交换出一些页：将它们写入一个存储设备，比如磁盘，并将其 PTE 标记为无效</li>
<li>如果一个应用程序读取或写入一个被换出到磁盘的页，CPU 将遇到一个页面故障。内核就可以检查故障地址</li>
<li>如果该地址属于磁盘上的页面，内核就会分配一个物理内存的页面，从磁盘上读取页面到该内存，更新 PTE 为有效并引用该内存，然后恢复应用程序</li>
<li>为了给该页腾出空间，内核可能要交换另一个页</li>
<li>这个特性不需要对应用程序进行任何修改，如果应用程序具有引用的位置性（即它们在任何时候都只使用其内存的一个子集），这个特性就能很好地发挥作用</li>
</ul>
</li>
<li><p>其他结合分页和分页错误异常的功能包括自动扩展堆栈和内存映射文件</p>
</li>
</ul>
<h2 id="Real-world-现实情况"><a href="#Real-world-现实情况" class="headerlink" title="Real world 现实情况"></a>Real world 现实情况</h2><ul>
<li>如果将内核内存映射到每个进程的用户页表中（使用适当的 PTE 权限标志），就不需要特殊的 trampoline 页了<ul>
<li>这也将消除从用户空间 trap 进入内核时对页表切换的需求</li>
<li>这也可以让内核中的系统调用实现利用当前进程的用户内存被映射的优势，让内核代码直接去间接引用（对地址取值）用户指针</li>
<li>许多操作系统已经使用这些想法来提高效率</li>
<li>xv6 没有实现这些想法，以减少由于无意使用用户指针而导致内核出现安全漏洞的机会，并减少一些复杂性，以确保用户和内核虚拟地址不重叠</li>
</ul>
</li>
</ul>
<h2 id="Exercises-练习"><a href="#Exercises-练习" class="headerlink" title="Exercises 练习"></a>Exercises 练习</h2><ul>
<li><p>函数 <code>copyin</code> 和 <code>copyinstr</code> 在软件中 walk 用户页表。设置内核页表，使内核拥有用户程序的内存映射，<code>copyin</code> 和 <code>copyinstr</code> 可以使用 <code>memcpy</code> 将系统调用参数复制到内核空间，依靠硬件来完成页表的 walk</p>
</li>
<li><p>实现内存的懒分配</p>
</li>
<li><p>实现写时复制 fork</p>
</li>
</ul>
<hr>
<ol>
<li><p><a name="ftn1"></a>内核中物理地址和虚拟地址时直接映射的，所以可以在启用分页时，通过物理地址访问。</p>
</li>
<li><p><a name="ftn2"></a>执行系统调用时，进程的pc会指向ecall指令，这里需要加4清除，因为进程栈的地址空间是从高到低。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/03/6-S081-Lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/03/6-S081-Lab3/" class="post-title-link" itemprop="url">Lab Page tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-03 15:35:24" itemprop="dateCreated datePublished" datetime="2024-06-03T15:35:24+08:00">2024-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-04 17:44:13" itemprop="dateModified" datetime="2024-06-04T17:44:13+08:00">2024-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>实验讲义：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/labs/pgtbl.html">Lab: page tables (mit.edu)</a></p>
</li>
<li><p>在这个实验中，你将探索页表并对其进行修改，以加快某些系统调用的速度，并检测那些页面已被访问</p>
</li>
<li><p>开始编码前，请阅读：xv6 book 第 3 章和相关文件：</p>
<ul>
<li><code>kernel/memlayout.h</code>，它捕获了内存布局</li>
<li><code>kernel/vm.c</code>，包含大多数虚拟内存的代码</li>
<li><code>kernel/kalloc.c</code>，包含用于分配和释放物理内存的代码</li>
</ul>
</li>
<li><p>开始实验之前，请输入：<code>git fetch &amp;&amp; git checkout pgtbl &amp;&amp; make clean</code></p>
<blockquote>
<p>这是必要的！过程中如果 Git 提醒你处理当前工作区中未提交的修改，输入 <code>git stash</code> 贮藏你的修改</p>
</blockquote>
</li>
</ul>
<h1 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h1><ul>
<li><p>一些操作系统通过在用户空间和内核之间的只读区域共享数据来加快某些系统调用的速度，这是因为用户程序可以之间在用户态下访问这个只读共享区域中的数据，而不用陷入到内核。</p>
</li>
<li><p>你的任务就是为 xv6 中的 <code>getpid()</code> 系统调用实现此优化</p>
</li>
<li><p>步骤</p>
<ul>
<li>创建每个进程时，在 USYSCALL（<code>memlayout.h</code> 中定义的虚拟地址）上映射一个只读页面</li>
<li>在这个页面的开始位置存储一个 usyscall 结构（也定义在 <code>memlayout.h</code> 中），初始化它以存储当前进程的 PID</li>
<li>用户空间中提供了 <code>ugetpid()</code>，会自动使用 USYSCALL 映射。你需要运行 <code>pgtbltest</code> 并通过了 ugatpid 的测试</li>
</ul>
</li>
<li><p>一些建议</p>
<ul>
<li>你可以在 <code>kernel/proc.c</code> 的 <code>proc_pagetable()</code> 中执行映射</li>
<li>选择允许用户空间只读页面的权限</li>
<li>你可能会发现 <code>kernel/vm.c</code> 的 <code>mappages()</code> 是一个很有用的程序</li>
<li>不要忘记在 <code>allocproc()</code> 中分配和初始化页面（<code>kernel/proc.c</code>）</li>
<li>确保在 <code>freeproc()</code> 中释放页面（<code>kernel/proc.c</code>）</li>
</ul>
</li>
<li><p><code>memlayout.h</code>  中定义了 USYSCALL，usyscall</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// User memory layout.  用户内存布局</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/memlayout.h</code></p>
</blockquote>
<ul>
<li>依照 xv6 book 第 3 章中提到的内核地址空间布局，不难发现 USYSCALL 仅在 TRAMPOLINE 和 TRAPFRAME 之下，是一个相当高的虚拟地址</li>
</ul>
<img src="/2024/06/03/6-S081-Lab3/Figure-3.3.jpg" class="" title="img">

<ul>
<li><code>proc_pagetable()</code> 为一个新进程创建一个映射了 trampoline、trapframe 的用户页表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process, with no user memory, </span></span><br><span class="line"><span class="comment">// 为一个进程创建一个用户页表，没有用户内存</span></span><br><span class="line"><span class="comment">// but with trampoline and trapframe pages. 但有trampoline和tramframe页面</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return) </span></span><br><span class="line">  <span class="comment">// 映射trampoline代码（为了系统调用返回）到用户虚拟地址的最高处</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address. </span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way  仅仅内核所用它，在到/从用户空间时，所以不是PTE_U（用户可以访问）</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe page just below the trampoline page, for </span></span><br><span class="line">  <span class="comment">// trampoline.S.</span></span><br><span class="line">  <span class="comment">// 映射trapframe页面到trampoline页面的下边，为了trampoline.S</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<ul>
<li>依照 TRAPFRAME 映射的过程，我们需要在 proc 中添加一个 usyscall</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usyscall</span>;</span>  <span class="comment">// my change</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.h</code></p>
</blockquote>
<ul>
<li>修改 <code>proc_pagetable()</code> 在新创建的用户页表中进行 USYSCALL 映射</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// map the trapframe page just below the trampoline page, for </span></span><br><span class="line">  <span class="comment">// trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// my change</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE, (uint64)p-&gt;usyscall, PTE_R | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code>，需要注意的是：</p>
<p>USYSCALL 映射的页面的权限是用户只读 <code>PTE_R | PTE_U</code></p>
<p>当 USYSCALL 映射失败时，需要释放 TRAMPOLINE、TRAPFRAME、pagetable</p>
</blockquote>
<ul>
<li><code>allocproc()</code> 在进程表中找一个未使用的 proc，为 proc 中的一些成员分配物理内存，并进行初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.  在进程表中寻找一个未使用的进程</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,  如果找到，初始化运行在内核中所需要的状态</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.  并返回，同时持有进程锁</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.  </span></span><br><span class="line"><span class="comment">// 如果没有空闲的进程，或内存分配失败，返回0</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;  <span class="comment">// 遍历进程表</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  </span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;  <span class="comment">// 找一个未使用的进程</span></span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();  <span class="comment">//初始化pid和state</span></span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page. 分配一个trapframe页面</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.  一个空的用户页表</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret, 设置新的上下文，以便在forket处开始执行</span></span><br><span class="line">  <span class="comment">// which returns to user space. forket返回用户空间</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<ul>
<li>需要为 proc 中的 usyscall 分配物理内存，这样才能在访问虚拟地址 USYSCALL 时通过页表映射找到 usycall 所在的物理地址</li>
<li>依照为 trapframe 分配物理内存的过程，修改 <code>allocproc()</code> 在创建一个进程时为 usyscall 分配物理内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Allocate a trapframe page. </span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// my change</span></span><br><span class="line">  <span class="keyword">if</span> ((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code>，不要忘记初始化 <code>usycall</code> 的 <code>pid</code></p>
</blockquote>
<ul>
<li><code>freeproc()</code> 释放一个 proc 及其相关的数据</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,  释放一个进程结构和其相关联的数据</span></span><br><span class="line"><span class="comment">// including user pages.  包括用户页面</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.  进程锁必须被持有</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<ul>
<li>依照 trapframe 的释放过程，修改 <code>freeproc()</code> 在释放一个进程时释放 usyscall</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// my change</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;usyscall) &#123;</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<ul>
<li>一个很重要的点是：<code>freeoroc()</code> 中调用了 <code>proc_freepagetable()</code> 释放进程的页表及映射的物理内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the  释放一个进程的页表，并且释放它所指向的物理内存</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<ul>
<li>依照 TRAPFRAME 的释放过程，修改 <code>proc_freepagetable()</code> 在释放一个页表时释放 USYSCALL 映射的物理内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// my change</span></span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/proc.c</code></p>
</blockquote>
<h1 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h1><ul>
<li><p>为了帮助可视化 RISC-V 页表，你的第二个任务是编写一个打印页表内容的函数</p>
</li>
<li><p>步骤</p>
<ul>
<li><p>定义一个名为 <code>vmprint()</code> 的函数，它的参数是类型为 <code>pagetable_t</code>，以下格式打印 pagetable</p>
</li>
<li><p><code>exec.c</code> 中在返回 argc 之前，插入 <code>if (p-&gt;pid == 1) vmprint(p-&gt;pagetable)</code>，打印第一个进程的页表</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">page table <span class="number">0x0000000087f6e000</span></span><br><span class="line"> .<span class="number">.0</span>: pte <span class="number">0x0000000021fda801</span> pa <span class="number">0x0000000087f6a000</span></span><br><span class="line"> .. .<span class="number">.0</span>: pte <span class="number">0x0000000021fda401</span> pa <span class="number">0x0000000087f69000</span></span><br><span class="line"> .. .. .<span class="number">.0</span>: pte <span class="number">0x0000000021fdac1f</span> pa <span class="number">0x0000000087f6b000</span></span><br><span class="line"> .. .. .<span class="number">.1</span>: pte <span class="number">0x0000000021fda00f</span> pa <span class="number">0x0000000087f68000</span></span><br><span class="line"> .. .. .<span class="number">.2</span>: pte <span class="number">0x0000000021fd9c1f</span> pa <span class="number">0x0000000087f67000</span></span><br><span class="line"> .<span class="number">.255</span>: pte <span class="number">0x0000000021fdb401</span> pa <span class="number">0x0000000087f6d000</span></span><br><span class="line"> .. .<span class="number">.511</span>: pte <span class="number">0x0000000021fdb001</span> pa <span class="number">0x0000000087f6c000</span></span><br><span class="line"> .. .. .<span class="number">.509</span>: pte <span class="number">0x0000000021fdd813</span> pa <span class="number">0x0000000087f76000</span></span><br><span class="line"> .. .. .<span class="number">.510</span>: pte <span class="number">0x0000000021fddc07</span> pa <span class="number">0x0000000087f77000</span></span><br><span class="line"> .. .. .<span class="number">.511</span>: pte <span class="number">0x0000000020001c0b</span> pa <span class="number">0x0000000080007000</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行显示 <code>vmprint()</code> 的参数（即 pagetable）</p>
</li>
<li><p>之后的每一行包括引用树中更深层页面的 PTE，通过用 <code>..</code> 进行缩进，每条 PTE 显示：PTE 索引、PTE 的位、PTE 中提取的物理地址</p>
</li>
<li><p>不打印无效的 PTE</p>
</li>
<li><p>一些建议</p>
<ul>
<li>你可以将 <code>vmprint()</code> 放在 <code>kernel/vm.c</code> 中</li>
<li>使用 <code>kernel/riscv.h</code> 末尾定义的宏会很有用</li>
<li><code>freewalk</code> 函数可以对你很有帮助</li>
<li>在 <code>kernel/defs.h</code> 中定义 <code>vmprint</code> 的原型，以便你可以在 <code>exec.c</code> 中调用它</li>
<li>在 <code>printf</code> 中使用 <code>%p</code> 打印完整的 64 位十六进制 PTE 和地址</li>
</ul>
</li>
<li><p><code>kernel/riscv.h</code> 末尾定义的宏真的很有趣，它们都是和页表相关的</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;	<span class="comment">// pte_t是一个非负的64位整数类型，可以作为地址使用</span></span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs	pagetable_t是一个指向uint64的指针，可以作为数组使用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __ASSEMBLER__</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page	表示一个页表4096字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page		表示页内偏移的位数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))	<span class="comment">// 不知道是什么，还没见过</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid	权限位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L &lt;&lt; 4) <span class="comment">// user can access</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"><span class="comment">// 将物理地址右移到PTE（页表项）的正确位置，10位用来设置权限位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)	<span class="comment">// 从pte提取出56位的物理地址，44位来自pte的ppn + 12位0</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address. 从虚拟地址中提取三个9位的页表索引</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))	<span class="comment">// 12 + 9 *level</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK) <span class="comment">// 左移12再左移9*levle</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// one beyond the highest possible virtual address. 		超出最高可能虚拟地址的一个单位</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by 	MAXVA 实际上比 Sv39 允许的最大值少一个比特位</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses 	以避免需要对设置了最高位的虚拟地址进行符号扩展</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/riscv.h</code></p>
</blockquote>
<ul>
<li><code>freewalk</code> 帮助我们理解如何递归的遍历页表<ul>
<li>如果 <code>(pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == 0</code> 成立，说明当前 PTE 不是叶子 PTE，也说明只有叶子 PTE 才有可能可读、可写、可执行</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages. 递归地释放页表页面</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed 所有叶子映射必须先已经被移除</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table. 这个PTE指向一个低层的页表</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/vm.c</code></p>
</blockquote>
<ul>
<li>在 <code>kernel/vm.c</code> 中添加 <code>vmprint</code>。为了方便，创建一个辅助函数 <code>vmprint_help</code> 根据当前页表的 level 打印 <code>..</code></li>
<li>在 <code>vmprint</code> 中打印第一行，其他行通过 <code>vmprint_help</code> 递归打印</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my change</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint_help</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>) &#123;</span><br><span class="line">      uint64 child = PTE2PA(pte); <span class="comment">// 得到下一级页表的物理地址</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte)); </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte)); </span><br><span class="line">      &#125;</span><br><span class="line">      vmprint_help((<span class="type">pagetable_t</span>)child, level - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte)); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  vmprint_help(pagetable, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/vm.c</code></p>
</blockquote>
<ul>
<li>在 <code>kernel/defs.h</code> 中定义 <code>vmprint</code> 的原型，以便可以在 <code>exec.c</code> 中调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm.c</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// my change</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/defs.h</code></p>
</blockquote>
<ul>
<li>修改 <code>exec.c</code>，在 argc 返回之前打印第一个进程的 pagetable</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  p = myproc();</span><br><span class="line">  <span class="comment">// my change</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;pid == <span class="number">1</span>) vmprint(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/exec.c</code></p>
</blockquote>
<h1 id="Detecting-which-pages-have-benn-accessed"><a href="#Detecting-which-pages-have-benn-accessed" class="headerlink" title="Detecting which pages have benn accessed"></a>Detecting which pages have benn accessed</h1><ul>
<li><p>一些垃圾收集器可以从有关哪些页面被访问的信息中受益</p>
</li>
<li><p>你将向 xv6 添加一项新功能，该功能通过检查 RISC-V 页面表中的访问位来检测并向用户空间报告此信息</p>
</li>
<li><p>步骤</p>
<ul>
<li>你的工作是实现 <code>pgaccess()</code>，这是一个系统调用，用于报告哪些页面已被访问</li>
<li>该系统调用有三个参数：用户页面的起始虚拟地址，需要检查的页数，存储结果的位掩码</li>
<li>位掩码的每一位对应于每页，比如第一页对应于位掩码中的最低有效位</li>
</ul>
</li>
<li><p>一些建议</p>
<ul>
<li>首先在 <code>kernel/sysproc.c</code> 中实现 <code>sys_pgaccess()</code></li>
<li>你需要使用 <code>kernel/syscall.c</code> 中的  <code>argaddr()</code> 和 <code>argint()</code> 解析参数</li>
<li>对于输出的位掩码，在内核中存储临时缓冲区，在用正确的位填充后将其复制给用户（使用 <code>copyout()</code>）</li>
<li>可以对需要扫描的页数设置上限</li>
<li><code>kernel/vm.c</code> 中的 <code>walk()</code> 对于找到正确的 PTE 非常有用</li>
<li>你需要在 <code>kernel/riscv.h</code> 中定义 PTE_A，即访问位</li>
<li>在检查是否设置后，请务必清除 PTE_A，防止访问位被永久设置</li>
<li><code>vmprint()</code> 在调试页表可能会有所帮助</li>
</ul>
</li>
<li><p><code>user/user.h</code> 中已经定义好了 <code>pgaccess()</code> 的原型</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pgaccess</span><span class="params">(<span class="type">void</span> *base, <span class="type">int</span> len, <span class="type">void</span> *mask)</span>;	<span class="comment">// 用户页面起始虚拟地址 页数 掩码</span></span><br><span class="line"><span class="comment">// usyscall region</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ugetpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>user/user.h</code></p>
</blockquote>
<ul>
<li><code>user/pgtbltest.c</code> 中调用了 <code>pgaccess()</code>。第一个参数传入 32 页面的起始虚拟地址，第二个参数表示 32 个页面，第三个参数传入一个指向位掩码的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pgaccess_test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *buf;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> abits;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pgaccess_test starting\n&quot;</span>);</span><br><span class="line">  testname = <span class="string">&quot;pgaccess_test&quot;</span>;</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">32</span> * PGSIZE);</span><br><span class="line">  <span class="keyword">if</span> (pgaccess(buf, <span class="number">32</span>, &amp;abits) &lt; <span class="number">0</span>)</span><br><span class="line">    err(<span class="string">&quot;pgaccess failed&quot;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>user/pgtbltest.c</code></p>
</blockquote>
<ul>
<li>在 <code>kernel/riscv.h</code> 中定义 PTE_A</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L &lt;&lt; 4) <span class="comment">// user can access</span></span></span><br><span class="line"><span class="comment">// my change</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6) <span class="comment">// 访问位</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这是根据 xv6 book 第 3 章中提到的 RISC-V 标准设置的</li>
</ul>
<img src="/2024/06/03/6-S081-Lab3/Figure-3.2.jpg" class="" title="img">





<ul>
<li>在 <code>kernel/sysproc.c</code> 中实现 <code>sys_pgaccess()</code>。通过前边的学习，我们知道用户空间中的 <code>pgaccess()</code> 实际会调用 <code>kernel/sysproc.c</code> 中定义的 <code>sys_pgaccess()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span>  <span class="comment">// my change</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 base, addr;</span><br><span class="line">  uint32 mask = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;base);</span><br><span class="line">  argint(<span class="number">1</span>, &amp;len);</span><br><span class="line">  argaddr(<span class="number">2</span>, &amp;addr);</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">0</span> || len &gt; <span class="number">32</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (base &gt;= MAXVA) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> ((pte = walk(p-&gt;pagetable, base, <span class="number">0</span>)) != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_A) != <span class="number">0</span>) &#123;</span><br><span class="line">      mask |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">      *pte &amp;= (~PTE_A);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    base += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span> (copyout(p-&gt;pagetable, addr, (<span class="type">char</span>*)&amp;mask, <span class="keyword">sizeof</span>(mask)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/sysproc.c</code>，要注意不要自己再定义 <code>sys_pgaccess()</code> 了，官方已经给出了框架</p>
</blockquote>
<ul>
<li><p>在 <code>sys_pgaccess()</code> 中，有一些需要注意的点</p>
<ul>
<li><p>通过 <code>argaddr()</code>、<code>argint()</code> 提取出用户传递的参数</p>
</li>
<li><p>限制检测的页数 <code>len</code> 必须在 <code>[0, 32]</code> 之间</p>
<ul>
<li>因为 <code>user/pgtbltest.c</code> 中调用 <code>pgaccess()</code> 时传入的指针指向的是 <code>unsigned int</code> 类型的数据，只有 32 位，这也是为什么调用 <code>pgaccess()</code> 时直接硬编码了页数为 32</li>
<li>还有就是不要使用 <code>len &lt; 0 || len &gt; sizeof(uint32)</code>，<code>uint32</code> 其实是 <code>unsigned int</code> 64 位，而不是 32 位；<code>uint64</code> 为 <code>unsigned long</code></li>
</ul>
</li>
<li><p>通过 <code>walk()</code> 检测当前虚拟地址是否已经被访问，每当一个页面 TLB 未命中且处理过后，这个 PTE 的访问位会被置为 1</p>
<ul>
<li><code>*pte &amp; PTE_A</code> 的目的是：一个页面只能统计一次。每次检查完后会将 PTE_V 清除，后面再次检查这个页面时 PTE_A 无效</li>
</ul>
</li>
<li><p>检查过访问位后，通过 <code>*pte &amp;= (~PTE_A)</code> 清除访问位</p>
</li>
</ul>
</li>
<li><p><code>kernel/syscall.c</code> 中，一些添加系统调用的必备步骤已经被实现了</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line">[SYS_pgaccess] sys_pgaccess,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kernel/syscall.c</code></p>
</blockquote>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make clean &amp;&amp; make grade</strong> 进行测试</li>
</ul>
<img src="/2024/06/03/6-S081-Lab3/image-20240604173924619.png" class="" title="image-20240604173924619">

<blockquote>
<p>如果你想要完整通过测试</p>
<p>创建一个名为 <code>answer-pgtbl.txt</code> 的文件，输入两个问题的答案（随便写也能通过）</p>
<p>创建一个名为 <code>time.txt</code> 的文件，输入在这个实验中花费的时间</p>
</blockquote>
<ul>
<li>当然，也可以 <strong>make clean &amp;&amp; make qemu &amp;&amp; pgtbltest</strong> 进行测试</li>
</ul>
<img src="/2024/06/03/6-S081-Lab3/image-20240604174347450.png" class="" title="image-20240604174347450">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16087757.html">MIT6.S081-Lab3 Pgtbl 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/AD-milk/p/16103905.html">6.S081-2021-Lab3 Pgtbl学习笔记 - AD_milk - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">计组复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-23 17:25:17" itemprop="dateCreated datePublished" datetime="2024-05-23T17:25:17+08:00">2024-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-31 21:29:01" itemprop="dateModified" datetime="2024-05-31T21:29:01+08:00">2024-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><ul>
<li>机械计算机</li>
<li>电子模拟计算机：数据由连续的量表示</li>
<li>电子数字计算机：数据不由连续的数字表示</li>
<li>专用机、通用机</li>
</ul>
<h2 id="计算机发展简史"><a href="#计算机发展简史" class="headerlink" title="计算机发展简史"></a>计算机发展简史</h2><ul>
<li><p>计算机的发展</p>
<ul>
<li>第一代：电子管计算机</li>
<li>第二代：晶体管计算机</li>
<li>第三代：集成电路计算机：半导体存储器，出现微程序设计，出现操作系统</li>
<li>第四代：大规模集成电路计算机：出现数据库系统、分步操作系统、微处理器和微型计算机</li>
<li>第五代：巨大规模集成电路计算机：单片机</li>
</ul>
</li>
<li><p>半导体存储器的发展</p>
<ul>
<li>微小的铁磁体环 -&gt; 半导体存储器</li>
</ul>
</li>
<li><p>微处理器的发展</p>
<ul>
<li>4 位的 4004 微处理器 -&gt; 16位 8086 微处理器，采用流水线技术</li>
</ul>
</li>
<li><p>微型计算机的特点</p>
<ul>
<li>体积小、功耗低</li>
<li>可靠性高、使用环境要求低</li>
<li>设计灵活</li>
</ul>
</li>
<li><p>摩尔定律：晶体管面积会逐渐缩小，说明同样的面积下，晶体管越来越多</p>
</li>
<li><p>计算机性能指标</p>
<ul>
<li><p>吞吐量：某一时间间隔能处理的信息量（byte&#x2F;s）</p>
</li>
<li><p>响应时间：输入到系统产生响应（微妙 10^-6^、纳秒 10^-9^）</p>
</li>
<li><p>利用率：给定时间间隔内，系统被实际使用的时间占比</p>
</li>
<li><p>处理机字长：处理机运算器中一次能完成二进制数的位数</p>
</li>
<li><p>总线宽度：CPU 中运算器和存储器相连的内部总线的二进制位数</p>
</li>
<li><p>存储器容量：存储器中存储单元的总数（KB 2^10^、MB 2^20^、GB 2^30^、TB 2^40^）</p>
</li>
<li><p>存储器带宽：单位时间内从存储器读出二进制数的量（byte&#x2F;s）</p>
</li>
<li><p>主频&#x2F;时钟周期：主时钟的频率 f 即为 CPU 的主频（兆赫兹 MHz、GHz），主频的倒数即为 CPU 时钟周期</p>
</li>
<li><p>CPU 执行时间：CPU 执行一段程序所占用的 CPU 时间</p>
<blockquote>
<p>CPU 时钟周期数 * CPU 时钟周期长</p>
</blockquote>
</li>
<li><p>CPI：每条指令周期数</p>
<blockquote>
<p>执行某段程序所需 CPU 时钟周期数 &#x2F; 该程序的指令条数</p>
</blockquote>
</li>
<li><p>MIPS：每秒百万条指令数</p>
<blockquote>
<p>指令条数 &#x2F; (程序执行时间 * 10^6^) &#x3D; 时钟频率 &#x2F; (CPI * 10^6^)</p>
</blockquote>
</li>
<li><p>Te：程序执行时间</p>
<blockquote>
<p>指令条数 &#x2F; (MIPS * 10^6^)</p>
</blockquote>
</li>
<li><p>MFLOPS：每秒百万次浮点操作数</p>
<blockquote>
<p>程序中浮点操作次数 &#x2F; (程序执行时间 * 10^6^)</p>
<p>MIPS 是基于指令的，MIPS 越高机器越快；MFLOPS 基于浮点操作，不能体现机器整体性能</p>
</blockquote>
</li>
<li><p>TFLOPS：每秒万亿次浮点操作次数，常用于超级计算机</p>
</li>
</ul>
</li>
</ul>
<h2 id="计算机的硬件"><a href="#计算机的硬件" class="headerlink" title="计算机的硬件"></a>计算机的硬件</h2><ul>
<li><p>冯诺依曼计算机的设计思想：程序存储，程序控制</p>
<ul>
<li>计算机由五部分组成：控制器、运算器、存储器、输入设备、输出设备</li>
<li>程序和数据都以二进制代码的形式不加区别的存放在存储器上</li>
<li>指令由操作码和地址码组成，由指令计数器 PC 指出要执行指令所在单元地址，一般顺序执行</li>
<li>I&#x2F;O 设备和存储器传送数据时都通过运算器，以运算器为中心</li>
</ul>
</li>
<li><p>控制器</p>
<ul>
<li><p>获得执行的指令，明确指令功能，获得操作的数据，执行指令，返回结果</p>
<blockquote>
<p>取指周期，从内存读出的信息流向控制器，执行周期流向运算器</p>
</blockquote>
</li>
</ul>
</li>
<li><p>适配器和 I&#x2F;O 设备</p>
<ul>
<li><p>输入设备：将人熟悉的信息变为机器棵识别的二进制信息</p>
</li>
<li><p>输出设备：将计算机处理的结果变为人熟悉的信息</p>
</li>
<li><p>适配器：使外围设备可通过系统总线与主机联系</p>
</li>
<li><p>总线：系统部件间数据传送的公共通路</p>
<blockquote>
<p>系统总线包含三个子总线：数据总线、地址总线、控制总线</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="计算机的软件"><a href="#计算机的软件" class="headerlink" title="计算机的软件"></a>计算机的软件</h2><ul>
<li>软件的分类：系统软件和应用软件</li>
<li>软件的发展演变<ul>
<li>编程语言：手写程序 -&gt; 汇编语言 -&gt; 高级语言</li>
<li>系统软件：操作系统 -&gt; 分布式操作系统</li>
</ul>
</li>
</ul>
<h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><ul>
<li><p>第一级是微程序级，第二级是机器语言级，第三级是操作系统级，第四级是汇编语言级，第五级是高级应用级</p>
</li>
<li><p>层次结构的特点</p>
<ul>
<li>每一级都可以直接编程，得到下一级的支持</li>
<li>1 - 3 是二进制语言，易于机器执行；4 - 5 级是符号，易于人理解</li>
<li>级数越低越接近硬件</li>
</ul>
</li>
<li><p>软件和硬件的逻辑等价性：任何操作既可以用软件实现，也可以用硬件实现</p>
<ul>
<li>需要考虑的是其他因素：价格、速度、可靠性 ……</li>
</ul>
</li>
</ul>
<h1 id="运算器和运算方法"><a href="#运算器和运算方法" class="headerlink" title="运算器和运算方法"></a>运算器和运算方法</h1><h2 id="数据与文字的表示方法"><a href="#数据与文字的表示方法" class="headerlink" title="数据与文字的表示方法"></a>数据与文字的表示方法</h2><ul>
<li><p>十进制到 R 进制的转换</p>
<ul>
<li>整数部分：除 R 取余，R 进制为基数</li>
<li>小数部分：乘 R 取整</li>
</ul>
</li>
<li><p>数据的表示格式</p>
<ul>
<li>定点表示：纯整数 &#x2F; 纯小数，带符号 &#x2F; 不带符号</li>
<li>浮点表示</li>
</ul>
</li>
<li><p>纯小数</p>
</li>
</ul>
<style>.qgsyuqokbrxt{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525092537175.png" class="qgsyuqokbrxt" alt="image-20240525092537175">

<ul>
<li><p>纯整数的取值范围：<code>0 &lt;= |x| &lt;= 2^n^ -1 </code></p>
</li>
<li><p>IEEE 754 浮点标准</p>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525092918929.png" class="" title="image-20240525092918929">

<ul>
<li><p>32 位浮点数，<code>x = (-1)^S^ × (1.M) × 2^E-127^</code>、 <code>e = E - 127</code></p>
<ul>
<li>M 尾数 23 位；E 阶码 8 位，用移码表示</li>
</ul>
</li>
<li><p>64 位浮点数，<code>x = (-1)^S^ × (1.M) × 2^E-1023^</code> 、<code>e = E - 1023</code></p>
<ul>
<li>M 尾数 52 位；E 阶码 11 位</li>
</ul>
</li>
<li><p>表示 0：当 E 阶码位全为 0 时， M 尾数位也全为 0，根据 S 符号位是 1 &#x2F; 0，有正 0 和负 0 之分</p>
</li>
<li><p>表示无穷：当 E 阶码位全为 1 时，M 尾数位全为 0，根据 S 符号位是 1 &#x2F; 0，有正无穷和负无穷之分</p>
</li>
<li><p>因为要排除阶码 E 全 0 全 1 的情况，32 位浮点数的 E 的取值范围为：1 ~ 254，真正的指数 e 的取值范围为：-126 ~ 127</p>
</li>
</ul>
</li>
<li><p>BCD 码</p>
<ul>
<li>一般用 8421 码，其 4 个二进制码的权从高到低分别为 8、4、2 和 1。</li>
<li>用 0000，0001，…，1001 分别表示 0，1，…，9，每个数位内部满足二进制规则，而数位之间满足十进制规则，故称这种编码为 “以二进制编码的十进制 (binary coded decimal，简称 BCD) 码”</li>
<li>部实现 BCD 码算术运算，要对运算结果进行修正，对加法运算的修正规则是： <ul>
<li>如果两个一位 BCD 码相加之和小于或等于 (1001)2， 即 (9)10，不需要修正</li>
<li>如相加之和大于或等于 (10)10，要进行加 6 修正， 并向高位进位</li>
</ul>
</li>
</ul>
</li>
<li><p>机器码表示</p>
<ul>
<li>原码，反码，补码，移码</li>
</ul>
<p>	</p>
</li>
<li><p>原码</p>
<ul>
<li>定点小数的取值范围：<code>2^-n^ - 1 ~ 1 - 2^-n^</code></li>
<li>定点整数的取值范围：<code>1 - 2^n^ ~ 2^n^ – 1</code></li>
<li>缺点：加减很麻烦</li>
</ul>
</li>
<li><p>补码</p>
<style>.ubqtkflhtdfs{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525100239650.png" class="ubqtkflhtdfs" alt="image-20240525100239650">

<ul>
<li><p>原理是：一个负数用其补码代替，同样可以得到正确的运算结果</p>
<ul>
<li>如果是 n 位整数，其模为2^n^ </li>
<li>如果是 n 位小数，其模为 2</li>
</ul>
</li>
<li><p>补码的优点就是将减法运算可以转为加法运算，无正 0 和负 0 之分</p>
</li>
<li><p>由原码求补码</p>
<ul>
<li>正数的原码、反码、补码都相同</li>
<li>负数：符号位 1 保持不变，其余位取反，得到反码；反码最低位 + 1 得到补码</li>
</ul>
</li>
<li><p>由 x 的补码求 x&#x2F;2 的补码：算术右移</p>
</li>
</ul>
</li>
<li><p>反码</p>
<ul>
<li>正数的原码、反码、补码相同</li>
<li>负数的符号位保持不变，其他位按位取反</li>
<li>反码有正 0 和负 0 之分</li>
</ul>
</li>
<li><p>移码</p>
<ul>
<li>通常用在阶码中</li>
<li>特点：移码和补码尾数相同，符号位相反</li>
<li><code>00000000</code> 阶码表示数字 “0” ，尾数的隐含位为 0；<code>11111111</code> 阶码表示数字 “无穷大” ，尾数的隐含位为 0</li>
</ul>
</li>
<li><p>字符和字符串的表示</p>
<ul>
<li><p>字符用 ASCLL：一个字节表示，低 7 位用来编码，高 1 位用来校验</p>
</li>
<li><p>字符串用连续的字节表示，一个字符一个字节</p>
</li>
<li><p>汉字：两个字节组成，每个字节高位都为1（区别于英文字符）（PPT 和 UTF - 8 好像不太一样，存疑）</p>
</li>
</ul>
</li>
<li><p>校验码</p>
<ul>
<li>由于信息传输和处理过程中受到干扰和故障，容易出错，所以在有效信息中加入一些冗余信息（校验位）</li>
<li>原理：在 k 位数据码之外增加 1 位校验位，使 k + 1 位码字中取值为 1 的位数总保持为偶数（偶校验）或奇数（奇校验）</li>
<li>只能发现错误，不能改错</li>
</ul>
</li>
</ul>
<h2 id="定点加法、减法运算"><a href="#定点加法、减法运算" class="headerlink" title="定点加法、减法运算"></a>定点加法、减法运算</h2><ul>
<li><p>补码加法</p>
<ul>
<li><style>.dtgowqwyjdkn{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525102611629.png" class="dtgowqwyjdkn" alt="image-20240525102611629">
</li>
<li><style>.rytqjcepydvr{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525102633614.png" class="rytqjcepydvr" alt="image-20240525102633614">
</li>
<li><p>符号位作为数的一部分参加运算</p>
</li>
<li><p>在 2^n+1^ 模意义下相加，即超过 2^n+1^ 的进位要丢掉</p>
</li>
</ul>
</li>
<li><p>补码减法</p>
<ul>
<li><p>为了将减法转为加法，[x-y]补 &#x3D; [x]补 - [y]补 &#x3D; [x]补 + [-y]补</p>
</li>
<li><p>由 [y]补 求 [-y]补：包括符号位都取反，在末位 + 1</p>
</li>
<li><style>.cuxiqeydwffw{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525103035698.png" class="cuxiqeydwffw" alt="image-20240525103035698">
</li>
<li><style>.wmeutwbtsyfk{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525103100440.png" class="wmeutwbtsyfk" alt="image-20240525103100440"></li>
</ul>
</li>
<li><p>溢出的概念</p>
<ul>
<li><p>两个正数相加得到负数，两个负数相加得到正数</p>
</li>
<li><p>溢出的检测</p>
<ul>
<li><p>双符号法：</p>
<style>.nmeapywbsacg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525104930090.png" class="nmeapywbsacg" alt="image-20240525104930090">
</li>
<li><p>两符号位相异时，表示溢出；相同时，没有溢出。无论是否溢出，SF1 表示结果正确的（其实是本该正确的）</p>
</li>
<li><p>超出双符号的部分还是需要丢掉的</p>
</li>
</ul>
</li>
<li><style>.zpkhgbbqefhb{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525105031857.png" class="zpkhgbbqefhb" alt="image-20240525105031857">
</li>
<li><style>.slfgoupdfhwg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525105048066.png" class="slfgoupdfhwg" alt="image-20240525105048066"></li>
</ul>
</li>
<li><p>基本的加法减法器</p>
<ul>
<li>半加器：不考虑进位</li>
<li>全加器：考虑进位</li>
</ul>
</li>
</ul>
<h2 id="定点乘法运算"><a href="#定点乘法运算" class="headerlink" title="定点乘法运算"></a>定点乘法运算</h2><ul>
<li><p>乘积的符号由两数的符号按异或运算得到，而乘 积的数值部分则是两个正数相乘之积</p>
</li>
<li><style>.heksrwpqzyrg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110244617.png" class="heksrwpqzyrg" alt="image-20240525110244617">
</li>
<li><p>通常机器只有 n 位长，两个 n 位数相乘，乘积可能为 2n 位</p>
</li>
<li><p>不带符号位的阵列乘法器</p>
<ul>
<li><style>.shqsvasbhqog{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110357689.png" class="shqsvasbhqog" alt="image-20240525110357689"></li>
</ul>
</li>
<li><p>带符号位的阵列乘法器</p>
<ul>
<li><style>.bszodrgtlbis{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110427695.png" class="bszodrgtlbis" alt="image-20240525110427695">
</li>
<li><style>.ygrpxqhgvgsy{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110441784.png" class="ygrpxqhgvgsy" alt="image-20240525110441784"></li>
</ul>
</li>
</ul>
<h2 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h2><ul>
<li>人工除法时，人可以比较被除数（余数）和除数的 大小来确定商 1（够减）或商 0（不够减） </li>
<li>机器除法时，余数为正表示够减，余数为负表示不够减。不够减时必须恢复原来余数，才能继续向下 运算。这种方法叫恢复余数法，控制比较复杂。 </li>
<li><strong>不恢复余数法（加减交替法）</strong> 余数为正，商 1，下次除数右移做减法； 余数为负，商 0，下次除数右移做加法。 控制简单，有规律</li>
<li><style>.ouvjmbtsxtlu{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525111512256.png" class="ouvjmbtsxtlu" alt="image-20240525111512256"></li>
</ul>
<h2 id="定点运算器的组成"><a href="#定点运算器的组成" class="headerlink" title="定点运算器的组成"></a>定点运算器的组成</h2><ul>
<li>多功能算术&#x2F;逻辑运算单元 ALU</li>
</ul>
<h2 id="浮点运算方法和浮点运算器"><a href="#浮点运算方法和浮点运算器" class="headerlink" title="浮点运算方法和浮点运算器"></a>浮点运算方法和浮点运算器</h2><ul>
<li><p>浮点数加法</p>
<ul>
<li><style>.ctcemriornnk{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145124955.png" class="ctcemriornnk" alt="image-20240525145124955">
</li>
<li><style>.cvgsserzldcz{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145955228.png" class="cvgsserzldcz" alt="image-20240525145955228">
</li>
<li><p>步骤：</p>
<ul>
<li><p>0 操作数检查</p>
<style>.dhsihjigfjpq{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145607017.png" class="dhsihjigfjpq" alt="image-20240525145607017">
</li>
<li><p>比较阶码大小并完成对阶（小阶向大阶对齐），通过尾数的移动以改变 Ex 和 Ey 对阶 ，使之相等</p>
<style>.dwidpipibcrr{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145536692.png" class="dwidpipibcrr" alt="image-20240525145536692">
</li>
<li><p>尾数进行加或减运算</p>
<style>.dgcpvmieibsq{zoom: 50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145644744.png" class="dgcpvmieibsq" alt="image-20240525145644744">
</li>
<li><p>结果格式化</p>
<style>.gvrxlyhforga{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145715674.png" class="gvrxlyhforga" alt="image-20240525145715674">

<blockquote>
<p>这里左规处理，我觉得应该是因为之前的 1 是符号位，我们要将其转为 1.M 的形式</p>
</blockquote>
</li>
<li><p>舍入处理</p>
<style>.zhpwdddtgnqn{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145838834.png" class="zhpwdddtgnqn" alt="image-20240525145838834"></li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.wtbajikoacjx{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145910146.png" class="wtbajikoacjx" alt="image-20240525145910146">

<ul>
<li><p>浮点乘除法</p>
<ul>
<li><style>.xaxwgmyvefqs{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150047579.png" class="xaxwgmyvefqs" alt="image-20240525150047579"></li>
<li><style>.mmhxsjtomxjs{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150902680.png" class="mmhxsjtomxjs" alt="image-20240525150902680">
</li>
<li><p>步骤：</p>
</li>
<li><style>.llnowudalvmx{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150319867.png" class="llnowudalvmx" alt="image-20240525150319867">

<ul>
<li><p>0 操作数检查</p>
<style>.mmluqxlkdxfx{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150439676.png" class="mmluqxlkdxfx" alt="image-20240525150439676">
</li>
<li><p>阶码加减操作</p>
<style>.lbpkojqiqkdz{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150504727.png" class="lbpkojqiqkdz" alt="image-20240525150504727">
</li>
<li><p>尾数乘除操作</p>
<style>.ususuhaarwfw{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150540605.png" class="ususuhaarwfw" alt="image-20240525150540605">
</li>
<li><p>结果规格化</p>
<style>.tvqdydjwkneg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150656893.png" class="tvqdydjwkneg" alt="image-20240525150656893">

<blockquote>
<p>使用第二种格式化结果感觉更合理</p>
</blockquote>
</li>
<li><p>舍入处理</p>
<style>.soukavsbgjwt{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150232580.png" class="soukavsbgjwt" alt="image-20240525150232580"></li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.mmeujjabspph{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150827187.png" class="mmeujjabspph" alt="image-20240525150827187">

<ul>
<li><p>浮点运算流水线</p>
<ul>
<li>空间并行性：增加冗余部件；时间并行性：流水线技术</li>
<li>流水线原理：把一个任务分解为几个有联系的子任务</li>
<li>基本概念：<ul>
<li>过程段 Si 所需的时间为 Ti，缓冲寄存器的延时为 T1，线性流水线的时钟周期定义为 <code>t＝max&#123;Ti&#125;＋T1＝Tm＋T1</code>，流水线处理的频率为 <code>f＝1/t</code></li>
<li>k 级流水线处理 n 个任务需要的时钟周期数：<code>Tk＝k＋(n－1)</code>。其中 k 个时钟周期用来处理第一个任务，剩下的 n - 1 个任务只需要 n - 1 个时钟周期</li>
</ul>
</li>
</ul>
</li>
<li><p>非流水线处理 n 个任务顺序完成的时间为：<code>T＝ n × k × t</code>，而流水线技术需要：<code>T＝Tk × t</code></p>
</li>
<li><p>k级线性流水线的加速比： <code>Ck ＝ n * k / [k＋(n－1)]</code></p>
</li>
</ul>
<h1 id="内部存储器"><a href="#内部存储器" class="headerlink" title="内部存储器"></a>内部存储器</h1><h2 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h2><ul>
<li><p>一个双稳态半导体电路或一个 CMOS 晶体管或磁性材料的存储元，均可以存储一位二进制代码</p>
<ul>
<li>二进制代码位是存储器中最小的存储单位，称为存储位元</li>
<li>多个存储位元构成存储单元，多个存储单元构成存储器</li>
</ul>
</li>
<li><p>存储器的分类：</p>
<ul>
<li>按存储介质：磁面 &#x2F; 半导体</li>
<li>按存取方式：随机 &#x2F; 顺序</li>
<li>按读写功能：RAM（随机易失性） &#x2F; ROM（只读非易失性）</li>
<li>按信息的保存：永久性 &#x2F; 非永久性</li>
</ul>
</li>
<li><p>存储器层次结构</p>
</li>
</ul>
<style>.fxljlynwsezg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526094535554.png" class="fxljlynwsezg" alt="image-20240526094535554">

<ul>
<li>主存储器技术指标<ul>
<li>字存储单元：存放一个机器字的存储单元</li>
<li>字节存储单元：存放一个字节的单元</li>
<li>存储容量：指一个存储器中可以容纳的存储单元总数</li>
<li>存取时间：指一次读操作命令发出 到该操作完成，将数据读出到数据总线上所经历的时间</li>
<li>存储周期：指连续启动两次读操作所需间隔的最小时间。 通常，存储周期略大于存取时间</li>
<li>存储器带宽：单位时间里存储器所存取的信息量，通常以位&#x2F;秒或字节&#x2F;秒做度量单位</li>
</ul>
</li>
</ul>
<h2 id="SRAM-存储器"><a href="#SRAM-存储器" class="headerlink" title="SRAM 存储器"></a>SRAM 存储器</h2><ul>
<li><p>主存是半导体存储器，分为两类：</p>
<ul>
<li>静态读写存储器 SRAM：存取速度块，容量不如 DRAM 大</li>
<li>动态读写存储器 DRAM</li>
</ul>
</li>
<li><p>SRAM 存储位元：一个锁存器（触发器）</p>
</li>
<li><p>只要直流供电电源一直加到这个记忆电路上，它就无限期地保持记忆的 1 状态或 0 状态。如果电源断电，那么存储的数据就会丢失</p>
</li>
<li><p>SRAM 存储器读写逻辑</p>
<ul>
<li>CS 拔是片选信号（低电平有效），无论读或写，总是打开（低电平）</li>
<li>OE 拔是读使能信号（低电平有效），读的时候打开</li>
<li>WE 拔是写使能信号（低电平有效），写时总是打开</li>
<li>读写要互斥，因此 OE 拔低电平时，WE 拔总是高电平，反之同理</li>
</ul>
</li>
</ul>
<style>.ftgletffkcwj{zoom: 67%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526100901062.png" class="ftgletffkcwj" alt="image-20240526100901062">

<ul>
<li><style>.ycxtrzkryorj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526101029931.png" class="ycxtrzkryorj" alt="image-20240526101029931"></li>
</ul>
<h2 id="DRAM-存储器"><a href="#DRAM-存储器" class="headerlink" title="DRAM 存储器"></a>DRAM 存储器</h2><ul>
<li><p>DRAM 的存储单元：</p>
<ul>
<li>SRAM 的存储单元是一个触发器，它具有两个稳定状态</li>
<li>DRAM 的存储单元是由一个 MOS 晶体管和电容器组成的记忆电路，通过电容有无电荷来区分信号 0、1，MOS 管则作为开关使用</li>
</ul>
</li>
<li><p>DRAM 的逻辑结构</p>
<ul>
<li>由于 DRAM 的容量很大，增加了行地址锁存器和列地址锁存器</li>
<li>由于 DRAM 存储单元是基于电荷的，电荷量随着时间和温度而减少，必须定期刷新，所以增加了刷新计数器</li>
<li>读周期、写周期的定义是从行选通信号 RAS 下降沿开始，到下一个RAS信号的下降沿为止。刷新操作和读 &#x2F; 写操作是交替进行的</li>
</ul>
</li>
</ul>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103222840.png" class="" title="image-20240526103222840">

<ul>
<li><p>存储容量扩充</p>
<ul>
<li><p>字长位数扩充</p>
<style>.wpspittqjvtm{zoom:67%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103635832.png" class="wpspittqjvtm" alt="image-20240526103635832">
</li>
<li><p>字存储容量扩展</p>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103716715.png" class="" title="image-20240526103716715"></li>
</ul>
</li>
<li><p>高级 DRAM 结构</p>
<ul>
<li>FPM DRAM：快速页模式动态存储器，它是根据程序的局部性原理来实现的</li>
<li>CDRAM：带高速缓冲存储器（cache）的动态存储器，在 DRAM 芯片内又集成了一个小容量的 SRAM，从而使 DRAM 芯片的性能得到显著改进</li>
<li>SDRAM：同步型动态存储器，SDRAM 的操作要求与系统时钟相同步，在系统时钟的控制下从 CPU 获得地址、数据和控制信息</li>
</ul>
</li>
<li><p>DRAM 读写正确性校验：增加了附加位，用于读&#x2F;写操作正确性校验。增加的附加位也要同数据位一起写入 DRAM 中保存</p>
</li>
</ul>
<h2 id="只读存储器（ROM）和闪速存储器（EPROM）"><a href="#只读存储器（ROM）和闪速存储器（EPROM）" class="headerlink" title="只读存储器（ROM）和闪速存储器（EPROM）"></a>只读存储器（ROM）和闪速存储器（EPROM）</h2><ul>
<li><p>只读存储器 ROM：在工作时只能读，不能写，因此原始数据必须在它工作前写入</p>
</li>
<li><p>ROM 的分类：</p>
<ul>
<li>掩模 ROM：也就是一个由商家提供的内存固定的 ROM，一旦芯片做成就不能改变了</li>
<li>可编程 ROM：用户后写入内容，有的可以多次写入<ul>
<li>一次性编程 PROM</li>
<li>多次编程的 EPROM 和 E^2^PROM</li>
</ul>
</li>
</ul>
</li>
<li><p>可编程 ROM</p>
<ul>
<li><p>EPROM 叫光擦除可编程只读存储器，常用的有以浮栅雪崩注入型 MOS 管为存储单元的 EPROM</p>
</li>
<li><p>E^2^PROM 叫电擦除可编程只读存储器，其存储元是一个具有两个栅级的 NMOS 管</p>
</li>
<li><p>这两种存储器出厂时为全 1 状态，使用者可根据需要写 0</p>
</li>
</ul>
</li>
<li><p>闪速存储器</p>
<ul>
<li>FLASH 存储器也叫闪速存储器，它是高密度非易失性读&#x2F;写存储器</li>
<li>高密度说明其存储容量很大，非易失性说明数据没有电源也能长期保存</li>
<li>它既有 RAM 的优点，也有 ROM 的优点，是一个跨时代的进展</li>
<li>FLASH 存储元在 EPROM 存储元基础上发展起来的</li>
</ul>
</li>
</ul>
<h2 id="并行存储器"><a href="#并行存储器" class="headerlink" title="并行存储器"></a>并行存储器</h2><ul>
<li><p>为了解决 CPU 和主存储器之前的速度不匹配问题，解决途径：</p>
<ul>
<li>多个存储器并行工作：并行访问和交叉访问</li>
<li>采用分层存储系统：Cache、虚拟存储系统</li>
</ul>
</li>
<li><p>双端口存储器（空间并行）</p>
<ul>
<li>由于同一个存储器具有两组相互独立的读写控制电路而得名，通过 BUSY 位来保证读写互斥</li>
</ul>
</li>
<li><p>多模块交叉存储器（时间并行）</p>
<ul>
<li><p>一个由若干个模块组成的主存储器，有两种访问方式：一种是顺序方式，一种是交叉方式</p>
<ul>
<li>顺序方式</li>
</ul>
<style>.hinlhvcerjbi{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526112808903.png" class="hinlhvcerjbi" alt="image-20240526112808903">

<ul>
<li><p>交叉方式</p>
<style>.fqwgbgcrxrxp{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526112835300.png" class="fqwgbgcrxrxp" alt="image-20240526112835300">

<ul>
<li>通常在一个存储器周期内联系访问四个模块。各模块的 读写过程将重叠进行</li>
<li>各个存储体的启动间隔为 <code>t = T/n</code>（n为交叉存取度） </li>
<li><code>t顺序 = xT</code>（x 表示任务个数），<code>x交叉 = T + (x - 1)t</code>（第一个 T 是第一个任务，剩下的 x - 1 个任务都只需要 t）</li>
</ul>
<style>.guidebsgvjtj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526113259735.png" class="guidebsgvjtj" alt="image-20240526113259735">

<blockquote>
<p>Mb 的 b 表示 bit，而 MB 的 B 表示 byte</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Cache-存储器"><a href="#Cache-存储器" class="headerlink" title="Cache 存储器"></a>Cache 存储器</h2><ul>
<li><p>Cache 是一种高速缓冲存储器介于 CPU 和主存之 间的小容量存储器，但存取速度比主存快。随着集成度的提高，Cache 已放入 CPU中，工作速度接近于 CPU 的速度，纯硬件控制</p>
</li>
<li><p>Cache 是由 SRAM 组成的，它的设计依据是局部性原理</p>
<ul>
<li>CPU 与 Cache 之间的数据传送是以字为单位</li>
<li>主存与 Cache 之间的数据传送是以块为单位</li>
</ul>
</li>
<li><p><code>Ne</code> 表示 cache 完成存取的总次数，<code>Nm</code> 表示主存完成存取的总次数，<code>h</code> 表示命中率</p>
</li>
<li><p><code>tc</code> 表示命中时 cache 的访问时间，<code>tm</code> 表示未命中时主存的访问时间，<code>1-h</code> 表示未命中率，<code>ta</code> 表示 cache&#x2F;主存储系统的平均访问时间</p>
</li>
<li><p><code>r = tm / tc</code>，表示主存慢于 cache 的倍率，<code>e</code> 表示访问效率</p>
</li>
</ul>
<style>.croserjdzjlh{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526135617821.png" class="croserjdzjlh" alt="image-20240526135617821">

<ul>
<li><style>.wfjnjjumpofq{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526135756896.png" class="wfjnjjumpofq" alt="image-20240526135756896">
</li>
<li><p>主存与 cache 的地址映射</p>
<ul>
<li><p>cache 的容量很小，保存的内容只是主存内容的一个子集，且 cache 与主存的数据交换是以块为单位</p>
</li>
<li><p>全相联的地址映射</p>
<ul>
<li><p>主存中的任一块可以映射到缓存中的任一块</p>
</li>
<li><p>此时内存地址由块号、偏移量组成，将块号和 cache 中每一行的标记位比较</p>
<style>.xturedkicsoa{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526140337048.png" class="xturedkicsoa" alt="image-20240526140337048">
</li>
<li><p>冲突概率小，Cache 的利用高，但比较器难实现，需要一个访问速度很快代 价高的相联存储器</p>
</li>
</ul>
</li>
<li><p>直接映射</p>
<ul>
<li><p>Cache 的行号 i 和主存的块号 j 函数关系 <code>i = j mod m</code>，m 是 cache 中的总行数</p>
</li>
<li><p>每个缓存块 i 可以和若干个主存块对应；每个主存块 j 只能和一个缓存块对应</p>
</li>
<li><p>此时内存地址有 tag、行号、偏移量组成，直接和 cache 中对于行的 tag 比较</p>
<style>.yecqstexoxdp{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526140716082.png" class="yecqstexoxdp" alt="image-20240526140716082">
</li>
<li><p>硬件实现简单，但冲突概率高（抖动）</p>
</li>
</ul>
</li>
<li><p>组相联映射方式</p>
<ul>
<li><p>前两者的组合，Cache 分组，组间采用直接映射方式，组内采用全相联的映射方式</p>
</li>
<li><p>主存块存放在哪个组是固定的，至于存到该组哪一行是灵活的</p>
</li>
<li><p>此时内存地址由 tag、组号、偏移量组成，在 cache 对应的组中逐个比较 tag</p>
<style>.lhhyelpprhiw{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526142729893.png" class="lhhyelpprhiw" alt="image-20240526142729893">
</li>
<li><p>当只有一个组时，是全映射；当组的容量为 1 时，是直接映射</p>
</li>
<li><p>组的容量一般取值比较小，假设为 v，则称为 v 路组相联 cache</p>
</li>
</ul>
</li>
<li><style>.mobskchitrne{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526143206068.png" class="mobskchitrne" alt="image-20240526143206068"></li>
</ul>
</li>
<li><p>替换策略</p>
<ul>
<li>LFU（最不经常使用 ）：被访问的行计数器增加 1， 换值小的行，不能反映近期 cache 的访问情况</li>
<li>LRU（近期最少使用）：被访问的行计数器置 0， 其他的计数器增加 1，换值大的行，符合局部性原理</li>
<li>随机替换：硬件上容易实现，且速度也比前两种策略快，但随意换出的数据很可能马上又要使用</li>
</ul>
</li>
<li><p>写操作策略</p>
<ul>
<li>由于 cache 的内容只是主存部分内容的拷贝，它应当与主存内容保持一致</li>
<li>写回法：换出时，对行的修改位进行判断，决定是写回到主存还是舍掉</li>
<li>全写法：写命中时，Cache 与内存一起写</li>
<li>写一次法：与写回法一致，但是第一次 Cache 命中时采用全写法</li>
</ul>
</li>
<li><p>使用多级 cache 减少缺失损失</p>
</li>
</ul>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><ul>
<li><p>基本概念</p>
<ul>
<li>用户编写的程序按照虚拟地址存放在辅存中，程序运行时，由地址变换机构依据当时分配给该程序的物理地址空间把程序的一部分调入实存</li>
</ul>
</li>
<li><p>cache - 主存和主存 - 虚拟内存的异同</p>
<ul>
<li>相同点：都是为了提高系统的性能价格比而进行的分层，都利用了局部性原理将经常访问的数据块调入容量小速度快的存储器</li>
<li>不同点：<ul>
<li>cache - 主存主要是解决 CPU 与主存速度不匹配问题，主存 - 虚拟内存主要是为了解决存储容量、管理、分配、保护等问题</li>
<li>透明性也不同，cache 是由硬件管理的，设置不暴露给系统程序员</li>
<li>未命中处罚不同：cache 的速度是主存的 5 - 10 倍，主存是辅存的 1000 倍</li>
</ul>
</li>
</ul>
</li>
<li><p>页式虚拟地址映射</p>
<ul>
<li><p>虚拟地址由逻辑页号和偏移量组成，物理地址由物理页号和偏移量组成，偏移量是相同的，而页号可能长度都不同</p>
</li>
<li><p>每个进程都有一个页表，逻辑页号 + 页表基址找到相应的物理页号，物理页号 + 偏移量 &#x3D; 物理地址</p>
<style>.kshslavjhspk{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526154921194.png" class="kshslavjhspk" alt="image-20240526154921194">

<style>.nolnyvulncbb{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526154941193.png" class="nolnyvulncbb" alt="image-20240526154941193">
</li>
<li><p>每个进程的页表的页数都不是固定的，有的进程页表可能很大，解决方案</p>
<ul>
<li>一些系统把页表存储在虚存中，因而页表本身也要进行分页。当一个进程运行时，其页表中一部分在主存中，另一部分则在辅存中保存</li>
<li>二级页表结构。每个进程有一个页目录表，其中的每个表项指向一个页表。若页目录表的长度（表项数）是 m，每个页表的最大长度（表项数）为 n，则一个进程最多可以有 m×n 个页</li>
<li>反向页表实现物理页号到逻辑页号的反向映射</li>
</ul>
</li>
<li><p>页表是虚地址到主存物理地址的变换表，通常称为内页表</p>
</li>
<li><p>外页表是用于虚地址与辅存地址之间的变换，主存缺页时就会用到</p>
</li>
<li><p>转换后援缓冲器 TLB</p>
<ul>
<li><p>把页表中的最活跃的部分存放在高 速存储器中，组成快表</p>
<style>.dvffmgnoiyan{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526155823138.png" class="dvffmgnoiyan" alt="image-20240526155823138">
</li>
<li><p>可能的情况</p>
<style>.ntogwzsbnqho{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526155856547.png" class="ntogwzsbnqho" alt="image-20240526155856547"></li>
</ul>
</li>
</ul>
</li>
<li><p>段式虚拟存储器</p>
<ul>
<li><p>把代码、数据、堆、栈等不同类型的数据划分到不同的段中</p>
</li>
<li><p>虚地址由段号、偏移量组成，每一个程序一个段表，段表的每一个表项对应一个段。段表常驻主存</p>
</li>
<li><p>每个表项包含：</p>
<ul>
<li>有效位：该段是否调入主存</li>
<li>段基址：该段在主存中的起始地址</li>
<li>段长：该段的实际长度，防止访问越界</li>
</ul>
</li>
<li><style>.nygrbhnemjcq{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526160420104.png" class="nygrbhnemjcq" alt="image-20240526160420104">
</li>
<li><p>分段易于管理，便于共享，但需要更多的硬件支持</p>
</li>
</ul>
</li>
<li><p>段页式虚拟存储器</p>
<ul>
<li><p>上面两者的结合，每个程序则先按逻辑结构分段， 每段再按照实存的页大小分页</p>
</li>
<li><p>虚拟地址构成</p>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526160833463.png" class="" title="image-20240526160833463">
</li>
<li><p>基号 N 找到段表，段号 S 找到页表，页号找到物理页号，物理页号 + 偏移量 D &#x3D; 物理地址</p>
<style>.hicjxqhrribs{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161114148.png" class="hicjxqhrribs" alt="image-20240526161114148"></li>
</ul>
</li>
</ul>
<style>.vdoscnzghfky{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161134274.png" class="vdoscnzghfky" alt="image-20240526161134274">

<blockquote>
<p>这些表项中都应该有一个有效位的</p>
</blockquote>
<ul>
<li><style>.ocviffxosmog{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161912949.png" class="ocviffxosmog" alt="image-20240526161912949">

<style>.gsqwmcwquxad{zoom: 50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161928436.png" class="gsqwmcwquxad" alt="image-20240526161928436">

<style>.elogykaqwunm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161957376.png" class="elogykaqwunm" alt="image-20240526161957376">
</li>
<li><p>虚拟内存的替换算法</p>
<ul>
<li><p>当从辅存调页至主存而主存已满时，也需要进行主存页面的替换</p>
</li>
<li><p>替换算法与 cache 的替换算法类似：FIFO 算法、LRU 算法、LFU 算法</p>
</li>
<li><p>不同点</p>
<ul>
<li>cache 的替换全部靠硬件实现，而虚拟存储器的替换有操作系统的支持</li>
<li>虚存缺页对系统性能的影响比 cache未命中要大得多</li>
</ul>
</li>
<li><p>FIFO+LRU 算法是对 FIFO 算法的一种改进，如果某个页面命中，则将该页面移动到 FIFO 队列入口位置。因为局部性原理，刚被访问的页面在最近的将来被再次访问的概率较大，故将其被替换的时间延后</p>
</li>
</ul>
</li>
</ul>
<h2 id="奔腾系列机的虚存组织"><a href="#奔腾系列机的虚存组织" class="headerlink" title="奔腾系列机的虚存组织"></a>奔腾系列机的虚存组织</h2><ul>
<li>略</li>
</ul>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令系统的发展与性能要求"><a href="#指令系统的发展与性能要求" class="headerlink" title="指令系统的发展与性能要求"></a>指令系统的发展与性能要求</h2><ul>
<li><p>指令就是要计算机执行的某种操作，分为：微指令（硬件），宏指令（软件），机器指令（我们要讨论的）</p>
<ul>
<li>一台计算机的所有机器指令的集合就是它的指令系统</li>
</ul>
</li>
<li><p>指令系统的发展：复杂指令系统 CISC，精简指令系统 RISC</p>
</li>
<li><p>指令系统的性能要求：完备性、有效性、规整性、兼容性</p>
</li>
<li><p>高级语言：与计算机的硬件结构和指令系统无关</p>
</li>
<li><p>低级语言：机器语言（二进制语言），汇编语言（符号语言）：依赖于硬件和指令系统</p>
</li>
</ul>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><ul>
<li><p>指令格式包括操作码字段、地址码字段</p>
</li>
<li><p>操作码：不同的操作码字段表示该指令应进行什么性质的操作</p>
<ul>
<li>组成操作码字段的位数一般取决于计算机指令系统的规模</li>
</ul>
</li>
<li><p>地址码：根据一条指令有几个操作数地址，可以将该指令称为几操作数指令 &#x2F; 几地址指令</p>
<ul>
<li>一般的操作数有被操作数、操作数、操作结果</li>
<li>分为：三地址指令、二地址指令、单地址指令、零地址指令</li>
<li>二地址指令根据操作数的物理位置又分为：存储器 - 存储器，寄存器 - 存储器，寄存器 - 寄存器</li>
</ul>
</li>
<li><p>指令字长度：指令包含的二进制位数</p>
<ul>
<li>机器字长：计算机能直接处理的二进制位数</li>
<li>所以分为：单字长指令、半字长指令、双字长指令</li>
</ul>
</li>
<li><p>指令助记符：为了便于书写和阅读程序，每条指令通常用 3个或 4 个英文缩写字母来表示二进制操作码</p>
</li>
</ul>
<h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><ul>
<li>地址数据：地址也是一种形式上的数据</li>
<li>数值数据分为：定点正数、小数，浮点数，BCD</li>
<li>字符数据：ASCLL</li>
<li>逻辑数据：一个单元中有几位二进制 bit 项组成</li>
</ul>
<h2 id="指令和数据的寻址方式"><a href="#指令和数据的寻址方式" class="headerlink" title="指令和数据的寻址方式"></a>指令和数据的寻址方式</h2><ul>
<li><p>寻址方式是指 CPU 根据指令中给出的地址码字段寻找相应的操作数的方式</p>
</li>
<li><p>指令的寻址分为：顺序寻址、条约寻址</p>
<style>.llnxwirjpyho{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527204803749.png" class="llnxwirjpyho" alt="image-20240527204803749">
</li>
<li><p>操作数寻址的基本方式</p>
<ul>
<li><p>把操作数形式地址变为操作数有效地址的过程</p>
<style>.ardhoqsufjtc{zoom: 67%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527204943758.png" class="ardhoqsufjtc" alt="image-20240527204943758">
</li>
<li><p>隐含寻址：没有明确给出操作数的地址，而是以某些默认寄存器作为源&#x2F;目的寄存器</p>
</li>
<li><p>立即寻址：指令中在操作码字段后面的部分不是操作数地址，而是操作数本身，又称为立即数</p>
<ul>
<li>不够灵活，不容易修改且受到指令字长的限制，常用于给某一寄存器或主存单元赋初值，或用于提供一个常数</li>
</ul>
</li>
<li><p>直接寻址：指令中地址码字段给出的地址就是操作数的有效地址</p>
</li>
<li><p>间接寻址：指令的地址码部分给出的地址存放操作数地址的主存单元的地址，简称操作数地址的地址</p>
<ul>
<li>灵活，不必修改指令，但效率低下，至少需要两次访问主存储器才能取出操作数</li>
</ul>
</li>
<li><p>寄存器寻址：指令的地址码部分给出 CPU 内某一通用寄存器的编号，指令的操作数存放在相应的寄存器中</p>
<ul>
<li>访问快，且减少地址码字段长度</li>
</ul>
</li>
<li><p>寄存器间接寻址：操作数放在主存储器中，而操作数的地址放在某一通用寄存器中，指令的地址码部分给出该通用寄存器的编号</p>
<ul>
<li>解决了间接寻址慢的问题，灵活且只需要一次访问主存，被广泛使用</li>
</ul>
</li>
<li><p>偏移寻址：分为相对寻址、基址寻址、变址寻址</p>
<ul>
<li><p>相对寻址：由程序计数器 PC 提供基准地址，而指令的地址码部分给出相对的位移量 D，两者相加后作为操作数的有效地址</p>
<style>.ekfaelqahsnp{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210450839.png" class="ekfaelqahsnp" alt="image-20240527210450839">
</li>
<li><p>基址寻址：指令的地址码部分给出偏移量，而基准地址放在基址寄存器中，基准地址与偏移量相加得到有效地址</p>
<style>.wqfffmdbutin{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210619747.png" class="wqfffmdbutin" alt="image-20240527210619747">
</li>
<li><p>变址寻址：将指令的地址码部分给出的基准地址与 CPU 内某特定的变址寄存器中的偏移量相加，以形成操作数的有效地址</p>
<ul>
<li><p>被广泛使用，在遇到需要频繁修改操作数地址时，无须修改指令，只要修改寄存器中的变址值就可以了</p>
<style>.xygrmehtpglu{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210803495.png" class="xygrmehtpglu" alt="image-20240527210803495"></li>
</ul>
</li>
</ul>
</li>
<li><p>段寻址：内存空间被划分为多段</p>
<style>.orwbmiufgzyj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527211512391.png" class="orwbmiufgzyj" alt="image-20240527211512391">
</li>
<li><p>堆结构：分为硬堆栈（专用寄存器），软堆栈（主存储器中）</p>
<ul>
<li>作用：实现程序调用，子程序嵌套调用和递归调用；实现中断，保存现场</li>
</ul>
</li>
<li><p>总结</p>
<style>.uytjgmbjapnn{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527211955003.png" class="uytjgmbjapnn" alt="image-20240527211955003"></li>
</ul>
</li>
</ul>
<h2 id="典型指令"><a href="#典型指令" class="headerlink" title="典型指令"></a>典型指令</h2><ul>
<li><p>简单分类：</p>
<ul>
<li>数据传送类指令：一般传送指令，数据交换指令，堆栈操作指令</li>
<li>运算类指令：算术运算指令，逻辑运算指令，移位指令</li>
<li>程序控制类指令、输入输出指令、字符串处理指令 ……</li>
</ul>
</li>
<li><p>复杂指令集计算机 CISC</p>
<ul>
<li><p>28 定律：CISC 中大约有 20% 的指令使用占据了 80% 的处理机时间，而有 80% 的不常用指令只占用处理机的 20% 时间</p>
</li>
<li><p>特征：</p>
<ul>
<li>使用微代码：指令集可以直接在微代码内存（比主内存的速度快很多）里执行</li>
<li>庞大的指令集，通过增强指令系统的功能，简化了软件，增加了硬件的复杂程度</li>
<li>高级语言对应的指令集</li>
</ul>
</li>
<li><p>优点：能够有效缩短新指令的微代码设计时间，允许设计师实现 CISC 体系机器的向上兼容</p>
</li>
<li><p>缺点：设计越来越复杂，不同的指令，需要不同的时钟周期来完成，执行较慢的指令，将影响整台机器的执行效</p>
</li>
</ul>
</li>
<li><p>精简指令集计算机 RISC</p>
<ul>
<li>指令系统应当只包含那 些使用频率很高的少量指令。并提供一些必要的指令以支持操作系统和高级语言</li>
<li>特征（采用流水线技术）：<ul>
<li>指令条数少；简单而统一格式的指令译码；简单的寻址方式</li>
<li>大部分指令可以单周期执行； 只有LOAD&#x2F;STORE可以访问存储器；较多的寄存器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><h2 id="CPU-的功能和组成"><a href="#CPU-的功能和组成" class="headerlink" title="CPU 的功能和组成"></a>CPU 的功能和组成</h2><ul>
<li><p>CPU 的功能就是取指令和执行指令</p>
</li>
<li><p>CPU 的基本组成</p>
<ul>
<li><p>运算器：ALU、通用寄存器、数据缓冲寄存器、状态字寄存器</p>
<ul>
<li>功能：接受控制器的命令而进行操作</li>
</ul>
</li>
<li><p>控制器：程序计数器、指令寄存器、地址寄存器 ……</p>
<ul>
<li>功能：对指令进行译码或测试，并产生相应的操作控制信号</li>
</ul>
</li>
<li><p>cache</p>
</li>
</ul>
</li>
<li><p>CPU 的主要寄存器</p>
<ul>
<li><p>数据缓冲寄存器 DR：作为 ALU 运算结果和通用寄存器之间信息传送中时间上的缓冲</p>
</li>
<li><p>指令寄存器 IR、指令译码器 ID：存放从存储器中取出的待执行的指令，暂存的指令只有经译码后才能识别出是一条什么样的指令</p>
<ul>
<li>译码器经过对指令进行分析和解释，产生相应的控制信号</li>
</ul>
</li>
<li><p>程序计数器 PC：用来存放正在执行的指令的地址或接着将要执行的下一条指令的地址</p>
</li>
<li><p>数据地址寄存器 AR：保存当前 CPU 访问的数据在 cache 中单元的地址</p>
</li>
<li><p>通用寄存器 R0 ~ R3：可存放源操作数、结果操作数</p>
</li>
<li><p>状态字寄存器 PSW：保存由算术指令和逻辑指令运算或测试结果、中断或系统工作状态等信息</p>
</li>
</ul>
</li>
<li><p>操作控制器和时序产生器</p>
<ul>
<li><p>数据通路：寄存器之间传送信息的通路</p>
</li>
<li><p>操作控制器：为数据通路的建立提供各种操作信号。可分为时序逻辑型和存储逻辑型</p>
<ul>
<li>硬布线控制器：采用时序逻辑技术实现</li>
<li>微程序控制器：采用存储逻辑来实现</li>
</ul>
</li>
<li><p>时序产生器：提供定时和时序信号对各种操作信号实施时间上的控制</p>
</li>
</ul>
</li>
</ul>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><ul>
<li><p>指令周期：取指指令、分析指令到执行完该指令所需的全部时间</p>
</li>
<li><p>机器周期：通常又称 CPU 周期、时钟周期，通常把一条指令周期划分为若干个机器周期，每个机器周期完成一个基本操作</p>
<ul>
<li>不同的指令，可能包含不同数目的机器周期</li>
</ul>
</li>
<li><p>一个机器周期中，包含若干个 T 周期（节拍脉冲或 T 脉冲， 处理操作的最基本单位）</p>
</li>
</ul>
<style>.inkoczhdxime{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192515259.png" class="inkoczhdxime" alt="image-20240528192515259">

<ul>
<li><p>MOV 指令的指令周期</p>
<style>.znuejiuvknfh{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192643133.png" class="znuejiuvknfh" alt="image-20240528192643133">
</li>
<li><p>LAD 指令的指令周期：它的数据传 送方向是从内存到寄存器</p>
</li>
</ul>
<style>.cqivfupdvpcv{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192751788.png" class="cqivfupdvpcv" alt="image-20240528192751788">

<ul>
<li><p>ADD 指令的指令周期</p>
<style>.blvimuowodsa{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192845807.png" class="blvimuowodsa" alt="image-20240528192845807">
</li>
<li><p>STO 指令的指令周期：将寄存器或立即数中的值存储到指定的内存地址</p>
</li>
</ul>
<style>.mcfwiqcbhuvr{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192931988.png" class="mcfwiqcbhuvr" alt="image-20240528192931988">

<ul>
<li>JMP 指令的指令周期</li>
</ul>
<style>.fqgmtwqudaxd{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192954705.png" class="fqgmtwqudaxd" alt="image-20240528192954705">

<ul>
<li>方框图语言表示指令周期<ul>
<li>方框：按CPU周期；方框内内容：数据通路操作或控制操作；菱形符号：判别或测试</li>
</ul>
</li>
</ul>
<style>.gvepglhldvib{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528193103420.png" class="gvepglhldvib" alt="image-20240528193103420">

<ul>
<li>一条指令包括一个取指令周期和一个及一 个以上的执行周期组成</li>
</ul>
<h2 id="时序产生器和控制方式"><a href="#时序产生器和控制方式" class="headerlink" title="时序产生器和控制方式"></a>时序产生器和控制方式</h2><ul>
<li><p>时序产生器的作用：CPU 中的控制器用它指挥机器的工作，可以辨别从内存中取出的是指令还是数据</p>
</li>
<li><p>时序产生器的体制：电位—脉冲制</p>
</li>
<li><p>硬布线控制器</p>
<ul>
<li>时序信号采用主状态周期、节拍电位、节拍脉冲三级体制</li>
<li>一个节拍电位表示一个 CPU 周期，包含多个节拍脉冲</li>
<li>一个主状态周期包含多个节拍电位</li>
</ul>
</li>
<li><p>微程序控制器</p>
<ul>
<li>时序信号采用节拍电位（1个）、节拍脉冲（多个）二级体制</li>
</ul>
</li>
<li><p>时序产生器的功能：用逻辑电路来产生时序信号</p>
</li>
<li><p>控制方式：控制不同操作序列时序信号的方法，主要有以下几种</p>
<ul>
<li>同步控制方式：指令的机器周期和时钟周期数不变</li>
<li>异步控制方式：每条指令需要多长时间就占多长时间</li>
<li>联合控制方式：大部分指令在固定的周期内完成，少数难以确定的操作采用异步方式 <ul>
<li>机器周期的节拍脉冲固定，但是各指令的机器周期数不固定（微程序控制器采用）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><ul>
<li><p>基本思想：把操作控制信号编制成微指令，存放到控制存储器里，运行时，从控存中取出微指令，产生指令运行所需的操作控制信号</p>
<ul>
<li>以设计软件的方法设计硬件</li>
</ul>
</li>
<li><p>微命令：构成控制序列的最小单位，控制器件向执行部件发出的各种控制命令</p>
</li>
<li><p>微操作：微命令的操作过程，微操作是执行部件中最基本的操作，分为两类</p>
<ul>
<li>互斥的微操作：不能在同一 CPU 周期并行执行的微操作</li>
<li>相容的微操作：能够在同一 CPU 周期并行执行的微操作</li>
</ul>
</li>
<li><p>微指令：把在同一 CPU 周期内并行执行的微操作控制信息，存储在控制存储器里，称为一条微指令。分为两部分</p>
<ul>
<li><p>操作控制字段：又称微操作码字段，用以产生某一步操作所需的各个微操作控制信号。</p>
<ul>
<li>某位为 1 表明发微命令。微指令持续时间为一个 CPU 周期</li>
</ul>
</li>
<li><p>顺序控制字段：又称微地址码字段，用以控制产生下一条要执行的微指令地址</p>
</li>
</ul>
</li>
<li><p>微程序：一系列微指令的有序集合就是微程序。，一段微程序对应一条机器指令</p>
</li>
<li><p>微地址：存放微指令的控制存储器的单元地址</p>
</li>
<li><p>一些相关的寄存器</p>
<ul>
<li>控制存储器 μCM：这是微程序控制器的核心部件，用来存放微程序</li>
<li>微指令寄存器 μIR：用来存放从 μCM 取出的正在执行的微指令</li>
<li>微命令寄存器：用来保存一条微指令的操作控制字段和判别测试字段的信息</li>
<li>微地址寄存器 μMAR：决定将要访问的下一条微指令的地址</li>
</ul>
</li>
<li><p>CPU 周期与微指令的周期之间的关系</p>
<ul>
<li>微指令周期等于读出微指令的时间加上执行该条微指令的时间</li>
<li>一个微指令周期时间设计恰好和 CPU 周期时间相等</li>
</ul>
</li>
<li><p>微程序设计技术</p>
<ul>
<li><p>微命令的编码方法</p>
<ul>
<li><p>直接表示法：操作控制字段中的各位分别可以直接控制计算机，不需要进行译码</p>
<style>.qqsjdcvlqrpa{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203758900.png" class="qqsjdcvlqrpa" alt="image-20240528203758900">
</li>
<li><p>编码表示法：将操作控制字段分为若干个小段，每段内采用最短编码法，段与段之间采用直接控制法</p>
<style>.qrsdsosscrsh{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203904975.png" class="qrsdsosscrsh" alt="image-20240528203904975">
</li>
<li><p>混合编码法：两者的结合</p>
<style>.klfrfkwfjszf{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203943373.png" class="klfrfkwfjszf" alt="image-20240528203943373">
</li>
<li><p>编码的原则</p>
<ul>
<li>把互斥性的微命令分在同一段内，兼容性的微命令分在不同段内</li>
<li>每个小段中包含的信息位不能太多</li>
<li>一般每个小段还要留出一个状态，表示本字段不发出任何微命令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.omtwweqnbjqt{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204109642.png" class="omtwweqnbjqt" alt="image-20240528204109642">

<ul>
<li><style>.havaoehyjehg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204129483.png" class="havaoehyjehg" alt="image-20240528204129483"></li>
</ul>
<style>.ndxdvffnslfj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204143019.png" class="ndxdvffnslfj" alt="image-20240528204143019">

<style>.kevgpivfrtdq{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204156706.png" class="kevgpivfrtdq" alt="image-20240528204156706">

<ul>
<li><p>微指令地址的形成</p>
<ul>
<li>入口地址：每条机器指令对应一段微程序，由机器指令的操作码字段指出各段微程序的入口地址。主要方式有<ul>
<li>计数器的方式：微程序控制器中也有一个微程序计数器 μPC，一般情况下都是将微地址寄存器 μMAR 作为 μPC</li>
<li>多路转移的方式</li>
</ul>
</li>
</ul>
</li>
<li><p>微指令的格式，分为</p>
<ul>
<li><p>水平型微指令：指一次能定义并能并行执行多个微命令的微指令</p>
<ul>
<li>并行能力强，速度快，但难以掌握</li>
</ul>
</li>
<li><p>垂直型微指令：采用编码方式，一次只能执行一到二个微命令</p>
<ul>
<li>速度慢，相较而言容易掌握</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h2><ul>
<li><p>实现方法：通过逻辑电路直接连线而产生的，又称为组合逻辑控制方式</p>
</li>
<li><p>设计目标：使用最少元件，速度最高</p>
</li>
<li><p>指令的执行流程</p>
<style>.foshhxrjmmqw{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528210718631.png" class="foshhxrjmmqw" alt="image-20240528210718631">
</li>
<li><p>微信号的产生</p>
<ul>
<li>在微程序控制器中，微操作控制信号由微指令产生</li>
<li>在硬联线控制器中，某一微操作控制信号由布尔代数表达式描述的输出函数产生<ul>
<li>设计步骤<ul>
<li>画出指令流程图，列出微操作时间表，进行微操作信号的综合，实现电路</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="传统-CPU"><a href="#传统-CPU" class="headerlink" title="传统 CPU"></a>传统 CPU</h2><ul>
<li>略</li>
</ul>
<h2 id="流水-CPU"><a href="#流水-CPU" class="headerlink" title="流水 CPU"></a>流水 CPU</h2><ul>
<li><p>并行性：具有可以同时进行运算或操作的特性，在同一时刻或在同一时间间隔内完成两种或两种以上的工作，他们在时间上相互重叠，都体现了并行性</p>
<ul>
<li>时间并行（重叠）：让多个处理过程在时间上相互错开，轮流使用同一套硬件设备的各个部件， 实现方式就是采用流水处理</li>
<li>空间并行（资源重复）：以数量取胜，</li>
<li>时间+空间并行：超标量流水线技术它能真正的体现同时性</li>
</ul>
</li>
<li><p>流水线的分类：指令流水线（按照指令步骤的并行）、算术流水线（按照运算操作步骤的并行）、处理机流水线（按照程序步骤的并行）</p>
</li>
<li><p>流水线中的主要问题</p>
<ul>
<li><p>资源相关：多条指令进入流水线后在同一时钟周期内争用同一功能部件</p>
<ul>
<li>解决办法：后边指令拖一拍再推进；增设一个功能部件</li>
</ul>
</li>
<li><p>数据相关</p>
<ul>
<li>RAW (Read After Write)：后面指令用到前面指令所写的数据</li>
<li>WAW (Write After Write)：两条指令写同一个单元（在简单流水线中没有此类相关，因为不会乱序执行）</li>
<li>WAR (Write After Read)：后面指令覆盖前面指令所读的单元（在简单流水线中没有此类相关）</li>
<li>解决办法： 可以推后后继指令对相关单元的读操作</li>
</ul>
</li>
<li><p>控制相关 </p>
<ul>
<li>引起原因：转移指令</li>
<li>解决办法：延迟转移法，转移预测法</li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.tbfpbxyqsopm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528213126274.png" class="tbfpbxyqsopm" alt="image-20240528213126274">

<h1 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h1><h2 id="总线的概念和结构形态"><a href="#总线的概念和结构形态" class="headerlink" title="总线的概念和结构形态"></a>总线的概念和结构形态</h2><ul>
<li><p>总线的基本概念：总线是构成计算机系统的互联机构，是多个系统功能部件之间进行数据传送的公共通路</p>
</li>
<li><p>总线的分类</p>
<ul>
<li>内部总线：CPU 内部连接各寄存器及运算器部件之间的总线</li>
<li>系统总线：外部总线，CPU 和计算机系统中其他高速功能部件相互连接的总线</li>
<li>I&#x2F;O总线：中低速 I&#x2F;O 设备相互连接的总线</li>
</ul>
</li>
<li><p>总线的特性</p>
<ul>
<li>物理特性：总线的物理连接方式</li>
<li>功能特性：每根线的功能</li>
<li>电气特性：每根线上信号的传递方向及有效电平范围</li>
<li>时间特性：规定了每根总线在什么时间有效</li>
</ul>
</li>
<li><p>总线标准</p>
<ul>
<li>由于标准化，不同厂家生产的内部实现不同但功能相同的功能部件可以互换使用</li>
<li>已经出现了很多总线标准：PCI、ISA</li>
</ul>
</li>
<li><p>总线带宽：总线本身所能达到的最高传输速率</p>
<ul>
<li>一次操作可以传输的数据位数（MB&#x2F;s），如 S100 为 8 位，ISA 为 16 位，EISA 为 32 位，PCI 可达 64 位</li>
<li>总线宽度不会超过微处理器外部数据总线的宽度</li>
</ul>
</li>
<li><style>.fmkmzorgplhq{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529180641225.png" class="fmkmzorgplhq" alt="image-20240529180641225">
</li>
<li><p>单机系统中总线的基本结构</p>
<ul>
<li><p>单总线：使用一条单一的系统总线来连接 CPU、内存和 I&#x2F;O 设备</p>
<ul>
<li><p>要求连接到总线上的逻辑部件必须高速运行；而当不再使用总线时，能迅速放弃总线控制权</p>
<style>.yxynvvfrxmih{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529180852668.png" class="yxynvvfrxmih" alt="image-20240529180852668"></li>
</ul>
</li>
<li><p>多总线：在 CPU、主存、I&#x2F;O 之间互联采用多条总线</p>
<ul>
<li><style>.sryiwtqfugrt{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181002510.png" class="sryiwtqfugrt" alt="image-20240529181002510"></li>
</ul>
</li>
</ul>
</li>
<li><p>总线的内部结构</p>
<ul>
<li><p>早期是处理器芯片引脚的延伸，是处理器与 I&#x2F;O 设备适配器的通道</p>
<ul>
<li>总线结构紧密与 CPU 相关，通用性较差</li>
</ul>
</li>
<li><p>当代流行的内部结构</p>
<ul>
<li><style>.rvxkorkwxkqs{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181527522.png" class="rvxkorkwxkqs" alt="image-20240529181527522"></li>
</ul>
</li>
</ul>
</li>
<li><p>现代大多数计算机采用了分层次的多总线结构，三层次：CPU总线、PCI 总线和 ISA 总线</p>
<style>.xdcqfyeutdvw{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181604088.png" class="xdcqfyeutdvw" alt="image-20240529181604088"></li>
</ul>
<h2 id="总线接口"><a href="#总线接口" class="headerlink" title="总线接口"></a>总线接口</h2><ul>
<li><p>计算机中信息传输的三种基本方式：</p>
<ul>
<li>串行传输：仅使用一条传输线，采用脉冲传送，速度慢</li>
<li>并行传输：系统总线上传输的信息必须是并行传输。每一个数据位都需要使用一条传输线，一般使用电位传输法</li>
<li>分时传输：总线复用或共享总线的部件分时使用总线</li>
</ul>
</li>
<li><p>总线接口的基本概念：接口是 CPU 、主存和外设之间通过总线进行连接的逻辑部件</p>
<style>.ovqdqzjgbdsf{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531142702926.png" class="ovqdqzjgbdsf" alt="image-20240531142702926">
</li>
<li><p>接口的典型功能：控制、缓冲、状态、转换、整理、程序 中断</p>
<ul>
<li>一个适配器的两个接口：一个同系统总线相连，采用并行 方式，另外一个同设备相连，可能采用并行方式或是串行方式</li>
</ul>
</li>
<li><style>.acvwomgrxrpa{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531142756627.png" class="acvwomgrxrpa" alt="image-20240531142756627"></li>
</ul>
<h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><ul>
<li><p>连接到总线上的功能模块有两种：主动和被动，主动方可以启动一个总线周期，被动方只能响应主动方的请求。每次总线操作中，只能有一个主动方，但被动方可以有多个</p>
<ul>
<li>对于多个设备提出的占用总线请求， 一般采用优先级或公平策略进行仲裁</li>
</ul>
</li>
<li><p>为了解决多个功能模块争用总线的问题，必须设置总线仲裁部件，按照仲裁电路的位置不同，分为：集中式和分布式两种</p>
</li>
<li><p>集中式仲裁有三种</p>
<ul>
<li><p>链式查询方式：离中央仲裁器最近的设备具有最高优先权，离总线控制器越 远，优先权越低</p>
</li>
<li><p>计数器定时查询方式：</p>
<ul>
<li><p>总线上的任一设备要求使用总线时， 通过 BR 线发出总线请求</p>
</li>
<li><p>中央仲裁器接到请求信号以后，在 BS 线为 “0” 的情况下让计数器开始计数，计数值通过一组地址线发向各设备</p>
</li>
<li><p>每个设备接口都有一个设备地址判别电路， 当地址线上的计数值与请求总线的设备地址相一致时，该设备置 “1” BS 线，获得了总线使用权，此时中止计数查询</p>
</li>
<li><p>计数器从 0 开始，则设备的优先级和链式查询一样，优先级是固定的，计数器从中止点开始奇数，则各个设备优先级相同</p>
</li>
</ul>
</li>
<li><p>独立请求的方式：</p>
<ul>
<li>每个共享总线的设备都有一对总线请求线 BRi 和总线授权线 BGi。总线仲裁器中有一个排队电路，它根据一定的优先次序决定首先响应哪个设备的请求</li>
<li>很灵活，当代总线标准普遍采用独立请求的方式</li>
</ul>
</li>
</ul>
</li>
<li><p>分布式：不需要中央仲裁器，而是多个仲裁器竞争使用总线</p>
<ul>
<li>当它们有总线请求时，把它们唯一的仲裁号发送到共享的仲裁总线上</li>
<li>每个仲裁器将 仲裁总线上得到的号与自己的号进行比较</li>
<li>如果仲裁总线上的号大，则它的总线请求不予响应，并撤消它的仲裁号</li>
<li>最后，获胜者的仲裁号保留在仲裁总线上</li>
</ul>
</li>
<li><p>总线定时：事件出现在总线上的时序关系，分为：同步定时、异步定时</p>
<ul>
<li>同步定时：事件出现在总线 上的时刻由总线时钟信号来确定</li>
<li>异步定时：后一事件出现在总线上的时刻取决于前一事件的出现</li>
</ul>
</li>
<li><p>总线的信息传递的过程：请求总线、总线仲裁、寻址、信息传送、状态返回</p>
</li>
<li><style>.ybiaoixlufio{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531161030531.png" class="ybiaoixlufio" alt="image-20240531161030531"></li>
</ul>
<style>.jsehygeunfuv{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531161041767.png" class="jsehygeunfuv" alt="image-20240531161041767">

<style>.itwiogxgmijm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531161058791.png" class="itwiogxgmijm" alt="image-20240531161058791">

<ul>
<li><p>总线的数据传送模式</p>
<ul>
<li><p>读、写操作：读操作是由从方到主方的数据传送； 写操作是由主方到从方的数据传送</p>
</li>
<li><p>块传送操作：只需给出块的起始地址，然后对固定块长度的数据一个接一个地读出或写入（猝发式传送）</p>
</li>
<li><p>写后读、读修改写操作：只给出地址一次，或进行先写后读操作，或进行先读后写操作</p>
</li>
<li><p>广播、广集操作：允许一个主方对多个从方进行写操作，这种操作称为广播。与广播相反的操作称为广集</p>
</li>
</ul>
</li>
</ul>
<style>.eslkkylwstue{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531161613526.png" class="eslkkylwstue" alt="image-20240531161613526">

<h1 id="外围设备"><a href="#外围设备" class="headerlink" title="外围设备"></a>外围设备</h1><h2 id="外围设备概述"><a href="#外围设备概述" class="headerlink" title="外围设备概述"></a>外围设备概述</h2><ul>
<li><p>外围设备的基本组成：</p>
<ul>
<li>存储介质：具有保存信息的物理特征</li>
<li>驱动装置：用于移动存储介质</li>
<li>控制电路：它向存储介质发送数据或从存储介质接受数据</li>
</ul>
</li>
<li><p>外围设备的分类：输入设备、输出设备、外存设备、数据通信设备和过程控制设备几大类</p>
<ul>
<li>每一种外围设备，都是在它自己的设备控制器控制下进行工作，而设备控制器则通过I&#x2F;O接口和主机连接，并受主机控制</li>
</ul>
</li>
</ul>
<h2 id="磁盘存储设备"><a href="#磁盘存储设备" class="headerlink" title="磁盘存储设备"></a>磁盘存储设备</h2><ul>
<li><p>磁盘记录原理</p>
<ul>
<li>磁表面存储，是用某些磁性材料薄薄地涂在金属铝或塑料表面作载磁体来存储信息</li>
</ul>
</li>
<li><p>磁表面存储器的读写原理</p>
<ul>
<li>写操作：利用磁头来形成 磁层中的磁化状态<ul>
<li>电磁变换，利用磁头写线圈中的脉冲电流，可把一位二进制代码转换成载磁体存储元的不同剩磁状态</li>
</ul>
</li>
<li>读操作：利用磁头来判别磁层中的磁化状态<ul>
<li>通过磁电变换，利用磁头读出线圈， 可将由存储元的不同剩磁状态表示的二进制代码转换成电信号输出</li>
</ul>
</li>
</ul>
</li>
<li><p>硬磁盘：记录介质为硬质圆形盘片的磁表面存储器</p>
<ul>
<li><p>包括：磁记录介质、磁盘控制器（数据并-串变换电路 串-并变换电路）、磁盘驱动器</p>
</li>
<li><p>写入时，将计算机并行送来的数据取至并串变换寄存器，变为串行数据，然后一位一位地由功率放大并加到写磁头线圈上产生电流，从而在盘片磁层上形成按位的磁化存储元</p>
</li>
<li><p>读出时，此读出信息经放大检测就可还原成原来存入的数据，由于数据是一位一位串行读出的，故要送至串-并变 换寄存器变换为并行数据，再并行送至计算机</p>
</li>
<li><p>根据盘片结构也分为：可移动磁头固定盘片、可移动磁头可换盘片、固定磁头（每个磁道一个磁头）</p>
</li>
</ul>
</li>
<li><p>温彻斯特磁盘：可移动磁头固定盘片的磁盘机。高速旋转在盘面上形成的气垫将磁头平稳浮起，优点是防尘性能好，工作环境要求不高</p>
</li>
<li><p>磁盘驱动器的基本结构：定位驱动系统、主轴系统和数据转换系统</p>
<style>.bkhdonhtyxry{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531193436351.png" class="bkhdonhtyxry" alt="image-20240531193436351">
</li>
<li><p>磁盘控制器是主机与磁盘驱动器之间的接口，它需要有两个方面的接口： </p>
<ul>
<li>一个是与主机的接口，控制外存与主机总线之间交换 数据；另一个是与设备的接口，根据主机命令控制设备的操作</li>
</ul>
</li>
<li><p>主机与磁盘驱动器交换数据：</p>
<ul>
<li><p>磁盘上的信息经读磁头读出以后送读出放大器，然后进行数据与时钟的分离，再进行串——并变换、格式变换，最后送入数据缓冲器，经 DMA (直接存储器传送) 控制将数据传送到主机总线</p>
<style>.mdcflejgdqdh{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531193644566.png" class="mdcflejgdqdh" alt="image-20240531193644566"></li>
</ul>
</li>
<li><p>磁盘上的信息分布：</p>
<ul>
<li><p>盘片的上下两面都能记录信息，通常把磁盘片表面称为记录面</p>
</li>
<li><p>记录面上一系列同心圆称为磁道，每个盘片表面通常有几百到几千个磁道</p>
</li>
<li><p>每个磁道又分为若干个扇区</p>
</li>
<li><p>磁盘地址由记录面号（也称磁头号)、磁道号和扇区号三部分组成</p>
<style>.dkqzdhciswgu{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531193843290.png" class="dkqzdhciswgu" alt="image-20240531193843290"></li>
</ul>
</li>
<li><p>磁盘存储器的技术指标：</p>
<ul>
<li><p>存储密度：存储密度分道密度、位密度和面密度</p>
<ul>
<li>道密度：沿磁盘半径方向单位长度上的磁道数</li>
<li>位密度：磁道单位长度上能记录的二进制代码位数</li>
<li>面密度：位密度和道密度的乘积</li>
</ul>
</li>
<li><p>存储容量：一个磁盘存储器所能存储的字节总数，称为磁盘存储器的存储容量</p>
</li>
<li><p>存取时间：从发出读写命令后，磁头从某一起始位置移动至新的记录位置，到开始从盘片表面读出或写入信息加上传送数据所需要的时间</p>
<ul>
<li>取决于：寻道时间、旋转时间、数据传送时间</li>
</ul>
</li>
<li><p>数据传输效率：磁盘存储器在单位时间内向主机传送数据的字节数</p>
<ul>
<li>假设磁盘旋转速度为 n转&#x2F;秒，每条磁道容量为 N 个字节，则数据传输率：<code>Dr = nN</code> (字节&#x2F;秒)</li>
</ul>
</li>
</ul>
</li>
<li><style>.zomlmvgpbteg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531194247266.png" class="zomlmvgpbteg" alt="image-20240531194247266"></li>
</ul>
<style>.ivyjjbmnmwbv{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531194301199.png" class="ivyjjbmnmwbv" alt="image-20240531194301199">

<h2 id="磁盘存储设备的技术发展"><a href="#磁盘存储设备的技术发展" class="headerlink" title="磁盘存储设备的技术发展"></a>磁盘存储设备的技术发展</h2><ul>
<li><p>磁盘 cache</p>
<ul>
<li>主存和 CPU 之间设置高速缓存 cache 是为了弥补主存和 CPU之间速度上的差异</li>
<li>同样，磁盘 cache 是为了弥补慢速磁盘和主存之间速度上的差异</li>
<li>磁盘 cache 利用了被访问数据的空间局部性和时间局部性原理</li>
</ul>
</li>
<li><p>磁盘阵列 RAID</p>
<ul>
<li>RAID 称廉价冗余磁盘阵列，它是用多台磁盘存储器组成的大容量外存系统</li>
<li>利用数据分块技术和并行处理技术，在多个磁盘上交错存放数据，可实现数据的并行存储、交叉存储、单独存储</li>
</ul>
</li>
</ul>
<h2 id="磁带存储设备"><a href="#磁带存储设备" class="headerlink" title="磁带存储设备"></a>磁带存储设备</h2><ul>
<li>磁带机的记录原理与磁盘机基本相同，只是它的载磁体是一种带状塑料，叫做磁带</li>
<li>磁带存储设备由磁带机和磁带两部分组成。磁带速度比磁盘速度慢，原因是磁带上的数据采用顺序访问方式，而磁盘则采用随机访问方式，所以它通常存储海量数据</li>
</ul>
<h2 id="光盘和磁光盘存储设备"><a href="#光盘和磁光盘存储设备" class="headerlink" title="光盘和磁光盘存储设备"></a>光盘和磁光盘存储设备</h2><ul>
<li><p>只读型光盘系统都基于一个共同原理，即光盘上的信息以坑点形式分布，有坑点表示为 “1”，无坑点表示为 “0”，一系列的坑点 (存储元) 形成信息记录道。必须采用激光作为光源，并采用良好的光学系统才能实现</p>
</li>
<li><p>光盘的记录信息以凹坑方式永久性存储</p>
</li>
</ul>
<h2 id="显示设备"><a href="#显示设备" class="headerlink" title="显示设备"></a>显示设备</h2><ul>
<li><p>器件：CRT（阴极射线管）、LCD、等离子体 </p>
</li>
<li><p>显示内容：字符、图象 </p>
</li>
<li><p>CRT 中又可以分类： </p>
<ul>
<li>扫描方式：光栅扫描和随机扫描 </li>
<li>分辨率：高分辨率和低分辨率 <ul>
<li>分辨率：显示器所能显示的像素个数</li>
<li>灰度级：像素点的亮暗差别（黑白）颜色的不同（彩色）。灰度级越多，图象层次越清楚越逼真</li>
</ul>
</li>
<li>显示颜色：单色和彩色 </li>
<li>显示屏幕大小：14、15、17、19 等</li>
</ul>
</li>
<li><p>刷新：电子束打在荧光粉上引起的发光只能维持几十毫 秒的时间。因此必须让电子束反复不断地扫描整个屏幕， 该过程称为刷新</p>
</li>
</ul>
<h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="外围设备的定时方式和信息交换方式"><a href="#外围设备的定时方式和信息交换方式" class="headerlink" title="外围设备的定时方式和信息交换方式"></a>外围设备的定时方式和信息交换方式</h2><ul>
<li><p>高速的 CPU 与速度参差不齐的外设怎样在时间上同步？</p>
<ul>
<li>解决办法时在 CPU 和外设之间数据传送时加以定时（同步定时）</li>
</ul>
</li>
<li><p>输入输出设备同 CPU 交换数据的过程：</p>
<ul>
<li><p>输入过程：</p>
<ul>
<li>CPU 把一个地址值放到地址总线上，这一步将选择某一输入设备</li>
<li>CPU 等候输入设备的数据成为有效</li>
<li>CPU 从数据总线输入数据，并放在一个相应的寄存器中</li>
</ul>
</li>
<li><p>输出过程：</p>
<ul>
<li>CPU 把一个地址值放到地址总线上，这一步将选择 某一输出设备</li>
<li>CPU 把数据放在数据总线上</li>
<li>输出设备认为数据有效，从而把数据取</li>
</ul>
</li>
</ul>
</li>
<li><p>外围设备的速度分类：</p>
<ul>
<li>速度慢的设备：CPU只需要接受或者发送数据即可</li>
<li>中速的设备：CPU从外设接收一个字，则它首先询问外设的状态，如果准备就绪，则 CPU 将数据取走，发出响应信号，外设将状态位复位，进行下一个字节的交换。如果外设状态是忙，那 CPU 进入一个循环，每次询问外设状态</li>
<li>高速的设备：采用同步定时方式，CPU 和外设以相等的时间间隔执行操作</li>
</ul>
</li>
<li><p>信息的交换方式：</p>
<style>.ptdltuefibrp{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531203549926.png" class="ptdltuefibrp" alt="image-20240531203549926">

<ul>
<li>程序查询方式：CPU 和外围设备之间的传送完全靠计算机程序控制，由于查询循环的存在，浪费 CPU 时间</li>
<li>程序中断方式：中断是外围设备用来 “主动” 通知 CPU，节省 CPU 时间<ul>
<li>以上两种方式适用于：数据传输率比 较低的外围设备</li>
</ul>
</li>
<li>直接内存访问（DMA）方式：DMA控制器从CPU完全接管对总线的控制，数据交换不经过 CPU，而直接在内存和外围设备之间进行，完全由硬件控制</li>
<li>通道方式：通道是一个具有特殊功能的处理器，实现对外围设备的统一管理<ul>
<li>以上两种方式适用于：数据传输率比较高的设备</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="程序的查询方式"><a href="#程序的查询方式" class="headerlink" title="程序的查询方式"></a>程序的查询方式</h2><ul>
<li><p>数据在 CPU 和外围设备之间的传送完全靠计算机程序控制，是在CPU主动控制下进行的</p>
<ul>
<li>当需要输入&#x2F;输出时，CPU 暂停执行主程序，转去执行设备输入&#x2F;输出的服务程序，根据服务 程序中的 I&#x2F;O 指令进行数据传送</li>
</ul>
</li>
<li><p>设备编址</p>
<ul>
<li>统一编址：输入&#x2F;输出设备和内存单元一样看待，联合变址，可以用访问内存的指令访问 I&#x2F;O 设备，不需要专门的 I&#x2F;O 指令组</li>
<li>单独编址：内存和 I&#x2F;O 设备分开看待，需要专门的 I&#x2F;O 指令组</li>
</ul>
</li>
<li><p>输入输出指令</p>
<ul>
<li>I&#x2F;O 指令：<ul>
<li>置 “1” 或置 “0” I&#x2F;O 接口的某些控制触发器，用于控制设备的某些动作</li>
<li>测试设备状态</li>
<li>传送数据</li>
</ul>
</li>
</ul>
</li>
<li><p>程序查询方式的接口：设备选择电路、数据缓冲寄存器、设备状态寄存器</p>
</li>
</ul>
<style>.jymylllcjdkw{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531204806636.png" class="jymylllcjdkw" alt="image-20240531204806636">

<h2 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h2><ul>
<li>中断（Interrupt）是指 CPU 暂时中止现行程序， 转去处理随机发生的紧急事件，处理完后自动 返回原程序的功能和技术</li>
<li>中断处理过程注意几个问题： <ul>
<li>响应中断时机：外界中断请求是随机的， 但 CPU 只有在当前指令执行完毕后，才转至公操作</li>
<li>断点保护问题（PC，寄存器内容和状态 的保存）</li>
<li>开中断和关中断问题</li>
<li>中断是由软硬件结合起来实现的</li>
</ul>
</li>
</ul>
<style>.jxflygxmiyoj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240531210416282.png" class="jxflygxmiyoj" alt="image-20240531210416282">

<ul>
<li><p>程序中断方式的基本接口</p>
<ul>
<li>BS 外设接口忙（BuSy）标志 </li>
<li>RD 外设准备就绪（ReaDy）标志 </li>
<li>EI（Enable Interrupt中断允许触发器）</li>
<li>IR（Interrupt Request）中断请求触发器 </li>
<li>IM（Interrupt Mask）中断屏蔽触发器</li>
</ul>
</li>
<li><p>单级中断</p>
<ul>
<li>所有中断源属于同一级，离 CPU 越近优先级越高</li>
<li>不允许其它中断源再打断中断服务程序，即使优先权比它高的中断源也不能再打断</li>
<li>中断向量：CPU 响应中断时，由硬件直接产生一个固定的地址，即向量地址<ul>
<li>由向量地址指出每个中断源设备的中断服务程序入口，每个中断源分别有一个中断服务程序</li>
<li>有些产生的向量地址不是直接地址，而是一个偏移量，有的则是通过地址转移法来灵活的分配中断处理程序</li>
</ul>
</li>
</ul>
</li>
<li><p>多级中断</p>
<ul>
<li>一个系统有 n 级中断，则 CPU 中有 n 个 IR、IM，某级中断被响应后，则关闭本级和低于本级的 IM，开放更高级的 IM</li>
<li>多级中断可以嵌套，但同一级的中断不允许嵌套</li>
</ul>
</li>
</ul>
<h2 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h2><ul>
<li><p>直接存储器访问（Direct Memory Address） DMA 方式是为了在主存储器与 I&#x2F;O 设备间高速交换批量数据而设置的</p>
<ul>
<li>基本思想是：通过硬件控制实现主存与 I&#x2F;O 设备间的直接数据传送，在传送过程中无需 CPU 的干预</li>
</ul>
</li>
<li><p>基本操作</p>
<ul>
<li>从外围设备发出 DMA 请求</li>
<li>CPU 响应请求，把 CPU 工作改为 DMA 操作方式，DMA 控制器从 CPU 接管总线的控制</li>
<li>由 DMA 控制器对内存寻址，即决定数据传送的内存单元地址及数据传送个数的计数，并执行数据传送的操作</li>
<li>向 CPU 报告 DMA 操作的结束， DMA 让出总线控制权</li>
</ul>
</li>
<li><p>DMA 传送的方式</p>
<ul>
<li>停止CPU访问内存：主机响应 DMA 请求后，让出存储总线，直到 DMA 控制器把总线控制权交还给 CPU</li>
<li>周期挪用方式：一旦 I&#x2F;O 设备有 DMA 请求，则由 I&#x2F;O 设备挪用一个或几个内存周期</li>
<li>DMA 和 CPU 交替访问内存工作方式：如果 CPU 的工作周期比内存存取周期长很多，可以采用该种方法</li>
</ul>
</li>
<li><p>选择型和多路型 DMA 控制器</p>
<ul>
<li>选择型：物理上连接多个设备，逻辑上只允许连接一个设备</li>
<li>多路型：不仅物理上可以连接多个外围设备，而且在逻辑上也允许这些外围设备同时工作<ul>
<li>以字节交叉方式通过 DMA 控制器进行数据传送</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h2><ul>
<li>通道是计算机系统中代替 CPU 管理控制外设的独立部件，是一种能执行有限 I&#x2F;O 指令集合（通道 命令）的 I&#x2F;O 处理机</li>
<li>CPU 将 “传输控制” 功能下放给通道后只负责 “数据处理” 功能<ul>
<li>通道与CPU分时使用存储器，实现 CPU 内部运算与 I&#x2F;O 设备的并行工作</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/05/18/Java-%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/18/Java-%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">Java 复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-18 09:00:15" itemprop="dateCreated datePublished" datetime="2024-05-18T09:00:15+08:00">2024-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-31 21:28:48" itemprop="dateModified" datetime="2024-05-31T21:28:48+08:00">2024-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><ul>
<li><p>Java 源文件可以有多个类，只能有一个 public 类，也可以没有 public 类</p>
</li>
<li><p>Java 应用程序的主类（包含 main）并不是必须是 public 类，其他类也可以包含 main</p>
<ul>
<li>如果你的主类不是 public 类，不能通过 <code>java filename</code> 直接运行这个文件，但它可以被同一包中的其他类调用</li>
<li>当然，主类不是 public 类的话类名也可以和文件名不同</li>
<li>如果想要直接通过 <code>java filename</code> 直接运行，这必须需要一个和文件名同名的 public 类，且包含 main 方法作为入口</li>
<li>所以显而易见的是，如果有一个与文件名同名的 public 类，但没有包含 main 方法作为入口，那也无法运行</li>
</ul>
</li>
<li><p>JDK 提供的编译器是 javac.exe，java.exe 更多是 JVM 的启动器</p>
</li>
<li><p>javac 编译一个源文件会生成多个字节码文件（.class），与文件名同名的 public 类的好处是：它有一个唯一可识别的位置，JVM 可以很容易的通过包名、类名找到它并运行它的 main</p>
<ul>
<li>如果非 public 类中也包含 main 方法，我们也可以通过 <code>java path</code> 指定完整的路径名运行它</li>
</ul>
</li>
<li><p>补充</p>
<ul>
<li>Java 源文件应该以 .Java 为扩展名。源文件的基本组成部分是类（class）。</li>
<li>Java 程序的执行方法是 main() 方法，它有固定的书写格式 <code>public static void main(String avg[]) &#123;&#125;</code>。</li>
<li>一个源文件只能有一个 public 类，其他类个数不限。</li>
<li>如果源文件中包含一个 public 类，则文件命名必须按该类名命名。</li>
<li>也可以将 main() 方法写在非 public 类中，指定运行非 public 类，这样入口方法就是非 public 类的 main 方法。</li>
</ul>
</li>
</ul>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><ul>
<li><p><code>int[] a, b[];</code> 声明了一个一维数组 a 和一个二维数组 b</p>
</li>
<li><p><code>float a[20]</code> 是不合法的，正确的数组声明是 <code>float[] a = new float[20]; float[] a = &#123;...&#125;; </code> </p>
</li>
<li><p><code>System.out.println</code> 中的 System 只是一个类，所以它不是关键字</p>
</li>
<li><p>标识符：只能以数字、字母、下划线、美元组成，不能以数字开头</p>
</li>
<li><p>char 在 Java 中是 2 个字节，16 bit，所以取值范围是 [0, 2^16^-1]，即 [0, 65535]</p>
</li>
<li><p><code>float foo = 1.0;</code> 并不是正确的，浮点数在 Java 中默认是 double，需要加上 f 或 F</p>
</li>
<li><p><code>char a = 100; byte b = 100;</code> 是正确的，Java 允许将一个整型常量在有效范围内赋值给 byte、char、short</p>
<ul>
<li>但 <code>int i = 100; char a = i; byte b = i;</code> 就是错误的了，不能将 int 型变量赋值给 byte、char、short</li>
</ul>
</li>
<li><p>关于基本数据类型</p>
<ul>
<li><p>Java 的整型常量默认为 int 型，声明 long 类型需要在后边加 l 或 L</p>
</li>
<li><p>Java 的浮点型常量默认为double型，声明float型常量，需要后面加 f 或 F</p>
</li>
<li><p>浮点数使用陷阱，2.7 和 8.1&#x2F;3 比较。通过计算得到的浮点数是一个接近 2.7 的一个小数，但不是 2.7</p>
</li>
<li><p>Java 中不能使用 0 或非 0 的整数代替 true 或 false</p>
</li>
</ul>
</li>
<li><p>关于类型转换</p>
<ul>
<li>自动类型转换<ul>
<li><p>char -&gt; int -&gt; long -&gt; float -&gt; double</p>
</li>
<li><p>byte -&gt; short -&gt; int -&gt; long -&gt;float -&gt; double</p>
</li>
<li><p>有多种数据类型混合运算时，系统首先自动将所有数据转换成容量最大的数据类型，再进行计算</p>
</li>
<li><p>当我们把精度大的数据类型赋给精度小的数据类型时就会报错，反之会进行自动类型转换</p>
</li>
<li><p>（byte，short）和 char 之间不会进行自动类型转换</p>
</li>
<li><p>byte，short，char，他们三者在计算时，首先自动转换为 int 型</p>
</li>
<li><p>boolean不参与类型转换</p>
</li>
<li><p>自动提升原则：表达式中结果的类型会自动提升为操作数中最大的数据类型。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><ul>
<li><p><code>(short)10 + &#39;a&#39;</code> 的结果是 int 型数据，这是因为在整型运算中都会提升到 int</p>
</li>
<li><p>Java 中不能再使用 0 代表 true，非 0 代表 false</p>
</li>
<li><p><code>char a = ‘a&#39; + 1;</code> 是正确的，<code>int x =  1; char a = &#39;a&#39; + x; </code> 是错误的，所以还是一样的 <code>‘a’ + 1</code> 仍然是整型常量，而 <code>‘a’ + x</code> 会被提升为 int 型数据</p>
<blockquote>
<p>解释的有点不严谨，因为 <code>‘a’ + x</code> 的结果其实也是整型常量，但常量 + 常量就不会有问题，而变量 + 常量就会提示为 int 型</p>
</blockquote>
</li>
<li><p>A - Z：[65, 90]，a - z：[97, 122]。中文字符一般都比英文字符大</p>
</li>
<li><p>关于赋值运算</p>
<ul>
<li><p><code>char a = &#39;a&#39;; int i = 1; a += i; </code> 是正确的，<code>a = a + i;</code> 就是错误的了，这是因为 <code>a += i;</code> 等价于 <code>a = (char)(a + i);</code>，赋值运算符是强大的！</p>
</li>
<li><p>三元运算符要看作一个整体。<code>Object obj = true ? new Integer(1) : new Double(2.0); System.out.println(obj);</code>输出 1.0，因为double提高了整体的精度</p>
</li>
</ul>
</li>
<li><p>关于 switch</p>
<ul>
<li>表达式的类型与 case 后的常量类型保持一致，或是可以自动转换成可以比较的类型。比如 char，int。<ul>
<li>switch（表达式）中，表达式返回的类型必须是（byte，short，int，char，enum（枚举），String）。</li>
<li>case 子语句中的值必须是常量，不能是变量。</li>
<li>default 是可以没有的。</li>
<li>break 语句用来跳出 swtich 结构，但如果没有 break，将继续执行下条语句，直到遇到 break 或运行到 swithc 语句结尾</li>
</ul>
</li>
</ul>
</li>
<li><p>关于数组</p>
<ul>
<li><p>一维数组的声明方式有：<code>int[] arr;  int arr[];</code></p>
</li>
<li><p>二维数组的声明方式有：<code>int[][] arr;  int[] arr[];  int arr[][];</code></p>
</li>
<li><p>数组赋值是值拷贝，引用传递</p>
</li>
</ul>
</li>
</ul>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><ul>
<li><p>Java 应用程序由若干个类组成，这些类可以在一个源文件中，也可以在不同源文件中，但必须有其中一个源文件包含主类</p>
</li>
<li><p>方法中局部变量的名字不能和方法中参数的名字相同，因为参数也是局部变量</p>
</li>
<li><pre><code class="java">class Hello &#123;
    int Hello() &#123;return 100;&#125;	// 合法的
&#125;
</code></pre>
</li>
<li><p>类的实例方法也叫做类的成员方法（没有 static），所以很明显的是它不能通过类名来调用</p>
</li>
<li><p>构造方法的访问权限可以是 public、private、protected、默认（没有限制）</p>
</li>
<li><p>关于可变数组</p>
<ul>
<li>可变参数的实参可以是0个或任意多个，可变参数的本质就是数组</li>
<li>可变参数可以和普通类型的参数一起放在形参列表中，但必须保证可变参数放在最后，一个形参列表中只能出现一个可变参数</li>
</ul>
</li>
<li><p>关于构造器</p>
<ul>
<li>一个类可以定义多个不同的构造器，即构造器重载</li>
<li>构造器名要与类名相同，没有返回值</li>
<li>构造器是完成对对象的初始化，而不是创建对象，在创建对象时，相同会自动调用该类的构造方法。</li>
<li>如果程序员没有定义构造器，相同会自动给类生成一个默认无参构造器（也叫默认构造器）。<code>Cat() &#123;&#125;</code></li>
<li>一旦定义了自己的构造器，默认无参构造器就被覆盖了，就不能再使用默认无参构造器，除非显示的定义一下</li>
</ul>
</li>
<li><p>成员变量初始化步骤：默认初始化、显示初始化、构造器初始化</p>
</li>
</ul>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><ul>
<li><p>子类并不继承父类的构造方法，但子类在构造对象时会隐式或显示（super）的调用父类的构造方法</p>
</li>
<li><p>子类继承了父类所有的属性和方法，但私有属性不能在子类中直接访问，要通过父类提供的公共方法去访问</p>
<ul>
<li>因此子类继承的方法只能操作子类继承和隐藏的成员变量这句话是对的</li>
</ul>
</li>
<li><p>关于抽象类</p>
<ul>
<li><p>抽象类不一定要包含 abstract 方法，也就是说可以没有抽象方法，或者也可以有非抽象方法（实现的方法）</p>
</li>
<li><p>一个类一旦包含了 abstract 方法，这个类就必须声明为 abstract</p>
</li>
<li><p>abstract 只能修饰类、方法，不能修饰属性和其他</p>
</li>
<li><p>抽象类可以有任意成员（抽象类的本质还是类），比如：非抽象方法、构造器、静态属性等等</p>
</li>
<li><p>抽象方法不能有主体，即不能实现</p>
</li>
<li><p>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非他自己也声明为 abstract 类</p>
</li>
<li><p>抽象方法不能使用 private、final、static 关键字来修饰，因为这些关键字都和重写相违背</p>
</li>
</ul>
</li>
<li><p>子类实现抽象类中的抽象方法时，重写方法的访问修饰符必须和抽象方法的访问权限相匹配（可以更宽松，但不能更严格）</p>
</li>
<li><p>方法的重写和重载是不一样的，对于重写</p>
<ul>
<li>子类方法的形参列表、方法名称，要和父类的形参列表、方法名称完全一致。</li>
<li>子类方法的返回类型和父类方法的返回类型一样，或者是父类返回类型的子类。如 <code>public Object test() &#123;&#125; 和 public String test() &#123;&#125;</code></li>
<li>子类方法不能缩小父类方法的访问权限。如<code>void test() &#123;&#125; 和 public void test() &#123;&#125;可以 private void test() &#123;&#125; 不行</code></li>
<li>static 方法不能被重写，可能它在广义上没有错，但 IDEA 不让通过</li>
</ul>
</li>
<li><p>子类中想使用被子类隐藏的成员变量或成员方法就需要使用关键字 super，这是正确的，避免了直接从子类开始查找</p>
</li>
<li><p>你不能使用 <code>final </code>关键字来修饰构造方法，因为构造方法不能被继承也不能被重写，使用 <code>final</code> 修饰构造方法是没有意义的</p>
</li>
<li><p>static 方法并不能被重写，如果你在子类中 “重写” 一个父类的 static 方法，实际上你是创建了一个新的 static 方法，并没有重写</p>
</li>
<li><p>不能使用 <code>super()</code> 调用父类的静态方法，因为 <code>super()</code>  和 <code>this</code> 类似都是和对象相关的</p>
</li>
<li><p>关于包</p>
<ul>
<li><p>包的实质就是创建不同的文件夹（目录）来保存类文件</p>
</li>
<li><p>import java.util.Scanner，就只引入一个类 Scanner，import java.util.*，引入java.util包下的所有类</p>
</li>
<li><p>package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一个 package</p>
</li>
</ul>
</li>
<li><p>关于访问权限</p>
<ul>
<li><table>
<thead>
<tr>
<th align="center">访问级别</th>
<th align="center">访问修饰符</th>
<th align="center">同类</th>
<th align="center">同包</th>
<th align="center">子类</th>
<th align="center">不同包</th>
</tr>
</thead>
<tbody><tr>
<td align="center">公开</td>
<td align="center">public</td>
<td align="center">可</td>
<td align="center">可</td>
<td align="center">可</td>
<td align="center">可</td>
</tr>
<tr>
<td align="center">受保护</td>
<td align="center">protected</td>
<td align="center">可</td>
<td align="center">可</td>
<td align="center">可</td>
<td align="center">不可</td>
</tr>
<tr>
<td align="center">默认</td>
<td align="center">无</td>
<td align="center">可</td>
<td align="center">可</td>
<td align="center">不可</td>
<td align="center">不可</td>
</tr>
<tr>
<td align="center">私有</td>
<td align="center">private</td>
<td align="center">可</td>
<td align="center">不可</td>
<td align="center">不可</td>
<td align="center">不可</td>
</tr>
</tbody></table>
</li>
<li><p>关于继承</p>
<ul>
<li>继承的本质就是建立查找关系</li>
<li>子类继承了父类所有的属性和方法，但私有属性不能在子类中直接访问（默认属性在同包下可以访问，不同包不能访问），要通过父类提供的公共方法去访问</li>
<li>子类创建对象时必须先调用父类的构造器完成对父类的初始化，再调用子类构造器</li>
<li>当创建对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器（默认会添加一个隐藏的 <code>super()</code> 来调用无参构造器），如果父类没有提供无参构造器，则必须在子类构造器中使用 super 指明使用父类的哪个构造器完成对父类的初始化工作，否则，编译编译不会通过</li>
<li>super 在使用时，必须放在构造器的第一行</li>
<li>super( ) 和 this( ) 都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器（super( ) 调用父类的构造器，this( ) 调用自己的构造器）</li>
</ul>
</li>
<li><p>关于多态</p>
<ul>
<li><p>多态的本质是父类对象引用指向了子类对象，编译类型决定了是否可以调用方法，运行类型决定了从哪里开始找</p>
</li>
<li><p>而属性是由编译类型决定的</p>
</li>
<li><p>动态绑定机制又不一样了</p>
<ul>
<li>当调用对象方法的时候，该方法会与该对象的内存地址（运行类型）绑定</li>
<li>当调用该对象的属性时，没有动态绑定机制，哪里声明哪里使用</li>
</ul>
</li>
<li><p><code>instanceof</code> 是 Java 中的一个关键字，判断运行时类型</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关于重写和重载</p>
</li>
<li><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">发生范围</th>
<th align="center">方法名</th>
<th align="center">形参列表</th>
<th align="center">返回类型</th>
<th align="center">修饰符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">重载（overload）</td>
<td align="center">本类</td>
<td align="center">相同</td>
<td align="center">类型，个数，顺序至少一个不一样</td>
<td align="center">无要求</td>
<td align="center">无要求</td>
</tr>
<tr>
<td align="center">重写（override）</td>
<td align="center">父子类</td>
<td align="center">相同</td>
<td align="center">相同</td>
<td align="center">子类和父类一样，或是子类返回类型父类的子类</td>
<td align="center">子类不能缩小父类的访问范围</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><ul>
<li><p>关于接口</p>
<ul>
<li>接口不能被实例化</li>
<li>接口中的所有方法都是 public（即所有方法前都隐藏了一个 public），接口中抽象方法，可以不用 abstract 修饰</li>
<li>一个普通类实现（implements）接口，就要将该接口的所有方法都实现（快捷键 alt + Enter）</li>
<li>抽象类实现（implements）接口，可以不用实现接口方法</li>
<li>一个类同时可以实现（implements）多个接口 <code>class A implements B,C &#123; &#125;</code></li>
<li>接口中的属性，只能是 final，而且是 public static final 修饰符（即前边隐藏了public static final，即使 <code>int a;</code>）</li>
<li>接口中属性的访问形式：接口名.属性（因为属性是 public static final）</li>
<li>接口不能继承（extends）其他的类，但可以继承其他多个接口（接口与接口之间的关系是继承）<code>interface A extends B,C &#123;&#125;</code></li>
<li>接口的修饰符只能是 public 和默认，这点和类的修饰符一样</li>
</ul>
</li>
<li><p>接口中的属性只能是 final，但抽象类不是，接口和抽象类还是有很多不同的，需要区分开来</p>
</li>
<li><p>接口中并不能定义变量，只能定义常量（即使在接口中 <code>int a = 100;</code> 也是常量，<code>public static final</code> 是隐藏的）</p>
<ul>
<li>这是因为变量需要存储空间，并且可以有变化的值，这与接口的设计目的相违背。</li>
<li>接口主要是用于定义一组方法的契约，而具体的实现细节（包括变量的存储和变化）则留给实现该接口的类来处理</li>
</ul>
</li>
<li><p>接口中的非抽象方法必须加 <code>default</code> 关键字</p>
</li>
<li><p>Java 9 之后接口中可以定义private方法，这一改变允许接口在内部实现一些辅助方法，而不需要将这些方法暴露给实现接口的类</p>
<ul>
<li>记住就好</li>
</ul>
</li>
<li><p>通过接口名调用其中实现的 static 方法，这是可以的，因为并不涉及创建实例对象</p>
</li>
<li><p>关于静态成员</p>
<ul>
<li>静态方法只能访问静态成员，非静态方法既可以访问静态成员，也可以访问非静态成员</li>
</ul>
</li>
<li><p>关于代码块</p>
<ul>
<li>代码块又称为初始化块，使用 static 修饰的叫静态代码块，没有 static 修饰的叫普通代码块（代码块只能用 static 修饰）</li>
<li>代码块的好处：相当于另一种形式的构造器（对构造器的补充机制），当多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</li>
<li>静态代码块只有类加载的时候（new、创建子类对象父类被加载、调用静态成员）才会执行，普通代码块创建实例时才执行</li>
<li>调用顺序：<ul>
<li>静态代码块 &amp;&amp; 静态初始化 -&gt; 普通代码块 &amp;&amp; 普通初始化 -&gt; 构造器</li>
<li>创建子类对象时：父类静态 -&gt; 子类静态 -&gt; 父类普通 -&gt; 父类构造 -&gt; 子类普通 -&gt; 子类构造</li>
</ul>
</li>
</ul>
</li>
<li><p>关于 final</p>
<ul>
<li>final 可以修饰类、属性、方法和局部变量</li>
<li>当不希望类被继承时，可以用 final 关键字修饰</li>
<li>当不希望父类的某个方法被子类覆盖&#x2F;重写（override）时，可以使用 final 关键字修饰</li>
<li>当不希望类的某个属性的值被修改，可以使用 final 修饰</li>
<li>当不希望某个局部变量被修改，可以使用 final 修饰</li>
</ul>
</li>
</ul>
<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><ul>
<li><p>匿名内部类的类体中不能声明 static 成员变量和成员方法，这是因为 static 总是和类相关，而匿名内部类总是被用作创建实例对象，并且没有显示的类名，无法引用 static 成员</p>
</li>
<li><p>匿名内部类不能是抽象类，因为由于匿名类在声明的同时就被实例化了，所以它必须是一个具体的类，即它必须提供所有抽象方法的实现</p>
</li>
<li><p>关于内部类</p>
<ul>
<li><p>定义在外部类的局部位置上（比如方法内）:</p>
<ul>
<li>局部内部类（有类名）不能添加访问修饰符<ul>
<li>因为他的地位就是一个局部变量，局部变量是不允许使用访问修饰符的。但可以使用 final 修饰</li>
<li>它可以随便访问外部类成员，外部类只能在它的局部作用域中通过 new 访问它，其他外部类不能访问它</li>
</ul>
</li>
<li>匿名内部类（没有类名，重点！！！）<ul>
<li>其实有名字，编译器给的，但它是隐藏的；由于也是局部的，所以不能添加访问修饰符；匿名内部类就相当于一个对象</li>
<li>可以随便访问外部类成员，外部类通过其作用域中生成的对象访问它，其他外部类不能访问</li>
</ul>
</li>
<li>如果有和外部类同名的成员，都采用就近原则，想访问外部类的同名成员通过<code>outer.this.name</code></li>
</ul>
</li>
<li><p>定义在外部类的成员变量上：</p>
<ul>
<li><p>成员内部类（没有static修饰）</p>
<ul>
<li>可以添加访问修饰符</li>
<li>它随便访问外部类成员，外部类成员通过 new 访问它，其他外部类通过 <code>A.B b1 = new A().new B();</code> 访问它</li>
</ul>
</li>
<li><p>静态内部类（使用static修饰）</p>
<ul>
<li>可以添加访问修饰符</li>
<li>随便访问外部类的静态成员，外部类通过 new 访问它，其他外部类通过 <code>Outer.Inner i1 = new Outer.Inner();</code> 访问它</li>
</ul>
</li>
<li><p>同样的就近原则，访问外部类同名成员 <code>outer.this.name</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><ul>
<li><p>String 类是 final 类，不能有子类，在 <code>java.lang</code> 包中</p>
</li>
<li><p>String 类中的 <code>==</code> 比较的是是否是同一对象，<code>equal</code> 才比较是否内容相同</p>
</li>
<li><p><code>public static void main(String args[])</code> 中的 args，如果命令行中输入的是 <code>java filename 1 2 3 4</code>，那么 args &#x3D; {“1”, “2”, “3”, “4”}</p>
</li>
<li><p><code>new Date(1000)</code> 是以毫秒为单位的，它表示从1970年1月1日00:00:00 UTC（也被称为 Unix 时间戳或 epoch 时间）开始的1000 毫秒（即 1 秒）后的时间</p>
</li>
<li><p>对于判断一个字符串常量是否合法，观察它的转移字符是否合法</p>
</li>
<li><p>Random 对象的 nextInt（int n）方法随机返回 [0，n）之间的一个整数</p>
</li>
<li><p><code>“\t\nABC&quot;.length()</code> 的结果为 5，说明转移字符 <code>\t \n</code> 等通常被视为一个字符</p>
</li>
<li><p>UTF-8 编码（Unicode 的一种实现方式）：</p>
<ul>
<li>字母（包括ASCII字符集）占用 1 个字节</li>
<li>常用的汉字在 UTF-8 中通常占用 3 个字节</li>
</ul>
</li>
<li><p>StringBuilder 是线程不安全的，StringBuffer 是线程安全的</p>
</li>
<li><p>更多常用类：包装类</p>
</li>
<li><p>关于 throw 和 throws 的区别</p>
<ul>
<li><code>throw</code> 是生成异常对象，<code>throws</code> 是声明方法可能抛出的异常类型</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">意义</th>
<th align="center">位置</th>
<th align="center">后面跟的东西</th>
</tr>
</thead>
<tbody><tr>
<td align="center">throws</td>
<td align="center">处理异常的一种发生</td>
<td align="center">方法声明处</td>
<td align="center">异常类型</td>
</tr>
<tr>
<td align="center">throw</td>
<td align="center">手动生成异常对象的关键字</td>
<td align="center">方法体中</td>
<td align="center">异常对象</td>
</tr>
</tbody></table>
<h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><ul>
<li>创建 <code>File</code> 对象本身在 Java 中通常不会直接抛出异常，因为 <code>File</code> 类只是用于表示文件或目录路径名的抽象表示形式，并不涉及实际的文件 I&#x2F;O 操作。但是，当你尝试使用 <code>File</code> 对象进行实际的文件操作（如读取、写入、删除等）时，就可能会遇到异常</li>
<li>常见的输入输出流<ul>
<li>字节流：InputStream、OutputStream - FileInputStream、FileOutputStream - BufferInputStream、BufferOutputStream</li>
<li>字符流：Reader、Writer - FileReader、FileWriter - BufferReader、BufferWriter</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/05/17/xv6-book-chapter-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/17/xv6-book-chapter-3/" class="post-title-link" itemprop="url">xv6 book Chapter 3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-17 21:48:40" itemprop="dateCreated datePublished" datetime="2024-05-17T21:48:40+08:00">2024-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-10 12:32:03" itemprop="dateModified" datetime="2024-07-10T12:32:03+08:00">2024-07-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h1><ul>
<li>通过页表机制，操作系统为每个进程提供各自私有的地址空间和内存。<ul>
<li>页表决定了内存地址的含义，以及物理内存的哪些部分可以被访问。</li>
<li>它们允许 xv6 隔离不同进程的地址空间，并将它们映射到物理内存上。</li>
<li>页表还提供了一个间接层次，允许 xv6 实现一些技巧：在几个地址空间中映射同一内存（trampoline 页），以及用一个未映射页来保护内核栈和用户栈。</li>
<li>本章其余部分将解释 RISC-V 硬件提供的页表以及 xv6 如何使用它们。</li>
</ul>
</li>
</ul>
<h2 id="Paging-hardware-分页硬件"><a href="#Paging-hardware-分页硬件" class="headerlink" title="Paging hardware 分页硬件"></a>Paging hardware 分页硬件</h2><ul>
<li><p>提醒一下，RISC-V 指令（包括用户和内核）操作的是虚拟地址。</p>
<ul>
<li>机器的 RAM，或者说物理内存，是用物理地址来做索引的。</li>
<li>RISC-V 的页表硬件通过将每个虚拟地址映射到一个物理地址将这两种地址联系起来。</li>
</ul>
</li>
<li><p>xv6 运行在 Sv39 RISC-V 上，这意味着只会使用 64 位虚拟地址的低 39 位，高 25 位没有被使用。</p>
<ul>
<li>在这种 Sv39 配置中，一个 RISC-V 页表在逻辑上是一个由 2²⁷（134,217,728）个 <b>页表项（Page Table Entry, PTE）</b>组成的数组。</li>
<li>每个 <strong>PTE</strong> 包含一个 44 位的 <b>物理页号（Physical Page Number, PPN）</b>和一些标志位。</li>
<li>分页硬件通过利用 39 位中的高 27 位索引到页表中找到一个 <strong>PTE</strong> 来转换一个虚拟地址，并计算出一个 56 位的物理地址，它的前44 位来自于 <strong>PTE</strong> 中的 <strong>PPN</strong>，而它的后 12 位则是从原来的虚拟地址复制过来的。</li>
<li>图 3.1 显示了这个过程，在逻辑上可以把页表看成是一个简单的 <strong>PTE</strong> 数组（更完整的描述见图 3.2）。</li>
<li>页表让操作系统控制虚拟地址到物理地址的转换，其粒度为 4096（2¹²）字节的对齐块。这样的分块称为页。</li>
</ul>
</li>
<li><p>在 Sv39 RISC-V 中，虚拟地址的高 25 位不用于地址转换；将来，RISC-V 可能会使用这些位来定义更多的转换层。</p>
<ul>
<li>物理地址也有增长的空间：在 <strong>PTE</strong> 格式中，物理页号还有 10 位的增长空间。</li>
</ul>
</li>
</ul>
<img src="/2024/05/17/xv6-book-chapter-3/Figure-3.1.jpg" class="" title="img"> 

<ul>
<li><p>如图 3.2 所示，实际上转换过程分三步进行。一个页表以三层树的形式存储在物理内存中。</p>
<ul>
<li>树的根部是一个 4096 字节的页表页，它包含 512 个 PTE，这些 PTE 包含树的下一级页表页的物理地址。</li>
<li>每一页都包含 512 个 PTE，用于指向下一个页表或物理地址。</li>
<li>分页硬件用 27 位中的高 9 位选择根页表页中的 PTE，用中间 9 位选择树中下一级页表页中的 PTE，用低 9 位选择最后的 PTE。</li>
</ul>
</li>
<li><p>如果转换一个地址所需的三个 PTE 中的任何一个不存在，分页硬件就会引发一个 <strong>缺页异常（page-fault exception）</strong>，让内核来处理这个异常（见第 4 章）。</p>
<ul>
<li>这种三层结构允许页表在处理大范围的虚拟地址没有被映射这种常见情况时，能够忽略整个页表。</li>
</ul>
</li>
<li><p>每个 PTE 都包含标志位，用于告诉分页硬件相关的虚拟地址被允许怎样使用。</p>
<ul>
<li><code>PTE_V</code> 表示 PTE 是否存在：如果没有设置，对该页的引用会引起异常（即不允许）。</li>
<li><code>PTE_R</code> 控制是否允许指令读取该页。</li>
<li><code>PTE_W</code> 控制是否允许指令向该页写入。</li>
<li><code>PTE_X</code> 控制 CPU 是否可以将页面的内容解释为指令并执行。</li>
<li><code>PTE_U</code> 控制是否允许用户态下的指令访问页面；如果不设置 <code>PTE_U</code>， 对应 PTE 只能在内核态下使用。</li>
<li>图 3.2 显示了这一切的工作原理。标志位和与分页硬件相关的数据结构定义在（<code>kernel/riscv.h</code>）中。</li>
</ul>
</li>
</ul>
<img src="/2024/05/17/xv6-book-chapter-3/Figure-3.2.jpg" class="" title="img">

<ul>
<li><p>要告诉硬件使用一个页表，内核必须将对应根页表页的物理地址写入 <code>satp</code> 寄存器中。</p>
<ul>
<li>每个 CPU 都有自己的 <code>satp</code> 寄存器。一个 CPU 将使用自己的 <code>satp</code> 所指向的页表来翻译后续指令产生的所有地址。</li>
<li>每个 CPU 都有自己的 <code>satp</code>，这样不同的 CPU 可以运行不同的进程，每个进程都有自己的页表所描述的私有地址空间。</li>
</ul>
</li>
<li><p>关于术语的一些说明：物理内存指的是 <strong>DRAM</strong> 中的存储单元。</p>
<ul>
<li>物理存储器的一个字节有一个地址，称为物理地址。</li>
<li>当指令操作虚拟地址时，分页硬件会将其翻译成物理地址，然后发送给 DRAM 硬件，以读取或写入存储。</li>
<li>不像物理内存和虚拟地址，虚拟内存不是一个物理对象，而是指内核提供的管理物理内存和虚拟地址的抽象和机制的集合。</li>
</ul>
</li>
</ul>
<h2 id="Kernel-address-space-内核地址空间"><a href="#Kernel-address-space-内核地址空间" class="headerlink" title="Kernel address space 内核地址空间"></a>Kernel address space 内核地址空间</h2><ul>
<li>xv6 为每个进程维护一个用于描述进程的用户地址空间的页表，外加一个单独的描述内核地址空间的页表。<ul>
<li><p>内核配置其地址空间的布局，使其能够通过可预测的虚拟地址访问物理内存和各种硬件资源。</p>
</li>
<li><p>图 3.3 显示了这个设计是如何将内核虚拟地址映射到物理地址的。文件（<code>kernel/memlayout.h</code>）声明了 xv6 内核内存布局的常量。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical memory layout </span></span><br><span class="line"><span class="comment">// 物理内存布局</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu -machine virt is set up like this, </span></span><br><span class="line"><span class="comment">// 当使用 qemu -machine virt 配置时，物理内存的布局大致如下</span></span><br><span class="line"><span class="comment">// based on qemu&#x27;s hw/riscv/virt.c: </span></span><br><span class="line"><span class="comment">// 基于 qemu 的 hw/riscv/virt.c 文件：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 00001000 -- boot ROM, provided by qemu  </span></span><br><span class="line"><span class="comment">// 00001000 -- 启动 ROM，由 qemu 提供</span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT </span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT（核心本地中断器）</span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC </span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC（平台级中断控制器）</span></span><br><span class="line"><span class="comment">// 10000000 -- uart0 </span></span><br><span class="line"><span class="comment">// 10000000 -- uart0（UART 串口 0）</span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk </span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk（virtio 磁盘）</span></span><br><span class="line"><span class="comment">// 80000000 -- boot ROM jumps here in machine mode </span></span><br><span class="line"><span class="comment">// 80000000 -- 启动 ROM 在机器模式下跳转到这里</span></span><br><span class="line"><span class="comment">//             -kernel loads the kernel here </span></span><br><span class="line"><span class="comment">// 			   -kernel 选项会在这里加载内核</span></span><br><span class="line"><span class="comment">// unused RAM after 80000000. </span></span><br><span class="line"><span class="comment">// 80000000 之后的 RAM 未使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel uses physical memory thus:</span></span><br><span class="line"><span class="comment">// 内核对物理内存的使用如下：</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S, then kernel text and data</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S（启动汇编代码），然后是内核的代码和数据</span></span><br><span class="line"><span class="comment">// end -- start of kernel page allocation area</span></span><br><span class="line"><span class="comment">// end -- 内核页面分配区域的开始</span></span><br><span class="line"><span class="comment">// PHYSTOP -- end RAM used by the kernel</span></span><br><span class="line"><span class="comment">// PHYSTOP -- 内核使用的 RAM 的结束位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="comment">// qemu 在物理内存的 10000000 地址位置放置了 UART 寄存器。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio interface</span></span><br><span class="line"><span class="comment">// virtio MMIO 接口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// core local interruptor (CLINT), which contains the timer.</span></span><br><span class="line"><span class="comment">// 核心本地中断器（CLINT），包含计时器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT 0x2000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIME (CLINT + 0xBFF8) <span class="comment">// cycles since boot. 自启动以来的时钟周期数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts platform-level interrupt controller (PLIC) here.</span></span><br><span class="line"><span class="comment">// qemu 在这里放置了平台级中断控制器（PLIC）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC 0x0c000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PRIORITY (PLIC + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PENDING (PLIC + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel expects there to be RAM</span></span><br><span class="line"><span class="comment">// for use by the kernel and user pages</span></span><br><span class="line"><span class="comment">// from physical address 0x80000000 to PHYSTOP.</span></span><br><span class="line"><span class="comment">// 内核期望从物理地址 0x80000000 到 PHYSTOP 的内存区域用于内核和用户页面</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="comment">// 将 trampoline 页面映射到用户空间和内核空间中的最高地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="comment">// 在 trampoline 页面下方映射内核栈，每个栈周围都环绕着无效的保护页</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// 用户内存布局</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">// 首先从地址零开始：</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">// 	 文本段（text）</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">// 	 原始数据段和未初始化数据段（bss）</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   固定大小的栈</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">// 	 可扩展的堆</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">// 	 TRAPFRAME（p-&gt;trapframe，由 trampoline 使用）</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="comment">// 	 TRAMPOLINE（与内核中相同的页面）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ul>
 <img src="/2024/05/17/xv6-book-chapter-3/Figure-3.3.jpg" class="" title="img"> 

<ul>
<li><p>QEMU 模拟的计算机包含 RAM（ 物理内存），从物理地址 <code>0x80000000</code> 开始， 至少到 <code>0x86400000</code>，xv6 称之为 <code>PHYSTOP</code>。</p>
<ul>
<li><p>QEMU 模拟还包括 I&#x2F;O 设备，如磁盘接口。QEMU 将设备接口作为 <b>内存映射（memory-mapped）</b>的控制寄存器暴露给软件，这些寄存器位于物理地址空间的 <code>0x80000000</code> 以下。</p>
<blockquote>
<p>因此物理地址 0x80000000 并不包含在 RAM 中</p>
</blockquote>
</li>
<li><p>内核可以通过读取&#x2F;写入这些特殊的物理地址与设备进行交互；这种读取和写入与设备硬件而不是与 RAM 进行通信。</p>
</li>
<li><p>第 4 章解释了 xv6 如何与设备交互。</p>
</li>
</ul>
</li>
<li><p>内核对 RAM 和内存映射的设备寄存器使用 “直接映射”，也就是将这些资源映射到和它们物理地址相同的虚拟地址上。</p>
<ul>
<li>例如，内核本身在虚拟地址空间和物理内存中的位置都是 <code>KERNBASE=0x80000000</code>。直接映射简化了读&#x2F;写物理内存的内核代码。例如，当 <code>fork</code> 为子进程分配用户内存时，分配器返回该内存的物理地址；<code>fork</code> 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。</li>
</ul>
</li>
<li><p>有几个内核虚拟地址不是直接映射：</p>
<ul>
<li><p>trampoline 页。它被映射在虚拟地址空间的顶端；用户页表也有这个映射。第4 章讨论了 trampoline 页的作用，但我们在这里看到了页表的一个有趣的用例；一个物理页（存放 trampoline 代码）在内核的虚拟地址空间中被映射了两次：一次是在虚拟地址空间的顶部，一次是直接映射。</p>
<blockquote>
<p>映射两次指的是：我们可以在两个不同的虚拟地址位置访问到同一个物理页，一个是在虚拟地址空间的顶部，一个是虚拟地址空间的直接映射位置</p>
</blockquote>
</li>
<li><p>内核栈页。每个进程都有自己的内核栈，内核栈被映射到高地址处，所以 xv6 可以在它后面留下一个未映射的守护页。守护页的 PTE 是无效的（不设置 <code>PTE_V</code> 位），这样如果内核栈溢出，很可能会引起异常，内核会报错。如果没有防护页，栈溢出时会覆盖其他内核内存，导致不正确的操作。报错还是比较好的。</p>
</li>
</ul>
</li>
<li><p>内核通过高地址映射使用它的栈空间，栈空间也可以通过直接映射的地址被内核访问。</p>
<ul>
<li>另一种的设计是只使用直接映射，并在直接映射的地址上使用 stack。</li>
<li>但是在这种安排中，提供保护页将涉及到取消映射虚拟地址，否则这些地址将指向物理内存，这将很难使用。</li>
</ul>
</li>
<li><p>内核将 trampoline 和 text（可执行程序的代码段）映射为有 <code>PTE_R</code> 和 <code>PTE_X</code> 权限的页。</p>
<ul>
<li>内核从这些页读取和执行指令。内核映射的其他页会有 <code>PTE_R</code> 和 <code>PTE_W</code> 权限，以便内核读写这些页面的内存。</li>
<li>守护页的映射是无效的（不设置 <code>PTE_V</code>）。</li>
</ul>
</li>
</ul>
<h2 id="Code-creating-an-address-space-创建一个地址空间"><a href="#Code-creating-an-address-space-创建一个地址空间" class="headerlink" title="Code: creating an address space 创建一个地址空间"></a>Code: creating an address space 创建一个地址空间</h2><ul>
<li><p>大部分用于操作地址空间和页表的 xv6 代码都在 <code>vm.c</code>（<code>kernel/vm.c:1</code>）中。</p>
<ul>
<li>核心数据结构是 <code>pagetable_t</code>，它实际上是一个指向 RISC-V 根页表页的指针；</li>
<li><code>pagetable_t</code> 可以是内核页表，也可以是进程的页表。核心函数是 <code>walk</code> 和 <code>mappages</code>，前者通过虚拟地址得到 PTE，后者将虚拟地址映射到物理地址。</li>
<li>以 <code>kvm</code> 开头的函数操作内核页表；以 <code>uvm</code> 开头的函数操作用户页表；其他函数同时用于这两种页表。</li>
<li><code>copyout</code> 和 <code>copyin</code> 将数据复制到或复制出被作为系统调用参数的用户虚拟地址；它们在 <code>vm.c</code> 中，因为它们需要显式转换用户空间的地址，以便找到相应的物理内存。</li>
</ul>
</li>
<li><p>在机器启动时，在启动序列的靠前部分，<code>main</code> 调用 <code>kvminit</code>（<code>kernel/vm.c:22</code>）来创建内核页表。</p>
<ul>
<li>这个调用发生在 xv6 在 RISC-V 启用分页之前，所以地址直接指向物理内存。</li>
<li><code>kvminit</code> 首先分配一页物理内存来存放根页表页。然后调用 <code>kvmmap</code> 将内核所需要的硬件资源映射到物理地址。这些资源包括内核的指令和数据，<code>KERNBASE</code> 到 <code>PHYSTOP</code>的物理内存，以及实际上是设备的内存范围。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// Initialize the one kernel_pagetable</span></span><br><span class="line"><span class="comment">// 初始化一个内核页表</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="comment">// 创建一个直接映射的页表给内核</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line"><span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uart registers</span></span><br><span class="line">kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio disk interface</span></span><br><span class="line">kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// PLIC</span></span><br><span class="line">kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line"><span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line"><span class="comment">// 分配并映射一个内核栈给每个进程</span></span><br><span class="line">proc_mapstacks(kpgtbl);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>kvmmap</code>（<code>kernel/vm.c:118</code>）调用 <code>mappages</code>（<code>kernel/vm.c:149</code>），它将指定范围的虚拟地址映射到一段物理地址。<ul>
<li>它将范围内地址分割成多页（忽略余数），每次映射一页的起始地址。</li>
<li>对于每个要映射的虚拟地址（页的起始地址），<code>mapages</code> 调用 <code>walk</code> 找到该地址的最后一级 PTE 的地址。</li>
<li>然后，它配置 PTE，使其持有相关的物理页号、所需的权限（<code>PTE_W</code>、<code>PTE_X</code>和&#x2F;或<code>PTE_R</code>），以及 <code>PTE_V</code> 来标记 PTE 为有效（<code>kernel/vm.c:161</code>）。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// 添加一个映射到内核页表</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// 仅在启动时使用</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="comment">// 不刷新 TLB（Translation Lookaside Buffer）或启用分页（Paging）</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa.</span></span><br><span class="line"><span class="comment">// 为 va 开始的虚拟地址创建 PTEs，这写PTEs指向 pa 开始的物理地址</span></span><br><span class="line"><span class="comment">// va and size MUST be page-aligned.</span></span><br><span class="line"><span class="comment">// va 和 size 必须是页对齐的</span></span><br><span class="line"><span class="comment">// Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="comment">// 返回 0 表示成功，返回 -1 如果 walk() 没有分配一个需要的页表页</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 a, last;</span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)	<span class="comment">// 查看是否是页对齐的</span></span><br><span class="line"> panic(<span class="string">&quot;mappages: va not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((size % PGSIZE) != <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;mappages: size not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line"></span><br><span class="line">a = va;</span><br><span class="line">last = va + size - PGSIZE;	<span class="comment">// 这里其实很神奇的是，配合下边的for，每次都是先do在判断，效果一样</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)	<span class="comment">// 得到包含虚拟地址a的pte</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">if</span>(*pte &amp; PTE_V)	<span class="comment">// 检查PTE_V有效位</span></span><br><span class="line">   panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line"> *pte = PA2PTE(pa) | perm | PTE_V;	<span class="comment">// 宏PA2PTE右移12位再左移10位，设置指定标志位和PTE_V有效位</span></span><br><span class="line"> <span class="keyword">if</span>(a == last)	</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> a += PGSIZE;</span><br><span class="line"> pa += PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>walk</code>（<code>kernel/vm.c:72</code>）模仿 RISC-V 分页硬件查找虚拟地址的 PTE（见图 3.2）。<ul>
<li><code>walk</code> 每次降低 9 位来查找三级页表。它使用每一级的 9 位虚拟地址来查找下一级页表或最后一级（<code>kernel/vm.c:78</code>）的 PTE。</li>
<li>如果 PTE 无效，那么所需的物理页还没有被分配；如果 <code>alloc</code> 参数被设置，<code>walk</code> 会分配一个新的页表页，并把它的物理地址放在 PTE 中。</li>
<li>它返回树中最低层 PTE 的地址（<code>kernel/vm.c:88</code>）。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// 从页表中返回包含虚拟地址 va 的 PTE </span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">// 如果 alloc != 0，创建任何需要的页表页</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// risc-v Sv39 有三级页表，一个页表页包含 512 个 64 位的 PTE</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">// 一个 64 位的虚拟地址被分割成 5 个字段：</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.				39 - 63 必须为 0</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.		30 - 38 9 位为 2 级页表的索引</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.		21 - 29	9 位为 1 级页表的索引</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.		12 - 20 9 位为 0 级页表的索引</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.	0 - 11 12 位为页的偏移量</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line"><span class="comment">// typedef uint64 *pagetable_t;(riscv.h) pagetable 其实是一个指针，我们像将其作为数组使用</span></span><br><span class="line"><span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];	<span class="comment">// PX是一个宏，这里的作用是提取出va的每级页表的索引</span></span><br><span class="line"><span class="keyword">if</span>(*pte &amp; PTE_V) &#123;	<span class="comment">// PTE_V 同样也是一个宏 00……01，检查第一位有效位</span></span><br><span class="line">	 <span class="comment">// PTE2PA 也是一个宏，右移10位再左移12位，因为下一级页表的物理地址是当前pte的44位和12位的0</span></span><br><span class="line">  pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte); <span class="comment">// 更新页表层级</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)	<span class="comment">// 如果alloc!=0，分配一个页</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line"><span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);	<span class="comment">// 将这个页（由于直接映射，就是物理地址）的所有位设为0</span></span><br><span class="line">*pte = PA2PTE(pagetable) | PTE_V;	<span class="comment">// PA2PTE是右移12左移10，设置PTE_V标志</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>main</code> 调用 <code>kvminithart</code>（<code>kernel/vm.c:53</code>）来映射内核页表。<ul>
<li>它将根页表页的物理地址写入寄存器 <code>satp</code> 中。在这之后，CPU 将使用内核页表翻译地址。</li>
<li>由于内核使用唯一映射，所以指令的虚拟地址将映射到正确的物理内存地址。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="comment">// 将硬件页面表寄存器切换到内核的页表，并启用分页  </span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// wait for any previous writes to the page table memory to finish.</span></span><br><span class="line"><span class="comment">// 等待页面表内存中的任何先前写入操作完成</span></span><br><span class="line">sfence_vma();</span><br><span class="line"></span><br><span class="line">w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush stale entries from the TLB.</span></span><br><span class="line"><span class="comment">// 从TLB中刷新陈旧条目</span></span><br><span class="line">sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>procinit</code>（<code>kernel/proc.c:26</code>），它由  <code>main</code> 调用，为每个进程分配一个内核栈。它将每个栈映射在 <code>KSTACK</code> 生成的虚拟地址上，这就为栈守护页留下了空间。<ul>
<li><code>kvmmap</code> 将对应的 PTE 加入到内核页表中，然后调用 <code>kvminithart</code> 将内核页表重新加载到 <code>satp</code> 中，这样硬件就知道新的 PTE 了。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">initlock(&amp;wait_lock, <span class="string">&quot;wait_lock&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">   initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">   p-&gt;state = UNUSED;</span><br><span class="line">   <span class="comment">// #define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)</span></span><br><span class="line">   <span class="comment">// KSTACK将每个进程的内核栈设置在TRAMPOLINE下，且每个内核栈一个页大小，下边跟一个守护页</span></span><br><span class="line">   p-&gt;kstack = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>每个 RISC-V CPU 都会在 <strong>Translation Look-aside Buffer(TLB)</strong> 中缓存页表项，当 xv6 改变页表时，必须告诉 CPU 使相应的缓存 TLB 项无效。<ul>
<li>如果它不这样做，那么在以后的某个时刻，TLB 可能会使用一个旧的缓存映射，指向一个物理页，而这个物理页在此期间已经分配给了另一个进程，这样的话，一个进程可能会在其他进程的内存上 “乱写乱画“。</li>
<li>RISC-V 有一条指令 <code>sfence.vma</code>，可以刷新当前 CPU 的 TLB。</li>
<li>xv6 在<code>kvminithart</code> 中，重新加载 <code>satp</code> 寄存器后， 执行 <code>sfence.vma</code>，也会在从内核空间返回用户空间前，切换到用户页表的 trampoline 代码中执行 <code>sfence.vma</code>（<code>kernel/trampoline.S:79</code>）。</li>
</ul>
</li>
</ul>
<h2 id="Physical-memory-allocation-物理内存分配"><a href="#Physical-memory-allocation-物理内存分配" class="headerlink" title="Physical memory allocation 物理内存分配"></a>Physical memory allocation 物理内存分配</h2><ul>
<li>内核必须在运行时为页表、用户内存、内核堆栈和管道缓冲区分配和释放物理内存。<ul>
<li>xv6 使用内核地址结束到 <code>PHYSTOP</code> 之间的物理内存来进行运行时分配。</li>
<li>它每次分配和释放整个 4096 字节的页面。它通过保存空闲页链表，来记录哪些页是空闲的。</li>
<li>分配包括从链表中删除一页；释放包括将释放的页面添加到空闲页链表中。</li>
</ul>
</li>
</ul>
<h2 id="Code-Physical-memory-allocator-物理内存分配器"><a href="#Code-Physical-memory-allocator-物理内存分配器" class="headerlink" title="Code: Physical memory allocator 物理内存分配器"></a>Code: Physical memory allocator 物理内存分配器</h2><ul>
<li>分配器在 <code>kalloc.c</code>（<code>kernel/kalloc.c:1</code>）中。分配器的数据结构是一个可供分配的物理内存页的 <strong>空闲链表</strong>，每个空闲页的链表元素是一个结构体 <code>struct run</code>（<code>kernel/kalloc.c:17</code>）。<ul>
<li>分配器从哪里获得内存来存放这个结构体呢？它把每个空闲页的 <code>run</code> 结构体存储在空闲页自身里面，因为那里没有其他东西存储。</li>
<li>空闲链表由一个 <strong>自旋锁</strong> 保护（<code>kernel/kalloc.c:21-24</code>）。链表和锁被包裹在一个结构体中，以明确锁保护的是结构体中的字段。</li>
<li>现在，请忽略锁以及 <code>acquire</code> 和<code>release</code> 的调用；第 6 章将详细研究锁。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>main</code> 调用 <code>kinit</code> 来初始化分配器（<code>kernel/kalloc.c:27</code>）。<ul>
<li><code>kinit</code> 初始化空闲页链表，以保存内核地址结束到 <code>PHYSTOP</code> 之间的每一页。</li>
<li>xv6 应该通过解析硬件提供的配置信息来确定有多少物理内存可用。但是它没有这么做，而是假设机器有 128M 字节的 RAM。</li>
<li><code>kinit</code> 通过调用 <code>freerange</code> 来添加内存到空闲页链表，<code>freerange</code> 则对每一页都调用 <code>kfree</code>。</li>
<li>PTE 只能指向按 4096 字节对齐的物理地址（4096 的倍数），因此 <code>freerange</code> 使用 <code>PGROUNDUP</code> 来确保它只添加对齐的物理地址到空闲链表中。</li>
<li>分配器开始时没有内存；这些对 <code>kfree</code> 的调用给了它一些内存管理。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line"><span class="comment">// extern char end[]; // first address after kernel. end 是内核之后的第一个地址   </span></span><br><span class="line">freerange(end, (<span class="type">void</span>*)PHYSTOP); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"><span class="comment">// #define PGROUNDUP(sz) (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1)) </span></span><br><span class="line"><span class="comment">// 这个宏定义用于将一个大小（sz）向上舍入到最接近且大于或等于该大小的页面大小</span></span><br><span class="line">p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line"><span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line"> kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="comment">// 释放由 pa 指向的物理内存页面，  </span></span><br><span class="line"><span class="comment">// 这个页面通常应该是通过调用 kalloc() 函数获得的  </span></span><br><span class="line"><span class="comment">//（例外情况是在初始化内存分配器时；参见上面的 kinit）</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pa必须是页对齐的，大于end且&lt;PHYSTOP</span></span><br><span class="line"><span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)	</span><br><span class="line"> panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line"><span class="comment">// 填充垃圾(1)，防止被错误使用</span></span><br><span class="line"><span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">acquire(&amp;kmem.lock);</span><br><span class="line">r-&gt;next = kmem.freelist; <span class="comment">// 头插到空闲链表</span></span><br><span class="line">kmem.freelist = r;</span><br><span class="line">release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>分配器有时把地址当作整数来处理，以便对其进行运算（如 <code>freerange</code> 遍历所有页）， 有时把地址当作指针来读写内存（如操作存储在每页中的 <code>run</code> 结构体）；这种对地址的双重使用是分配器代码中充满 C 类型转换的主要原因。</p>
<ul>
<li>另一个原因是，释放和分配本质上改变了内存的类型。</li>
</ul>
</li>
<li><p><code>kfree</code>（<code>kernel/kalloc.c:47</code>）将被释放的内存中的每个字节设置为1。</p>
<ul>
<li>这将使得释放内存后使用内存的代码（使用悬空引用）将会读取垃圾而不是旧的有效内容；希望这将导致这类代码更快地崩溃。</li>
<li>然后 <code>kfree</code> 将页面预存入释放列表：它将 <code>pa</code>（物理地址）转为指向结构体 <code>run</code> 的指针，在 <code>r-&gt;next</code> 中记录空闲链表之前的节点，并将释放列表设为 <code>r</code>。</li>
<li><code>kalloc</code> 移除并返回空闲链表中的第一个元素。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// 分配一个4096字节的物理内存页</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// 返回一个内核可以使用的指针</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="comment">// 返回0如果内存不能被分配</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk 填充垃圾</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Process-address-space-进程地址空间"><a href="#Process-address-space-进程地址空间" class="headerlink" title="Process address space 进程地址空间"></a>Process address space 进程地址空间</h2><ul>
<li>每个进程都有一个单独的页表，当 xv6 在进程间切换时，也会改变页表。<ul>
<li>如图 2.3 所示，一个进程的用户内存从虚拟地址 0 开始，可以增长到 <code>MAXVA</code>（<code>kernel/riscv.h:348</code>），原则上允许一个进程寻址 256GB 的内存。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// 一个超出最高可能的虚拟地址</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="comment">// MAXVA实际上是一个小于Sv39所允许的最大值的bit</span></span><br><span class="line"><span class="comment">// 为了避免对拥有高比特位的虚拟地址进行符号扩展</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>当一个进程要求 xv6 提供更多的用户内存时，xv6 首先使用 <code>kalloc</code> 来分配物理页，然后将指向新物理页的 PTE 添加到进程的页表中。</p>
<ul>
<li>xv6 设置这些 PTE 的 <code>PTE_W</code>、<code>PTE_X</code>、<code>PTE_R</code>、<code>PTE_U</code> 和 <code>PTE_V</code> 标志。</li>
<li>大多数进程不使用整个用户地址空间；xv6 将不使用的 PTE 的 <code>PTE_V</code> 位保持为清除状态。</li>
</ul>
</li>
<li><p>我们在这里看到了几个有趣例子，是关于使用页表的。</p>
<ul>
<li>首先，不同的进程页表将用户地址转化为物理内存的不同页，这样每个进程都有私有的用户内存。</li>
<li>第二，每个进程都认为自己的内存具有从零开始的连续的虚拟地址，而进程的物理内存可以是不连续的。</li>
<li>第三，内核会映射带有 <code>trampoline</code> 代码的页到用户地址空间顶端，因此，有一物理内存页在所有地址空间中都会出。</li>
</ul>
</li>
</ul>
<img src="/2024/05/17/xv6-book-chapter-3/Figure-3.4.jpg" class="" title="img">

<ul>
<li><p>图 3.4 更详细地显示了 xv6 中执行进程的用户内存布局。</p>
<ul>
<li>栈只有一页，图中显示的是由 <code>exec</code> 创建的初始内容。</li>
<li>位于栈顶部的字符串中包含了命令行中输入的参数和指向他们的指针数组。在下方是允许程序在 <code>main</code> 启动的值，就像函数 <code>main(argc, argv)</code> 是刚刚被调用一样<a href="#ftn1">[1]</a>。</li>
</ul>
</li>
<li><p>为了检测用户栈溢出分配的栈内存，xv6 会在 stack 的下方放置一个无效的保护页。如果用户栈溢出，而进程试图使用栈下面的地址，硬件会因为该映射无效而产生一个缺页异常。</p>
<ul>
<li>一个现实世界中的操作系统可能会在用户栈溢出时自动为其分配更多的内存。</li>
</ul>
</li>
</ul>
<h2 id="Code-sbrk"><a href="#Code-sbrk" class="headerlink" title="Code: sbrk"></a>Code: sbrk</h2><ul>
<li><code>sbrk</code> 是一个进程收缩或增长内存的系统调用 。 </li>
<li>该系统调用由函数 <code>growproc</code>（<code>kernel/proc.c:239</code>）实现，<code>growproc</code> 调用 <code>uvmalloc</code> 或 <code>uvmdealloc</code>，取决于 <code>n</code> 是正数还是负数。</li>
<li><code>uvmalloc</code>（<code>kernel/vm.c:229</code>）通过 <code>kalloc</code> 分配物理内存，并使用 <code>mappages</code> 将 PTE 添加到用户页表中。</li>
<li><code>uvmdealloc</code> 调用 <code>uvmunmap</code>（<code>kernel/vm.c:174</code>），它使用 <code>walk</code> 来查找 PTE 并使用 <code>kfree</code> 来释放它们所引用的物理内存。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// 增长或缩小n字节的用户内存</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 sz;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">sz = p-&gt;sz;	<span class="comment">// sz是进程内存的字节数</span></span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n, PTE_W)) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;sz = sz;	<span class="comment">// 更新sz</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate PTEs and physical memory to grow process from oldsz to</span></span><br><span class="line"><span class="comment">// newsz, which need not be page aligned.  Returns new size or 0 on error.</span></span><br><span class="line"><span class="comment">// 分配PTEs和物理内存将进程从oldsz增长到newsz，不需要页对齐</span></span><br><span class="line"><span class="comment">// 返回新size或0表示错误</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *mem;</span><br><span class="line">uint64 a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line"> <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">oldsz = PGROUNDUP(oldsz);	<span class="comment">// 让oldsz向上取整到页大小的整数倍(oldsz在这里被当作虚拟内存指针)</span></span><br><span class="line"><span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line"> mem = kalloc();</span><br><span class="line"> <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">   uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE); <span class="comment">// 填充0</span></span><br><span class="line"> <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123; <span class="comment">// 分配PTE</span></span><br><span class="line">   kfree(mem);</span><br><span class="line">   uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deallocate user pages to bring the process size from oldsz to</span></span><br><span class="line"><span class="comment">// newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span></span><br><span class="line"><span class="comment">// 释放用户页将进程从oldsz缩减到newsz</span></span><br><span class="line"><span class="comment">// need to be less than oldsz.  oldsz can be larger than the actual</span></span><br><span class="line"><span class="comment">// process size.  Returns the new process size.</span></span><br><span class="line"><span class="comment">// oldsz和newsz不需要页对齐，newsz也不需要小于oldsz，oldsz可以比实际进程size大，返回新进程的size</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">uvmdealloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(newsz &gt;= oldsz)</span><br><span class="line"> <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line"> <span class="type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE; <span class="comment">// 保证有npages个页面</span></span><br><span class="line"> uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove npages of mappings starting from va. va must be</span></span><br><span class="line"><span class="comment">// page-aligned. The mappings must exist.</span></span><br><span class="line"><span class="comment">// 移除开始于va的npages个映射，映射必须存在</span></span><br><span class="line"><span class="comment">// Optionally free the physical memory.</span></span><br><span class="line"><span class="comment">// 可选的释放物理内存</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span>	<span class="comment">// do_free为1就释放物理内存</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 a;</span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)	</span><br><span class="line"> panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line"> <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)	<span class="comment">// 找到包含虚拟地址va的PTE</span></span><br><span class="line">   panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">   panic(<span class="string">&quot;uvmunmap: not mapped&quot;</span>);</span><br><span class="line"> <span class="comment">// #define PTE_FLAGS(pte) ((pte) &amp; 0x3FF) 提取低10位的标志位，判断是否是叶子节点</span></span><br><span class="line"> <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V) </span><br><span class="line">   panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">   uint64 pa = PTE2PA(*pte); <span class="comment">// 右移10位左移12位得到物理地址pa</span></span><br><span class="line">   kfree((<span class="type">void</span>*)pa); <span class="comment">// 释放物理地址</span></span><br><span class="line"> &#125;</span><br><span class="line"> *pte = <span class="number">0</span>;	<span class="comment">// 移除映射</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>xv6 使用进程的页表不仅是为了告诉硬件如何映射用户虚拟地址，也是将其作为分配给该进程的物理地址的唯一记录。<ul>
<li>这就是为什么释放用户内存（<code>uvmunmap</code> 中）需要检查用户页表的原因。</li>
</ul>
</li>
</ul>
<h2 id="Code-exec"><a href="#Code-exec" class="headerlink" title="Code: exec"></a>Code: exec</h2><ul>
<li><p><code>exec</code> 是创建一个地址空间的用户部分的系统调用。</p>
<ul>
<li><p>它读取储存在文件系统上的文件用来初始化一个地址空间的用户部分。</p>
</li>
<li><p><code>exec</code>（<code>kernel/exec.c:13</code>）使用 <code>namei</code>（<code>kernel/exec.c:26</code>）打开二进制文件路径，这在第 8 章中有解释。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;  <span class="comment">// 打开二进制文件，得到这个文件的indoe(元数据)</span></span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>然后，它读取 ELF 头。xv6 应用程序用 ELF 格式来描述可执行文件，它定义在（<code>kernel/elf.h</code>）。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf)) <span class="comment">// 读取ELF文件头</span></span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read data from inode.  从inode中读取数据</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有锁</span></span><br><span class="line"><span class="comment">// If user_dst==1, then dst is a user virtual address;  user_dst==1表示dst是用户虚拟地址</span></span><br><span class="line"><span class="comment">// otherwise, dst is a kernel address.  负责dst是一个内核地址 off应该是用来指定dst的偏移，n表示读取的字节数</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">readi</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>一个 ELF 二进制文件包括一个 ELF 头，<code>struct elfhdr</code>（<code>kernel/elf.h:6</code>）。之后是一串程序段头（program section header），<code>struct proghdr</code>（<code>kernel/elf.h:25</code>）。</p>
</li>
<li><p>每一个 <code>proghdr</code> 描述了应用的一个必须加载到内存中的程序段；xv6 程序只有一个程序段头，但其他系统可能有分开的指令段和数据段需要加载到内存。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File header ELF头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">  uint magic;  <span class="comment">// must equal ELF_MAGIC	魔法数字</span></span><br><span class="line">  uchar elf[<span class="number">12</span>];</span><br><span class="line">  ushort type;</span><br><span class="line">  ushort machine;</span><br><span class="line">  uint version;</span><br><span class="line">  uint64 entry;</span><br><span class="line">  uint64 phoff;</span><br><span class="line">  uint64 shoff;</span><br><span class="line">  uint flags;</span><br><span class="line">  ushort ehsize;</span><br><span class="line">  ushort phentsize;</span><br><span class="line">  ushort phnum;</span><br><span class="line">  ushort shentsize;</span><br><span class="line">  ushort shnum;</span><br><span class="line">  ushort shstrndx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program section header 程序段头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> &#123;</span></span><br><span class="line">  uint32 type;</span><br><span class="line">  uint32 flags;</span><br><span class="line">  uint64 off;</span><br><span class="line">  uint64 vaddr;</span><br><span class="line">  uint64 paddr;</span><br><span class="line">  uint64 filesz;</span><br><span class="line">  uint64 memsz;</span><br><span class="line">  uint64 align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>第一步是快速检查文件是否是 ELF 格式。一个 ELF 二进制文件以四个字节的 “魔法数字”（magic number） <code>0x7F</code>、<code>E</code>、<code>L</code>、<code>F</code> 或 <code>ELF_MAGIC</code>（<code>kernel/elf.h:3</code>）开始。</p>
<ul>
<li>如果 ELF 头有正确的 ”魔法数字“，<code>exec</code> 就会认为该二进制文件是正确的类型。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(elf.magic != ELF_MAGIC)  <span class="comment">// 检查是否是魔法数字</span></span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)  <span class="comment">// 创建一个空页表</span></span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>exec </code> 使用 <code>proc_pagetable</code>（<code>kernel/exec.c:38</code>）分配一个没有使用的页表，使用 <code>uvmalloc</code>（<code>kernel/exec.c:52</code>）为每一个 ELF 段分配内存，使用 <code>loadseg</code>（<code>kernel/exec.c:10</code>）加载每一个段到内存中。</p>
<ul>
<li><code>loadseg</code> 使用 <code>walkaddr</code> 找到分配内存的物理地址，在该地址写入 ELF 段的每一页，页的内容通过 <code>readi</code> 从文件中读取。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load program into memory.  加载程序到内存</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))  <span class="comment">// 读取程序段头</span></span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)  </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == <span class="number">0</span>)<span class="comment">//sz从0开始</span></span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate PTEs and physical memory to grow process from oldsz to</span></span><br><span class="line"><span class="comment">// newsz, which need not be page aligned.  Returns new size or 0 on error.</span></span><br><span class="line"><span class="comment">// 分配PTEs和物理内存将进程从oldsz增长到newsz，不需要页对齐</span></span><br><span class="line"><span class="comment">// 返回新size或0表示错误</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load a program segment into pagetable at virtual address va. 加载一个程序段到页表中的虚拟地址va</span></span><br><span class="line"><span class="comment">// va must be page-aligned  va必须是页对齐的</span></span><br><span class="line"><span class="comment">// and the pages from va to va+sz must already be mapped. 页面从va到va+sz必须已经被映射</span></span><br><span class="line"><span class="comment">// Returns 0 on success, -1 on failure. 返回0表示成功，返回-1表示失败</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">loadseg</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint i, n;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    pa = walkaddr(pagetable, va + i);</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;loadseg: address should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sz - i &lt; PGSIZE) <span class="comment">// 每次加载一个页面，不够就加载完</span></span><br><span class="line">      n = sz - i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      n = PGSIZE;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)pa, offset+i, n) != n)<span class="comment">//从ip(inode)中读取n个字节到pa，pa从偏移offset+i开始</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>用 <code>exec</code> 创建的第一个用户程序 <code>/init</code> 的程序段头是这样的：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># objdump -p _init</span></span><br><span class="line">user/_init: file format elf64-littleriscv</span><br><span class="line">Program Header:</span><br><span class="line">	LOAD off 	0x00000000000000b0 vaddr 0x0000000000000000</span><br><span class="line">    							   paddr 0x0000000000000000 align 2**3</span><br><span class="line">    	 filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx</span><br><span class="line">   STACK off 	0x0000000000000000 vaddr 0x0000000000000000</span><br><span class="line">    						 	   paddr 0x0000000000000000 align 2**4</span><br><span class="line">    	 filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-</span><br></pre></td></tr></table></figure>

<ul>
<li><p>程序段头的 <code>filesz</code> 可能小于 <code>memsz</code>，说明它们之间的空隙应该用 0 来填充（对于 C 语言中的全局变量），而不是从文件中读取。</p>
<ul>
<li>对于 <code>/init</code> 来说，<code>filesz</code> 是 2112 字节，<code>memsz</code> 是 2136 字节，因此 <code>uvmalloc</code> 分配了足够的物理内存来容纳 2136 字节，但只从文件 <code>/init</code> 中读取 2112 字节。</li>
</ul>
</li>
<li><p><code>exec</code> 在栈页的下方放置了一个不可访问页，这样程序如果试图使用多个页面，就会出现故障。</p>
<ul>
<li>这个不可访问的页还能允许 <code>exec</code> 处理过大的参数；在这种情况下，<code>exec</code> 用来复制参数到栈的 <code>copyout</code>（<code>kernel/vm.c:355</code>）函数会注意到目标页不可访问，并返回-1。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate two pages at the next page boundary. 在下一个页边界处分配两个页面</span></span><br><span class="line"><span class="comment">// Make the first inaccessible as a stack guard. 将第一个页面设置为不可访问，作为栈保护</span></span><br><span class="line"><span class="comment">// Use the second as the user stack. 使用第二个页面作为用户栈</span></span><br><span class="line">sz = PGROUNDUP(sz);</span><br><span class="line">uint64 sz1;</span><br><span class="line"><span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE, PTE_W)) == <span class="number">0</span>)  <span class="comment">// 页表中分配两个页的物理内存和PTE</span></span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">sz = sz1;</span><br><span class="line">uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE); <span class="comment">// 将第一个页面设为用户不可访问，即保护页</span></span><br><span class="line">sp = sz;  <span class="comment">// 更新栈指针和栈底指针</span></span><br><span class="line">stackbase = sp - PGSIZE;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mark a PTE invalid for user access.  将一个PTE标记为对用户访问无效</span></span><br><span class="line"><span class="comment">// used by exec for the user stack guard page. 在执行（exec）过程中用于用户栈保护页</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmclear</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  </span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmclear&quot;</span>);</span><br><span class="line">  *pte &amp;= ~PTE_U;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>在准备新的内存映像的过程中，如果 <code>exec</code> 检测到一个错误，比如一个无效的程序段， 它就会跳转到标签 <code>bad</code>，释放新的映像，并返回 -1。</p>
<ul>
<li><code>exec</code> 必须延迟释放旧映像，直到它确定 <code>exec</code> 系统调用会成功：如果旧映像消失了，系统调用就不能返回 -1。</li>
<li><code>exec</code> 中唯一的错误情况发生在创建映像的过程中。</li>
<li>一旦镜像完成，<code>exec</code> 就可以提交到新的页表（<code>kernel/exec.c:113</code>）并释放旧的页表（<code>kernel/exec.c:117</code>）。</li>
</ul>
</li>
<li><p><code>exec</code> 将 ELF 文件中的字节按 ELF 文件指定的地址加载到内存中。</p>
<ul>
<li>用户或进程可以将任何他们想要的地址放入 ELF 文件中。</li>
<li>因此，<code>exec</code> 是有风险的，因为 ELF 文件中的地址可能会意外地或故意地指向内核。</li>
<li>对于一个不小心的内核来说，后果可能从崩溃到恶意颠覆内核的隔离机制（即安全漏洞）。</li>
<li>xv6 执行了一些检查来避免这些风险。例如 <code>if (ph.vaddr + ph.memsz &lt; ph.vaddr)</code> 检查总和是否溢出一个 64 位整数。</li>
<li>危险的是，用户可以用指向用户选择的地址的 <code>ph.vaddr</code> 和足够大的 <code>ph.memsz</code> 来构造一个 ELF 二进制，使总和溢出到 <strong>0x1000</strong>，这看起来像是一个有效值。</li>
<li>在旧版本的 xv6 中，用户地址空间也包含内核（但在用户模式下不可读&#x2F;写），用户可以选择一个对应内核内存的地址，从而将 ELF 二进制中的数据复制到内核中。</li>
<li>在 RISC-V 版本的 xv6 中，这是不可能的，因为内核有自己独立的页表；<code>loadseg</code> 加载数据到进程的页表中，而不是内核的页表中。</li>
</ul>
</li>
<li><p>内核开发人员很容易忽略一个关键的检查，现实中的内核有很长一段缺少检查的空档期， 用户程序可以利用缺少这些检查来获得内核特权。</p>
<ul>
<li>xv6 在验证需要提供给内核的用户程序数据的时候，并没有完全验证其是否是恶意的，恶意用户程序可能利用这些数据来绕过 xv6 的隔离。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s, *last;</span><br><span class="line">  <span class="type">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;  <span class="comment">// 打开二进制文件，得到这个文件的indoe(元数据)</span></span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf)) <span class="comment">// 读取ELF文件头</span></span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)  <span class="comment">// 检查是否是魔法数字</span></span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)  <span class="comment">// 创建一个空页表</span></span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load program into memory.  加载程序到内存</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))  <span class="comment">// 读取程序段头</span></span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)  </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary. 在下一个页边界处分配两个页面</span></span><br><span class="line">  <span class="comment">// Make the first inaccessible as a stack guard. 将第一个页面设置为不可访问，作为栈保护</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack. 使用第二个页面作为用户栈</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE, PTE_W)) == <span class="number">0</span>)  <span class="comment">// 页表中分配两个页的物理内存和PTE</span></span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE); <span class="comment">// 将第一个页面设为用户不可访问，即保护页</span></span><br><span class="line">  sp = sz;  <span class="comment">// 更新栈指针和栈底指针</span></span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack. 将参数字符串压入栈，准备其余栈内容在ustack中</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>; <span class="comment">// 设置参数的起始地址</span></span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned  riscv的栈指针必须是16字节对其</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="comment">// 参数入栈</span></span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    ustack[argc] = sp;  <span class="comment">// 记录参数在栈中的位值</span></span><br><span class="line">  &#125;</span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers. 将参数指针数组入栈</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="type">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv) 传递给用户 main(argc, argv) 的参数</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return argc 通过系统调用的返回值返回</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.  该返回值存放在 a0 寄存器中</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;  <span class="comment">// 这里设置传递给main的参数argv[]，将参数指针数组的起始地址放入a1，argc放在a0中，是系统调用设置的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging. 保存程序名字为了调试</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>; <span class="comment">// 退出时last位于path中最后一个文件名的起始地址</span></span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name)); <span class="comment">// last复制到p-&gt;name，最多sizeof(p-&gt;name)个字节</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.  提交用户镜像</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable; </span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main 初始化程序计数器（PC）为main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer 初始化栈指针</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);  <span class="comment">// 释放旧页表</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// argc的值最终会被放入a0寄存器，这是传递给main(argc, argv)函数的第一个参数</span></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)  </span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">flags2perm</span><span class="params">(<span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> perm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flags &amp; <span class="number">0x1</span>)</span><br><span class="line">      perm = PTE_X;</span><br><span class="line">    <span class="keyword">if</span>(flags &amp; <span class="number">0x2</span>)</span><br><span class="line">      perm |= PTE_W;</span><br><span class="line">    <span class="keyword">return</span> perm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Real-world-现实世界"><a href="#Real-world-现实世界" class="headerlink" title="Real world 现实世界"></a>Real world 现实世界</h2><ul>
<li><p>像大多数操作系统一样，xv6 使用分页硬件进行内存保护和映射。</p>
<ul>
<li>大多数操作系统对分页的使用要比 xv6 复杂得多，它将分页和缺页异常结合起来，我们将在第 4 章中讨论。</li>
</ul>
</li>
<li><p>xv6 的内核使用虚拟地址和物理地址之间的直接映射，这样会更简单，并假设在地址 0x8000000 处有物理 RAM，即内核期望加载的地方。</p>
<ul>
<li>这在 QEMU 中是可行的，但是在真实的硬件上，它被证明是一个糟糕的想法；</li>
<li>真实的硬件将 RAM 和设备放置在不可预测的物理地址上，例如在 0x8000000 处可能没有 RAM，而 xv6 期望能够在那里存储内核。</li>
<li>更好的内核设计利用页表将任意的硬件物理内存布局变成可预测的内核虚拟地址布局。</li>
</ul>
</li>
<li><p>RISC-V 支持物理地址级别的保护，但 xv6 没有使用该功能。</p>
</li>
<li><p>在有大量内存的机器上，使用 RISC-V 对超级页（4MB 的页）的支持可能是有意义的。</p>
<ul>
<li>当物理内存很小的时候，小页是有意义的，可以对磁盘进行精细地分配和分页。</li>
<li>例如，如果一个程序只使用 8 千字节的内存，那么给它整整 4 兆字节的超级物理内存页是浪费的。更大的页在有大量内存的机器上是有意义的，可以减少页表操作的开销。</li>
</ul>
</li>
<li><p>xv6 内核缺乏一个类 malloc 的分配器为小程序提供内存，这使得内核没有使用需要动态分配的复杂数据结构，从而简化了设计。</p>
</li>
<li><p>内存分配是一个常年的热门话题，基本问题是有效利用有限的内存和为未来未知的请求做准备<a href="#ftn2">[2]</a>。</p>
<ul>
<li>如今人们更关心的是速度而不是空间效率。</li>
<li>此外，一个更复杂的内核可能会分配许多不同大小的小块，而不是（在 xv6 中）只分配 4096 字节的块；</li>
<li>一个真正的内核分配器需要处理小块分配以及大块分配。</li>
</ul>
</li>
</ul>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li><p>分析 RISC-V 的设备树（device tree），找出计算机有多少物理内存。</p>
</li>
<li><p>编写一个用户程序，通过调用 <code>sbrk(1)</code> 使其地址空间增加一个字节。运行该程序，研究调用 <code>sbrk</code> 之前和调用<code>sbrk</code> 之后的程序页表。内核分配了多少空间？新内存的 PTE 包含哪些内容？</p>
</li>
<li><p>修改 xv6 使得内核使用超级页 4M。</p>
</li>
<li><p>修改 xv6，使用户程序间接引用一个空指针时，会收到一个异常，即修改 xv6，使用户程序的虚拟地址 0 不被映射。</p>
</li>
<li><p>Unix 实现的 exec 传统上包括对 shell 脚本的特殊处理。如果要执行的文件以文本 <code>#!</code> 开头， 那么第一行就被认为是要运行的程序来解释文件。例如，如果调用 <code>exec</code> 运行 <code>myprog arg1</code>， 而 <code>myprog</code> 的第一行是 <code>#!/interp</code>，那么 <code>exec</code> 执行 <code>/interp myprog arg1</code>。在 xv6 中实现对这个约定的支持。</p>
</li>
<li><p>为内核实现地址空间的随机化。</p>
</li>
</ol>
<hr>
<ol>
<li><a name="ftn1"></a> 即在栈中保存了从main返回所需要的信息</li>
<li><a name="ftn2"></a> dereference，就是对地址取值，例如 *p。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/05/17/xv6-book-chapter-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/17/xv6-book-chapter-2/" class="post-title-link" itemprop="url">xv6 book Chapter 2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-17 21:40:31" itemprop="dateCreated datePublished" datetime="2024-05-17T21:40:31+08:00">2024-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-20 21:47:54" itemprop="dateModified" datetime="2024-05-20T21:47:54+08:00">2024-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Operating-system-organization-操作系统组织"><a href="#Operating-system-organization-操作系统组织" class="headerlink" title="Operating system organization 操作系统组织"></a>Operating system organization 操作系统组织</h1><ul>
<li><p>操作系统的一个关键要求是同时支持几个活动。</p>
<ul>
<li>例如，使用第 1 章中描述的系统调用接口，一个进程可以用 <strong>fork</strong> 创建新进程。</li>
<li>操作系统必须在这些进程之间分时共享计算机的资源。例如，即使进程的数量多于硬件CPU的数量，操作系统也必须保证所有的进程都有机会执行。</li>
<li>操作系统还必须安排进程之间的隔离。也就是说，如果一个进程出现了 bug 并发生了故障，其不应该影响不依赖该 bug 进程的进程。</li>
<li>然而，完全隔离也不可取，因为进程间可能需要进行交互，例如管道。</li>
<li>因此，一个操作系统必须满足三个要求：多路复用、隔离和交互。</li>
</ul>
</li>
<li><p>本章概述了如何组织操作系统来实现这三个要求。</p>
<ul>
<li>现实中有很多方法，但本文主要介绍以宏内核 <a href="#ftn1">[1]</a> 为中心的主流设计，很多 Unix 操作系统都采用这种设计。</li>
<li>本章还介绍了 xv6 进程的概述，xv6 进程是 xv6 中的隔离单元，还介绍了 xv6 启动时第一个进程的创建。</li>
</ul>
</li>
<li><p>xv6 运行在多核 <a href="#ftn2">[2]</a> RISC-V 微处理器上，它的许多底层功能（例如，它的进程实现）是 RISC-V 所特有的。</p>
<ul>
<li>RISC-V 是一个 64 位的 CPU，xv6 是用 “LP64” C 语言编写的，这意味着 C 编程语言中的 long(L) 和指针 (P) 是 64 位的，但 int 是 32 位的。</li>
<li>本书假定读者在某种架构上做过一点机器级的编程，并会介绍一些 RISC-V 特有的思想。</li>
<li>RISC-V 有用的参考资料是 “The RISC-V Reader,An Open Architecture Attlas”［12］。</li>
<li>用户级 ISA [2] 和特权架构 [1] 是官方规范。</li>
</ul>
</li>
<li><p>一台完整的计算机中的 CPU 被支持它的硬件所包围，这些硬件大部分呈 I&#x2F;O 接口的形式。</p>
<ul>
<li>编写 xv6 时，支撑它的硬件是通过带 “-machine virt” 选项的 qemu 模拟出来的。</li>
<li>其中包括 RAM、包含启动代码的 ROM、与用户键盘&#x2F;屏幕的串行连接以及用于存储的磁盘。</li>
</ul>
</li>
</ul>
<h2 id="Abstracting-physical-resources-抽象化物理资源"><a href="#Abstracting-physical-resources-抽象化物理资源" class="headerlink" title="Abstracting physical resources 抽象化物理资源"></a>Abstracting physical resources 抽象化物理资源</h2><ul>
<li><p>遇到一个操作系统，人们可能会问的第一个问题是为什么需要它呢？</p>
<ul>
<li>答案是，我们可以把图 1.2 中的系统调用作为一个库来实现，应用程序与之连接。</li>
<li>在这个想法中，每个应用程序可以根据自己的需要定制自己的库。</li>
<li>应用程序可以直接与硬件资源进行交互，并以最适合应用程序的方式使用这些资源（例如，实现高效、可预测的性能）。</li>
<li>一些用于嵌入式设备或实时系统的操作系统就是以这种方式组织的。</li>
</ul>
</li>
<li><p>这种系统库方式的缺点是，如果有多个应用程序在运行，这些应用程序必须正确执行。</p>
<ul>
<li>例如，每个应用程序必须定期放弃 CPU，以便其他应用程序能够运行。</li>
<li>如果所有的应用程序都相互信任并且没有 bug，这样的 <strong>cooperative</strong> 分时方案可能是 OK 的。</li>
<li>更典型的情况是，应用程序之间互不信任，并且有 bug，所以人们通常希望比 <strong>cooperative</strong> 方案提供更强的隔离性。</li>
</ul>
</li>
<li><p>为了实现强隔离，禁止应用程序直接访问敏感的硬件资源，而将资源抽象为服务是很有帮助的。</p>
<ul>
<li>例如，Unix 应用程序只通过文件系统的 <code>open</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 系统调用与文件系统进行交互，而不是直接读写磁盘。</li>
<li>这为应用程序带来了路径名的便利，而且它允许操作系统（作为接口的实现者）管理磁盘。</li>
<li>即使不考虑隔离问题，那些有意交互的程序（或者只是希望互不干扰）很可能会发现文件系统是一个比直接使用磁盘更方便的抽象。</li>
</ul>
</li>
<li><p>同样，Unix 在进程之间透明地切换硬件 CPU，必要时保存和恢复寄存器状态，这样应用程序就不必意识到时间共享。</p>
<ul>
<li>这种透明性允许操作系统共享 CPU，即使一些应用程序处于无限循环中。</li>
</ul>
</li>
<li><p>另一个例子是，Unix 进程使用 <code>exec</code> 来建立它们的内存映像，而不是直接与物理内存交互。</p>
<ul>
<li>这使得操作系统可以决定将进程放在内存的什么位置；如果内存紧张，操作系统甚至可能将进程的部分数据存储在磁盘上。</li>
<li><code>exec</code> 还允许用户将可执行文件储存在文件系统中。</li>
</ul>
</li>
<li><p>Unix 进程之间的许多形式的交互都是通过文件描述符进行的。</p>
<ul>
<li>文件描述符不仅可以抽象出许多细节（例如，管道或文件中的数据存储在哪里），而且它们的定义方式也可以简化交互。</li>
<li>例如，如果管道中的一个应用程序崩溃了，内核就会为管道中的另一个进程产生一个文件结束信号。</li>
</ul>
</li>
<li><p>图 1.2 中的系统调用接口经过精心设计，既为程序员提供了便利，又提供了强隔离的可能。</p>
<ul>
<li>Unix接口并不是抽象资源的唯一方式，但事实证明它是一种非常好的方式。</li>
</ul>
</li>
</ul>
<h2 id="User-mode-supervisor-mode-and-system-calls-用户模式，内核模式，和系统调用"><a href="#User-mode-supervisor-mode-and-system-calls-用户模式，内核模式，和系统调用" class="headerlink" title="User mode, supervisor mode, and system calls 用户模式，内核模式，和系统调用"></a>User mode, supervisor mode, and system calls 用户模式，内核模式，和系统调用</h2><ul>
<li><p>强隔离要求应用程序和操作系统之间有一个分界线。</p>
<ul>
<li>如果应用程序发生错误，我们不希望操作系统崩溃，也不希望其他应用程序崩溃。</li>
<li>相反，操作系统应该能够清理崩溃的应用程序并继续运行其他应用程序。</li>
<li>为了实现强隔离，操作系统必须安排应用程序不能修改（甚至不能读取）操作系统的数据结构和指令，应用程序不能访问其他进程的内存。</li>
</ul>
</li>
<li><p>CPU 提供了强隔离的硬件支持。</p>
<ul>
<li>例如，RISC-V 有三种模式，CPU 可以执行指令：<strong>机器模式</strong>、<strong>监督者（supervisor）模式</strong> 和 <strong>用户模式</strong>。</li>
<li>在机器模式下执行的指令具有完全的权限，一个CPU在机器模式下启动。机器模式主要用于配置计算机。</li>
<li>xv6 会在机器模式下执行几条指令，然后转为监督者模式。</li>
</ul>
</li>
<li><p>在监督者（supervisor）模式下，CPU 被允许执行特权指令：例如，启用和禁用中断，读写保存页表地址的寄存器等。</p>
<ul>
<li>如果用户模式下的应用程序试图执行一条特权指令，CPU 不会执行该指令，而是切换到监督者模式，这样监督者模式的代码就可以终止该应用程序，因为它做了不该做的事情。</li>
<li>第 1 章的图 1.1 说明了这种组织方式。</li>
<li>一个应用程序只能执行用户模式的指令（如数字相加等），被称为运行在用户空间，而处于监督者模式的软件也可以执行特权指令，被称为运行在内核空间。</li>
<li>运行在内核空间（或监督者模式）的软件称为内核。</li>
</ul>
</li>
<li><p>一个应用程序如果要调用内核函数（如 xv6 中的 <code>read</code> 系统调用），必须过渡到内核。</p>
<ul>
<li>CPU 提供了一个特殊的指令，可以将 CPU 从用户模式切换到监督者模式，并在内核指定的入口处进入内核。( RISC-V 为此提供了 <code>ecall</code> 指令。)</li>
<li>一旦 CPU 切换到监督者模式，内核就可以验证系统调用的参数，决定是否允许应用程序执行请求的操作，然后拒绝或执行该操作。</li>
<li>由内核控制监督者模式的入口点是很重要的；如果应用程序可以决定内核的入口点，那么恶意应用程序就能够在跳过参数验证的情况下进入内核。</li>
</ul>
</li>
</ul>
<h2 id="Kernel-organization-内核组织"><a href="#Kernel-organization-内核组织" class="headerlink" title="Kernel organization 内核组织"></a>Kernel organization 内核组织</h2><ul>
<li><p>一个关键的设计问题是操作系统的哪一部分应该在监督者模式下运行。</p>
<ul>
<li>一种可能是整个操作系统驻留在内核中，这样所有系统调用的实现都在监督者模式下运行。这种组织方式称为 <strong>宏内核</strong>。</li>
</ul>
</li>
<li><p>在这种组织方式中，整个操作系统以全硬件权限运行。</p>
<ul>
<li>这种组织方式很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要全硬件权限。</li>
<li>此外，操作系统的不同部分更容易合作。例如，一个操作系统可能有一个缓冲区，其被缓存文件系统和虚拟内存系统共享。</li>
</ul>
</li>
<li><p>宏内核组织方式的一个缺点是操作系统的不同部分之间的接口通常是复杂的（我们将在本文的其余部分看到），因此操作系统开发者很容易在这上面出错。</p>
</li>
<li><p>在宏内核中，一个错误是致命的，因为监督者模式下的错误往往会导致内核崩溃。</p>
</li>
<li><p>如果内核崩溃，计算机就会停止工作，因此所有的应用程序也会崩溃。计算机必须重启。</p>
</li>
<li><p>为了降低内核出错的风险，操作系统设计者可以尽量减少在监督者模式下运行的操作系统代码量，而在用户模式下执行操作系统的大部分代码。这种内核组织方式称为 <strong>微内核</strong>。</p>
</li>
</ul>
<img src="/2024/05/17/xv6-book-chapter-2/Figure-2.1.png" class="" title="Figure-2.1">

<ul>
<li><p>图 2.1 说明了这种微内核设计。</p>
<ul>
<li>在图中，文件系统作为一个用户级进程运行。作为进程运行的 OS 服务称为服务器。</li>
<li>为了让应用程序与文件服务器进行交互，内核提供了一种进程间通信机制，用于从一个用户模式进程向另一个进程发送消息。</li>
<li>例如，如果一个像 shell 这样的应用程序想要读写文件，它就会向文件服务器发送一个消息，并等待响应。</li>
</ul>
</li>
<li><p>在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。</p>
<ul>
<li>这种组织方式使得内核相对简单，因为大部分操作系统驻留在用户级服务器中。</li>
</ul>
</li>
<li><p>xv6 和大多数 Unix 操作系统一样，是以宏内核的形式实现的。</p>
<ul>
<li>因此，xv6 内核接口与操作系统接口相对应，内核实现了完整的操作系统。</li>
<li>由于 xv6 不提供很多服务，所以它的内核比一些微内核要小，但从概念上讲 xv6 是宏内核。</li>
</ul>
</li>
</ul>
<h2 id="Code-xv6-organization-xv6-的组织结构"><a href="#Code-xv6-organization-xv6-的组织结构" class="headerlink" title="Code: xv6 organization xv6 的组织结构"></a>Code: xv6 organization xv6 的组织结构</h2><ul>
<li>xv6 内核源码在 <code>kernel/</code> 子目录下。<ul>
<li>按照模块化的概念，源码被分成了多个文件，图 2.2 列出了这些文件。模块间的接口在 <code>kernel/defs.h</code> 中定义。</li>
</ul>
</li>
</ul>
<img src="/2024/05/17/xv6-book-chapter-2/Figure-2.2.png" class="" title="Figure-2.2">

<h2 id="Process-overview-进程概述"><a href="#Process-overview-进程概述" class="headerlink" title="Process overview 进程概述"></a>Process overview 进程概述</h2><ul>
<li><p>xv6 中的隔离单位（和其他 Unix 操作系统一样）是一个进程。</p>
<ul>
<li>进程抽象可以防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。</li>
<li>它还可以防止进程破坏内核，所以进程不能破坏内核的隔离机制。</li>
<li>内核必须小心翼翼地实现进程抽象，因为一个错误或恶意的应用程序可能会欺骗内核或硬件做一些不好的事情（例如，规避隔离）。</li>
<li>内核用来实现进程的机制包括：用户&#x2F;监督模式标志、地址空间和线程的时间片轮转。</li>
</ul>
</li>
<li><p>为了帮助实施隔离，进程抽象为程序提供了一种错觉，即它有自己的私有机器。</p>
<ul>
<li>一个进程为程序提供了一个看似私有的内存系统，或者说是地址空间，其他进程不能对其进行读写。</li>
<li>进程还为程序提供了 “私有” 的 CPU，用来执行程序的指令。</li>
</ul>
</li>
<li><p>xv6 使用页表（由硬件实现）给每个进程提供自己的地址空间。</p>
<ul>
<li>RISC-V 页表将 <strong>虚拟地址</strong>（RISC-V 指令操作的地址）转换（或 “映射”）为 <strong>物理地址</strong>（CPU芯片发送到主存储器的地址）。</li>
</ul>
</li>
<li><p>xv6 为每个进程维护一个单独的页表，定义该进程的地址空间。</p>
<ul>
<li>如图 2.3 所示，进程的用户空间内存的地址空间是从虚拟地址0开始的。</li>
<li>指令存放在最前面，其次是全局变量，然后是栈，最后是一个堆区（用于 <strong>malloc</strong>），进程可以根据需要扩展。</li>
<li>有一些因素限制了进程地址空间的最大长度：RISC-V 上的指针是 64 位宽；硬件在页表中查找虚拟地址时只使用低的 39 位；xv6 只使用 39 位中的 38 位。</li>
<li>因此，最大地址是 $2^{38}-1$ &#x3D; 0x3fffffffff，也就是 <code>MAXVA</code>（kernel&#x2F;riscv.h:348）。</li>
<li>在地址空间的顶端，xv6 保留了一页，用于 <strong>trampoline</strong> 和映射进程 <strong>trapframe</strong> 的页，以便切换到内核，我们将在第 4 章中解释。</li>
</ul>
</li>
</ul>
<img src="/2024/05/17/xv6-book-chapter-2/Figure-2.3.png" class="" title="Figure-2.3">

<ul>
<li>xv6 内核为每个进程维护了许多状态，记录在 <code>proc</code> 结构体 (kernel&#x2F;proc.h:86)。<ul>
<li>一个进程最重要的内核状态是它的页表、内核栈和运行状态。</li>
<li>我们用 <code>p-&gt;xxx</code> 来表示 <code>proc</code> 结构的元素，例如，<code>p-&gt;pagetable</code> 是指向进程页表的指针。</li>
</ul>
</li>
</ul>
<blockquote>
<p>kernel&#x2F;proc.h:86</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line"><span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line"><span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line"><span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line"><span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line"><span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>每个进程都有一个执行线程（简称线程），执行进程的指令。</p>
<ul>
<li>一个线程可以被暂停，然后再恢复。</li>
<li>为了在进程之间透明地切换，内核会暂停当前运行的线程，并恢复另一个进程的线程。</li>
<li>线程的大部分状态（局部变量、函数调用返回地址）都存储在线程的栈中。</li>
<li>每个进程有两个栈：用户栈和内核栈（<code>p-&gt;kstack</code>）。</li>
<li>当进程在执行用户指令时，只有它的用户栈在被使用，而它的内核栈是空的。</li>
<li>当进程进入内核时（因为系统调用或中断），内核代码在进程的内核栈上执行；</li>
<li>当进程在内核中时，它的用户栈仍然包含保存的数据，但不被主动使用。</li>
<li>进程的线程在用户栈和内核栈中交替执行。</li>
<li>内核栈是独立的（并且受到保护，不受用户代码的影响），所以即使一个进程用户栈被破坏了，内核也可以执行。</li>
</ul>
</li>
<li><p>一个进程可以通过执行 RISC-V <code>ecall</code> 指令进行系统调用。</p>
<ul>
<li>该指令提高硬件权限级别，并将程序计数器改变为内核定义的入口点。</li>
<li>入口点的代码会切换到内核栈，并执行实现系统调用的内核指令。</li>
<li>当系统调用完成后，内核切换回用户栈，并通过调用 <code>sret</code> 指令返回用户空间，降低硬件特权级别，恢复执行系统调用前的用户指令。</li>
<li>进程的线程可以在内核中阻塞等待 I&#x2F;O，当 I&#x2F;O 完成后，再从离开的地方恢复。</li>
</ul>
</li>
<li><p><code>p-&gt;state</code> 表示进程是创建、就绪、运行、等待 I&#x2F;O，还是退出。</p>
</li>
<li><p><code>p-&gt;pagetable</code> 以 RISC-V 硬件需要的格式保存进程的页表，当进程在用户空间执行时，xv6 使分页硬件使用进程的 <code>p-&gt;pagetable</code>。</p>
<ul>
<li>进程的页表也会记录分配给该进程内存的物理页地址。</li>
</ul>
</li>
</ul>
<h2 id="Code-starting-xv6-and-the-first-process-启动xv6和第一个进程"><a href="#Code-starting-xv6-and-the-first-process-启动xv6和第一个进程" class="headerlink" title="Code: starting xv6 and the first process 启动xv6和第一个进程"></a>Code: starting xv6 and the first process 启动xv6和第一个进程</h2><ul>
<li><p>为了使 xv6 更加具体，我们将概述内核如何启动和运行第一个进程。后面的章节将更详细地描述这个概述中出现的机制。</p>
</li>
<li><p>当 RISC-V 计算机开机时，它会初始化自己，并运行一个存储在只读存储器中的 <strong>boot loader</strong>。<strong>boot loader</strong> 将 xv6 内核加载到内存中。</p>
<ul>
<li>然后，在机器模式下，CPU从 <code>_entry</code>（kernel&#x2F;entry.S:6）开始执行 xv6。</li>
<li>RISC-V 在禁用分页硬件的情况下启动：虚拟地址直接映射到物理地址。</li>
</ul>
</li>
</ul>
<blockquote>
<p>kernel&#x2F;entry.S</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     # qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">     # and causes each hart (i.e. CPU) to jump there.</span><br><span class="line">     # kernel.ld causes the following code to</span><br><span class="line">     # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">     # set up a stack for C.</span><br><span class="line">     # stack0 is declared in start.c,</span><br><span class="line">     # with a 4096-byte stack per CPU.</span><br><span class="line">     # sp = stack0 + (hartid * 4096)</span><br><span class="line">     la sp, stack0</span><br><span class="line">     li a0, 1024*4</span><br><span class="line">     csrr a1, mhartid</span><br><span class="line">     addi a1, a1, 1</span><br><span class="line">     mul a0, a0, a1</span><br><span class="line">     add sp, sp, a0</span><br><span class="line">     # jump to start() in start.c</span><br><span class="line">     call start</span><br><span class="line">spin:</span><br><span class="line">     j spin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>loader 将 xv6 内核加载到物理地址 <code>0x80000000</code> 的内存中。</p>
<ul>
<li>之所以将内核放在 <code>0x80000000</code> 而不是 <code>0x0</code>，是因为地址范围 <code>0x0:0x80000000</code> 包含 I&#x2F;O 设备。</li>
</ul>
</li>
<li><p><code>_entry</code> 处的指令设置了一个栈，这样 xv6 就可以运行 C 代码。</p>
<ul>
<li>xv6 在文件 <code>start.c</code> (kernel&#x2F;start.c:11) 中声明了初始栈的空间，即 <code>stack0</code>。</li>
<li>在 <code>_entry</code> 处的代码加载栈指针寄存器 <code>sp</code>，地址为 <code>stack0+4096</code>，也就是栈的顶部，因为 RISC-V 的栈是向下扩张的。</li>
<li>现在内核就拥有了栈，<code>_entry</code> 调用 <code>start</code> (kernel&#x2F;start.c:21)，并执行其 C 代码。</li>
</ul>
</li>
</ul>
<blockquote>
<p>kernel&#x2F;start.c:11</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S needs one stack per CPU.</span></span><br><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br></pre></td></tr></table></figure>

<p>kernel&#x2F;start.c:21</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">x |= MSTATUS_MPP_S;</span><br><span class="line">w_mstatus(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line"><span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line"><span class="comment">// disable paging for now.</span></span><br><span class="line">w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line"><span class="comment">// access to all of physical memory.</span></span><br><span class="line">w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ask for clock interrupts.</span></span><br><span class="line">timerinit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line"><span class="type">int</span> id = r_mhartid();</span><br><span class="line">w_tp(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>函数 <code>start</code> 执行一些只有在机器模式下才允许的配置，然后切换到监督者模式。</p>
<ul>
<li>为了进入监督者模式，RISC-V 提供了指令 <code>mret</code>。这条指令最常用来从上一次的调用中返回，上一次调用从监督者模式到机器模式。</li>
<li><code>start</code> 并不是从这样的调用中返回，而是把事情设置得像有过这样的调用一样：它在寄存器 <code>mstatus</code> 中把上一次的特权模式设置为特权者模式，它把 <code>main</code> 的地址写入寄存器 <code>mepc</code> 中，把返回地址设置为 <code>main</code> 函数的地址，在特权者模式中把 <code>0</code> 写入页表寄存器 <code>satp</code> 中，禁用虚拟地址转换，并把所有中断和异常委托给特权者模式。</li>
</ul>
</li>
<li><p>在进入特权者模式之前，<code>start</code> 还要执行一项任务：对时钟芯片进行编程以初始化定时器中断。</p>
<ul>
<li>在完成了这些基本管理后，<code>start</code> 通过调用 <code>mret</code> “返回” 到监督者模式。</li>
<li>这将导致程序计数器变为 <code>main</code>（kernel&#x2F;main.c:11）的地址。</li>
</ul>
</li>
</ul>
<blockquote>
<p>kernel&#x2F;main.c:11</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line"> consoleinit();</span><br><span class="line"> printfinit();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line"> kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line"> kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line"> procinit();      <span class="comment">// process table</span></span><br><span class="line"> trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line"> trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line"> plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line"> plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line"> binit();         <span class="comment">// buffer cache</span></span><br><span class="line"> iinit();         <span class="comment">// inode table</span></span><br><span class="line"> fileinit();      <span class="comment">// file table</span></span><br><span class="line"> virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line"> userinit();      <span class="comment">// first user process</span></span><br><span class="line"> __sync_synchronize();</span><br><span class="line"> started = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">   ;</span><br><span class="line"> __sync_synchronize();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line"> kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line"> trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line"> plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scheduler();        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>在 <code>main</code> (kernel&#x2F;main.c:11) 初始化几个设备和子系统后，它通过调用 <code>userinit</code> (kernel&#x2F;proc.c:232) 来创建第一个进程。<ul>
<li>第一个进程执行一个用 RISC-V 汇编编写的小程序 <code>initcode.S</code>（user&#x2F;initcode.S:1），它通过调用 <code>exec</code> 系统调用重新进入内核。</li>
<li>正如我们在第一章中所看到的，<code>exec</code> 用一个新的程序（本例中是 <code>/init</code>）替换当前进程的内存和寄存器。</li>
</ul>
</li>
</ul>
<blockquote>
<p>kernel&#x2F;proc.c:232</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">p = allocproc();</span><br><span class="line">initproc = p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate one user page and copy initcode&#x27;s instructions</span></span><br><span class="line"><span class="comment">// and data into it.</span></span><br><span class="line">uvmfirst(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>user&#x2F;initcode.S:1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">     la a0, init</span><br><span class="line">     la a1, argv</span><br><span class="line">     li a7, SYS_exec</span><br><span class="line">     ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">     li a7, SYS_exit</span><br><span class="line">     ecall</span><br><span class="line">     jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">.string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">.long init</span><br><span class="line">.long 0</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>一旦内核完成 <code>exec</code>，它就会在 <code>/init</code> 进程中返回到用户空间。<ul>
<li><code>init</code>  (user&#x2F;init.c:15) 在需要时会创建一个新的控制台设备文件，然后以文件描述符0、1和2的形式打开它。</li>
<li>然后它在控制台上启动一个 shell。这样系统就启动了。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;init.c:15</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pid, wpid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line"> open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line">dup(<span class="number">0</span>);  <span class="comment">// stdout</span></span><br><span class="line">dup(<span class="number">0</span>);  <span class="comment">// stderr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">   exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">   <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">   <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">   wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">     <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Real-world-现实情况"><a href="#Real-world-现实情况" class="headerlink" title="Real world 现实情况"></a>Real world 现实情况</h2><ul>
<li><p>在现实世界中，既可以找到宏内核，也可以找到微内核。</p>
<ul>
<li>许多 Unix 内核都是宏内核。例如，Linux 的内核，尽管有些操作系统的功能是作为用户级服务器运行的（如windows系统）。</li>
<li>L4、Minix 和 QNX 等内核是以服务器的形式组织的微内核，并在嵌入式环境中得到了广泛的部署。</li>
<li>大多数操作系统都采用了进程概念，大多数进程都与 xv6 的相似。</li>
</ul>
</li>
<li><p>然而，现代操作系统支持进程可以拥有多个线程，以允许一个进程利用多个CPU。</p>
<ul>
<li>在一个进程中支持多个线程涉及到不少 xv6 没有的机制，包括潜在的接口变化 (如 Linux 的 <code>clone</code>，<code>fork</code> 的变种)，以控制线程所共享进程的那些部分。</li>
</ul>
</li>
</ul>
<h2 id="Exercises-练习"><a href="#Exercises-练习" class="headerlink" title="Exercises 练习"></a>Exercises 练习</h2><ol>
<li>你可以使用 gdb 来观察 kernel mode 到 user mode 的第一次转换。运行 <code>make qemu-gdb</code>。在同一目录下的另一个窗口中，运行<code>gdb</code>。输入 gdb 命令 <code>break *0x3ffffff10e</code>，这将在内核中跳转到用户空间的 <code>sret</code> 指令处设置一个断点。输入 <code>continue</code>  gdb 命令，gdb 应该在断点处停止，并即将执行 <code>sret</code>。gdb 现在应该显示它正在地址 0x0 处执行，该地址在 <code>initcode.S</code> 的用户空间开始处。</li>
</ol>
<hr>
<ol>
<li><p><a name="ftn1"></a> 与微内核设计理念相对应的理念，这也是一个源自操作系统级别的概念。对于宏内核来说，整个操作系统就是一个整体，包括了进程管理、内存管理、文件系统等等</p>
</li>
<li><p><a name="ftn2"></a> 本文所说的 “多核 “是指多个共享内存但并行执行的 CPU，每个 CPU 都有自己的一套寄存器。本文有时使用多处理器一词作为多核的同义词，但多处理器也可以更具体地指具有多个不同处理器芯片的计算机。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/05/13/6-S081-Lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/13/6-S081-Lab2/" class="post-title-link" itemprop="url">Lab System calls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-13 19:41:01" itemprop="dateCreated datePublished" datetime="2024-05-13T19:41:01+08:00">2024-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-16 16:02:01" itemprop="dateModified" datetime="2024-05-16T16:02:01+08:00">2024-05-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>实验讲义：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/labs/syscall.html">Lab: System calls (mit.edu)</a></p>
</li>
<li><p>在这个实验中，你将向 xv6 添加一些新的系统调用，这将帮助你了解它们的工作原理，并将你暴漏在 xv6 内核的一些内部！</p>
</li>
<li><p>在开始之前，请阅读 xv6 book 的第 2 章，第 4 章的 4.3 和 4.4 节，以及相关源文件：</p>
<ul>
<li>系统调用的用户空间代码：<code>user/user.h</code> 和 <code>user/usys.pl</code></li>
<li>内核空间代码：<code>kernel/syscall.h</code> 和 <code>kernel/syscall.c</code></li>
<li>与进程相关的代码：<code>kernel/proc.h</code> 和 <code>kernel/proc.c</code></li>
</ul>
</li>
<li><p>请输入命令：<code>git fetch</code>、<code>git checkout syscall</code> 和 <code>make clean</code>，这将会帮助你构建实验相关的文件</p>
<blockquote>
<p>这是必要的！别问我为什么知道）</p>
</blockquote>
</li>
</ul>
<h1 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h1><ul>
<li><p>在此任务中，你将添加一个系统调用跟踪功能。它接受一个参数，一个整数 ”掩码“，其位指定哪些系统调用进行跟踪。</p>
<ul>
<li>如果在掩码中设置了系统调用的编号（比如 <code>SYS_fork</code>），那么每当这个系统调用返回时，你必须修改 xv6 内核以打印一行。</li>
<li>该行包含进程 ID、系统调用名称、返回值（比如 <code>3: syscall read -&gt; 1024</code>）</li>
<li>trace 系统调用应该能够跟踪调用它的进程及其子进程，并不影响其他进程</li>
</ul>
</li>
<li><p>官方已经提供了 trace 的用户级程序，查看 <code>user/trace.c</code>，</p>
<blockquote>
<p>这就是之前输入的命令构建的，当然，别问我为什么要强调）</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> *nargv[MAXARG];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">3</span> || (argv[<span class="number">1</span>][<span class="number">0</span>] &lt; <span class="string">&#x27;0&#x27;</span> || argv[<span class="number">1</span>][<span class="number">0</span>] &gt; <span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: %s mask command\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trace(atoi(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;</span><br><span class="line">    nargv[i<span class="number">-2</span>] = argv[i];</span><br><span class="line">  &#125;</span><br><span class="line">  exec(nargv[<span class="number">0</span>], nargv);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一些提示</p>
<ul>
<li>在 Makefile 中将 <code>$U/trace</code> 添加到 <code>UPROGS</code></li>
<li>将系统调用原型添加到 <code>user/user.h</code>，将存根添加到 <code>user/usys.pl</code>，将 syscall 号码添加到 <code>kernel/syscall.h</code></li>
<li>在 <code>kernel/sysproc.c</code> 中添加一个 <code>sys_trace()</code> 函数，该函数通过 proc 结构中的新变量记住其参数（<code>kernel/proc.h</code>）</li>
<li>修改 fork 函数（<code>kernel/proc.c</code>）将跟踪掩码从父进程复制到子进程</li>
<li>修改 syscall 函数（<code>kernel/syscall.c</code>）以打印跟踪输出，你需要添加要索引的 syscall 的名称的数组</li>
</ul>
</li>
<li><p>根据 xv6 book 的 4.3、4.4 节及上述提示，我们可以大致了解到系统调用的具体流程</p>
</li>
<li><p>首先，我们在 <code>user/user.h</code> 中添加系统调用原型</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">// my change</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将存根添加到 <code>user/usys.pl</code></li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>); <span class="comment"># my change</span></span><br></pre></td></tr></table></figure>

<ul>
<li>根据官方提示我们了解到：Makefile 将调用 <code>user/usys.pl</code> 这个 perl 脚本生成 <code>user/usys.S</code>，即实际的系统调用存根</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trace:</span><br><span class="line"> li a7, SYS_trace</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果我们在编译后马后炮一下回头来看 <code>user/usys.S</code>，发现它会比以前多一项 trace 系统调用的存根，它将 <code>SYS_trace</code>（系统调用编号，与 <code>kernel/syscall.c</code> 中的 syscalls 数组中的项匹配）放入 <code>a7</code> 寄存器并调用 <code>ecall</code> 进入内核</p>
</li>
<li><p>我们到 <code>kernel/syscall.c</code> 中来看看 syscalls 数组是何方神圣</p>
<blockquote>
<p>当然它已经被我添加了一个新项</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An array mapping syscall numbers from syscall.h</span></span><br><span class="line"><span class="comment">// to the function that handles the system call.</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,  <span class="comment">// my change</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>syscalls 数组是一个函数指针数组，这些函数指针的类型是 <code>uint64 (*func_ptr)(void)</code>，不接受参数且返回 uint64 类型的值</li>
<li>其中的一项比如 <code>[SYS_fork] sys_fork</code>，<code>SYS_fork</code> 可能是一个枚举值或宏，指定数组中特定位置的元素为 <code>sys_fork</code> 函数指针</li>
<li>为了与 syscalls 数组中添加的新项匹配，我们需要在 <code>kernel/syscall.h</code> 中添加 <code>sys_trace</code> 对应的系统调用编号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22   <span class="comment">// my change</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>当然别忘了在 <code>kernel/syscall.c</code> 中声明一下 <code>sys_trace</code> 的函数原型</p>
<blockquote>
<p>别问我怎么知道的）</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// my change</span></span><br></pre></td></tr></table></figure>

<ul>
<li>现在 syscalls 数组中的系统调用编号就准备好了，我们需要具体实现 <code>sys_trace()</code> 这个实际的函数</li>
<li>根据提示，在 <code>kernel/sysproc.c</code> 中添加 <code>sys_trace()</code> 函数，该函数通过 proc 结构中的新变量记住其参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my change</span></span><br><span class="line">uint64 </span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  argint(<span class="number">0</span>, &amp;mask);</span><br><span class="line">  <span class="keyword">if</span> (mask &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  myproc()-&gt;mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 xv6 book 的 4.3 节中我们了解到：用户代码将用户级 trace 的参数放在 <code>a0</code> 寄存器中，我们通过 <code>arging</code> 函数将 <code>a0</code> 寄存器中的值（掩码）赋值到当前进程的 mask 成员变量中</li>
<li>当然 proc 结构（<code>kernel/proc.h</code>）中的新变量 mask 也需要我们自己添加</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> mask; <span class="comment">// my change</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里补充一下 <code>argint</code> 函数的作用，它调用 <code>argraw</code> 函数提取相关寄存器中的值（<code>kernel/syscall.c</code>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 xv6 book 的 4.3 节中我们还了解到：<code>ecall</code> 指令进入内核，执行 <code>uservec</code>、<code>usertrap</code>，然后执行  <code>syscall</code> </li>
<li>同样的官方也提示我们需要修改 syscall 函数（<code>kernel/syscall.c</code>）以打印跟踪输出</li>
<li><code>syscall</code> 会从当前进程的 <code>a7</code> 寄存器中得到系统调用号，并其作为索引在 <code>syscalls</code> 查找相应函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">    <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> ((p-&gt;mask &amp; (<span class="number">1</span>&lt;&lt;num)) != <span class="number">0</span>) &#123; <span class="comment">// my change</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscallnames[num], p-&gt;trapframe-&gt;a0);  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们要做的就是通过调用 <code>sys_trace()</code> 后设置的 mask 掩码与当前正在进行的系统调用的号码比较（<code>&amp;</code> 操作），如果符合（<code>!= 0</code>）就打印相关信息 </p>
</li>
<li><p>在打印相关信息时，我们需要用到系统调用的名称，这需要我们自己提供</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my change</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *syscallnames[] = &#123;</span><br><span class="line">[SYS_fork]    <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">[SYS_exit]    <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">[SYS_wait]    <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">[SYS_pipe]    <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">[SYS_read]    <span class="string">&quot;read&quot;</span>,</span><br><span class="line">[SYS_kill]    <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">[SYS_exec]    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">[SYS_fstat]   <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">[SYS_chdir]   <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">[SYS_dup]     <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">[SYS_getpid]  <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">[SYS_sbrk]    <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">[SYS_sleep]   <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">[SYS_uptime]  <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">[SYS_open]    <span class="string">&quot;open&quot;</span>,</span><br><span class="line">[SYS_write]   <span class="string">&quot;write&quot;</span>,</span><br><span class="line">[SYS_mknod]   <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">[SYS_unlink]  <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">[SYS_link]    <span class="string">&quot;link&quot;</span>,</span><br><span class="line">[SYS_mkdir]   <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">[SYS_close]   <span class="string">&quot;close&quot;</span>,</span><br><span class="line">[SYS_trace]   <span class="string">&quot;trace&quot;</span>,  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们在 <code>kernel/syscall.c</code> 中添加这样的一个 syscall 的名称的数组，当然官方也提示我们这样做了</p>
</li>
<li><p>最后不要忘记修改 fork 函数（<code>kernel/proc.c</code>），将父进程的 mask 掩码变量复制到子进程</p>
<blockquote>
<p>这很重要！当然这也是官方提示的）</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// my change</span></span><br><span class="line">  np-&gt;mask = p-&gt;mask;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>好吧，最后的最后在 Makefile 中将 <code>$U/trace</code> 添加到 <code>UPROGS</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_xargs\</span><br><span class="line">	$U/_trace</span><br></pre></td></tr></table></figure>

<ul>
<li>大功告成！<strong>make qemu &amp;&amp; trace 2 primes</strong>，让我们来通过 primes 程序测试一下 trace</li>
</ul>
<img src="/2024/05/13/6-S081-Lab2/image-20240516154717084.png" class="" title="image-20240516154717084">

<ul>
<li>符合预期！</li>
</ul>
<h1 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h1><ul>
<li><p>在此任务中，你将添加一个系统调用 sysinfo，收集有关运行系统的信息</p>
<ul>
<li>sysinfo 系统调用接受一个参数：指向结构 sysinfo 的指针（<code>kernel/sysinfo.h</code>）</li>
<li>内核应填写此结构的字段：<code>freemem</code> 字段应设置为可用内存字节数，<code>nproc</code> 字段应设置为不是 <code>UNUSED</code> 状态的进程数</li>
<li>我们提供了一个测试程序 sysinfotest，如果它打印 “sysinfotest: OK”，你将通过此作业</li>
</ul>
</li>
<li><p>一些建议</p>
<ul>
<li><p>在 Makefile 中将 <code>&amp;U/_sysinfotest</code> 添加到 <code>UPROGS</code></p>
</li>
<li><p>添加系统调用 sysinfo，和添加上一个系统调用的步骤相同。</p>
</li>
<li><p>在 <code>user/user.h</code> 中声明 sysinfo 的原型，你需要先声明 struct sysinfo 的存在：</p>
<p><code>struct sysinfo; int sysinfo(struct sysinfo *);</code></p>
</li>
<li><p>sysinfo 需要将结构 sysinfo 复制会用户空间，有关如何使用 <code>copyout()</code> 执行此操作的示例，请参阅 <code>sys_fstat()</code>（<code>kernel/sysfile.c</code>）和 <code>filestat()</code>（<code>kernel/file.c</code>）</p>
</li>
<li><p>要收集可用内存量，请向 <code>kernel/kalloc.c</code> 中添加一个函数</p>
</li>
<li><p>要收集进程数量，请向 <code>kernel/proc.c</code> 中添加一个函数</p>
</li>
</ul>
</li>
<li><p>首先，我们依照上一个任务的相关提示，将 sysinfo 系统调用的相关信息添加到对应文件</p>
</li>
<li><p>在 <code>user/user.h</code> 中声明 struct sysinfo 和 sysinfo 的原型</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span> <span class="comment">// my change</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">// my change</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *)</span>;  <span class="comment">// my change</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>user/usys.pl</code> 中添加存根</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>); <span class="comment"># my change</span></span><br><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);   <span class="comment"># my change</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/syscall.h</code> 中添加系统调用编号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link    19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir   20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close   21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace   22   <span class="comment">// my change</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo 23   <span class="comment">// my change</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/syscall.c</code> 中添加相关信息到 syscalls、syscallnames 数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  syscalls ...</span></span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,  <span class="comment">// my change</span></span><br><span class="line">[SYS_sysinfo] sys_sysinfo,  <span class="comment">// my change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// syscallnames ...</span></span><br><span class="line">[SYS_mkdir]   <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">[SYS_close]   <span class="string">&quot;close&quot;</span>,</span><br><span class="line">[SYS_trace]   <span class="string">&quot;trace&quot;</span>,  </span><br><span class="line">[SYS_sysinfo] <span class="string">&quot;sys_sysinfo&quot;</span>,  <span class="comment">// my change</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同时不要忘了在 <code>kernel/syscall.c</code> 中声明一下 <code>sys_sysinfo()</code> 的原型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// my change</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// my change</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/sysproc.c</code> 中添加一个 <code>sys_sysinfo()</code> 函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my change</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sys_sysinfo()</code> 具体该怎么实现呢？sysinfo 接收一个指向 sysinfo 结构的指针，如果我们想要将 sysinfo 结构复制回用户空间，需要使用 <code>copyout()</code> 函数</li>
<li>根据提示信息，我们查看一下  <code>sys_fstat()</code>（<code>kernel/sysfile.c</code>）和 <code>filestat()</code>（<code>kernel/file.c</code>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  uint64 st; <span class="comment">// user pointer to struct stat</span></span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;st);</span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> filestat(f, st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过观察，我们了解到了 <code>copyout()</code> 的使用方法</p>
<ul>
<li>第一个参数需要当前进程的 pagetable，我们可以通过 <code>myproc()</code> 得到 proc 结构，从而得到 <code>p-&gt;pagetable</code></li>
<li>第二个参数需要用户级函数传递的地址参数，在这里也就是 sysinfo 结构的指针，根据之前的知识，这个指针参数通常在相关寄存器中，我们可以通过 <code>argaddr()</code> 得到</li>
<li>第三个参数就是我们实际要复制回用户空间的 sysinfo 结构了，需要将它强转为 <code>(char*)</code></li>
<li>第四个参数是复制回用户空间的结构的大小，使用 <code>sizeof()</code> 轻松解决</li>
</ul>
</li>
<li><p>现在我们已经知道 <code>copyout()</code> 如何使用了，但还不知道 sysinfo 结构的具体情况，查看一下 <code>kernel/sysinfo.h</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> &#123;</span></span><br><span class="line">  uint64 freemem;   <span class="comment">// amount of free memory (bytes)</span></span><br><span class="line">  uint64 nproc;     <span class="comment">// number of process</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>根据提示信息，<code>freemem</code> 字段应该设置为可用内存字节数，<code>nproc</code> 字段应该设置为不是 <code>UNUSED</code> 状态的进程数</p>
</li>
<li><p>要统计可用内存字节数，官方提示我们在 <code>kernel/kalloc.c</code> 中添加一个函数</p>
</li>
<li><p>在 <code>kernel/kalloc.c</code> 中我发现了几个关键信息</p>
<ul>
<li><p>在开始的注释中提到：这里是物理内存分配器，用于用户进程、内核栈、页表页面，以及管道缓冲区。它分配完整的 <strong>4096</strong> 字节页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical memory allocator, for user processes,</span></span><br><span class="line"><span class="comment">// kernel stacks, page-table pages,</span></span><br><span class="line"><span class="comment">// and pipe buffers. Allocates whole 4096-byte pages.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关键信息是一个页面 4096 字节，如果我们可以遍历所有未使用的物理页面，* 4096 就可以得到未使用的内存字节数了</p>
</li>
<li><p>定义了两个结构体，需要注意的是：第二个其实是定义了一个全局的结构变量 <code>kmem</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kmem</code> 中的成员遍历 <code>freelist</code> 值得注意，它应该和空闲物理页面有关，应该是一个链表！</p>
</li>
<li><p><code>kfree()</code>：释放由指针 <code>pa</code> 指向的物理内存页面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过阅读，<code>kfree()</code> 释放指针 pa 指向的物理内存页面，并使用头插法将释放后的页面插入 <code>kmem</code> 的 <code>freelist</code> 成员变量！</p>
</li>
</ul>
</li>
<li><p>通过上述分析，我们几乎可以确定 <code>kmem</code> 通过链表维护空闲的物理内存页面！我们可以通过遍历这个链表得到未使用内存字节数</p>
</li>
<li><p>在 <code>kernel/kalloc.c</code> 中定义一个 <code>freemem()</code> 函数</p>
<blockquote>
<p>如果观察的仔细，宏 PGSIZE 已经给出了 4096）</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my change </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">freemem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> bytes = <span class="number">4096</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count * bytes; <span class="comment">// return count * PGSIZE;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>接下来我们需要统计不是 <code>UNUSED</code> 状态的进程数，官方同样提示我们需要在 <code>kernel/proc.c</code> 中定义一个函数</p>
</li>
<li><p>在 <code>kernle/proc.c</code> 中我也观察到了一些关键信息</p>
<ul>
<li><p>定义了一个全局的 proc 结构数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历 proc 数组说不定就可以统计到不是 <code>UNUSED</code> 状态的进程数</p>
</li>
<li><p><code>allocproc()</code>：在进程表中查找一个处于 <code>UNUSED</code> 状态的进程 …… 它的一个遍历 proc 数组的代码片段对我们很有用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过上述分析，我们可以很容易的在 <code>kernel/proc.c</code> 中定义一个函数 <code>nproc()</code> 来统计不是 <code>UNUSED</code> 状态的进程数</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my change</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state != UNUSED) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>好了，现在我们可以给出 <code>sys_sysinfo()</code> 的完整实现了</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my change</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  </span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;addr);</span><br><span class="line">  <span class="keyword">if</span> (addr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  info.freemem = freemem();</span><br><span class="line">  info.nproc = nproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (copyout(p-&gt;pagetable, addr, (<span class="type">char</span>*)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>哦，很重要的一点是：如果我们想要在 <code>kernel/sysproc.c</code> 中使用刚刚定义的 <code>freemem()</code> 和 <code>nproc()</code>，我们需要在 <code>kernel/sysproc.c</code> 中声明一下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">freemem</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">nproc</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后，在 Makefile中将 <code>&amp;U/_sysinfotest</code> 添加到 <code>UPROGS</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_xargs\</span><br><span class="line">	$U/_trace\</span><br><span class="line">	$U/_sysinfotest</span><br></pre></td></tr></table></figure>

<ul>
<li><p>好的，<strong>make qemu &amp;&amp; sysinfotest</strong> 测试一下</p>
<blockquote>
<p>最好在 <code>make qemu</code> 之前先 <code>make clean</code> 一下，别问我为什么要强调）</p>
</blockquote>
</li>
</ul>
<img src="/2024/05/13/6-S081-Lab2/image-20240516154204624.png" class="" title="image-20240516154204624">

<ul>
<li>测试通过！</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/332243456">MIT 6.S081 2020 Lab2 system calls讲解 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48283247/article/details/121217307">操作系统实验Lab 2:system calls(MIT 6.S081 FALL 2020)_mit操作系统实验2020-CSDN博客</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">算法设计与分析复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-11 16:26:03" itemprop="dateCreated datePublished" datetime="2024-05-11T16:26:03+08:00">2024-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-31 21:28:01" itemprop="dateModified" datetime="2024-05-31T21:28:01+08:00">2024-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h1><ul>
<li><p>什么是算法：算法是由若干条指令组成的有穷序列</p>
</li>
<li><p>算法具有哪些特征：</p>
<ul>
<li>输入（0 个或多个）</li>
<li>输出（一个或多个）</li>
<li>确定性（组成算法的每条指令必须有确定含义，无歧义）</li>
<li>有限性（算法中的指令的条数有限，每条指令的执行次数有限，执行每条指令的时间有限）</li>
<li>可行性（有待实现的运算都是基本运算）</li>
</ul>
</li>
<li><p>什么是算法的复杂性：算法的复杂性指运行所需要的计算机资源量</p>
</li>
<li><p>如何衡量算法的复杂性：用算法运行所需要的计算机资源的量的多少来衡量算法的复杂性</p>
</li>
<li><p>算法不能直接在计算机上执行，程序能直接在计算机上执行</p>
</li>
<li><p>算法的复杂性是指算法在计算机上运行时所消耗的计算机资源的量。最重要的计算机资源是 <strong>时间资源</strong> 和 <strong>空间资源</strong></p>
</li>
<li><p>算法与程序的主要区别在于算法具有 <strong>有限性</strong></p>
</li>
</ul>
<h1 id="证明题"><a href="#证明题" class="headerlink" title="证明题"></a>证明题</h1><ul>
<li>存在常数 C 和自然数 N0，使得 N &gt;&#x3D; N0 时有 f(N) &lt;&#x3D; Cg(N)，记为 f(N) &#x3D; O(g(N))。证明：O(f(N)) + O(g(N)) &#x3D; O(f(N) + g(N))。</li>
</ul>
<style>.yjagntvngcyv{zoom: 33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/b3dfe4f80c758cf17fab5ba32a659984.jpg" class="yjagntvngcyv" alt="img">

<ul>
<li>存在常数 C 和自然数 N0，使得 N &gt;&#x3D; N0 时有 f(N) &lt;&#x3D; Cg(N)，记为 f(N) &#x3D; O(g(N))。证明：O(f(N)) * O(g(N)) &#x3D; O(f(N) * g(N))。</li>
</ul>
<style>.svlgdhzkjghm{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/6f2a742cf432389d4996650905ce7402.jpg" class="svlgdhzkjghm" alt="img">

<ul>
<li>存在常数 C 和自然数 N0，使得 N &gt;&#x3D; N0 时有 f(N) &lt;&#x3D; Cg(N)，记为 f(N) &#x3D; O(g(N))。证明：O(f(N)) + O(g(N)) &#x3D; O(max{f(N), g(N)})。</li>
</ul>
<style>.oifjhmkpowou{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/c7f45596273ee692c80e9ed5b0ccfdfa.jpg" class="oifjhmkpowou" alt="img">

<h1 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h1><ul>
<li>T(n) &#x3D; 2T(n - 1) + O(1)，T(1) &#x3D; 1，则 T(n) &#x3D; __</li>
</ul>
<style>.dwvfxlfugvuq{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/cf9a9fc703f5c7dc1a74bc37db46983a.jpg" class="dwvfxlfugvuq" alt="img">

<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><ul>
<li><p>简述分治法的特征：</p>
<ul>
<li>将规模大的问题分成规模较小的子问题</li>
<li>问题规模足够小时容易解决</li>
<li>子问题相互独立</li>
<li>子问题的解决方法与原问题相同</li>
<li>递归解决子问题</li>
<li>子问题的解能够合并成原问题的解</li>
</ul>
</li>
<li><p>简述分治法的基本思想：</p>
<ul>
<li>将规模为 n 的问题分解为 k 个规模较小的子问题，子问题相互独立且与原问题相同</li>
<li>递归的求解这些子问题</li>
<li>然后将子问题的解合并得到原问题的解</li>
</ul>
</li>
<li><p>Strassen 矩阵乘法利用了分治策略</p>
</li>
<li><p>大整数乘法用到了分治策略</p>
</li>
<li><p>从分治法的一般设计模式可以看出，用它设计的程序一般是递归算法</p>
</li>
</ul>
<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><ul>
<li><p>二分搜索算法在最坏情况下的时间复杂度是 <strong>O(logn)</strong></p>
</li>
<li><p>用二分搜索算法在一个有序序列中查找某指定元素是否存在，当前查找范围是 a[low:high]，分治策略中的分解操作是 <strong>(low+high)&#x2F;2</strong></p>
</li>
<li><p>对一个有序序列，以比较为基础的搜索算法的最坏时间复杂度为 <strong>O(logn)</strong></p>
</li>
<li><p>代码实现</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; a[mid]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li><p>简述快速排序算法的思想：</p>
<ul>
<li>选取待排序列的第一个元素为基准元素</li>
<li>通过一趟扫描将待排序列的元素分割成独立的两个序列，第一个序列中元素不大于基准元素，第二个序列中元素不小于基准元素</li>
<li>对两个序列分别递归排序，最终整个序列变成有序序列</li>
</ul>
</li>
<li><p>快速排序算法中，选取基准元素的方法是：随机选取序列中的一个元素作为基准元素（选择题）</p>
</li>
<li><p>快速排序代码实现</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> base = a[left];</span><br><span class="line">    <span class="type">int</span> left = start;</span><br><span class="line">    <span class="type">int</span> right = end;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= base) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = a[right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt; base) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[right] = a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = base;</span><br><span class="line">    </span><br><span class="line">    quick_sort(a, start, left - <span class="number">1</span>);</span><br><span class="line">    quick_sort(a, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>采用快速排序升序 (5, 3, 8, 2, 1, 9, 23, 12, 16)，要求：写出首次分解得到两个子问题的过程、递归结果、子问题的解合并成原问题的解的过程</p>
<ul>
<li>选取基准元素 5 并保存，划分过程如下：<ul>
<li>设置指针 i 指向元素 5，指针 j 指向元素 16</li>
<li>j 向左寻找小于 5 的元素，j 找到 1，将 j 指向的 1 覆盖到 i 指向的 5</li>
<li>i 向右寻找大于等于 5 的元素，i 找到 8，将 i 指向的 8 覆盖到 j 指向的 1</li>
<li>j 继续向左寻找小于 5 的元素，j 找到 2，将 j 指向的 2 覆盖到 i 指向的 8</li>
<li>i 继续向右寻找大于等于 5 的元素，i &#x3D;&#x3D; j 指向了 2</li>
<li>将基准元素覆盖到 i、j 指向的 2</li>
<li>此时两个子问题为 {1, 3, 2}、{8, 9, 23, 12, 16}</li>
</ul>
</li>
<li>递归的结果为 {1, 2, 3}、{8, 9, 12, 16, 23}</li>
<li>此时整个序列有序，为 {1, 2, 3, 5, 8, 9, 12, 16, 23}</li>
</ul>
</li>
<li><p>请使用快速排序升序排序 (10, 18, 10, 9, 15, 6, 3, 2, 24, 4)，给出第一趟划分结果及后续操作</p>
</li>
</ul>
<style>.fxyiwulhudhe{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/d21d4614799775b3e5fb3c034fd17f01.jpg" class="fxyiwulhudhe" alt="img">

<ul>
<li>请使用快速排序升序排序 (5, 1, 4, 3, 9, 6, 3, 2, 8, 10, 7)，给出第一趟划分结果及后续操作</li>
</ul>
<style>.uffocbybzzmn{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/a9a9e90d2acc75c7f9936b39f414f264.jpg" class="uffocbybzzmn" alt="img">

<ul>
<li>快速排序算法的性能取决于划分的对称性</li>
</ul>
<h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><ul>
<li>使用分治法设计合并排序算法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(a, left, mid);</span><br><span class="line">        merge_sort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(a, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>采用合并排序的思想将给定序列 T[1:9] &#x3D; {5, 3, 8, 2, 1, 9, 23, 12, 6} 升序，要求：写出首次分解得到两个子问题的过程、递归结果、子问题的解合并成原问题的解的过程</p>
<ul>
<li><p>(1 + 9) &#x2F; 2 &#x3D; 5</p>
</li>
<li><p>两个子问题是：T[1:5]、T[6:9]</p>
</li>
<li><p>递归的结果：T[1:5] &#x3D; {1, 2, 3, 5, 8}，T[6:9] &#x3D; {6, 9, 12, 23}</p>
</li>
<li><p>两个子问题合并得到原问题的解，合并过程如下：</p>
<ul>
<li>将 1, 2, 3, 5 放入辅助数组</li>
<li>将 6 放入辅助数组</li>
<li>将 8 放入辅助数组</li>
<li>将 9, 12, 23 放入辅助数组，得到一个有序序列</li>
</ul>
</li>
<li><p>将辅助数组中的元素复制到数组 T，得到 T[1:9] &#x3D; {1, 2, 3, 5, 6, 8, 9, 12, 23}</p>
</li>
</ul>
</li>
<li><p>分析合并排序的时间复杂度</p>
<ul>
<li><style>.rcdmtvdgvknb{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/e924469f3069a2b56b889c2ba96c5b22.jpg" class="rcdmtvdgvknb" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="棋盘覆盖问题"><a href="#棋盘覆盖问题" class="headerlink" title="棋盘覆盖问题"></a>棋盘覆盖问题</h2><ul>
<li>对于如下 2^3^ * 2^3^ 的特殊棋盘，共需要多少 L 型骨牌；并在棋盘上填写 L 型骨牌的覆盖情况。</li>
</ul>
<style>.yzkjtciklyiw{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/dce9ae0daba371a20b1329701a453dfb.jpg" class="yzkjtciklyiw" alt="img">

<style>.ovveyywosvtz{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/00309eebce67d0b8269c011e53dc30f5.jpg" class="ovveyywosvtz" alt="img">

<h2 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h2><ul>
<li>有 n &#x3D; 2^k^ 个运动员要进行循环赛，设计一个赛程表：1. 每个选手必须和其他 n - 1 个选手各比赛一次；2. 每个选手一天至多比赛一次；3. 循环赛要在最短时间内完成；<ul>
<li>（1）如果 n &#x3D; 2^k^，循环赛最少需要进行几天（<strong>n - 1 天</strong>）</li>
<li>（2）当 n &#x3D; 2^3^ &#x3D; 8 时，画出循环赛日程表</li>
</ul>
</li>
</ul>
<style>.rdrmnwnhhbei{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/ecacc48cc2780a67de1bf5a074b4f92b.jpg" class="rdrmnwnhhbei" alt="img">

<h1 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h1><ul>
<li><p>简述动态规划求解优化问题的步骤：</p>
<ul>
<li>最优子结构性质分析</li>
<li>递归定义最优值</li>
<li>以自底向上的方式计算出最优值</li>
<li>根据计算最优值时得到的信息，构造最优解</li>
</ul>
</li>
<li><p>动态规划算法的主要步骤：</p>
<ul>
<li><p>问题具有最优子结构性质</p>
</li>
<li><p>构造最优值的递归关系表达式</p>
</li>
<li><p>最优值的算法描述</p>
</li>
<li><p>构造最优值</p>
</li>
</ul>
</li>
<li><p>动态规划算法的基本要素：最优子结构性质、重叠子问题、自底向上的求解方法</p>
</li>
<li><p>动态规划求解最大字段和问题，其时间复杂性为：<strong>O(n)</strong></p>
</li>
<li><p>动态规划法为什么需要最优子结构性质：</p>
<ul>
<li>最优子结构性质指大问题的最优解包含小问题的最优解，动态规划法自底向上求解子问题，可以利用子问题的最优解构造大问题的最优解，因此需要最优子结构性质</li>
</ul>
</li>
<li><p>分治法和动态规划法的相同点：将原问题分解为几个子问题，从子问题的解中得到原问题的解</p>
<ul>
<li>不同点：动态规划分解得到的问题往往不是相互独立的</li>
</ul>
</li>
</ul>
<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><ul>
<li><p>描述 0-1 背包问题：已知一个背包容量为 c，有 n 件物品，物品 i 的重量为 Wi，价值为 Vi，应如何选择装入背包中的物品，使得总价值最大</p>
</li>
<li><p>递推关系：m(n，C) &#x3D; </p>
<ul>
<li><p>0，if n &#x3D; 0 or C &#x3D; 0</p>
</li>
<li><p>max{m(n - 1，C)，m(n - 1，C - wn) + vn}，wn &lt;&#x3D; C</p>
</li>
<li><p>m(n - 1，C)，wn &gt; C</p>
</li>
</ul>
</li>
<li><p>0-1 背包问题代码实现</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">knapSack</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> n, <span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> dp[n + <span class="number">1</span>][c + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= c; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n + <span class="number">1</span>][c + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用贪心算法解决背包问题时所用的贪心策略是：单位重量的价值大的物品优先装入背包</p>
</li>
<li><p>0-1 背包问题用动态规划算法的时间复杂度为 <strong>O(nc)</strong></p>
</li>
<li><p>有 0-1 背包问题如下：n &#x3D; 4，c &#x3D; 13，P &#x3D; (18, 15, 8, 12)，W &#x3D; (10, 2, 3, 4)。试用动态规划求出问题的最优解和最优值</p>
</li>
</ul>
<style>.icsrupunlcfm{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/c691e25d3af8ae45bab678a19a08e371.jpg" class="icsrupunlcfm" alt="img">

<style>.gmtqcxngrspw{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/84b6f519dc4176d074e239a883e13cbb.jpg" class="gmtqcxngrspw" alt="img">

<h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><ul>
<li>递推关系：C[i，j] &#x3D; <ul>
<li>0，if i &#x3D; 0 or j &#x3D; 0</li>
<li>max{C[i - 1，j]，C[i, j - 1]}，xi !&#x3D; yi</li>
<li>C[i - 1, j - 1] + 1，xi &#x3D; yi</li>
</ul>
</li>
<li>最长公共子序列问题代码实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">char</span>[] x, <span class="type">char</span>[] y, <span class="type">int</span>[][] c, <span class="type">int</span>[][] b)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) c[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) c[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[i] == y[j]) &#123;</span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                b[i][j] = <span class="number">1</span>; <span class="comment">// 1:LU</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c[i][j] = max(c[i - <span class="number">1</span>][j], c[i][j - <span class="number">1</span>]);</span><br><span class="line">                b[i][j] = c[i][j] == c[i - <span class="number">1</span>][j] ? <span class="number">2</span> : <span class="number">3</span>; <span class="comment">// 2:U 3:L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>给定两个序列的长度分别为 m、n，求这两个序列的最长公共子序列耗时 <strong>O(mn)</strong></li>
</ul>
<style>.dqxypwvdjxun{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/d07160810c0c4bce9769e195b7f2863f.jpg" class="dqxypwvdjxun" alt="img">

<h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h2><ul>
<li><p>用 A[1:n] 表示 A1…An 连乘，给定 A[1:10]，用动态规划算法求解时，用来存储各子问题最优值的二维数组共有 <strong>100</strong> 个存储单元</p>
</li>
<li><p>用 A[1:n] 表示 A1…An 连乘，用动态规划求解 A[1:n] 时，计算各子问题最优值的复杂度是 <strong>O(n^3^)</strong></p>
</li>
<li><p>M1(5 * 10)，M2(10 * 4)，M3(4 * 6)。矩阵连乘 M1 * M2 * M3 需要最少乘法次数为 <strong>320</strong>（5 * 4 * 10 + 5 * 6 * 4 &#x3D; 320）</p>
</li>
</ul>
<h1 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h1><ul>
<li><p>贪心法的两个基本要素：贪心选择性质、最优子结构性质</p>
</li>
<li><p>贪心策略设计算法的关键是：选好贪心策略</p>
</li>
<li><p>接近活动安排问题，最好用贪心算法</p>
</li>
<li><p>动态规划法和贪心法的相同点：最优子结构性质</p>
<ul>
<li>不同的：动态规划法的每一步依赖于子问题的解，贪心法则不依赖；动态规划自底向上求解，贪心法自顶向下求解</li>
</ul>
</li>
</ul>
<h2 id="Difkstra-算法"><a href="#Difkstra-算法" class="headerlink" title="Difkstra 算法"></a>Difkstra 算法</h2><ul>
<li>简述求单源最短路径问题的 Dijkstra 算法思想：<ul>
<li>初始时令 S &#x3D; {源点}，Dist 数组记录最短特殊路径长度，重复如下操作</li>
<li>选择一条特殊最短路径，将其连接的 V-S 中的点加入 S，更新特殊最短路径</li>
<li>直到 S &#x3D; V 为止，根据前驱数组的记录，构建最优解</li>
</ul>
</li>
<li>用贪心算法求 s 到 t 的最短路</li>
</ul>
<style>.pmkeohnpklnv{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/9ccc62b3bfdd142687b23e8ba91ead3e.jpg" class="pmkeohnpklnv" alt="img">

<style>.ygcklyowjfcg{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/786e2a92c1695ead1a6b852563f45346.jpg" class="ygcklyowjfcg" alt="img">

<h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><ul>
<li>Prim 算法构造最小生成树的基本思想：<ul>
<li>初始时令 U &#x3D; (u0)，u0 ∈ V，TE &#x3D; {}</li>
<li>选取 i ∈ U，j ∈ V - U，边 (i, j) 是连接 U 和 V - U 所有边中最短的</li>
<li>然后，将 j 加入集合 U，将边 (i, j) 加入到集合 TE 中</li>
<li>继续上面的贪心选择直到 U &#x3D; V 为止</li>
</ul>
</li>
<li>Prim 算法生成最小生成树的过程中，贪心策略是：<ul>
<li>选取 i ∈ U，j ∈ V - U，边 (i, j) 是连接 U 和 V - U 所有边中最短的</li>
<li>然后，将 j 加入集合 U，将边 (i, j) 加入到最小生成树中</li>
</ul>
</li>
<li>给定 n 个顶点的无向连通图，Prim 算法的时间复杂度为 <strong>O(n^2^)</strong></li>
<li>使用 Prim 算法求最小生成树</li>
</ul>
<style>.ttpsoqbwiuhy{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/700466b5efe108a2774d8594a7531743.jpg" class="ttpsoqbwiuhy" alt="img">

<h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><ul>
<li><p>Kruskal 算法的时间复杂度为 <strong>eloge</strong>，e 为无向连通图的边数</p>
</li>
<li><p>对稀疏图，Kruskal 算法比 Prim 算法有效</p>
</li>
<li><p>Kruskal 算法基本思想：</p>
<ul>
<li>按照图中边权由大到小的次序依次考虑每条边是否加入最小生成树中</li>
<li>当考虑到某条边时，如果该边与已经加入到最小生成树中的边不形成回路，则将该边加入进去</li>
</ul>
</li>
</ul>
<style>.imuvuocftkyy{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/28c4128ff54b201f901b17477f2fd552.jpg" class="imuvuocftkyy" alt="img">

<ul>
<li>使用 Kruskal 算法求最小生成树</li>
</ul>
<style>.aoxahcwizwqr{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/0e0a864b988b7fb477bebfb9fb1b228b.jpg" class="aoxahcwizwqr" alt="img">

<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><ul>
<li>哈夫曼编码的贪心算法的时间复杂度是：<strong>O(nlogn)</strong></li>
<li>简述哈夫曼编码算法的思想：<ul>
<li>将 n 个字符看做 n 棵孤立的树，组成一个集合</li>
<li>从集合中取出两棵出现频率最低的树，让其作为左右子树构成一棵新树，新树的频率为左右子树频率之和，将那个新树插入到集合中</li>
<li>重复操作，直到只剩下一颗树为止</li>
</ul>
</li>
<li>已知元素出现频率 (a, b, c, d, e, f, g) &#x3D; (0.15, 0.25, 0.12, 0.05, 0.03, 0.1, 0.3)，请建立哈夫曼编码对应的二叉树，并写出相应元素的编码。</li>
</ul>
<style>.ddmupvufpfsl{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/8f430532951518f222caf2d7f7dc2ebd.jpg" class="ddmupvufpfsl" alt="img">

<h2 id="流水作业调度问题-Johnson-算法"><a href="#流水作业调度问题-Johnson-算法" class="headerlink" title="流水作业调度问题 Johnson 算法"></a>流水作业调度问题 Johnson 算法</h2><ul>
<li><p>流水线作业调度问题的 Johnson 算法的思想：</p>
<ul>
<li>令 N1 &#x3D; {i|ai &lt; bi}，N2 &#x3D; {i|ai &gt;&#x3D; bi}</li>
<li>将 N1 中作业按 ai 递增排序，将 N2 中作业按 bi 递减排序</li>
<li>N1 中作业接 N2 中作业得到最优调度</li>
</ul>
</li>
<li><p>M1 上处理 (a1, a2, a3, a4, a5, a6, a7) &#x3D; (2,5, 7, 10, 5, 3, 8)，M2 上处理 (b1, b2, b3, b4, b5, b6, b7) &#x3D; (3, 8, 2, 11, 5, 4, 4)，按照流水线作业调度问题的 Johnson 算法步骤，给出该问题的最优调度方案。</p>
</li>
</ul>
<style>.qfxfyltfrkkk{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/6745c41e9c2a473a9d4494af314b9cb9.jpg" class="qfxfyltfrkkk" alt="img">

<style>.xjhxlsgjptyp{zoom:33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/ca27278ce499a04ae4b0a13ab8f0ecb6.jpg" class="xjhxlsgjptyp" alt="img">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>关于渐进符号</li>
</ul>
<style>.nkyyvicqasih{zoom: 50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512211853820.png" class="nkyyvicqasih" alt="image-20240512211853820"><style>.lvxkzbupumgm{zoom: 50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512211954178.png" class="lvxkzbupumgm" alt="image-20240512211954178">

<style>.wfxrtvsrdhvd{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212119179.png" class="wfxrtvsrdhvd" alt="image-20240512212119179"><style>.ymybkagyfouw{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212033993.png" class="ymybkagyfouw" alt="image-20240512212033993">

<style>.qvgsnvretpqs{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212200992.png" class="qvgsnvretpqs" alt="image-20240512212200992">

<ul>
<li>关于常用公式</li>
</ul>
<style>.zvsuddcrfomu{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212244626.png" class="zvsuddcrfomu" alt="image-20240512212244626">

<style>.ksrhtqalmofu{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512194033369.png" class="ksrhtqalmofu" alt="image-20240512194033369">

<style>.kxjhqkxgrdqr{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212840553.png" class="kxjhqkxgrdqr" alt="image-20240512212840553">

<ul>
<li>关于一些定理</li>
</ul>
<style>.dnrblodhdvdv{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212449328.png" class="dnrblodhdvdv" alt="image-20240512212449328"><style>.xmmrtctgipof{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212506627.png" class="xmmrtctgipof" alt="image-20240512212506627">

<style>.xexhonrqvyux{}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240525173449277.png" class="xexhonrqvyux" alt="image-20240525173449277">

<style>.sutdpzhpfwxv{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212600843.png" class="sutdpzhpfwxv" alt="image-20240512212600843"><style>.bhxbglxahgrr{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212625852.png" class="bhxbglxahgrr" alt="image-20240512212625852">



<ul>
<li>关于一些基本性质</li>
</ul>
<style>.unswctkjxfha{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512212821060.png" class="unswctkjxfha" alt="image-20240512212821060">	<style>.fkquoqdsvqws{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213147783.png" class="fkquoqdsvqws" alt="image-20240512213147783">



<style>.cudszntdnmfe{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213239005.png" class="cudszntdnmfe" alt="image-20240512213239005">

<ul>
<li>关于递归的一些方法</li>
</ul>
<style>.plgxhgszgwom{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213806651.png" class="plgxhgszgwom" alt="image-20240512213806651">

<style>.ughpvlplqyjq{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213620162.png" class="ughpvlplqyjq" alt="image-20240512213620162"><style>.totkelihddsx{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213634721.png" class="totkelihddsx" alt="image-20240512213634721">

<style>.vyuoubeqxjbq{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512213838992.png" class="vyuoubeqxjbq" alt="image-20240512213838992"><style>.mnkpbwhvfptr{zoom: 33%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240512214132757.png" class="mnkpbwhvfptr" alt="image-20240512214132757">

<ul>
<li><p>补充</p>
<style>.khvgykvhnicb{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240526203140637.png" class="khvgykvhnicb" alt="image-20240526203140637"></li>
</ul>
<style>.njpmcmnntvit{zoom:50%;}</style><img src="/2024/05/11/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/image-20240526203158738.png" class="njpmcmnntvit" alt="image-20240526203158738">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/05/08/xv6-book-chapter-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/08/xv6-book-chapter-1/" class="post-title-link" itemprop="url">xv6 book Chapter 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-08 22:31:39" itemprop="dateCreated datePublished" datetime="2024-05-08T22:31:39+08:00">2024-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-17 21:58:27" itemprop="dateModified" datetime="2024-05-17T21:58:27+08:00">2024-05-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6: a simple, Unix-like teaching operating system (mit.edu)</a></p>
</blockquote>
<h1 id="Operating-system-interfaces-操作系统接口"><a href="#Operating-system-interfaces-操作系统接口" class="headerlink" title="Operating system interfaces 操作系统接口"></a>Operating system interfaces 操作系统接口</h1><ul>
<li><p>操作系统的工作是将计算机的资源在多个程序间共享，并且给程序提供一系列比硬件本身支持的更有用的服务。</p>
<ul>
<li>操作系统管理并抽象底层硬件，因此，举例来说，一个文字处理程序不需要去关心自己使用的是何种硬盘。</li>
<li>操作系统还对硬件进行多路复用，使多个程序可以同时运行的 (或者看起来是同时运行)。</li>
<li>最后，操作系统为程序提供了一种可控的交互方式，使得多个程序可以共享数据，共同工作。</li>
</ul>
</li>
<li><p>操作系统通过接口向用户程序提供服务。设计一个好的接口实际上是很困难的。</p>
<ul>
<li>一方面，我们希望接口简单和精准，这样它就容易正确地实现；</li>
<li>另一方面，我们可能又想为应用提供许多更加复杂的功能。解决这种矛盾的诀窍是让接口的设计依赖于一些 <em>机制</em> (*mechanism)*，并通过这些机制的组合来提供通用性。</li>
</ul>
</li>
<li><p>本书以一个操作系统为例，来说明操作系统的概念。</p>
<ul>
<li>这个操作系统就是xv6，它提供了在 Ken Thompson 和 Dennis Ritchie 的 Unix操作系统 [14] 中引入的基本接口，同时也模仿了Unix的内部设计。</li>
<li>Unix提供了一个机制组合得非常良好的窄接口，具有惊人的通用性。这样的接口设计非常成功，这也使得BSD，Linux，Mac OS X，Solaris 这样的现代操作系统，甚至 Windows 都有类似 Unix 的接口。</li>
<li>理解xv6是理解这些操作系统的一个良好起点。</li>
</ul>
</li>
<li><p>如图1.1所示，xv6 使用了传统形式的 <strong>内核</strong> —— 一个向其他运行中的程序提供服务的特殊程序。</p>
<ul>
<li>每一个正在运行的程序（称为<strong>进程</strong>），都拥有自己的包含指令、数据、栈的内存空间。</li>
<li>指令实现程序的运算，数据是用于运算过程的变量，栈则管理程序的过程调用。</li>
<li>一台计算机通常有许多进程，但只有一个内核。</li>
</ul>
</li>
</ul>
<img src="/2024/05/08/xv6-book-chapter-1/Figure-1.1-17159541562291.png" class="" title="Figure-1.1">

<ul>
<li><p>当一个进程需要调用一个内核服务时，它就会调用 <strong>系统调用</strong>，这是操作系统接口中的一个调用。</p>
<ul>
<li>系统调用会进入内核，让内核执行服务然后返回。所以进程会在用户空间和内核空间之间交替运行。</li>
</ul>
</li>
<li><p>内核使用 CPU <a href="#ftn1">[1]</a> 提供的硬件保护机制来确保在用户空间中执行的每个进程只能访问自己的内存。</p>
<ul>
<li>内核运行时拥有硬件特权，可以访问这些受到保护的资源，而用户程序运行时则没有这些特权。</li>
<li>当用户程序调用系统调用时，硬件提高特权级别并开始执行内核中预定义的函数。</li>
</ul>
</li>
<li><p>内核提供的系统调用集合就是用户程序可见的接口。</p>
<ul>
<li>xv6 内核提供了传统 Unix 内核所提供的服务和系统调用的一个子集。</li>
<li>图1.2 列出了 xv6 的所有系统调用。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int fork()</strong></td>
<td>创建一个进程，返回子进程的PID。</td>
</tr>
<tr>
<td><strong>int exit(int status)</strong></td>
<td>终止当前进程，并将status传递给wait()。不会返回。</td>
</tr>
<tr>
<td><strong>int wait(int *status)</strong></td>
<td>等待子进程结束，并将status接收到参数*status中，返回其PID。</td>
</tr>
<tr>
<td><strong>int kill(int pid)</strong></td>
<td>终止给定PID的进程，成功返回0，失败返回-1。</td>
</tr>
<tr>
<td><strong>int getpid()</strong></td>
<td>返回当前进程的PID。</td>
</tr>
<tr>
<td><strong>int sleep(int n)</strong></td>
<td>睡眠n个时钟周期。</td>
</tr>
<tr>
<td><strong>int exec(char *file, char *argv[])</strong></td>
<td>通过给定参数加载并执行一个文件；只在错误时返回。</td>
</tr>
<tr>
<td><strong>char *sbrk(int n)</strong></td>
<td>使进程内存增加n字节，返回新内存的起始地址。</td>
</tr>
<tr>
<td><strong>int open(char *file, int flags)</strong></td>
<td>打开一个文件，flags表示读或写，返回fd（文件描述符）。</td>
</tr>
<tr>
<td><strong>int write(int fd, char *buf, int n)</strong></td>
<td>将buf中n字节写入到文件描述符中；返回n。</td>
</tr>
<tr>
<td><strong>int read(int fd, char *buf, int n)</strong></td>
<td>从文件描述符中读取n字节到buf；返回读取字节数，文件结束返回0。</td>
</tr>
<tr>
<td><strong>int close(int fd)</strong></td>
<td>释放文件描述符fd。</td>
</tr>
<tr>
<td><strong>int dup(int fd)</strong></td>
<td>返回一个新文件描述符，其引用与fd相同的文件。</td>
</tr>
<tr>
<td><strong>int pipe(int p[])</strong></td>
<td>创建管道，将读&#x2F;写文件描述符放置在p[0]和p[1]。</td>
</tr>
<tr>
<td><strong>int chdir(char *dir)</strong></td>
<td>改变当前目录。</td>
</tr>
<tr>
<td><strong>int mkdir(char *dir)</strong></td>
<td>创建新目录。</td>
</tr>
<tr>
<td><strong>int mknod(char *file, int, int)</strong></td>
<td>创建新设备文件。</td>
</tr>
<tr>
<td><strong>int fstat(int fd, struct stat *st)</strong></td>
<td>将打开的文件的信息放置在*st中。</td>
</tr>
<tr>
<td><strong>int stat(char *file, struct stat *st)</strong></td>
<td>将命名文件信息放置在*st中。</td>
</tr>
<tr>
<td><strong>int link(char *file1, char * file2)</strong></td>
<td>为文件file1创建一个新的名称(file2)。</td>
</tr>
<tr>
<td><strong>int unlink(char *file)</strong></td>
<td>移除一个文件。</td>
</tr>
</tbody></table>
<p>​										图1.2  xv6 系统调用. 如果没有特别说明, 这些调用成功时返回 0，失败时返回 -1</p>
<ul>
<li><p>本章剩下的部分概述了 xv6 的服务的概貌 —— 进程、内存、文件描述符、管道和文件系统，并通过代码片段对其进行了说明，然后讨论了 <strong>shell</strong>（Unix 的命令行用户接口）中是如何使用它们的。</p>
<ul>
<li>这些系统调用在shell中的应用说明了系统调用的设计如何精巧。</li>
</ul>
</li>
<li><p>shell 是一个普通的程序，它从用户读取命令并执行它们。</p>
<ul>
<li>shell是一个用户程序，而不是内核的一部分，这一事实说明了系统调用接口的强大：shell没有什么特别之处。</li>
<li>这也意味着 shell 是很容易被替换的；因此，事实上现代 Unix 系统中有各种各样的 shell，每个都有自己的用户界面和脚本特性。</li>
<li>xv6 shell 是 Unix Bourne shell 的一个简单实现。它的实现可以在（<code>user/sh.c:1</code>）找到。</li>
</ul>
</li>
</ul>
<h2 id="Processes-and-memory-进程和内存"><a href="#Processes-and-memory-进程和内存" class="headerlink" title="Processes and memory 进程和内存"></a>Processes and memory 进程和内存</h2><ul>
<li><p>一个 xv6 进程由用户空间内存（指令、数据和堆栈）和内核私有的进程状态组成。</p>
<ul>
<li>xv6 对进程提供 <strong>分时</strong> 特性：它透明地切换当前 CPU 正在执行的进程。当一个进程暂时不使用 CPU 时，xv6 会保存它的 CPU 寄存器，在下次运行该进程时恢复它们。</li>
<li>内核为每个进程关联一个 <strong>PID</strong> (进程标识符)。</li>
</ul>
</li>
<li><p>可以使用 <strong>fork</strong> 系统调用创建一个新的进程。</p>
<ul>
<li><strong>fork</strong> 创建的新进程被称为 <strong>子进程</strong>，其内存内容与调用的进程完全相同，原进程被称为 <strong>父进程</strong>。</li>
<li>在父进程和子进程中，fork 都会返回。在父进程中，fork 返回子进程的 PID；在子进程中，fork返回 0。</li>
<li>例如，考虑以下用 C 编程语言编写的程序片段 [6]。</li>
</ul>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">	pid = wait((*<span class="type">int</span>* *)<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>exit</strong> 系统调用会使得调用它的进程退出，并释放资源，例如内存和打开的文件。</p>
<ul>
<li><strong>exit</strong> 需要一个整数状态参数，通常 0 表示成功，1 表示失败。</li>
</ul>
</li>
<li><p><strong>wait</strong> 系统调用返回当前进程的一个已退出（或被杀死）的子进程的 PID，并将该子进程的退出状态码复制到一个地址，该地址由 wait 参数提供；</p>
<ul>
<li>如果调用者的子进程都没有退出，则 <strong>wait</strong>等待一个子进程退出。如果调用者没有子进程，wait立即返回-1。</li>
<li>如果父进程不关心子进程的退出状态，可以传递一个 0 地址给 wait。</li>
</ul>
</li>
<li><p>在上面的例子中，输出为：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent: child=1234</span><br><span class="line">child: exiting</span><br></pre></td></tr></table></figure>

<ul>
<li>可能会以任何一种顺序输出，这取决于是父进程还是子进程先执行它的 <strong>printf</strong> 调用。在子程序退出后，父进程的 <strong>wait</strong> 返回，父进程打印：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child 1234 is done</span><br></pre></td></tr></table></figure>

<ul>
<li><p>虽然子进程最初与父进程拥有相同的内存内容，但父进程和子进程是在不同的内存和不同的寄存器中执行的：改变其中一个进程中的变量不会影响另一个进程。</p>
<ul>
<li>例如，当 <strong>wait</strong> 的返回值存储到父进程的 <strong>pid</strong> 变量中时，并不会改变子进程中的变量 <strong>pid</strong>。子进程中的 <strong>pid</strong> 值仍然为零。</li>
</ul>
</li>
<li><p><strong>exec</strong> 系统调用使用新内存映像来替换进程的内存， 新内存映像从文件系统中的文件中进行读取。</p>
<ul>
<li>这个文件必须有特定的格式，它指定了文件中哪部分存放指令，哪部分是数据，在哪条指令开始，等等。</li>
<li>xv6 使用 ELF 格式，第 3 章将详细讨论。</li>
<li>当 <strong>exec</strong> 成功时，它并不返回到调用程序；相反，从文件中加载的指令在 ELF 头声明的入口点开始执行。</li>
<li><strong>exec</strong> 需要两个参数：包含可执行文件的文件名和一个字符串参数数组。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码会执行 &#x2F;bin&#x2F;echo 程序，并将 argv 数组作为参数。大多数程序都会忽略参数数组的第一个元素，也就是程序名称。</p>
</li>
<li><p>xv6 shell 使用上述调用来在用户空间运行程序。</p>
<ul>
<li>shell 的主结构很简单，参见 <strong>main</strong> (user&#x2F;sh.c:145)。主循环用 <strong>getcmd</strong> 读取用户的一行输入，然后调用 <strong>fork</strong>，创建 shell 副本。</li>
<li>父进程调用 wait，而子进程则运行命令。</li>
<li>例如，如果用户向 shell输入了 <strong>echo hello</strong>，那么就会调用 <strong>runcmd</strong>，参数为 <strong>echo hello</strong>。<strong>runcmd</strong> (user&#x2F;sh.c:58) 运行实际的命令。</li>
<li>对于 <strong>echo hello</strong>，它会调用 <strong>exec</strong> (user&#x2F;sh.c:78)。如果 <strong>exec</strong> 成功，那么子进程将执行 echo 程序的指令，而不是 <strong>runcmd</strong> 的。</li>
<li>在某些时候，<strong>echo</strong> 会调用 <strong>exit</strong>，这将使父程序从 main (user&#x2F;sh.c:145)中的 <strong>wait</strong> 返回。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;sh.c:145</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that three file descriptors are open.</span></span><br><span class="line">  <span class="keyword">while</span>((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">      close(fd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read and run input commands. </span></span><br><span class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>你可能会奇怪为什么 <strong>fork</strong> 和 <strong>exec</strong> 没有结合在一次调用中，我们后面会看到 shell 在实现 I&#x2F;O 重定向时利用了这种分离的特性。</p>
<ul>
<li>为了避免创建相同进程并立即替换它（使用exec）所带来的浪费，内核通过使用虚拟内存技术（如copy-on-write）来优化这种用例的 fork 实现（见 4.6 节）。</li>
</ul>
</li>
<li><p>xv6 隐式分配大部分用户空间内存：<strong>fork</strong> 复制父进程的内存到子进程，<strong>exec</strong> 分配足够的内存来容纳可执行文件。</p>
<ul>
<li>一个进程如果在运行时需要更多的内存（可能是为了 <strong>malloc</strong>），可以调用 sbrk(n) 将其数据内存增长 n 个字节；sbrk 返回新内存的位置。</li>
</ul>
</li>
</ul>
<h2 id="I-O-and-File-descriptors-I-O-和文件描述符"><a href="#I-O-and-File-descriptors-I-O-和文件描述符" class="headerlink" title="I&#x2F;O and File descriptors I&#x2F;O 和文件描述符"></a>I&#x2F;O and File descriptors I&#x2F;O 和文件描述符</h2><ul>
<li><p><strong>文件描述符</strong> 是一个小整数，代表一个可由进程读取或写入的内核管理对象。</p>
<ul>
<li>一个进程可以通过打开一个文件、目录、设备，或者通过创建一个管道，或者通过复制一个现有的描述符来获得一个文件描述符。</li>
<li>为了简单起见，我们通常将文件描述符所指向的对象称为文件；</li>
<li>文件描述符接口将文件、管道和设备之间的差异抽象化，使它们看起来都像字节流。我们把输入和输出称为 <strong>I&#x2F;O</strong>。</li>
</ul>
</li>
<li><p>在内部，xv6 内核为每一个进程单独维护一个以文件描述符为索引的表，因此每个进程都有一个从 0 开始的文件描述符私有空间。</p>
<ul>
<li>按照约定，一个进程从文件描述符 0 (标准输入) 读取数据，向文件描述符 1 (标准输出) 写入输出，向文件描述符 2 (标准错误) 写入错误信息。</li>
<li>正如我们将看到的那样，shell 利用这个约定来实现 I&#x2F;O 重定向和管道。</li>
<li>shell确保自己总是有三个文件描述符打开（user&#x2F;sh.c:151），这些文件描述符默认是控制台的文件描述符。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;sh.c:151</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ensure that three file descriptors are open.</span></span><br><span class="line">  <span class="keyword">while</span>((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">      close(fd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>read</strong>&#x2F;<strong>write</strong> 系统调用可以从文件描述符指向的文件读写数据。</p>
<ul>
<li><p>调用 <strong>read(fd, buf, n)</strong> 从文件描述符 <strong>fd</strong> 中读取不超过 <strong>n</strong> 个字节的数据，将它们复制到 <strong>buf</strong> 中，并返回读取的字节数。</p>
</li>
<li><p>每个引用文件的文件描述符都有一个与之相关关联偏移量。<strong>read</strong> 从当前文件偏移量中读取数据，然后按读取的字节数推进偏移量，随后的 <strong>read</strong> 将返回上次读取之后的数据。当没有更多的字节可读时，读返回零，表示文件结束。</p>
</li>
<li><p><strong>write(fd, buf, n)</strong> 表示将 <strong>buf</strong> 中的 <strong>n</strong> 个字节写入文件描述符 <strong>fd</strong> 中，并返回写入的字节数。</p>
</li>
<li><p>若写入字节数小于 n 则该次写入发生错误。和 <strong>read</strong> 一样，<strong>write</strong> 在当前文件偏移量处写入数据，然后按写入的字节数将偏移量向前推进：每次 <strong>write</strong> 都从上一次写入的地方开始。</p>
</li>
</ul>
</li>
<li><p>下面的程序片段 (程序 <strong>cat</strong> 的核心代码) 将数据从其标准输入复制到其标准输出。如果出现错误，它会向标准错误写入一条消息。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">    n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (write(<span class="number">1</span>, buf, n) != n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在这个代码片段中，需要注意的是，<strong>cat</strong> 不知道它是从文件、控制台还是管道中读取的。</p>
<ul>
<li>同样，<strong>cat</strong> 也不知道它是在打印到控制台、文件还是其他什么地方。</li>
<li>文件描述符的使用和 0 代表输入，1 代表输出的约定，使得 <strong>cat</strong> 可以很容易实现。</li>
</ul>
</li>
<li><p><strong>close</strong> 系统调用会释放一个文件描述符，使它可以被以后的 <strong>open</strong>、<strong>pipe</strong> 或 <strong>dup</strong> 系统调用所重用（见下文）。</p>
<ul>
<li>新分配的文件描述符总是当前进程中最小的未使用描述符。</li>
</ul>
</li>
<li><p>文件描述符和 <strong>fork</strong> 相互作用，使 I&#x2F;O 重定向易于实现。</p>
<ul>
<li><strong>fork</strong> 将父进程的文件描述符表和它的内存一起复制，这样子进程开始时打开的文件和父进程完全一样。</li>
<li>系统调用 <strong>exec</strong> 替换调用进程的内存，但会保留文件描述符表。</li>
<li>这种行为允许 shell 通过 <strong>fork</strong> 实现 I&#x2F;O 重定向，在子进程中重新打开所选的文件描述符，然后调用 <strong>exec</strong> 运行新程序。</li>
<li>下面是 shell 运行 <strong>cat &lt; input.txt</strong> 命令的简化版代码。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>); </span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);  </span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>, argv);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在子进程关闭文件描述符 0 后，<strong>open</strong> 保证对新打开的 <strong>input.txt</strong> 使用该文件描述符0。因为此时0将是最小的可用文件描述符。</p>
<ul>
<li>然后 <strong>cat</strong> 执行时，文件描述符 0（标准输入）会指向 <strong>input.txt</strong>。</li>
<li>这不会改变父进程的文件描述符，它只会修改子进程的描述符。</li>
</ul>
</li>
<li><p>xv6 shell 中的 I&#x2F;O 重定向代码正是以这种方式工作的（user&#x2F;sh.c:82）。</p>
<ul>
<li>回想一下 shell 的代码，shell 已经 <strong>fork</strong> 子shell，<strong>runcmd</strong> 将调用 <strong>exec</strong> 来加载新的程序。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;sh.c:82</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> REDIR:</span><br><span class="line">    rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">    close(rcmd-&gt;fd);</span><br><span class="line">    <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;open %s failed\n&quot;</span>, rcmd-&gt;file);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>open</strong> 的第二个参数由一组用位表示的标志组成，用来控制 <strong>open</strong> 的工作。</p>
<ul>
<li>可能的值在文件控制 (fcntl) 头 (kernel&#x2F;fcntl.h:1-5) 中定义。</li>
<li><strong>O_RDONLY,</strong> <strong>O_WRONLY,</strong> <strong>O_RDWR</strong>, <strong>O_CREATE</strong>, 和 <strong>O_TRUNC,</strong> 它们分别指定 open 打开文件时的功能，读、写、读和写、如果文件不存在则创建文件、将文件长度截断为 0。</li>
</ul>
</li>
<li><p>现在应该清楚为什么 <strong>fork</strong> 和 <strong>exec</strong> 是分开调用的：在这两个调用之间，shell 有机会重定向子进程的 I&#x2F;O，而不干扰父进程的 I&#x2F;O 设置。</p>
<ul>
<li>我们可以假设一个由 <strong>fork</strong> 和 <strong>exec</strong> 组成的系统调用 <strong>forkexec</strong>，但是用这种调用来做 I&#x2F;O 重定向似乎很笨拙。</li>
<li>shell 在调用 <strong>forkexec</strong> 之前修改自己的 I&#x2F;O 设置（然后取消这些修改），或者 <strong>forkexec</strong> 可以将 I&#x2F;O 重定向的指令作为参数，或者（最糟糕的方案）每个程序（比如 cat）都需要自己做 I&#x2F;O 重定向。</li>
</ul>
</li>
<li><p>虽然 <strong>fork</strong> 复制了文件描述符表，但每个底层文件的偏移量都是父子共享的。想一想下面的代码。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在这个片段的最后，文件描述符 1 所引用的文件将包含数据 hello world。父进程中的 <strong>write</strong>（由于有了 <strong>wait</strong>，只有在子进程结束后才会运行）会从子进程的 <strong>write</strong> 结束的地方开始。</p>
<ul>
<li>这种行为有助于从 shell 命令的序列中产生有序的输出，比如 <strong>(echo hello; echo world) &gt;output.txt</strong>。</li>
</ul>
</li>
<li><p><strong>dup</strong> 系统调用复制一个现有的文件描述符，返回一个新的描述符，它指向同一个底层 I&#x2F;O 对象。</p>
<ul>
<li>两个文件描述符共享一个偏移量，就像被 <strong>fork</strong> 复制的文件描述符一样。这是将 hello world 写进文件的另一种方法。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果两个文件描述符是通过一系列的 <strong>fork</strong> 和 <strong>dup</strong> 调用从同一个原始文件描述符衍生出来的，那么这两个文件描述符共享一个偏移量。</p>
<ul>
<li>否则，文件描述符不共享偏移量，即使它们是由同一个文件的打开调用产生的。</li>
<li><strong>dup</strong> 允许 shell 实现这样的命令：l<strong>s existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</strong>。</li>
<li>2&gt;&amp;1 表示 2 是 1 的复制（**dup(1)**），即重定向错误信息到标准输出，已存在文件的名称和不存在文件的错误信息都会显示在文件tmp1中。</li>
<li>xv6 shell 不支持错误文件描述符的 I&#x2F;O 重定向，但现在你知道如何实现它了。</li>
</ul>
</li>
<li><p>文件描述符是一个强大的抽象，因为它们隐藏了它们连接的细节：一个向文件描述符 1 写入的进程可能是在向一个文件、控制台等设备或向一个管道写入。</p>
</li>
</ul>
<h2 id="Pipes-管道"><a href="#Pipes-管道" class="headerlink" title="Pipes 管道"></a>Pipes 管道</h2><ul>
<li><p><strong>管道</strong> 是一个小的内核缓冲区，作为一对文件描述符提供给进程，一个用于读，一个用于写。</p>
<ul>
<li>将数据写入管道的一端就可以从管道的另一端读取数据。</li>
<li>管道为进程提供了一种通信方式。</li>
</ul>
</li>
<li><p>下面的示例代码运行程序 wc，标准输入连接到管道的读取端。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>); </span><br><span class="line">    dup(p[<span class="number">0</span>]); </span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>程序调用 <strong>pipe</strong>，创建一个新的管道，并将读写文件描述符记录在数组 <strong>p</strong> 中，经过 <strong>fork</strong> 后，父进程和子进程的文件描述符都指向管道。</p>
<ul>
<li>子进程调用 <strong>close</strong> 和 <strong>dup</strong> 使文件描述符 0 引用管道的读端，并关闭 p 中的文件描述符，并调用 <strong>exec</strong> 运行 <strong>wc</strong>。</li>
<li>当 <strong>wc</strong> 从其标准输入端读取时，它将从管道中读取。</li>
<li>父进程关闭管道的读端，向管道写入，然后关闭写端。</li>
</ul>
</li>
<li><p>如果没有数据可用，管道上的 <strong>read</strong> 会等待数据被写入，或者等待所有指向写端的文件描述符被关闭；在后一种情况下，读将返回 0，就像数据文件的结束一样。</p>
</li>
<li><p>事实上，如果没有数据写入，读会无限阻塞，直到新数据不可能到达为止（写端被关闭），这也是子进程在执行上面的 <strong>wc</strong> 之前关闭管道的写端很重要的一个原因：如果 wc 的一个文件描述符仍然引用了管道的写端，那么 <strong>wc</strong> 将永远看不到文件的关闭（被自己阻塞）。</p>
</li>
<li><p>xv6 的 shell 实现了管道，如 <strong>grep fork sh.c | wc -l</strong>，shell 的实现类似于上面的代码（user&#x2F;sh.c:100）。</p>
<ul>
<li>执行 shell 的子进程创建一个管道来连接管道的左端和右端（去看源码，不看难懂）。然后，它在管道左端（写入端）调用 <strong>fork</strong> 和 <strong>runcmd</strong>，在右端（读取端）调用 <strong>fork</strong> 和 <strong>runcmd</strong>，并等待两者结束。</li>
<li>管道的右端（读取端）可以是一个命令，也可以是包含管道的多个命令（例如，<strong>a | b | c</strong>），它又会分叉为两个新的子进程（一个是<strong>b</strong>，一个是<strong>c</strong>）。</li>
<li>因此，shell 可以创建一棵进程树。这棵树的叶子是命令，内部（非叶子）节点是等待左右子进程结束的进程。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;sh.c:100</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PIPE:</span><br><span class="line">    pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">      close(<span class="number">1</span>);</span><br><span class="line">      dup(p[<span class="number">1</span>]);</span><br><span class="line">      close(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">1</span>]);</span><br><span class="line">      runcmd(pcmd-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">      close(<span class="number">0</span>);</span><br><span class="line">      dup(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">1</span>]);</span><br><span class="line">      runcmd(pcmd-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>原则上，我们可以让内部节点（非叶节点）运行管道的左端，但这样的实现会更加复杂。</p>
<ul>
<li>考虑只做以下修改：修改sh.c，使其不为 <strong>runcmd(p-&gt;left)</strong> fork 进程，直接递归运行 **runcmd(p-&gt;left)**。</li>
<li>像这样，<strong>echo hi | wc</strong> 不会产生输出，因为当 <strong>echo hi</strong> 在 <strong>runcmd</strong> 中退出时，内部进程会退出，而不会调用 <strong>fork</strong> 来运行管道的右端。</li>
<li>这种不正确的行为可以通过不在 <strong>runcmd</strong> 中为内部进程调用 <strong>exit</strong> 来修正，但是这种修正会使代码变得复杂：<strong>runcmd</strong> 需要知道该进程是否是内部进程（非叶节点）。</li>
<li>当不为 <strong>runcmd(p-&gt;right)</strong> fork 进程时，也会出现复杂的情况。像这样的修改，<strong>sleep 10 | echo hi</strong> 就会立即打印出 hi，而不是10 秒后，因为 <strong>echo</strong> 会立即运行并退出，而不是等待 <strong>sleep</strong> 结束。</li>
<li>由于 sh.c 的目标是尽可能的简单，所以它并没有试图避免创建内部进程。</li>
</ul>
</li>
<li><p>管道似乎没有比临时文件拥有更多的功能：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world | wc</span><br></pre></td></tr></table></figure>

<ul>
<li>不使用管道：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</span><br></pre></td></tr></table></figure>

<ul>
<li>在这种情况下，管道比临时文件至少有四个优势。<ul>
<li>首先，管道会自动清理自己；如果是文件重定向，shell 在完成后必须小心地删除 &#x2F;tmp&#x2F;xyz。</li>
<li>第二，管道可以传递任意长的数据流，而文件重定向则需要磁盘上有足够的空闲空间来存储所有数据。</li>
<li>第三，管道可以分阶段的并行执行，而文件方式则需要在第二个程序开始之前完成第一个程序。</li>
<li>第四，如果你要实现进程间的通信，管道阻塞读写比文件的非阻塞语义更有效率。</li>
</ul>
</li>
</ul>
<h2 id="File-system-文件系统"><a href="#File-system-文件系统" class="headerlink" title="File system 文件系统"></a>File system 文件系统</h2><ul>
<li>xv6 文件系统包含了数据文件（拥有字节数组）和目录（拥有对数据文件和其他目录的命名引用）。<ul>
<li>这些目录形成一棵树，从一个被称为根目录的特殊目录开始。</li>
<li>像 <strong>&#x2F;a&#x2F;b&#x2F;c</strong> 这样的路径指的是根目录 <strong>&#x2F;</strong> 中的 <strong>a</strong> 目录中的 <strong>b</strong> 目录中的名为 <strong>c</strong> 的文件或目录。</li>
<li>不以 <strong>&#x2F;</strong> 开头的路径是相对于调用进程的当前目录进行计算其绝对位置的，可以通过 <strong>chdir</strong> 系统调用来改变进程的当前目录。</li>
<li>下面两个 <strong>open</strong> 打开了同一个文件（假设所有涉及的目录都存在）。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>前两行将进程的当前目录改为 <strong>&#x2F;a&#x2F;b</strong>；后面两行既不引用也不改变进程的当前目录。</p>
</li>
<li><p>有一些系统调用来可以创建新的文件和目录：<strong>mkdir</strong> 创建一个新的目录，用 <strong>open</strong> 加上 <strong>O_CREATE</strong> 标志创建并打开一个新的数据文件，以及 <strong>mknod</strong> 创建一个新的设备文件。这个例子说明了这三个系统调用的使用。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>mknod</strong> 创建了一个引用设备的特殊文件。与</p>
<ul>
<li>设备文件相关联的是主要设备号和次要设备号 ( <strong>mknod</strong> 的两个参数)，它们唯一地标识一个内核设备。</li>
<li>当一个进程打开设备文件后，内核会将系统的读写调用转移到内核设备实现上，而不是将它们传递给文件系统。</li>
</ul>
</li>
<li><p>文件名称与文件是不同的；底层文件（非磁盘上的文件）被称为 <strong>inode</strong>，一个 inode 可以有多个名称，称为 <strong>链接</strong>。</p>
<ul>
<li>每个链接由目录中的一个项组成；该项包含一个文件名和对 inode 的引用。</li>
<li>inode 保存着一个文件的 <strong>metadata</strong>（元数据），包括它的类型（文件或目录或设备），它的长度，文件内容在磁盘上的位置，以及文件的链接数量。</li>
</ul>
</li>
<li><p><strong>fstat</strong> 系统调用从文件描述符引用的 inode 中检索信息。它定义在 <strong>stat.h</strong>  (kernel&#x2F;stat.h) 的 <strong>stat</strong> 结构中：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR 1    	<span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2   	<span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE 3 	<span class="comment">// Device</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> dev;     	<span class="comment">// File system’s disk device</span></span><br><span class="line">    uint ino;    	<span class="comment">// Inode number</span></span><br><span class="line">    <span class="type">short</span> type;  	<span class="comment">// Type of file</span></span><br><span class="line">    <span class="type">short</span> nlink; 	<span class="comment">// Number of links to file</span></span><br><span class="line">    uint64 size; 	<span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>link</strong> 系统调用创建了一个引用了同一个 inode 的文件（文件名）。下面的片段创建了引用了同一个 inode 两个文件 a 和 b。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>读写 a 与读写 b 是一样的，每个 inode 都有一个唯一的 inode 号来标识。</p>
<ul>
<li>经过上面的代码序列后，可以通过检查 fstat 的结果来确定 a 和 b 指的是同一个底层内容：两者将返回相同的 inode 号（<strong>ino</strong>），并且 nlink 计数为 2。</li>
</ul>
</li>
<li><p><strong>unlink</strong> 系统调用会从文件系统中删除一个文件名。</p>
<ul>
<li>只有当文件的链接数为零且没有文件描述符引用它时，文件的 inode 和存放其内容的磁盘空间才会被释放。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这行代码会删除 a，此时只有 b 会引用 inode。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/tmp/xyz&quot;</span>, O_CREATE | O_RDWR);</span><br><span class="line">unlink(<span class="string">&quot;/tmp/xyz&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段代码是创建一个临时文件的一种惯用方式，它创建了一个无名称 inode，故会在进程关闭 <strong>fd</strong> 或者退出时删除文件。</p>
</li>
<li><p>Unix 提供了 shell 可调用的文件操作程序，作为用户级程序，例如 <strong>mkdir</strong>、<strong>ln</strong> 和 <strong>rm</strong>。</p>
<ul>
<li>这种设计允许任何人通过添加新的用户级程序来扩展命令行接口。</li>
<li>现在看来，这个设计似乎是显而易见的，但在 Unix 时期设计的其他系统通常将这类命令内置到 shell 中（并将 shell 内置到内核中）。</li>
</ul>
</li>
<li><p>有一个例外，那就是 cd，它是在 shell 中实现的 (user&#x2F;sh.c:160)。cd 必须改变 shell 自身的当前工作目录。</p>
<ul>
<li>如果 cd 作为一个普通命令执行，那么 shell 就会 fork 一个子进程，而子进程会运行 cd，cd 只会改变子进程的当前工作目录。父进程（即 shell）的工作目录则保持不变。</li>
</ul>
</li>
</ul>
<blockquote>
<p>user&#x2F;sh.c:160</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read and run input commands.</span></span><br><span class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Real-world-现实情况"><a href="#Real-world-现实情况" class="headerlink" title="Real world 现实情况"></a>Real world 现实情况</h2><ul>
<li><p>Unix 将标准文件描述符、管道和方便的 shell 语法结合起来进行操作，是编写通用可重用程序的一大进步。</p>
<ul>
<li>这个想法引发了一种 “软件工具” 文化，这也是 Unix 强大和流行的主要原因，而 shell 是第一种所谓的脚本语言。</li>
<li>Unix 系统调用接口今天仍然存在于 BSD、Linux 和 Mac OS X 等操作系统中。</li>
</ul>
</li>
<li><p>xv6 并不符合 POSIX 标准：它缺少许多系统调用（包括基本的系统调用，如 <strong>lseek</strong>），而且它提供的许多系统调用与标准不同。</p>
<ul>
<li>我们对 xv6 的主要目标是简单明了，同时提供一个简单的类似 UNIX 的系统调用接口。</li>
<li>一些人已经添加了一些系统调用和一个简单的 C 库扩展了 xv6，以便运行基本的 Unix 程序。</li>
<li>然而，现代内核比 xv6 提供了更多的系统调用和更多种类的内核服务。例如，它们支持网络、窗口系统、用户级线程、许多设备的驱动程序等等。</li>
<li>现代内核不断快速发展，并提供了许多超越 POSIX 的功能。</li>
</ul>
</li>
<li><p>Unix 用一套文件名和文件描述符接口统一了对多种类型资源（文件、目录和设备）的访问。</p>
<ul>
<li>这个思想可以扩展到更多种类的资源，一个很好的例子是 Plan 9 项目 [13]，它把资源就是文件的概念应用到网络、图形等方面。然而，大多数 Unix 衍生的操作系统都没有遵循这一路线。</li>
</ul>
</li>
<li><p>文件系统和文件描述符已经是强大的抽象。即便如此，操作系统接口还有其他模式。</p>
<ul>
<li>Multics 是 Unix 的前身，它以一种使文件存储看起来像内存的方式抽象了文件存储，产生了一种截然不同的接口。</li>
<li>Multics 设计的复杂性直接影响了 Unix 的设计者，他们试图建立一些更简单的东西。</li>
</ul>
</li>
<li><p>xv6 没有用户系统；用 Unix 的术语来说，所有的 xv6 进程都以 root 身份运行。</p>
</li>
<li><p>本书研究的是 xv6 如何实现其类似 Unix 的接口，但其思想和概念不仅仅适用于 Unix。</p>
<ul>
<li>任何操作系统都必须将进程复用到底层硬件上，将进程相互隔离，并提供受控进程间通信的机制。</li>
<li>在学习了 xv6 之后，您应该能够研究其他更复杂的操作系统，并在这些系统中看到 xv6 中蕴含的基本概念。</li>
</ul>
</li>
</ul>
<h2 id="Exercises-练习"><a href="#Exercises-练习" class="headerlink" title="Exercises 练习"></a>Exercises 练习</h2><ol>
<li>使用 UNIX 的系统调用编写一个程序，通过一对管道在两个进程之间交换一个字节，每个方向各一个。以交换次数&#x2F;秒为单位测量程序的性能。</li>
</ol>
<hr>
<ol>
<li><a name="ftn1"></a> 本文一般用 CPU 中央处理单元的缩写来指代执行计算的硬件单元。其他文本 (如 RISC-V 规范) 也使用processor、core 和 hart 等词代替 CPU。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/04/26/6-S081-Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/6-S081-Lab1/" class="post-title-link" itemprop="url">Lab Utilities</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-26 21:05:06" itemprop="dateCreated datePublished" datetime="2024-04-26T21:05:06+08:00">2024-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-29 23:32:09" itemprop="dateModified" datetime="2024-04-29T23:32:09+08:00">2024-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>实验讲义：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/labs/util.html">Lab: Xv6 and Unix utilities (mit.edu)</a></p>
</li>
<li><p>配置实验环境：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/tools.html">6.S081 &#x2F; Fall 2021 (mit.edu)</a></p>
</li>
<li><p>本实验将让你熟悉 xv6 及其系统调用</p>
</li>
</ul>
<h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><ul>
<li><p>为 xv6 实现 UNIX 程序 sleep；你的 sleep 应该暂停用户指定的刻度数。你的解决方案应该在文件 <code>user/sleep.c</code> 中</p>
</li>
<li><p>一些提示</p>
<ul>
<li>开始前，阅读 xv6 book 的第 1 章</li>
<li>查看 <code>user/</code> 中的一些其他程序，比如 <code>user/echo.c</code>、<code>user\grep.c</code> 和 <code>user/rm.c</code>，看看如何获取传递给程序的命令行参数</li>
<li>如果用户忘记传递参数，sleep 应该打印错误消息</li>
<li>命令行参数以字符串的形式传递；使用 <code>atoi</code> 将其转换为整数</li>
<li>使用系统调用 sleep</li>
<li>确保 main 调用 exit() 退出你的程序</li>
<li>将你的 sleep 程序添加到 Makefile 中的 UPROGS 中；完成后，<code>make qemu</code> 将编译你的程序，你将能从 xv6 shell 运行它</li>
</ul>
</li>
<li><p>关于如何获取传递给程序的命令行参数，我们简单看一下 <code>user/echo.c</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;</span><br><span class="line">    write(<span class="number">1</span>, argv[i], <span class="built_in">strlen</span>(argv[i]));	<span class="comment">// 命令行参数通过 argv 获得</span></span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; argc)&#123;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还有一些关于命令行参数的细节是：</p>
<p>argv[0] 总是当前正在执行程序的 filename，argv 的后续指向的是参数字符串，最后以 NULL 结尾</p>
</blockquote>
<ul>
<li>其他就没什么好看的了，这个用户层次的 sleep 的实现很简单，具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: sleep error...\n&quot;</span>);	<span class="comment">// 如果没有传递参数，打印错误消息</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(atoi(argv[<span class="number">1</span>]));	<span class="comment">// 使用系统调用 sleep</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);	<span class="comment">// 调用 exit() 退出 main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>头文件不能改哦，我从 user&#x2F;echo.c 中 copy 过来的，可能有依赖关系的</p>
</blockquote>
<ul>
<li>修改 Makefile，找到 UPROGS 的位置，添加 sleep</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_zombie\</span><br><span class="line">	$U/_sleep\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make qemu &amp;&amp; sleep 100</strong>， 在 xv6 shell 中运行一下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429205300883.png" class="" title="image-20240429205300883">

<blockquote>
<p>嗯，它确实暂停了！</p>
</blockquote>
<ul>
<li><strong>.&#x2F;grade-lab-util sleep</strong> 进行测试，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429205605891.png" class="" title="image-20240429205605891">

<blockquote>
<p>测试通过！</p>
</blockquote>
<h1 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h1><ul>
<li><p>编写一个使用 UNIX 系统调用的程序，两个进程在一对管道上传递一个字节的 <strong>乒乓球</strong></p>
<ul>
<li>父进程向子进程发送 1 字节，子进程打印 <code>&lt;pid&gt;: received ping</code>，子进程将管道上的 1 字节写入父进程，然后退出</li>
<li>父进程从子进程中读取 1 字节，打印 <code>&lt;pid&gt; received pong</code>，然后退出</li>
</ul>
</li>
<li><p>你的解决方案应该在文件 <code>user/pingpong.c</code></p>
</li>
<li><p>一些提示</p>
<ul>
<li>使用 pipe 创建一个管道</li>
<li>使用 fork 创建一个子进程</li>
<li>使用 read 从管道中读取，write 写入到管道</li>
<li>使用 getpid 查找调用进程的进程 ID</li>
<li>在 Makefile 中将程序添加到 UOROGS 中</li>
<li>xv6 上的用户程序具有有限的功能，可以在 <code>user/user.h</code> 中查看调用列表</li>
</ul>
</li>
<li><p>需要注意的是，管道通常是单向的，父子进程之间通过管道相互传送数据，需要创建两个管道</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage pingpong error...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipefd_father[<span class="number">2</span>], pipefd_child[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd_father) &lt; <span class="number">0</span> || pipe(pipefd_child) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage pipe error...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage fork error...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;h&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipefd_father[<span class="number">1</span>]);	<span class="comment">// 关闭不需要的文件描述符</span></span><br><span class="line">        close(pipefd_child[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (read(pipefd_father[<span class="number">0</span>], buf, n) != n) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child read error...\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (write(pipefd_child[<span class="number">1</span>], buf, n) != n) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child write error...\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipefd_child[<span class="number">1</span>]);</span><br><span class="line">        close(pipefd_father[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pipefd_father[<span class="number">1</span>], buf, n) != n) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;father write error...\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (read(pipefd_child[<span class="number">0</span>], buf, n) != n) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;father read error...\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());    <span class="comment">// 甚至一个空格也不能少！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 Makefile 文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_sleep\</span><br><span class="line">	$U/_pingpong\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make qemu &amp;&amp; pingpong</strong>，在 xv6 shell 中运行一下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429211445101.png" class="" title="image-20240429211445101">

<blockquote>
<p>符合预期！</p>
</blockquote>
<ul>
<li><strong>.&#x2F;grade-lab-util pingpong</strong> 进行测试，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429211554825.png" class="" title="image-20240429211554825">

<blockquote>
<p>测试通过！</p>
<p>这里插播一条我之前犯的一个错误，导致我检查了很久也没通过测试，最终发现 ……</p>
<p>在父进程打印 <code>&lt;pid&gt;: received pong</code> 时，由于我写成了 <code>printf(&quot;%d:received pong\n&quot;, getpid());</code> 少了一个空格并且我也一直没有察觉，这就导致我测试时总是通不过，所以这些细节问题真的是 ……</p>
</blockquote>
<h1 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h1><ul>
<li><p>使用管道编写优质筛选的并发版本。你的目的是使用 pipe 和 fork 来建立管道。第一个进程将数字从 2 到 35 输入管道。对于每个素数，你将创建一个新进程，该进程从其左邻居的管道上读取，并在另一个管道上写，传输给其右邻居</p>
</li>
<li><p>你的解决方案应该在文件 <code>user/primes.c</code> 中</p>
</li>
<li><p>一些提示</p>
<ul>
<li>xv6 的文件描述符和进程数量有限</li>
<li>一个进程应该等待其所有子进程、孙子进程终止</li>
<li>当管道的写入端关闭时，读取端返回 0</li>
<li>在 Makefile 中将程序添加到 UPROGS 中</li>
</ul>
</li>
<li><p>看官方给的描述很懵，但它实际上就是让我们通过 pipe 和 fork 实现一个并发版本的素数筛选器，筛选 2 ~ 35 内的素数</p>
</li>
<li><p>基本原理就是我们在密码学中学到的：[厄拉多塞筛法 - kentle - 博客园 (cnblogs.com)](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kentle/p/14975035.html#:~:text=%E5%8E%84%E6%8B%89%E5%A4%9A%E5%A1%9E%E7%AD%9B%E7%AE%97%E6%B3%95%EF%BC%88Eratosthenes">https://www.cnblogs.com/kentle/p/14975035.html#:~:text=厄拉多塞筛算法（Eratosthenes</a> Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。 它的原理是，给定一个数 n，从 2,开始依次将 √n n 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。)</p>
</li>
<li><p>需要注意的时：由于文件描述符有限，所以我们必须在不需要一个文件描述符时果断 close，避免出现错误！</p>
<blockquote>
<p>我们创建了一些进程，每个进程都有一份父进程的文件描述符表的副本，这就导致了文件描述符的数量急剧飙升</p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;argc error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>], pid, status;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;pipe error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        process(pipefd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">36</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(pipefd[<span class="number">1</span>], &amp;i, len) != len) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>, i);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prime, n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((n = read(fd, &amp;prime, len)) == <span class="number">0</span>) &#123;	<span class="comment">// 没有素数了</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n != len) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);	<span class="comment">// 打印素数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>], pid, number, status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;pipe error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        close(fd);</span><br><span class="line">        process(pipefd[<span class="number">0</span>]);	<span class="comment">// 当前子进程 process 后就变成另一个进程的父进程了！</span></span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((n = read(fd, &amp;number, len)) != <span class="number">0</span>) &#123;	<span class="comment">// 读取父进程传递的数据</span></span><br><span class="line">            <span class="keyword">if</span> (n != len) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (number % prime != <span class="number">0</span>) &#123;	<span class="comment">// 如果不能被 prime 整除就发送给子进程</span></span><br><span class="line">                <span class="keyword">if</span> (write(pipefd[<span class="number">1</span>], &amp;number, len) != len) &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        close(fd);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 Makefile 文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_pingpong\</span><br><span class="line">	$U/_primes\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make qemu &amp;&amp; primes</strong>，在 xv6 shell 中运行一下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429215132041.png" class="" title="image-20240429215132041">

<blockquote>
<p>符合预期！</p>
</blockquote>
<ul>
<li><strong>.&#x2F;grade-lab-util primes</strong> 进行测试，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429215222078.png" class="" title="image-20240429215222078">

<blockquote>
<p>通过！</p>
</blockquote>
<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><ul>
<li><p>编写 UNIX find 程序的简单版本：查找具有特定名称的目录树中的所有文件。你的解决方案应该在 <code>user/find.c</code> 中</p>
</li>
<li><p>一些提示</p>
<ul>
<li>查看 <code>user/ls.c</code> 了解如何阅读目录</li>
<li>使用递归</li>
<li>不要重复进入 <code>&quot;.&quot;</code> 和 <code>&quot;..&quot;</code></li>
<li><code>make clean</code> 且 <code>make qemu</code> 获得一个干净的文件系统；文件系统的更改在 qemu 的运行中持续存在</li>
<li>&#x3D;&#x3D; 不会按照你期望的方式工作，使用 strcmp</li>
</ul>
</li>
<li><p>关于如何阅读目录，查看 <code>user/ls.c</code>，</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)	<span class="comment">// 从后往前找到第一个 /</span></span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));	</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27; &#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ls</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>)&#123;	<span class="comment">// 以只读的方式打开</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;	<span class="comment">// 获取文件的状态</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">  <span class="keyword">case</span> T_DEVICE:	</span><br><span class="line">  <span class="keyword">case</span> T_FILE:	<span class="comment">// 文件类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %l\n&quot;</span>, fmtname(path), st.type, st.ino, st.size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> T_DIR:	<span class="comment">// 目录类型</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);	<span class="comment">// 将 path 复制到 buf 且在追加一个 /</span></span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;	<span class="comment">// 很实用的技巧，先赋值再移动</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;	<span class="comment">// 读目录中的每个文件，学到了，还需要一个 dirent 结构体</span></span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)	</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      memmove(p, de.name, DIRSIZ); <span class="comment">// 在 / 后追加读到的文件名</span></span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;	<span class="comment">// 在最后追加 /0 显示结尾</span></span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d\n&quot;</span>, fmtname(buf), st.type, st.ino, st.size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">    ls(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;argc; i++)</span><br><span class="line">    ls(argv[i]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们的 find 的基本思路就是：是文件就 strcmp 再输出；是目录就读取目录内的所有 “文件”，再递归这些 “文件”</p>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">for</span>(p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--);</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(p, path)) p = <span class="number">0</span>;	<span class="comment">// 如果读不到 &#x27;/&#x27; 就说明 find path dstfile 中的 path 是一个文件而不是目录</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *dstfile)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;%s: open error\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fstat error\n&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">    <span class="comment">// case T_DEVICE:	细节，忽略设备文件</span></span><br><span class="line">    <span class="keyword">case</span> T_FILE:  </span><br><span class="line">        <span class="keyword">if</span> (fmtname(path) != <span class="number">0</span> &amp;&amp; !<span class="built_in">strcmp</span>(fmtname(path), dstfile)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 逆大天！不要把 break 写到 if 内啊</span></span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">        p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">        *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (de.inum == <span class="number">0</span> || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            memmove(p, de.name, DIRSIZ);</span><br><span class="line">            find(buf, dstfile);	<span class="comment">// 使用递归</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;argc error\n&quot;</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>头文件是从 <code>user/ls.c</code> 中 copy 的</p>
</blockquote>
<ul>
<li>修改 Makefile 文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_primes\</span><br><span class="line">	$U/_find\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make qemu &amp;&amp; echo &gt; b &amp;&amp; mkdir a &amp;&amp; echo &gt; a&#x2F;b &amp;&amp; find . b</strong> 在 xv6 shell 中运行一下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429222325895.png" class="" title="image-20240429222325895">

<blockquote>
<p>符合预期！</p>
</blockquote>
<ul>
<li><strong>.&#x2F;grade-lab-util find</strong> 进行测试，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429222417528.png" class="" title="image-20240429222417528">

<blockquote>
<p>测试通过</p>
</blockquote>
<h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><ul>
<li><p>编写 UNIX xargs 程序的简单版本：从标准输入中读取行，并为每行运行一个命令，将该行作为命令的参数提供。你的解决方案应该在文件 <code>user./xargs.c</code> 中</p>
</li>
<li><p>一些提示</p>
<ul>
<li>使用 fork 和 exec1 在每行输入上调用命令。父进程中等待子进程终止</li>
<li>要读取单个输入行，请一次读取一个字符，直到读到 <code>&#39;\n&#39;</code></li>
<li><code>kernel/param.h</code> 中声明了 MAXARG，对于声明 argv 数组可能有帮助</li>
<li>在 Makefile 中将程序添加到 UPROGS 中</li>
<li><code>make clean</code> 且 <code>make qemu</code> 获得一个干净的文件系统；文件系统的更改在 qemu 的运行中持续存在</li>
</ul>
</li>
<li><p>关于 <code>echo hello too | xargs echo bye</code> 行为的解释</p>
<ul>
<li>参数是 echo bye，追加参数是 hello too，所以 echo bye hello too 输出 bye hello too</li>
<li>xargs 的参数 echo bye 通过 argv 给出，而追加参数 hello too 则需要通过读取标准输入得到</li>
</ul>
</li>
<li><p>UNIX 上的 xargs 其实还可以有一些可选的标志，比如 <code>echo list.txt | xargs -n 1 echo line</code>，-n 1 表示一次只读取 list.txt 内的一行作为追加参数运行 xargs，直到读完 list.txt</p>
</li>
<li><p>假如 list.txt 中有 <code>1\n2\n</code>，那么</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> list.txt | xargs -n 1 <span class="built_in">echo</span> line</span></span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>而我们的 xargs 总是在将 -n 设置为 1 的情况下运行它，即表明我们总是需要每次读取标准输入的一行作为追加参数</p>
</li>
<li><p>一个 exec 的小细节是：对于第二个参数 argv，即使 argv[0] 总是作为 filename，但我们只是需要传递 argv 就可以了，而不需要 argv[1]，这是因为读取参数时它会总是忽略 argv[0]，从 argv[1] 开始，这是一个约定</p>
<blockquote>
<p>嗯，这应该是一个约定吧 ……</p>
</blockquote>
</li>
<li><p>具体实现如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readline</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> buf[], <span class="type">int</span> maxlen)</span> &#123;	<span class="comment">// 经典 readline，参考了 CSAPP</span></span><br><span class="line">    <span class="type">int</span> n, rc;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = read(fd, &amp;c, <span class="number">1</span>) == <span class="number">1</span>)) &#123;</span><br><span class="line">            *buf++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *buf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse</span><span class="params">(<span class="type">char</span> buf[], <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = buf;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != buf) p++;	<span class="comment">// 第一次不能 ++</span></span><br><span class="line">        <span class="type">char</span> *arg = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * ARGSIZE);</span><br><span class="line">        <span class="type">char</span> *t = arg;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*p == <span class="string">&#x27; &#x27;</span> || *p == <span class="string">&#x27;\n&#x27;</span>) &#123;	<span class="comment">// 读完一个参数</span></span><br><span class="line">                *arg = <span class="number">0</span>;	<span class="comment">// 显示结尾，这是必须的！</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *arg++ = *p++;	<span class="comment">// 使用了那个小技巧，先赋值再移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        *(argv + i++) = t;	<span class="comment">// 添加到 args</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid, status;</span><br><span class="line">    <span class="type">char</span> buf[ARGSIZE], *args[MAXARG];</span><br><span class="line">    <span class="built_in">memset</span>(args, <span class="number">0</span>, MAXARG);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;	<span class="comment">// 添加 argv 中的参数</span></span><br><span class="line">        *(args + i - <span class="number">1</span>) = argv[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (readline(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf)) != <span class="number">0</span>) &#123; <span class="comment">// 从标准输入中读取一行追加参数到 buf</span></span><br><span class="line">        parse(buf, args + argc - <span class="number">1</span>);	<span class="comment">// 解析追加参数到 args</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            exec(args[<span class="number">0</span>], args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 Makefile 文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	$U/_find\</span><br><span class="line">	$U/_xargs\</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make qemu &amp;&amp; sh &lt; xargstest.sh</strong> 在 xv6 shell 中运行一下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429230054163.png" class="" title="image-20240429230054163">

<blockquote>
<p>符合预期！</p>
</blockquote>
<ul>
<li><strong>.&#x2F;grade-lab-util xargs</strong> 进行测试，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429230151764.png" class="" title="image-20240429230151764">

<blockquote>
<p>通过！其实这里的测试和在 xv6 shell 中运行脚本测试是一样的 ……</p>
</blockquote>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make grade</strong>，结果如下</li>
</ul>
<img src="/2024/04/26/6-S081-Lab1/image-20240429230435789.png" class="" title="image-20240429230435789">

<blockquote>
<p>99 分！应该通过了吧</p>
</blockquote>
<ul>
<li>减了 1 分是因为 <strong>time：FAIL</strong>，官方要求我们创建一个新文件 <code>time.txt</code>，并在其中放入一个整数，即我在 lab 上花费的小时数</li>
</ul>
<blockquote>
<p>嗯，这里就不透露了，哈哈哈</p>
</blockquote>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>实验环境配置相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/428502480">2021 MIT6.S081 Xv6 实验环境配置 - 知乎 (zhihu.com)</a></p>
<blockquote>
<p><code>git clone git://g.csail.mit.edu/xv6-labs-2021</code> 获取实验源码时可能会遇到错误，将 2021 该为 2023 应该就可以了（当然之后可能就又不行了，需要随着时间更改）</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/limengshi138392/article/details/129378589">Ubuntu22.04系统：fatal: 无法连接到 github.com</a></p>
<blockquote>
<p>在 Ubuntu 上从 github 使用 git clone 可能会遇到问题</p>
</blockquote>
<ul>
<li>实验相关</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/edadada/article/details/126533075">6.S081-Lab1 总结笔记（0基础向）_lab1make grade 出错-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/624091268">MIT 6.S081 Operating System  - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/505537995">MIT-6.S081 | Lab1-Unix utilities - 知乎 (zhihu.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
