<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="概述计算机的分类 机械计算机 电子模拟计算机：数据由连续的量表示 电子数字计算机：数据不由连续的数字表示 专用机、通用机  计算机发展简史 计算机的发展  第一代：电子管计算机 第二代：晶体管计算机 第三代：集成电路计算机：半导体存储器，出现微程序设计，出现操作系统 第四代：大规模集成电路计算机：出现数据库系统、分步操作系统、微处理器和微型计算机 第五代：巨大规模集成电路计算机：单片机   半导体">
<meta property="og:type" content="article">
<meta property="og:title" content="计组复习">
<meta property="og:url" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="概述计算机的分类 机械计算机 电子模拟计算机：数据由连续的量表示 电子数字计算机：数据不由连续的数字表示 专用机、通用机  计算机发展简史 计算机的发展  第一代：电子管计算机 第二代：晶体管计算机 第三代：集成电路计算机：半导体存储器，出现微程序设计，出现操作系统 第四代：大规模集成电路计算机：出现数据库系统、分步操作系统、微处理器和微型计算机 第五代：巨大规模集成电路计算机：单片机   半导体">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525092537175.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525092918929.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525100239650.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525102611629.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525102633614.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525103035698.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525103100440.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525104930090.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525105031857.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525105048066.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110244617.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110357689.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110427695.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110441784.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525111512256.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145124955.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145955228.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145607017.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145536692.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145644744.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145715674.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145838834.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145910146.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150047579.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150902680.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150319867.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150439676.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150504727.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150540605.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150656893.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150232580.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150827187.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526094535554.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526100901062.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526101029931.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103222840.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103635832.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103716715.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526112808903.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526112835300.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526113259735.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526135617821.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526135756896.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526140337048.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526140716082.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526142729893.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526143206068.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526154921194.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526154941193.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526155823138.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526155856547.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526160420104.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526160833463.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161114148.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161134274.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161912949.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161928436.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161957376.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527204803749.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527204943758.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210450839.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210619747.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210803495.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527211512391.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527211955003.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192515259.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192643133.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192751788.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192845807.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192931988.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192954705.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528193103420.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203758900.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203904975.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203943373.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204109642.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204129483.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204143019.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204156706.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528210718631.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528213126274.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529180641225.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529180852668.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181002510.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181527522.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181604088.png">
<meta property="article:published_time" content="2024-05-23T09:25:17.000Z">
<meta property="article:modified_time" content="2024-05-29T10:16:23.668Z">
<meta property="article:author" content="yiweiBoi">
<meta property="article:tag" content="复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525092537175.png">

<link rel="canonical" href="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计组复习 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计组复习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-23 17:25:17" itemprop="dateCreated datePublished" datetime="2024-05-23T17:25:17+08:00">2024-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-29 18:16:23" itemprop="dateModified" datetime="2024-05-29T18:16:23+08:00">2024-05-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><ul>
<li>机械计算机</li>
<li>电子模拟计算机：数据由连续的量表示</li>
<li>电子数字计算机：数据不由连续的数字表示</li>
<li>专用机、通用机</li>
</ul>
<h2 id="计算机发展简史"><a href="#计算机发展简史" class="headerlink" title="计算机发展简史"></a>计算机发展简史</h2><ul>
<li><p>计算机的发展</p>
<ul>
<li>第一代：电子管计算机</li>
<li>第二代：晶体管计算机</li>
<li>第三代：集成电路计算机：半导体存储器，出现微程序设计，出现操作系统</li>
<li>第四代：大规模集成电路计算机：出现数据库系统、分步操作系统、微处理器和微型计算机</li>
<li>第五代：巨大规模集成电路计算机：单片机</li>
</ul>
</li>
<li><p>半导体存储器的发展</p>
<ul>
<li>微小的铁磁体环 -&gt; 半导体存储器</li>
</ul>
</li>
<li><p>微处理器的发展</p>
<ul>
<li>4 位的 4004 微处理器 -&gt; 16位 8086 微处理器，采用流水线技术</li>
</ul>
</li>
<li><p>微型计算机的特点</p>
<ul>
<li>体积小、功耗低</li>
<li>可靠性高、使用环境要求低</li>
<li>设计灵活</li>
</ul>
</li>
<li><p>摩尔定律：晶体管面积会逐渐缩小，说明同样的面积下，晶体管越来越多</p>
</li>
<li><p>计算机性能指标</p>
<ul>
<li><p>吞吐量：某一时间间隔能处理的信息量（byte&#x2F;s）</p>
</li>
<li><p>响应时间：输入到系统产生响应（微妙 10^-6^、纳秒 10^-9^）</p>
</li>
<li><p>利用率：给定时间间隔内，系统被实际使用的时间占比</p>
</li>
<li><p>处理机字长：处理机运算器中一次能完成二进制数的位数</p>
</li>
<li><p>总线宽度：CPU 中运算器和存储器相连的内部总线的二进制位数</p>
</li>
<li><p>存储器容量：存储器中存储单元的总数（KB 2^10^、MB 2^20^、GB 2^30^、TB 2^40^）</p>
</li>
<li><p>存储器带宽：单位时间内从存储器读出二进制数的量（byte&#x2F;s）</p>
</li>
<li><p>主频&#x2F;时钟周期：主时钟的频率 f 即为 CPU 的主频（兆赫兹 MHz、GHz），主频的倒数即为 CPU 时钟周期</p>
</li>
<li><p>CPU 执行时间：CPU 执行一段程序所占用的 CPU 时间</p>
<blockquote>
<p>CPU 时钟周期数 * CPU 时钟周期长</p>
</blockquote>
</li>
<li><p>CPI：每条指令周期数</p>
<blockquote>
<p>执行某段程序所需 CPU 时钟周期数 &#x2F; 该程序的指令条数</p>
</blockquote>
</li>
<li><p>MIPS：每秒百万条指令数</p>
<blockquote>
<p>指令条数 &#x2F; (程序执行时间 * 10^6^) &#x3D; 时钟频率 &#x2F; (CPI * 10^6^)</p>
</blockquote>
</li>
<li><p>Te：程序执行时间</p>
<blockquote>
<p>指令条数 &#x2F; (MIPS * 10^6^)</p>
</blockquote>
</li>
<li><p>MFLOPS：每秒百万次浮点操作数</p>
<blockquote>
<p>程序中浮点操作次数 &#x2F; (程序执行时间 * 10^6^)</p>
<p>MIPS 是基于指令的，MIPS 越高机器越快；MFLOPS 基于浮点操作，不能体现机器整体性能</p>
</blockquote>
</li>
<li><p>TFLOPS：每秒万亿次浮点操作次数，常用于超级计算机</p>
</li>
</ul>
</li>
</ul>
<h2 id="计算机的硬件"><a href="#计算机的硬件" class="headerlink" title="计算机的硬件"></a>计算机的硬件</h2><ul>
<li><p>冯诺依曼计算机的设计思想：程序存储，程序控制</p>
<ul>
<li>计算机由五部分组成：控制器、运算器、存储器、输入设备、输出设备</li>
<li>程序和数据都以二进制代码的形式不加区别的存放在存储器上</li>
<li>指令由操作码和地址码组成，由指令计数器 PC 指出要执行指令所在单元地址，一般顺序执行</li>
<li>I&#x2F;O 设备和存储器传送数据时都通过运算器，以运算器为中心</li>
</ul>
</li>
<li><p>控制器</p>
<ul>
<li><p>获得执行的指令，明确指令功能，获得操作的数据，执行指令，返回结果</p>
<blockquote>
<p>取指周期，从内存读出的信息流向控制器，执行周期流向运算器</p>
</blockquote>
</li>
</ul>
</li>
<li><p>适配器和 I&#x2F;O 设备</p>
<ul>
<li><p>输入设备：将人熟悉的信息变为机器棵识别的二进制信息</p>
</li>
<li><p>输出设备：将计算机处理的结果变为人熟悉的信息</p>
</li>
<li><p>适配器：使外围设备可通过系统总线与主机联系</p>
</li>
<li><p>总线：系统部件间数据传送的公共通路</p>
<blockquote>
<p>系统总线包含三个子总线：数据总线、地址总线、控制总线</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="计算机的软件"><a href="#计算机的软件" class="headerlink" title="计算机的软件"></a>计算机的软件</h2><ul>
<li>软件的分类：系统软件和应用软件</li>
<li>软件的发展演变<ul>
<li>编程语言：手写程序 -&gt; 汇编语言 -&gt; 高级语言</li>
<li>系统软件：操作系统 -&gt; 分布式操作系统</li>
</ul>
</li>
</ul>
<h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><ul>
<li><p>第一级是微程序级，第二级是机器语言级，第三级是操作系统级，第四级是汇编语言级，第五级是高级应用级</p>
</li>
<li><p>层次结构的特点</p>
<ul>
<li>每一级都可以直接编程，得到下一级的支持</li>
<li>1 - 3 是二进制语言，易于机器执行；4 - 5 级是符号，易于人理解</li>
<li>级数越低越接近硬件</li>
</ul>
</li>
<li><p>软件和硬件的逻辑等价性：任何操作既可以用软件实现，也可以用硬件实现</p>
<ul>
<li>需要考虑的是其他因素：价格、速度、可靠性 ……</li>
</ul>
</li>
</ul>
<h1 id="运算器和运算方法"><a href="#运算器和运算方法" class="headerlink" title="运算器和运算方法"></a>运算器和运算方法</h1><h2 id="数据与文字的表示方法"><a href="#数据与文字的表示方法" class="headerlink" title="数据与文字的表示方法"></a>数据与文字的表示方法</h2><ul>
<li><p>十进制到 R 进制的转换</p>
<ul>
<li>整数部分：除 R 取余，R 进制为基数</li>
<li>小数部分：乘 R 取整</li>
</ul>
</li>
<li><p>数据的表示格式</p>
<ul>
<li>定点表示：纯整数 &#x2F; 纯小数，带符号 &#x2F; 不带符号</li>
<li>浮点表示</li>
</ul>
</li>
<li><p>纯小数</p>
</li>
</ul>
<style>.viunpjndpfhw{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525092537175.png" class="viunpjndpfhw" alt="image-20240525092537175">

<ul>
<li><p>纯整数的取值范围：<code>0 &lt;= |x| &lt;= 2^n^ -1 </code></p>
</li>
<li><p>IEEE 754 浮点标准</p>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525092918929.png" class="" title="image-20240525092918929">

<ul>
<li><p>32 位浮点数，<code>x = (-1)^S^ × (1.M) × 2^E-127^</code>、 <code>e = E - 127</code></p>
<ul>
<li>M 尾数 23 位；E 阶码 8 位，用移码表示</li>
</ul>
</li>
<li><p>64 位浮点数，<code>x = (-1)^S^ × (1.M) × 2^E-1023^</code> 、<code>e = E - 1023</code></p>
<ul>
<li>M 尾数 52 位；E 阶码 11 位</li>
</ul>
</li>
<li><p>表示 0：当 E 阶码位全为 0 时， M 尾数位也全为 0，根据 S 符号位是 1 &#x2F; 0，有正 0 和负 0 之分</p>
</li>
<li><p>表示无穷：当 E 阶码位全为 1 时，M 尾数位全为 0，根据 S 符号位是 1 &#x2F; 0，有正无穷和负无穷之分</p>
</li>
<li><p>因为要排除阶码 E 全 0 全 1 的情况，32 位浮点数的 E 的取值范围为：1 ~ 254，真正的指数 e 的取值范围为：-126 ~ 127</p>
</li>
</ul>
</li>
<li><p>BCD 码</p>
<ul>
<li>一般用 8421 码，其 4 个二进制码的权从高到低分别为 8、4、2 和 1。</li>
<li>用 0000，0001，…，1001 分别表示 0，1，…，9，每个数位内部满足二进制规则，而数位之间满足十进制规则，故称这种编码为 “以二进制编码的十进制 (binary coded decimal，简称 BCD) 码”</li>
<li>部实现 BCD 码算术运算，要对运算结果进行修正，对加法运算的修正规则是： <ul>
<li>如果两个一位 BCD 码相加之和小于或等于 (1001)2， 即 (9)10，不需要修正</li>
<li>如相加之和大于或等于 (10)10，要进行加 6 修正， 并向高位进位</li>
</ul>
</li>
</ul>
</li>
<li><p>机器码表示</p>
<ul>
<li>原码，反码，补码，移码</li>
</ul>
<p>	</p>
</li>
<li><p>原码</p>
<ul>
<li>定点小数的取值范围：<code>2^-n^ - 1 ~ 1 - 2^-n^</code></li>
<li>定点整数的取值范围：<code>1 - 2^n^ ~ 2^n^ – 1</code></li>
<li>缺点：加减很麻烦</li>
</ul>
</li>
<li><p>补码</p>
<style>.tkkpclwprcur{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525100239650.png" class="tkkpclwprcur" alt="image-20240525100239650">

<ul>
<li><p>原理是：一个负数用其补码代替，同样可以得到正确的运算结果</p>
<ul>
<li>如果是 n 位整数，其模为2^n^ </li>
<li>如果是 n 位小数，其模为 2</li>
</ul>
</li>
<li><p>补码的优点就是将减法运算可以转为加法运算，无正 0 和负 0 之分</p>
</li>
<li><p>由原码求补码</p>
<ul>
<li>正数的原码、反码、补码都相同</li>
<li>负数：符号位 1 保持不变，其余位取反，得到反码；反码最低位 + 1 得到补码</li>
</ul>
</li>
<li><p>由 x 的补码求 x&#x2F;2 的补码：算术右移</p>
</li>
</ul>
</li>
<li><p>反码</p>
<ul>
<li>正数的原码、反码、补码相同</li>
<li>负数的符号位保持不变，其他位按位取反</li>
<li>反码有正 0 和负 0 之分</li>
</ul>
</li>
<li><p>移码</p>
<ul>
<li>通常用在阶码中</li>
<li>特点：移码和补码尾数相同，符号位相反</li>
<li><code>00000000</code> 阶码表示数字 “0” ，尾数的隐含位为 0；<code>11111111</code> 阶码表示数字 “无穷大” ，尾数的隐含位为 0</li>
</ul>
</li>
<li><p>字符和字符串的表示</p>
<ul>
<li><p>字符用 ASCLL：一个字节表示，低 7 位用来编码，高 1 位用来校验</p>
</li>
<li><p>字符串用连续的字节表示，一个字符一个字节</p>
</li>
<li><p>汉字：两个字节组成，每个字节高位都为1（区别于英文字符）（PPT 和 UTF - 8 好像不太一样，存疑）</p>
</li>
</ul>
</li>
<li><p>校验码</p>
<ul>
<li>由于信息传输和处理过程中受到干扰和故障，容易出错，所以在有效信息中加入一些冗余信息（校验位）</li>
<li>原理：在 k 位数据码之外增加 1 位校验位，使 k + 1 位码字中取值为 1 的位数总保持为偶数（偶校验）或奇数（奇校验）</li>
<li>只能发现错误，不能改错</li>
</ul>
</li>
</ul>
<h2 id="定点加法、减法运算"><a href="#定点加法、减法运算" class="headerlink" title="定点加法、减法运算"></a>定点加法、减法运算</h2><ul>
<li><p>补码加法</p>
<ul>
<li><style>.bcfriwcchhel{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525102611629.png" class="bcfriwcchhel" alt="image-20240525102611629">
</li>
<li><style>.lwrxcysoczcx{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525102633614.png" class="lwrxcysoczcx" alt="image-20240525102633614">
</li>
<li><p>符号位作为数的一部分参加运算</p>
</li>
<li><p>在 2^n+1^ 模意义下相加，即超过 2^n+1^ 的进位要丢掉</p>
</li>
</ul>
</li>
<li><p>补码减法</p>
<ul>
<li><p>为了将减法转为加法，[x-y]补 &#x3D; [x]补 - [y]补 &#x3D; [x]补 + [-y]补</p>
</li>
<li><p>由 [y]补 求 [-y]补：包括符号位都取反，在末位 + 1</p>
</li>
<li><style>.glnklstpvgov{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525103035698.png" class="glnklstpvgov" alt="image-20240525103035698">
</li>
<li><style>.xjyfdvywodmt{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525103100440.png" class="xjyfdvywodmt" alt="image-20240525103100440"></li>
</ul>
</li>
<li><p>溢出的概念</p>
<ul>
<li><p>两个正数相加得到负数，两个负数相加得到正数</p>
</li>
<li><p>溢出的检测</p>
<ul>
<li><p>双符号法：</p>
<style>.tmhaydueymeo{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525104930090.png" class="tmhaydueymeo" alt="image-20240525104930090">
</li>
<li><p>两符号位相异时，表示溢出；相同时，没有溢出。无论是否溢出，SF1 表示结果正确的（其实是本该正确的）</p>
</li>
<li><p>超出双符号的部分还是需要丢掉的</p>
</li>
</ul>
</li>
<li><style>.cssglylxtrnv{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525105031857.png" class="cssglylxtrnv" alt="image-20240525105031857">
</li>
<li><style>.rnjwvwnwwlju{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525105048066.png" class="rnjwvwnwwlju" alt="image-20240525105048066"></li>
</ul>
</li>
<li><p>基本的加法减法器</p>
<ul>
<li>半加器：不考虑进位</li>
<li>全加器：考虑进位</li>
</ul>
</li>
</ul>
<h2 id="定点乘法运算"><a href="#定点乘法运算" class="headerlink" title="定点乘法运算"></a>定点乘法运算</h2><ul>
<li><p>乘积的符号由两数的符号按异或运算得到，而乘 积的数值部分则是两个正数相乘之积</p>
</li>
<li><style>.qapxmnhugoey{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110244617.png" class="qapxmnhugoey" alt="image-20240525110244617">
</li>
<li><p>通常机器只有 n 位长，两个 n 位数相乘，乘积可能为 2n 位</p>
</li>
<li><p>不带符号位的阵列乘法器</p>
<ul>
<li><style>.munpywbeqlkm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110357689.png" class="munpywbeqlkm" alt="image-20240525110357689"></li>
</ul>
</li>
<li><p>带符号位的阵列乘法器</p>
<ul>
<li><style>.fydrnhobdojn{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110427695.png" class="fydrnhobdojn" alt="image-20240525110427695">
</li>
<li><style>.ruumuftuzftb{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525110441784.png" class="ruumuftuzftb" alt="image-20240525110441784"></li>
</ul>
</li>
</ul>
<h2 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h2><ul>
<li>人工除法时，人可以比较被除数（余数）和除数的 大小来确定商 1（够减）或商 0（不够减） </li>
<li>机器除法时，余数为正表示够减，余数为负表示不够减。不够减时必须恢复原来余数，才能继续向下 运算。这种方法叫恢复余数法，控制比较复杂。 </li>
<li><strong>不恢复余数法（加减交替法）</strong> 余数为正，商 1，下次除数右移做减法； 余数为负，商 0，下次除数右移做加法。 控制简单，有规律</li>
<li><style>.xfiovqvnbymj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525111512256.png" class="xfiovqvnbymj" alt="image-20240525111512256"></li>
</ul>
<h2 id="定点运算器的组成"><a href="#定点运算器的组成" class="headerlink" title="定点运算器的组成"></a>定点运算器的组成</h2><ul>
<li>多功能算术&#x2F;逻辑运算单元 ALU</li>
</ul>
<h2 id="浮点运算方法和浮点运算器"><a href="#浮点运算方法和浮点运算器" class="headerlink" title="浮点运算方法和浮点运算器"></a>浮点运算方法和浮点运算器</h2><ul>
<li><p>浮点数加法</p>
<ul>
<li><style>.ptlsirkqtwxo{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145124955.png" class="ptlsirkqtwxo" alt="image-20240525145124955">
</li>
<li><style>.wqzhldfelvwc{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145955228.png" class="wqzhldfelvwc" alt="image-20240525145955228">
</li>
<li><p>步骤：</p>
<ul>
<li><p>0 操作数检查</p>
<style>.bpckgjsmujhs{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145607017.png" class="bpckgjsmujhs" alt="image-20240525145607017">
</li>
<li><p>比较阶码大小并完成对阶（小阶向大阶对齐），通过尾数的移动以改变 Ex 和 Ey 对阶 ，使之相等</p>
<style>.wtyghgwjhrwg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145536692.png" class="wtyghgwjhrwg" alt="image-20240525145536692">
</li>
<li><p>尾数进行加或减运算</p>
<style>.bwnmnkxbmsdy{zoom: 50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145644744.png" class="bwnmnkxbmsdy" alt="image-20240525145644744">
</li>
<li><p>结果格式化</p>
<style>.thxwsymhveeg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145715674.png" class="thxwsymhveeg" alt="image-20240525145715674">

<blockquote>
<p>这里左规处理，我觉得应该是因为之前的 1 是符号位，我们要将其转为 1.M 的形式</p>
</blockquote>
</li>
<li><p>舍入处理</p>
<style>.nklsfjnoetge{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145838834.png" class="nklsfjnoetge" alt="image-20240525145838834"></li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.bqmrwbpjiazd{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525145910146.png" class="bqmrwbpjiazd" alt="image-20240525145910146">

<ul>
<li><p>浮点乘除法</p>
<ul>
<li><style>.tdlydtwwtjzy{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150047579.png" class="tdlydtwwtjzy" alt="image-20240525150047579"></li>
<li><style>.byppnzwrjdyu{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150902680.png" class="byppnzwrjdyu" alt="image-20240525150902680">
</li>
<li><p>步骤：</p>
</li>
<li><style>.wljxhfppdzxi{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150319867.png" class="wljxhfppdzxi" alt="image-20240525150319867">

<ul>
<li><p>0 操作数检查</p>
<style>.wikcixyqrvtt{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150439676.png" class="wikcixyqrvtt" alt="image-20240525150439676">
</li>
<li><p>阶码加减操作</p>
<style>.cttukmsubfog{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150504727.png" class="cttukmsubfog" alt="image-20240525150504727">
</li>
<li><p>尾数乘除操作</p>
<style>.bychcwvkptre{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150540605.png" class="bychcwvkptre" alt="image-20240525150540605">
</li>
<li><p>结果规格化</p>
<style>.qhnbeqkhntow{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150656893.png" class="qhnbeqkhntow" alt="image-20240525150656893">

<blockquote>
<p>使用第二种格式化结果感觉更合理</p>
</blockquote>
</li>
<li><p>舍入处理</p>
<style>.meqabissvpbm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150232580.png" class="meqabissvpbm" alt="image-20240525150232580"></li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.sohwybpslnfj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240525150827187.png" class="sohwybpslnfj" alt="image-20240525150827187">

<ul>
<li><p>浮点运算流水线</p>
<ul>
<li>空间并行性：增加冗余部件；时间并行性：流水线技术</li>
<li>流水线原理：把一个任务分解为几个有联系的子任务</li>
<li>基本概念：<ul>
<li>过程段 Si 所需的时间为 Ti，缓冲寄存器的延时为 T1，线性流水线的时钟周期定义为 <code>t＝max&#123;Ti&#125;＋T1＝Tm＋T1</code>，流水线处理的频率为 <code>f＝1/t</code></li>
<li>k 级流水线处理 n 个任务需要的时钟周期数：<code>Tk＝k＋(n－1)</code>。其中 k 个时钟周期用来处理第一个任务，剩下的 n - 1 个任务只需要 n - 1 个时钟周期</li>
</ul>
</li>
</ul>
</li>
<li><p>非流水线处理 n 个任务顺序完成的时间为：<code>T＝ n × k × t</code>，而流水线技术需要：<code>T＝Tk × t</code></p>
</li>
<li><p>k级线性流水线的加速比： <code>Ck ＝ n * k / [k＋(n－1)]</code></p>
</li>
</ul>
<h1 id="内部存储器"><a href="#内部存储器" class="headerlink" title="内部存储器"></a>内部存储器</h1><h2 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h2><ul>
<li><p>一个双稳态半导体电路或一个 CMOS 晶体管或磁性材料的存储元，均可以存储一位二进制代码</p>
<ul>
<li>二进制代码位是存储器中最小的存储单位，称为存储位元</li>
<li>多个存储位元构成存储单元，多个存储单元构成存储器</li>
</ul>
</li>
<li><p>存储器的分类：</p>
<ul>
<li>按存储介质：磁面 &#x2F; 半导体</li>
<li>按存取方式：随机 &#x2F; 顺序</li>
<li>按读写功能：RAM（随机易失性） &#x2F; ROM（只读非易失性）</li>
<li>按信息的保存：永久性 &#x2F; 非永久性</li>
</ul>
</li>
<li><p>存储器层次结构</p>
</li>
</ul>
<style>.iytixdkkfonj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526094535554.png" class="iytixdkkfonj" alt="image-20240526094535554">

<ul>
<li>主存储器技术指标<ul>
<li>字存储单元：存放一个机器字的存储单元</li>
<li>字节存储单元：存放一个字节的单元</li>
<li>存储容量：指一个存储器中可以容纳的存储单元总数</li>
<li>存取时间：指一次读操作命令发出 到该操作完成，将数据读出到数据总线上所经历的时间</li>
<li>存储周期：指连续启动两次读操作所需间隔的最小时间。 通常，存储周期略大于存取时间</li>
<li>存储器带宽：单位时间里存储器所存取的信息量，通常以位&#x2F;秒或字节&#x2F;秒做度量单位</li>
</ul>
</li>
</ul>
<h2 id="SRAM-存储器"><a href="#SRAM-存储器" class="headerlink" title="SRAM 存储器"></a>SRAM 存储器</h2><ul>
<li><p>主存是半导体存储器，分为两类：</p>
<ul>
<li>静态读写存储器 SRAM：存取速度块，容量不如 DRAM 大</li>
<li>动态读写存储器 DRAM</li>
</ul>
</li>
<li><p>SRAM 存储位元：一个锁存器（触发器）</p>
</li>
<li><p>只要直流供电电源一直加到这个记忆电路上，它就无限期地保持记忆的 1 状态或 0 状态。如果电源断电，那么存储的数据就会丢失</p>
</li>
<li><p>SRAM 存储器读写逻辑</p>
<ul>
<li>CS 拔是片选信号（低电平有效），无论读或写，总是打开（低电平）</li>
<li>OE 拔是读使能信号（低电平有效），读的时候打开</li>
<li>WE 拔是写使能信号（低电平有效），写时总是打开</li>
<li>读写要互斥，因此 OE 拔低电平时，WE 拔总是高电平，反之同理</li>
</ul>
</li>
</ul>
<style>.moclecvbmbpv{zoom: 67%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526100901062.png" class="moclecvbmbpv" alt="image-20240526100901062">

<ul>
<li><style>.gswvwcdkjyxl{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526101029931.png" class="gswvwcdkjyxl" alt="image-20240526101029931"></li>
</ul>
<h2 id="DRAM-存储器"><a href="#DRAM-存储器" class="headerlink" title="DRAM 存储器"></a>DRAM 存储器</h2><ul>
<li><p>DRAM 的存储单元：</p>
<ul>
<li>SRAM 的存储单元是一个触发器，它具有两个稳定状态</li>
<li>DRAM 的存储单元是由一个 MOS 晶体管和电容器组成的记忆电路，通过电容有无电荷来区分信号 0、1，MOS 管则作为开关使用</li>
</ul>
</li>
<li><p>DRAM 的逻辑结构</p>
<ul>
<li>由于 DRAM 的容量很大，增加了行地址锁存器和列地址锁存器</li>
<li>由于 DRAM 存储单元是基于电荷的，电荷量随着时间和温度而减少，必须定期刷新，所以增加了刷新计数器</li>
<li>读周期、写周期的定义是从行选通信号 RAS 下降沿开始，到下一个RAS信号的下降沿为止。刷新操作和读 &#x2F; 写操作是交替进行的</li>
</ul>
</li>
</ul>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103222840.png" class="" title="image-20240526103222840">

<ul>
<li><p>存储容量扩充</p>
<ul>
<li><p>字长位数扩充</p>
<style>.vujkgqczlyuj{zoom:67%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103635832.png" class="vujkgqczlyuj" alt="image-20240526103635832">
</li>
<li><p>字存储容量扩展</p>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526103716715.png" class="" title="image-20240526103716715"></li>
</ul>
</li>
<li><p>高级 DRAM 结构</p>
<ul>
<li>FPM DRAM：快速页模式动态存储器，它是根据程序的局部性原理来实现的</li>
<li>CDRAM：带高速缓冲存储器（cache）的动态存储器，在 DRAM 芯片内又集成了一个小容量的 SRAM，从而使 DRAM 芯片的性能得到显著改进</li>
<li>SDRAM：同步型动态存储器，SDRAM 的操作要求与系统时钟相同步，在系统时钟的控制下从 CPU 获得地址、数据和控制信息</li>
</ul>
</li>
<li><p>DRAM 读写正确性校验：增加了附加位，用于读&#x2F;写操作正确性校验。增加的附加位也要同数据位一起写入 DRAM 中保存</p>
</li>
</ul>
<h2 id="只读存储器（ROM）和闪速存储器（EPROM）"><a href="#只读存储器（ROM）和闪速存储器（EPROM）" class="headerlink" title="只读存储器（ROM）和闪速存储器（EPROM）"></a>只读存储器（ROM）和闪速存储器（EPROM）</h2><ul>
<li><p>只读存储器 ROM：在工作时只能读，不能写，因此原始数据必须在它工作前写入</p>
</li>
<li><p>ROM 的分类：</p>
<ul>
<li>掩模 ROM：也就是一个由商家提供的内存固定的 ROM，一旦芯片做成就不能改变了</li>
<li>可编程 ROM：用户后写入内容，有的可以多次写入<ul>
<li>一次性编程 PROM</li>
<li>多次编程的 EPROM 和 E^2^PROM</li>
</ul>
</li>
</ul>
</li>
<li><p>可编程 ROM</p>
<ul>
<li><p>EPROM 叫光擦除可编程只读存储器，常用的有以浮栅雪崩注入型 MOS 管为存储单元的 EPROM</p>
</li>
<li><p>E^2^PROM 叫电擦除可编程只读存储器，其存储元是一个具有两个栅级的 NMOS 管</p>
</li>
<li><p>这两种存储器出厂时为全 1 状态，使用者可根据需要写 0</p>
</li>
</ul>
</li>
<li><p>闪速存储器</p>
<ul>
<li>FLASH 存储器也叫闪速存储器，它是高密度非易失性读&#x2F;写存储器</li>
<li>高密度说明其存储容量很大，非易失性说明数据没有电源也能长期保存</li>
<li>它既有 RAM 的优点，也有 ROM 的优点，是一个跨时代的进展</li>
<li>FLASH 存储元在 EPROM 存储元基础上发展起来的</li>
</ul>
</li>
</ul>
<h2 id="并行存储器"><a href="#并行存储器" class="headerlink" title="并行存储器"></a>并行存储器</h2><ul>
<li><p>为了解决 CPU 和主存储器之前的速度不匹配问题，解决途径：</p>
<ul>
<li>多个存储器并行工作：并行访问和交叉访问</li>
<li>采用分层存储系统：Cache、虚拟存储系统</li>
</ul>
</li>
<li><p>双端口存储器（空间并行）</p>
<ul>
<li>由于同一个存储器具有两组相互独立的读写控制电路而得名，通过 BUSY 位来保证读写互斥</li>
</ul>
</li>
<li><p>多模块交叉存储器（时间并行）</p>
<ul>
<li><p>一个由若干个模块组成的主存储器，有两种访问方式：一种是顺序方式，一种是交叉方式</p>
<ul>
<li>顺序方式</li>
</ul>
<style>.xxfedexnucoc{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526112808903.png" class="xxfedexnucoc" alt="image-20240526112808903">

<ul>
<li><p>交叉方式</p>
<style>.upppseunohgn{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526112835300.png" class="upppseunohgn" alt="image-20240526112835300">

<ul>
<li>通常在一个存储器周期内联系访问四个模块。各模块的 读写过程将重叠进行</li>
<li>各个存储体的启动间隔为 <code>t = T/n</code>（n为交叉存取度） </li>
<li><code>t顺序 = xT</code>（x 表示任务个数），<code>x交叉 = T + (x - 1)t</code>（第一个 T 是第一个任务，剩下的 x - 1 个任务都只需要 t）</li>
</ul>
<style>.tbyjuybcyydf{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526113259735.png" class="tbyjuybcyydf" alt="image-20240526113259735">

<blockquote>
<p>Mb 的 b 表示 bit，而 MB 的 B 表示 byte</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Cache-存储器"><a href="#Cache-存储器" class="headerlink" title="Cache 存储器"></a>Cache 存储器</h2><ul>
<li><p>Cache 是一种高速缓冲存储器介于 CPU 和主存之 间的小容量存储器，但存取速度比主存快。随着集成度的提高，Cache 已放入 CPU中，工作速度接近于 CPU 的速度，纯硬件控制</p>
</li>
<li><p>Cache 是由 SRAM 组成的，它的设计依据是局部性原理</p>
<ul>
<li>CPU 与 Cache 之间的数据传送是以字为单位</li>
<li>主存与 Cache 之间的数据传送是以块为单位</li>
</ul>
</li>
<li><p><code>Ne</code> 表示 cache 完成存取的总次数，<code>Nm</code> 表示主存完成存取的总次数，<code>h</code> 表示命中率</p>
</li>
<li><p><code>tc</code> 表示命中时 cache 的访问时间，<code>tm</code> 表示未命中时主存的访问时间，<code>1-h</code> 表示未命中率，<code>ta</code> 表示 cache&#x2F;主存储系统的平均访问时间</p>
</li>
<li><p><code>r = tm / tc</code>，表示主存慢于 cache 的倍率，<code>e</code> 表示访问效率</p>
</li>
</ul>
<style>.gquwfobwpikj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526135617821.png" class="gquwfobwpikj" alt="image-20240526135617821">

<ul>
<li><style>.wlzuhilxqlrp{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526135756896.png" class="wlzuhilxqlrp" alt="image-20240526135756896">
</li>
<li><p>主存与 cache 的地址映射</p>
<ul>
<li><p>cache 的容量很小，保存的内容只是主存内容的一个子集，且 cache 与主存的数据交换是以块为单位</p>
</li>
<li><p>全相联的地址映射</p>
<ul>
<li><p>主存中的任一块可以映射到缓存中的任一块</p>
</li>
<li><p>此时内存地址由块号、偏移量组成，将块号和 cache 中每一行的标记位比较</p>
<style>.vemfqsjikjdb{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526140337048.png" class="vemfqsjikjdb" alt="image-20240526140337048">
</li>
<li><p>冲突概率小，Cache 的利用高，但比较器难实现，需要一个访问速度很快代 价高的相联存储器</p>
</li>
</ul>
</li>
<li><p>直接映射</p>
<ul>
<li><p>Cache 的行号 i 和主存的块号 j 函数关系 <code>i = j mod m</code>，m 是 cache 中的总行数</p>
</li>
<li><p>每个缓存块 i 可以和若干个主存块对应；每个主存块 j 只能和一个缓存块对应</p>
</li>
<li><p>此时内存地址有 tag、行号、偏移量组成，直接和 cache 中对于行的 tag 比较</p>
<style>.iwdgjidrbqmy{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526140716082.png" class="iwdgjidrbqmy" alt="image-20240526140716082">
</li>
<li><p>硬件实现简单，但冲突概率高（抖动）</p>
</li>
</ul>
</li>
<li><p>组相联映射方式</p>
<ul>
<li><p>前两者的组合，Cache 分组，组间采用直接映射方式，组内采用全相联的映射方式</p>
</li>
<li><p>主存块存放在哪个组是固定的，至于存到该组哪一行是灵活的</p>
</li>
<li><p>此时内存地址由 tag、组号、偏移量组成，在 cache 对应的组中逐个比较 tag</p>
<style>.ghhmgmwuwbnc{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526142729893.png" class="ghhmgmwuwbnc" alt="image-20240526142729893">
</li>
<li><p>当只有一个组时，是全映射；当组的容量为 1 时，是直接映射</p>
</li>
<li><p>组的容量一般取值比较小，假设为 v，则称为 v 路组相联 cache</p>
</li>
</ul>
</li>
<li><style>.cfhqifesfunc{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526143206068.png" class="cfhqifesfunc" alt="image-20240526143206068"></li>
</ul>
</li>
<li><p>替换策略</p>
<ul>
<li>LFU（最不经常使用 ）：被访问的行计数器增加 1， 换值小的行，不能反映近期 cache 的访问情况</li>
<li>LRU（近期最少使用）：被访问的行计数器置 0， 其他的计数器增加 1，换值大的行，符合局部性原理</li>
<li>随机替换：硬件上容易实现，且速度也比前两种策略快，但随意换出的数据很可能马上又要使用</li>
</ul>
</li>
<li><p>写操作策略</p>
<ul>
<li>由于 cache 的内容只是主存部分内容的拷贝，它应当与主存内容保持一致</li>
<li>写回法：换出时，对行的修改位进行判断，决定是写回到主存还是舍掉</li>
<li>全写法：写命中时，Cache 与内存一起写</li>
<li>写一次法：与写回法一致，但是第一次 Cache 命中时采用全写法</li>
</ul>
</li>
<li><p>使用多级 cache 减少缺失损失</p>
</li>
</ul>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><ul>
<li><p>基本概念</p>
<ul>
<li>用户编写的程序按照虚拟地址存放在辅存中，程序运行时，由地址变换机构依据当时分配给该程序的物理地址空间把程序的一部分调入实存</li>
</ul>
</li>
<li><p>cache - 主存和主存 - 虚拟内存的异同</p>
<ul>
<li>相同点：都是为了提高系统的性能价格比而进行的分层，都利用了局部性原理将经常访问的数据块调入容量小速度快的存储器</li>
<li>不同点：<ul>
<li>cache - 主存主要是解决 CPU 与主存速度不匹配问题，主存 - 虚拟内存主要是为了解决存储容量、管理、分配、保护等问题</li>
<li>透明性也不同，cache 是由硬件管理的，设置不暴露给系统程序员</li>
<li>未命中处罚不同：cache 的速度是主存的 5 - 10 倍，主存是辅存的 1000 倍</li>
</ul>
</li>
</ul>
</li>
<li><p>页式虚拟地址映射</p>
<ul>
<li><p>虚拟地址由逻辑页号和偏移量组成，物理地址由物理页号和偏移量组成，偏移量是相同的，而页号可能长度都不同</p>
</li>
<li><p>每个进程都有一个页表，逻辑页号 + 页表基址找到相应的物理页号，物理页号 + 偏移量 &#x3D; 物理地址</p>
<style>.sxrfpzlkhjtm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526154921194.png" class="sxrfpzlkhjtm" alt="image-20240526154921194">

<style>.qhlepbeckohr{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526154941193.png" class="qhlepbeckohr" alt="image-20240526154941193">
</li>
<li><p>每个进程的页表的页数都不是固定的，有的进程页表可能很大，解决方案</p>
<ul>
<li>一些系统把页表存储在虚存中，因而页表本身也要进行分页。当一个进程运行时，其页表中一部分在主存中，另一部分则在辅存中保存</li>
<li>二级页表结构。每个进程有一个页目录表，其中的每个表项指向一个页表。若页目录表的长度（表项数）是 m，每个页表的最大长度（表项数）为 n，则一个进程最多可以有 m×n 个页</li>
<li>反向页表实现物理页号到逻辑页号的反向映射</li>
</ul>
</li>
<li><p>页表是虚地址到主存物理地址的变换表，通常称为内页表</p>
</li>
<li><p>外页表是用于虚地址与辅存地址之间的变换，主存缺页时就会用到</p>
</li>
<li><p>转换后援缓冲器 TLB</p>
<ul>
<li><p>把页表中的最活跃的部分存放在高 速存储器中，组成快表</p>
<style>.kxihtvpcekwf{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526155823138.png" class="kxihtvpcekwf" alt="image-20240526155823138">
</li>
<li><p>可能的情况</p>
<style>.terfdddoezqf{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526155856547.png" class="terfdddoezqf" alt="image-20240526155856547"></li>
</ul>
</li>
</ul>
</li>
<li><p>段式虚拟存储器</p>
<ul>
<li><p>把代码、数据、堆、栈等不同类型的数据划分到不同的段中</p>
</li>
<li><p>虚地址由段号、偏移量组成，每一个程序一个段表，段表的每一个表项对应一个段。段表常驻主存</p>
</li>
<li><p>每个表项包含：</p>
<ul>
<li>有效位：该段是否调入主存</li>
<li>段基址：该段在主存中的起始地址</li>
<li>段长：该段的实际长度，防止访问越界</li>
</ul>
</li>
<li><style>.xoyqlncwujkq{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526160420104.png" class="xoyqlncwujkq" alt="image-20240526160420104">
</li>
<li><p>分段易于管理，便于共享，但需要更多的硬件支持</p>
</li>
</ul>
</li>
<li><p>段页式虚拟存储器</p>
<ul>
<li><p>上面两者的结合，每个程序则先按逻辑结构分段， 每段再按照实存的页大小分页</p>
</li>
<li><p>虚拟地址构成</p>
<img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526160833463.png" class="" title="image-20240526160833463">
</li>
<li><p>基号 N 找到段表，段号 S 找到页表，页号找到物理页号，物理页号 + 偏移量 D &#x3D; 物理地址</p>
<style>.iwvcdnafjhyo{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161114148.png" class="iwvcdnafjhyo" alt="image-20240526161114148"></li>
</ul>
</li>
</ul>
<style>.oizfuigqdkhb{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161134274.png" class="oizfuigqdkhb" alt="image-20240526161134274">

<blockquote>
<p>这些表项中都应该有一个有效位的</p>
</blockquote>
<ul>
<li><style>.isnrfngfhbkv{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161912949.png" class="isnrfngfhbkv" alt="image-20240526161912949">

<style>.cowqnucrlgab{zoom: 50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161928436.png" class="cowqnucrlgab" alt="image-20240526161928436">

<style>.ktyfhhmrjilj{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240526161957376.png" class="ktyfhhmrjilj" alt="image-20240526161957376">
</li>
<li><p>虚拟内存的替换算法</p>
<ul>
<li><p>当从辅存调页至主存而主存已满时，也需要进行主存页面的替换</p>
</li>
<li><p>替换算法与 cache 的替换算法类似：FIFO 算法、LRU 算法、LFU 算法</p>
</li>
<li><p>不同点</p>
<ul>
<li>cache 的替换全部靠硬件实现，而虚拟存储器的替换有操作系统的支持</li>
<li>虚存缺页对系统性能的影响比 cache未命中要大得多</li>
</ul>
</li>
<li><p>FIFO+LRU 算法是对 FIFO 算法的一种改进，如果某个页面命中，则将该页面移动到 FIFO 队列入口位置。因为局部性原理，刚被访问的页面在最近的将来被再次访问的概率较大，故将其被替换的时间延后</p>
</li>
</ul>
</li>
</ul>
<h2 id="奔腾系列机的虚存组织"><a href="#奔腾系列机的虚存组织" class="headerlink" title="奔腾系列机的虚存组织"></a>奔腾系列机的虚存组织</h2><ul>
<li>略</li>
</ul>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令系统的发展与性能要求"><a href="#指令系统的发展与性能要求" class="headerlink" title="指令系统的发展与性能要求"></a>指令系统的发展与性能要求</h2><ul>
<li><p>指令就是要计算机执行的某种操作，分为：微指令（硬件），宏指令（软件），机器指令（我们要讨论的）</p>
<ul>
<li>一台计算机的所有机器指令的集合就是它的指令系统</li>
</ul>
</li>
<li><p>指令系统的发展：复杂指令系统 CISC，精简指令系统 RISC</p>
</li>
<li><p>指令系统的性能要求：完备性、有效性、规整性、兼容性</p>
</li>
<li><p>高级语言：与计算机的硬件结构和指令系统无关</p>
</li>
<li><p>低级语言：机器语言（二进制语言），汇编语言（符号语言）：依赖于硬件和指令系统</p>
</li>
</ul>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><ul>
<li><p>指令格式包括操作码字段、地址码字段</p>
</li>
<li><p>操作码：不同的操作码字段表示该指令应进行什么性质的操作</p>
<ul>
<li>组成操作码字段的位数一般取决于计算机指令系统的规模</li>
</ul>
</li>
<li><p>地址码：根据一条指令有几个操作数地址，可以将该指令称为几操作数指令 &#x2F; 几地址指令</p>
<ul>
<li>一般的操作数有被操作数、操作数、操作结果</li>
<li>分为：三地址指令、二地址指令、单地址指令、零地址指令</li>
<li>二地址指令根据操作数的物理位置又分为：存储器 - 存储器，寄存器 - 存储器，寄存器 - 寄存器</li>
</ul>
</li>
<li><p>指令字长度：指令包含的二进制位数</p>
<ul>
<li>机器字长：计算机能直接处理的二进制位数</li>
<li>所以分为：单字长指令、半字长指令、双字长指令</li>
</ul>
</li>
<li><p>指令助记符：为了便于书写和阅读程序，每条指令通常用 3个或 4 个英文缩写字母来表示二进制操作码</p>
</li>
</ul>
<h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><ul>
<li>地址数据：地址也是一种形式上的数据</li>
<li>数值数据分为：定点正数、小数，浮点数，BCD</li>
<li>字符数据：ASCLL</li>
<li>逻辑数据：一个单元中有几位二进制 bit 项组成</li>
</ul>
<h2 id="指令和数据的寻址方式"><a href="#指令和数据的寻址方式" class="headerlink" title="指令和数据的寻址方式"></a>指令和数据的寻址方式</h2><ul>
<li><p>寻址方式是指 CPU 根据指令中给出的地址码字段寻找相应的操作数的方式</p>
</li>
<li><p>指令的寻址分为：顺序寻址、条约寻址</p>
<style>.owrjwvrouzli{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527204803749.png" class="owrjwvrouzli" alt="image-20240527204803749">
</li>
<li><p>操作数寻址的基本方式</p>
<ul>
<li><p>把操作数形式地址变为操作数有效地址的过程</p>
<style>.ishubboerskb{zoom: 67%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527204943758.png" class="ishubboerskb" alt="image-20240527204943758">
</li>
<li><p>隐含寻址：没有明确给出操作数的地址，而是以某些默认寄存器作为源&#x2F;目的寄存器</p>
</li>
<li><p>立即寻址：指令中在操作码字段后面的部分不是操作数地址，而是操作数本身，又称为立即数</p>
<ul>
<li>不够灵活，不容易修改且受到指令字长的限制，常用于给某一寄存器或主存单元赋初值，或用于提供一个常数</li>
</ul>
</li>
<li><p>直接寻址：指令中地址码字段给出的地址就是操作数的有效地址</p>
</li>
<li><p>间接寻址：指令的地址码部分给出的地址存放操作数地址的主存单元的地址，简称操作数地址的地址</p>
<ul>
<li>灵活，不必修改指令，但效率低下，至少需要两次访问主存储器才能取出操作数</li>
</ul>
</li>
<li><p>寄存器寻址：指令的地址码部分给出 CPU 内某一通用寄存器的编号，指令的操作数存放在相应的寄存器中</p>
<ul>
<li>访问快，且减少地址码字段长度</li>
</ul>
</li>
<li><p>寄存器间接寻址：操作数放在主存储器中，而操作数的地址放在某一通用寄存器中，指令的地址码部分给出该通用寄存器的编号</p>
<ul>
<li>解决了间接寻址慢的问题，灵活且只需要一次访问主存，被广泛使用</li>
</ul>
</li>
<li><p>偏移寻址：分为相对寻址、基址寻址、变址寻址</p>
<ul>
<li><p>相对寻址：由程序计数器 PC 提供基准地址，而指令的地址码部分给出相对的位移量 D，两者相加后作为操作数的有效地址</p>
<style>.wublyfmvtqfg{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210450839.png" class="wublyfmvtqfg" alt="image-20240527210450839">
</li>
<li><p>基址寻址：指令的地址码部分给出偏移量，而基准地址放在基址寄存器中，基准地址与偏移量相加得到有效地址</p>
<style>.ckekoyimnumc{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210619747.png" class="ckekoyimnumc" alt="image-20240527210619747">
</li>
<li><p>变址寻址：将指令的地址码部分给出的基准地址与 CPU 内某特定的变址寄存器中的偏移量相加，以形成操作数的有效地址</p>
<ul>
<li><p>被广泛使用，在遇到需要频繁修改操作数地址时，无须修改指令，只要修改寄存器中的变址值就可以了</p>
<style>.pwmpbvqojvln{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527210803495.png" class="pwmpbvqojvln" alt="image-20240527210803495"></li>
</ul>
</li>
</ul>
</li>
<li><p>段寻址：内存空间被划分为多段</p>
<style>.qweyykdnlkyp{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527211512391.png" class="qweyykdnlkyp" alt="image-20240527211512391">
</li>
<li><p>堆结构：分为硬堆栈（专用寄存器），软堆栈（主存储器中）</p>
<ul>
<li>作用：实现程序调用，子程序嵌套调用和递归调用；实现中断，保存现场</li>
</ul>
</li>
<li><p>总结</p>
<style>.shnjiyedcgqt{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240527211955003.png" class="shnjiyedcgqt" alt="image-20240527211955003"></li>
</ul>
</li>
</ul>
<h2 id="典型指令"><a href="#典型指令" class="headerlink" title="典型指令"></a>典型指令</h2><ul>
<li><p>简单分类：</p>
<ul>
<li>数据传送类指令：一般传送指令，数据交换指令，堆栈操作指令</li>
<li>运算类指令：算术运算指令，逻辑运算指令，移位指令</li>
<li>程序控制类指令、输入输出指令、字符串处理指令 ……</li>
</ul>
</li>
<li><p>复杂指令集计算机 CISC</p>
<ul>
<li><p>28 定律：CISC 中大约有 20% 的指令使用占据了 80% 的处理机时间，而有 80% 的不常用指令只占用处理机的 20% 时间</p>
</li>
<li><p>特征：</p>
<ul>
<li>使用微代码：指令集可以直接在微代码内存（比主内存的速度快很多）里执行</li>
<li>庞大的指令集，通过增强指令系统的功能，简化了软件，增加了硬件的复杂程度</li>
<li>高级语言对应的指令集</li>
</ul>
</li>
<li><p>优点：能够有效缩短新指令的微代码设计时间，允许设计师实现 CISC 体系机器的向上兼容</p>
</li>
<li><p>缺点：设计越来越复杂，不同的指令，需要不同的时钟周期来完成，执行较慢的指令，将影响整台机器的执行效</p>
</li>
</ul>
</li>
<li><p>精简指令集计算机 RISC</p>
<ul>
<li>指令系统应当只包含那 些使用频率很高的少量指令。并提供一些必要的指令以支持操作系统和高级语言</li>
<li>特征（采用流水线技术）：<ul>
<li>指令条数少；简单而统一格式的指令译码；简单的寻址方式</li>
<li>大部分指令可以单周期执行； 只有LOAD&#x2F;STORE可以访问存储器；较多的寄存器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><h2 id="CPU-的功能和组成"><a href="#CPU-的功能和组成" class="headerlink" title="CPU 的功能和组成"></a>CPU 的功能和组成</h2><ul>
<li><p>CPU 的功能就是取指令和执行指令</p>
</li>
<li><p>CPU 的基本组成</p>
<ul>
<li><p>运算器：ALU、通用寄存器、数据缓冲寄存器、状态字寄存器</p>
<ul>
<li>功能：接受控制器的命令而进行操作</li>
</ul>
</li>
<li><p>控制器：程序计数器、指令寄存器、地址寄存器 ……</p>
<ul>
<li>功能：对指令进行译码或测试，并产生相应的操作控制信号</li>
</ul>
</li>
<li><p>cache</p>
</li>
</ul>
</li>
<li><p>CPU 的主要寄存器</p>
<ul>
<li><p>数据缓冲寄存器 DR：作为 ALU 运算结果和通用寄存器之间信息传送中时间上的缓冲</p>
</li>
<li><p>指令寄存器 IR、指令译码器 ID：存放从存储器中取出的待执行的指令，暂存的指令只有经译码后才能识别出是一条什么样的指令</p>
<ul>
<li>译码器经过对指令进行分析和解释，产生相应的控制信号</li>
</ul>
</li>
<li><p>程序计数器 PC：用来存放正在执行的指令的地址或接着将要执行的下一条指令的地址</p>
</li>
<li><p>数据地址寄存器 AR：保存当前 CPU 访问的数据在 cache 中单元的地址</p>
</li>
<li><p>通用寄存器 R0 ~ R3：可存放源操作数、结果操作数</p>
</li>
<li><p>状态字寄存器 PSW：保存由算术指令和逻辑指令运算或测试结果、中断或系统工作状态等信息</p>
</li>
</ul>
</li>
<li><p>操作控制器和时序产生器</p>
<ul>
<li><p>数据通路：寄存器之间传送信息的通路</p>
</li>
<li><p>操作控制器：为数据通路的建立提供各种操作信号。可分为时序逻辑型和存储逻辑型</p>
<ul>
<li>硬布线控制器：采用时序逻辑技术实现</li>
<li>微程序控制器：采用存储逻辑来实现</li>
</ul>
</li>
<li><p>时序产生器：提供定时和时序信号对各种操作信号实施时间上的控制</p>
</li>
</ul>
</li>
</ul>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><ul>
<li><p>指令周期：取指指令、分析指令到执行完该指令所需的全部时间</p>
</li>
<li><p>机器周期：通常又称 CPU 周期、时钟周期，通常把一条指令周期划分为若干个机器周期，每个机器周期完成一个基本操作</p>
<ul>
<li>不同的指令，可能包含不同数目的机器周期</li>
</ul>
</li>
<li><p>一个机器周期中，包含若干个 T 周期（节拍脉冲或 T 脉冲， 处理操作的最基本单位）</p>
</li>
</ul>
<style>.serxtxwcivxt{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192515259.png" class="serxtxwcivxt" alt="image-20240528192515259">

<ul>
<li><p>MOV 指令的指令周期</p>
<style>.zjhongtgovcm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192643133.png" class="zjhongtgovcm" alt="image-20240528192643133">
</li>
<li><p>LAD 指令的指令周期：它的数据传 送方向是从内存到寄存器</p>
</li>
</ul>
<style>.xsrjbdnbdpez{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192751788.png" class="xsrjbdnbdpez" alt="image-20240528192751788">

<ul>
<li><p>ADD 指令的指令周期</p>
<style>.xmmsofiofpyt{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192845807.png" class="xmmsofiofpyt" alt="image-20240528192845807">
</li>
<li><p>STO 指令的指令周期：将寄存器或立即数中的值存储到指定的内存地址</p>
</li>
</ul>
<style>.jduthgfhiemd{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192931988.png" class="jduthgfhiemd" alt="image-20240528192931988">

<ul>
<li>JMP 指令的指令周期</li>
</ul>
<style>.phgvvgxfxouk{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528192954705.png" class="phgvvgxfxouk" alt="image-20240528192954705">

<ul>
<li>方框图语言表示指令周期<ul>
<li>方框：按CPU周期；方框内内容：数据通路操作或控制操作；菱形符号：判别或测试</li>
</ul>
</li>
</ul>
<style>.euvoqlwwlcft{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528193103420.png" class="euvoqlwwlcft" alt="image-20240528193103420">

<ul>
<li>一条指令包括一个取指令周期和一个及一 个以上的执行周期组成</li>
</ul>
<h2 id="时序产生器和控制方式"><a href="#时序产生器和控制方式" class="headerlink" title="时序产生器和控制方式"></a>时序产生器和控制方式</h2><ul>
<li><p>时序产生器的作用：CPU 中的控制器用它指挥机器的工作，可以辨别从内存中取出的是指令还是数据</p>
</li>
<li><p>时序产生器的体制：电位—脉冲制</p>
</li>
<li><p>硬布线控制器</p>
<ul>
<li>时序信号采用主状态周期、节拍电位、节拍脉冲三级体制</li>
<li>一个节拍电位表示一个 CPU 周期，包含多个节拍脉冲</li>
<li>一个主状态周期包含多个节拍电位</li>
</ul>
</li>
<li><p>微程序控制器</p>
<ul>
<li>时序信号采用节拍电位（1个）、节拍脉冲（多个）二级体制</li>
</ul>
</li>
<li><p>时序产生器的功能：用逻辑电路来产生时序信号</p>
</li>
<li><p>控制方式：控制不同操作序列时序信号的方法，主要有以下几种</p>
<ul>
<li>同步控制方式：指令的机器周期和时钟周期数不变</li>
<li>异步控制方式：每条指令需要多长时间就占多长时间</li>
<li>联合控制方式：大部分指令在固定的周期内完成，少数难以确定的操作采用异步方式 <ul>
<li>机器周期的节拍脉冲固定，但是各指令的机器周期数不固定（微程序控制器采用）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><ul>
<li><p>基本思想：把操作控制信号编制成微指令，存放到控制存储器里，运行时，从控存中取出微指令，产生指令运行所需的操作控制信号</p>
<ul>
<li>以设计软件的方法设计硬件</li>
</ul>
</li>
<li><p>微命令：构成控制序列的最小单位，控制器件向执行部件发出的各种控制命令</p>
</li>
<li><p>微操作：微命令的操作过程，微操作是执行部件中最基本的操作，分为两类</p>
<ul>
<li>互斥的微操作：不能在同一 CPU 周期并行执行的微操作</li>
<li>相容的微操作：能够在同一 CPU 周期并行执行的微操作</li>
</ul>
</li>
<li><p>微指令：把在同一 CPU 周期内并行执行的微操作控制信息，存储在控制存储器里，称为一条微指令。分为两部分</p>
<ul>
<li><p>操作控制字段：又称微操作码字段，用以产生某一步操作所需的各个微操作控制信号。</p>
<ul>
<li>某位为 1 表明发微命令。微指令持续时间为一个 CPU 周期</li>
</ul>
</li>
<li><p>顺序控制字段：又称微地址码字段，用以控制产生下一条要执行的微指令地址</p>
</li>
</ul>
</li>
<li><p>微程序：一系列微指令的有序集合就是微程序。，一段微程序对应一条机器指令</p>
</li>
<li><p>微地址：存放微指令的控制存储器的单元地址</p>
</li>
<li><p>一些相关的寄存器</p>
<ul>
<li>控制存储器 μCM：这是微程序控制器的核心部件，用来存放微程序</li>
<li>微指令寄存器 μIR：用来存放从 μCM 取出的正在执行的微指令</li>
<li>微命令寄存器：用来保存一条微指令的操作控制字段和判别测试字段的信息</li>
<li>微地址寄存器 μMAR：决定将要访问的下一条微指令的地址</li>
</ul>
</li>
<li><p>CPU 周期与微指令的周期之间的关系</p>
<ul>
<li>微指令周期等于读出微指令的时间加上执行该条微指令的时间</li>
<li>一个微指令周期时间设计恰好和 CPU 周期时间相等</li>
</ul>
</li>
<li><p>微程序设计技术</p>
<ul>
<li><p>微命令的编码方法</p>
<ul>
<li><p>直接表示法：操作控制字段中的各位分别可以直接控制计算机，不需要进行译码</p>
<style>.qfeiovctcmxb{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203758900.png" class="qfeiovctcmxb" alt="image-20240528203758900">
</li>
<li><p>编码表示法：将操作控制字段分为若干个小段，每段内采用最短编码法，段与段之间采用直接控制法</p>
<style>.nexqpbqbswns{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203904975.png" class="nexqpbqbswns" alt="image-20240528203904975">
</li>
<li><p>混合编码法：两者的结合</p>
<style>.oxueowqmnhpu{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528203943373.png" class="oxueowqmnhpu" alt="image-20240528203943373">
</li>
<li><p>编码的原则</p>
<ul>
<li>把互斥性的微命令分在同一段内，兼容性的微命令分在不同段内</li>
<li>每个小段中包含的信息位不能太多</li>
<li>一般每个小段还要留出一个状态，表示本字段不发出任何微命令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.sdjfpslzemni{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204109642.png" class="sdjfpslzemni" alt="image-20240528204109642">

<ul>
<li><style>.obcwlmztovpa{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204129483.png" class="obcwlmztovpa" alt="image-20240528204129483"></li>
</ul>
<style>.mmwbmwlelidh{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204143019.png" class="mmwbmwlelidh" alt="image-20240528204143019">

<style>.ulfflfxwhjnl{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528204156706.png" class="ulfflfxwhjnl" alt="image-20240528204156706">

<ul>
<li><p>微指令地址的形成</p>
<ul>
<li>入口地址：每条机器指令对应一段微程序，由机器指令的操作码字段指出各段微程序的入口地址。主要方式有<ul>
<li>计数器的方式：微程序控制器中也有一个微程序计数器 μPC，一般情况下都是将微地址寄存器 μMAR 作为 μPC</li>
<li>多路转移的方式</li>
</ul>
</li>
</ul>
</li>
<li><p>微指令的格式，分为</p>
<ul>
<li><p>水平型微指令：指一次能定义并能并行执行多个微命令的微指令</p>
<ul>
<li>并行能力强，速度快，但难以掌握</li>
</ul>
</li>
<li><p>垂直型微指令：采用编码方式，一次只能执行一到二个微命令</p>
<ul>
<li>速度慢，相较而言容易掌握</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h2><ul>
<li><p>实现方法：通过逻辑电路直接连线而产生的，又称为组合逻辑控制方式</p>
</li>
<li><p>设计目标：使用最少元件，速度最高</p>
</li>
<li><p>指令的执行流程</p>
<style>.ghgyfalyxpus{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528210718631.png" class="ghgyfalyxpus" alt="image-20240528210718631">
</li>
<li><p>微信号的产生</p>
<ul>
<li>在微程序控制器中，微操作控制信号由微指令产生</li>
<li>在硬联线控制器中，某一微操作控制信号由布尔代数表达式描述的输出函数产生<ul>
<li>设计步骤<ul>
<li>画出指令流程图，列出微操作时间表，进行微操作信号的综合，实现电路</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="传统-CPU"><a href="#传统-CPU" class="headerlink" title="传统 CPU"></a>传统 CPU</h2><ul>
<li>略</li>
</ul>
<h2 id="流水-CPU"><a href="#流水-CPU" class="headerlink" title="流水 CPU"></a>流水 CPU</h2><ul>
<li><p>并行性：具有可以同时进行运算或操作的特性，在同一时刻或在同一时间间隔内完成两种或两种以上的工作，他们在时间上相互重叠，都体现了并行性</p>
<ul>
<li>时间并行（重叠）：让多个处理过程在时间上相互错开，轮流使用同一套硬件设备的各个部件， 实现方式就是采用流水处理</li>
<li>空间并行（资源重复）：以数量取胜，</li>
<li>时间+空间并行：超标量流水线技术它能真正的体现同时性</li>
</ul>
</li>
<li><p>流水线的分类：指令流水线（按照指令步骤的并行）、算术流水线（按照运算操作步骤的并行）、处理机流水线（按照程序步骤的并行）</p>
</li>
<li><p>流水线中的主要问题</p>
<ul>
<li><p>资源相关：多条指令进入流水线后在同一时钟周期内争用同一功能部件</p>
<ul>
<li>解决办法：后边指令拖一拍再推进；增设一个功能部件</li>
</ul>
</li>
<li><p>数据相关</p>
<ul>
<li>RAW (Read After Write)：后面指令用到前面指令所写的数据</li>
<li>WAW (Write After Write)：两条指令写同一个单元（在简单流水线中没有此类相关，因为不会乱序执行）</li>
<li>WAR (Write After Read)：后面指令覆盖前面指令所读的单元（在简单流水线中没有此类相关）</li>
<li>解决办法： 可以推后后继指令对相关单元的读操作</li>
</ul>
</li>
<li><p>控制相关 </p>
<ul>
<li>引起原因：转移指令</li>
<li>解决办法：延迟转移法，转移预测法</li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.rcawhrsnigwz{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240528213126274.png" class="rcawhrsnigwz" alt="image-20240528213126274">

<h1 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h1><h2 id="总线的概念和结构形态"><a href="#总线的概念和结构形态" class="headerlink" title="总线的概念和结构形态"></a>总线的概念和结构形态</h2><ul>
<li><p>总线的基本概念：总线是构成计算机系统的互联机构，是多个系统功能部件之间进行数据传送的公共通路</p>
</li>
<li><p>总线的分类</p>
<ul>
<li>内部总线：CPU 内部连接各寄存器及运算器部件之间的总线</li>
<li>系统总线：外部总线，CPU 和计算机系统中其他高速功能部件相互连接的总线</li>
<li>I&#x2F;O总线：中低速 I&#x2F;O 设备相互连接的总线</li>
</ul>
</li>
<li><p>总线的特性</p>
<ul>
<li>物理特性：总线的物理连接方式</li>
<li>功能特性：每根线的功能</li>
<li>电气特性：每根线上信号的传递方向及有效电平范围</li>
<li>时间特性：规定了每根总线在什么时间有效</li>
</ul>
</li>
<li><p>总线标准</p>
<ul>
<li>由于标准化，不同厂家生产的内部实现不同但功能相同的功能部件可以互换使用</li>
<li>已经出现了很多总线标准：PCI、ISA</li>
</ul>
</li>
<li><p>总线带宽：总线本身所能达到的最高传输速率</p>
<ul>
<li>一次操作可以传输的数据位数（MB&#x2F;s），如 S100 为 8 位，ISA 为 16 位，EISA 为 32 位，PCI 可达 64 位</li>
<li>总线宽度不会超过微处理器外部数据总线的宽度</li>
</ul>
</li>
<li><style>.qivthddqvvyh{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529180641225.png" class="qivthddqvvyh" alt="image-20240529180641225">
</li>
<li><p>单机系统中总线的基本结构</p>
<ul>
<li><p>单总线：使用一条单一的系统总线来连接 CPU、内存和 I&#x2F;O 设备</p>
<ul>
<li><p>要求连接到总线上的逻辑部件必须高速运行；而当不再使用总线时，能迅速放弃总线控制权</p>
<style>.cevbhbgkswib{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529180852668.png" class="cevbhbgkswib" alt="image-20240529180852668"></li>
</ul>
</li>
<li><p>多总线：在 CPU、主存、I&#x2F;O 之间互联采用多条总线</p>
<ul>
<li><style>.mvgxbbahhybb{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181002510.png" class="mvgxbbahhybb" alt="image-20240529181002510"></li>
</ul>
</li>
</ul>
</li>
<li><p>总线的内部结构</p>
<ul>
<li><p>早期是处理器芯片引脚的延伸，是处理器与 I&#x2F;O 设备适配器的通道</p>
<ul>
<li>总线结构紧密与 CPU 相关，通用性较差</li>
</ul>
</li>
<li><p>当代流行的内部结构</p>
<ul>
<li><style>.dqhnyicnnaji{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181527522.png" class="dqhnyicnnaji" alt="image-20240529181527522"></li>
</ul>
</li>
</ul>
</li>
<li><p>现代大多数计算机采用了分层次的多总线结构，三层次：CPU总线、PCI 总线和 ISA 总线</p>
<style>.dpowlhhqosgm{zoom:50%;}</style><img src="/2024/05/23/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/image-20240529181604088.png" class="dpowlhhqosgm" alt="image-20240529181604088"></li>
</ul>
<h2 id="总线接口"><a href="#总线接口" class="headerlink" title="总线接口"></a>总线接口</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%8D%E4%B9%A0/" rel="tag"># 复习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/18/Java-%E5%A4%8D%E4%B9%A0/" rel="prev" title="Java 复习">
      <i class="fa fa-chevron-left"></i> Java 复习
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">计算机的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2"><span class="nav-number">1.2.</span> <span class="nav-text">计算机发展简史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%A1%AC%E4%BB%B6"><span class="nav-number">1.3.</span> <span class="nav-text">计算机的硬件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="nav-number">1.4.</span> <span class="nav-text">计算机的软件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">计算机系统的层次结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8%E5%92%8C%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">运算器和运算方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%96%87%E5%AD%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">数据与文字的表示方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E5%8A%A0%E6%B3%95%E3%80%81%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-number">2.2.</span> <span class="nav-text">定点加法、减法运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-number">2.3.</span> <span class="nav-text">定点乘法运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-number">2.4.</span> <span class="nav-text">定点除法运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E8%BF%90%E7%AE%97%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">2.5.</span> <span class="nav-text">定点运算器的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E5%99%A8"><span class="nav-number">2.6.</span> <span class="nav-text">浮点运算方法和浮点运算器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">内部存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">存储器概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SRAM-%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.2.</span> <span class="nav-text">SRAM 存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DRAM-%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">DRAM 存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88ROM%EF%BC%89%E5%92%8C%E9%97%AA%E9%80%9F%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88EPROM%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">只读存储器（ROM）和闪速存储器（EPROM）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.5.</span> <span class="nav-text">并行存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cache-%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.6.</span> <span class="nav-text">Cache 存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.7.</span> <span class="nav-text">虚拟存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%94%E8%85%BE%E7%B3%BB%E5%88%97%E6%9C%BA%E7%9A%84%E8%99%9A%E5%AD%98%E7%BB%84%E7%BB%87"><span class="nav-number">3.8.</span> <span class="nav-text">奔腾系列机的虚存组织</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.</span> <span class="nav-text">指令系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%A6%81%E6%B1%82"><span class="nav-number">4.1.</span> <span class="nav-text">指令系统的发展与性能要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">指令格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.3.</span> <span class="nav-text">操作数类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">4.4.</span> <span class="nav-text">指令和数据的寻址方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E6%8C%87%E4%BB%A4"><span class="nav-number">4.5.</span> <span class="nav-text">典型指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">中央处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU-%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%BB%84%E6%88%90"><span class="nav-number">5.1.</span> <span class="nav-text">CPU 的功能和组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="nav-number">5.2.</span> <span class="nav-text">指令周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E5%BA%8F%E4%BA%A7%E7%94%9F%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">5.3.</span> <span class="nav-text">时序产生器和控制方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">5.4.</span> <span class="nav-text">微程序控制器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">5.5.</span> <span class="nav-text">硬布线控制器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F-CPU"><span class="nav-number">5.6.</span> <span class="nav-text">传统 CPU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4-CPU"><span class="nav-number">5.7.</span> <span class="nav-text">流水 CPU</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.</span> <span class="nav-text">总线系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BB%93%E6%9E%84%E5%BD%A2%E6%80%81"><span class="nav-number">6.1.</span> <span class="nav-text">总线的概念和结构形态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.2.</span> <span class="nav-text">总线接口</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
