<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="调度 任何操作系统运行的进程数量都可能超过计算机的 CPU 数量，因此需要制定一个方案，在各进程之间分时共享 CPU 理想情况下，这种共享对用户进程是透明的。一种常见的方法是通过将进程复用到硬件 CPU 上，给每个进程提供它有自己的虚拟 CPU 的假象。本章解释 xv6 如何实现这种复用    Multiplexing 多路复用 xv6 通过在两种情况下将 CPU 从一个进程切换到另一个进程来实现">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6 book chapter 7">
<meta property="og:url" content="http://yiweiboi.github.io/2024/06/23/xv6-book-chapter-7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="调度 任何操作系统运行的进程数量都可能超过计算机的 CPU 数量，因此需要制定一个方案，在各进程之间分时共享 CPU 理想情况下，这种共享对用户进程是透明的。一种常见的方法是通过将进程复用到硬件 CPU 上，给每个进程提供它有自己的虚拟 CPU 的假象。本章解释 xv6 如何实现这种复用    Multiplexing 多路复用 xv6 通过在两种情况下将 CPU 从一个进程切换到另一个进程来实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yiweiboi.github.io/2024/06/23/xv6-book-chapter-7/Figure-7.1.png">
<meta property="article:published_time" content="2024-06-23T09:43:02.000Z">
<meta property="article:modified_time" content="2024-07-06T10:44:16.965Z">
<meta property="article:author" content="yiweiBoi">
<meta property="article:tag" content="6.s081">
<meta property="article:tag" content="xv6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yiweiboi.github.io/2024/06/23/xv6-book-chapter-7/Figure-7.1.png">

<link rel="canonical" href="http://yiweiboi.github.io/2024/06/23/xv6-book-chapter-7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>xv6 book chapter 7 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/23/xv6-book-chapter-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          xv6 book chapter 7
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-23 17:43:02" itemprop="dateCreated datePublished" datetime="2024-06-23T17:43:02+08:00">2024-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-06 18:44:16" itemprop="dateModified" datetime="2024-07-06T18:44:16+08:00">2024-07-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><ul>
<li>任何操作系统运行的进程数量都可能超过计算机的 CPU 数量，因此需要制定一个方案，在各进程之间分时共享 CPU<ul>
<li>理想情况下，这种共享对用户进程是透明的。一种常见的方法是通过将进程复用到硬件 CPU 上，给每个进程提供它有自己的虚拟 CPU 的假象。本章解释 xv6 如何实现这种复用</li>
</ul>
</li>
</ul>
<h2 id="Multiplexing-多路复用"><a href="#Multiplexing-多路复用" class="headerlink" title="Multiplexing 多路复用"></a>Multiplexing 多路复用</h2><ul>
<li><p>xv6 通过在两种情况下将 CPU 从一个进程切换到另一个进程来实现复用</p>
<ul>
<li>首先，xv6 的 <strong>sleep</strong> 和 <strong>wakeup</strong> 机制会进行切换，这会发生在进程等待设备或管道 I&#x2F;O，或等待子进程退出，或在 <strong>sleep</strong> 系统调用中等待</li>
<li>其次，xv6 周期性地强制切换，以应对长时间不进行 sleep 操作的计算进程</li>
<li>这种复用造成了每个进程都有自己的 CPU 的假象，就像 xv6 使用内存分配器和硬件页表造成每个进程都有自己的内存的假象一样</li>
</ul>
</li>
<li><p>实现复用会有一些挑战</p>
<ul>
<li>首先，如何从一个进程切换到另一个进程？虽然上下文切换的想法很简单，但在 xv6 的实现中上下文切换却是最不透明的代码之一</li>
<li>第二，如何以对用户进程透明的方式进行强制切换？xv6 采用标准通用的方式，用定时器中断来驱动上下文切换</li>
<li>第三，许多 CPU 可能会在进程间并发切换，需要设计一个锁来避免竞争</li>
<li>第四，当进程退出时，必须释放进程的内存和其他资源，但进程本身不能完全释放掉所有的资源，比如它不能在使用内核栈的同时释放自己的内核栈</li>
<li>第五，多核机器的每个内核必须记住它正在执行的进程，这样系统调用才能修改相应进程的内核状态</li>
<li>最后，<strong>sleep</strong> 和 <strong>wakeup</strong> 允许一个进程放弃 CPU，并睡眠等待某一事件，并允许另一个进程将睡眠的进程唤醒。需要注意一些竞争可能会使唤醒丢失</li>
<li>xv6 试图尽可能简单地解决这些问题，尽管如此，实际代码还是很棘手</li>
</ul>
</li>
</ul>
<h2 id="Code-Context-switching-上下文切换"><a href="#Code-Context-switching-上下文切换" class="headerlink" title="Code: Context switching 上下文切换"></a>Code: Context switching 上下文切换</h2><img src="/2024/06/23/xv6-book-chapter-7/Figure-7.1.png" class="" title="Figure-7.1">

<ul>
<li><p>图 7.1 概述了从一个用户进程切换到另一个用户进程所涉及的步骤：用户-内核的切换（通过系统调用或中断）到旧进程的内核线程，上下文（context）切换到当前 CPU 的调度器线程，上下文（context）切换到新进程的内核线程，以及 trap 返回到用户级进程</p>
<ul>
<li>xv6 调度器在每个 CPU 上有一个专门的线程 (保存了寄存器和栈)，因为调度器在旧进程的内核栈上执行是不安全的：因为其他核心可能会唤醒该进程并运行它，而在两个不同的核心上使用相同的栈将是一场灾难</li>
<li>在本节中，我们将研究在内核线程和调度线程之间切换的机制</li>
</ul>
</li>
<li><p>从一个线程切换到另一个线程，需要保存旧线程的 CPU 寄存器，并恢复新线程之前保存的寄存器；栈指针和 pc 被保存和恢复，意味着 CPU 将切换栈和正在执行的代码</p>
</li>
<li><p>函数 <strong>swtch</strong> 执行内核线程切换的保存和恢复。<strong>swtch</strong> 并不直接知道线程，它只是保存和恢复寄存器组，称为 **上下文(context)**。当一个进程要放弃 CPU 的时候，进程的内核线程会调用 <strong>swtch</strong> 保存自己的上下文并返回到调度器上下文</p>
<ul>
<li><p>每个上下文都包含在一个结构体 <strong>context(kernel&#x2F;proc.h:2)</strong> 中，它本身包含在进程的结构体 <strong>proc</strong> 或 CPU 的结构体 <strong>cpu</strong> 中</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">uint64 ra;</span><br><span class="line">uint64 sp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// callee-saved</span></span><br><span class="line">uint64 s0;</span><br><span class="line">uint64 s1;</span><br><span class="line">uint64 s2;</span><br><span class="line">uint64 s3;</span><br><span class="line">uint64 s4;</span><br><span class="line">uint64 s5;</span><br><span class="line">uint64 s6;</span><br><span class="line">uint64 s7;</span><br><span class="line">uint64 s8;</span><br><span class="line">uint64 s9;</span><br><span class="line">uint64 s10;</span><br><span class="line">uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line"><span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line"><span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line"><span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line"><span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line"><span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line"><span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line"><span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>swtch</strong> 有两个参数：<strong>struct context old</strong> 和 <strong>struct context new</strong>。它将当前的寄存器保存在 old 中，从 new 中加载寄存器，然后返回</p>
</li>
</ul>
</li>
<li><p>让我们跟随一个进程通过 <strong>swtch</strong> 进入 <strong>scheduler</strong>。我们在第 4 章看到，在中断结束时，有一种情况是 <strong>usertrap</strong> 调用 <strong>yield</strong></p>
</li>
<li><p><strong>yield</strong> 又调用 <strong>sched</strong>，<strong>sched</strong> 调用 <strong>swtch</strong> 将当前上下文保存在 <strong>p-&gt;context</strong> 中，并切换到之前保存在 <strong>cpu-&gt;scheduler</strong> 中的调度器上下文（kernel&#x2F;proc.c:509）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Give up the CPU for one scheduling round.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">acquire(&amp;p-&gt;lock);</span><br><span class="line">p-&gt;state = RUNNABLE;</span><br><span class="line">sched();</span><br><span class="line">release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Switch to scheduler.  Must hold only p-&gt;lock </span></span><br><span class="line"><span class="comment">// 切换到调度器。必须仅持有 p-&gt;lock 并且已经改变了 proc-&gt;state</span></span><br><span class="line"><span class="comment">// and have changed proc-&gt;state. Saves and restores</span></span><br><span class="line"><span class="comment">// intena because intena is a property of this</span></span><br><span class="line"><span class="comment">// kernel thread, not this CPU. It should</span></span><br><span class="line"><span class="comment">// 保存并恢复 intena，因为 intena 是这个内核线程的属性，而不是这个 CPU 的属性</span></span><br><span class="line"><span class="comment">// be proc-&gt;intena and proc-&gt;noff, but that would</span></span><br><span class="line"><span class="comment">// break in the few places where a lock is held but</span></span><br><span class="line"><span class="comment">// there&#x27;s no process.</span></span><br><span class="line"><span class="comment">// 它应该是 proc-&gt;intena 和 proc-&gt;noff，但那样会在少数几个地方出问题，在那些地方持有锁但没有进程</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> intena;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!holding(&amp;p-&gt;lock))	<span class="comment">// 此时必须持有进程锁</span></span><br><span class="line"> panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)	<span class="comment">// push_off()仅有一层，说明acquire只被调用一次，没有其他进程争抢这把锁</span></span><br><span class="line"> panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;state == RUNNING)	<span class="comment">// 当前进程的状态不能是running</span></span><br><span class="line"> panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(intr_get())			<span class="comment">// 中断必须是关闭的</span></span><br><span class="line"> panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">intena = mycpu()-&gt;intena;	<span class="comment">// 获得新线程的中断状态</span></span><br><span class="line">swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">mycpu()-&gt;intena = intena; <span class="comment">// 保存中断状态（这里是新线程的还是旧线程的，应该是新线程的，因为swtch后就已经切换上下文不在这里执行了，当重新返回到旧线程时回到这里再次保存新线程的中断状态）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>swtch(kernel&#x2F;swtch.S:3)</strong> 只保存 callee-saved（被调用者保存）寄存器，caller-saved（调用者保存）寄存器由调用的 C 代码保存在堆栈上 (如果需要)。<strong>swtch</strong> 知道 <strong>struct context</strong> 中每个寄存器字段的偏移量。它不保存 pc。相反，<strong>swtch</strong> 保存了 ra 寄存器<a href="#ftn1">[1]</a>，它保存了 <strong>swtch</strong> 应该返回的地址</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># Context switch</span><br><span class="line">#</span><br><span class="line">#   void swtch(struct context *old, struct context *new);</span><br><span class="line"># </span><br><span class="line"># Save current registers in old. Load from new.	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">     sd ra, 0(a0)</span><br><span class="line">     sd sp, 8(a0)</span><br><span class="line">     sd s0, 16(a0)</span><br><span class="line">     sd s1, 24(a0)</span><br><span class="line">     sd s2, 32(a0)</span><br><span class="line">     sd s3, 40(a0)</span><br><span class="line">     sd s4, 48(a0)</span><br><span class="line">     sd s5, 56(a0)</span><br><span class="line">     sd s6, 64(a0)</span><br><span class="line">     sd s7, 72(a0)</span><br><span class="line">     sd s8, 80(a0)</span><br><span class="line">     sd s9, 88(a0)</span><br><span class="line">     sd s10, 96(a0)</span><br><span class="line">     sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">     ld ra, 0(a1)</span><br><span class="line">     ld sp, 8(a1)</span><br><span class="line">     ld s0, 16(a1)</span><br><span class="line">     ld s1, 24(a1)</span><br><span class="line">     ld s2, 32(a1)</span><br><span class="line">     ld s3, 40(a1)</span><br><span class="line">     ld s4, 48(a1)</span><br><span class="line">     ld s5, 56(a1)</span><br><span class="line">     ld s6, 64(a1)</span><br><span class="line">     ld s7, 72(a1)</span><br><span class="line">     ld s8, 80(a1)</span><br><span class="line">     ld s9, 88(a1)</span><br><span class="line">     ld s10, 96(a1)</span><br><span class="line">     ld s11, 104(a1)</span><br><span class="line"></span><br><span class="line">     ret</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>现在，<strong>swtch</strong> 从新的上下文中恢复寄存器，新的上下文中保存着前一次 <strong>swtch</strong> 所保存的寄存器值。当 <strong>swtch</strong> 返回时，它返回到被恢复的 ra 寄存器所指向的指令，也就是新线程之前调用 <strong>swtch</strong> 的指令。此外，它还会返回新线程的堆栈</li>
</ul>
</li>
<li><p>在我们的例子中，<strong>sched</strong> 调用 <strong>swtch</strong> 切换到 <strong>cpu-&gt;scheduler</strong>，即 CPU 调度器的上下文。这个上下文已经被 <strong>scheduler</strong> 对 <strong>swtch</strong> 的调用所保存 (kernel&#x2F;proc.c:475)。当我们跟踪的 <strong>swtch</strong> 返回时，它不是返回到 <strong>sched</strong> 而是返回到 <strong>scheduler</strong>，它的栈指针指向当前 CPU 的调度器栈</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler. 							每个CPU的进程调度器</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up. 	每个CPU在设置好自己之后都会调用scheduler()</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing: 	调度器永不返回。它会持续循环执行以下操作：</span></span><br><span class="line"><span class="comment">//  - choose a process to run.					选择一个进程来运行</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.		切换到该进程以开始执行</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control	最终，该进程会通过切换（swtch）将控制权交还给调度器</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> <span class="comment">// The most recent process to run may have had interrupts</span></span><br><span class="line"> <span class="comment">// turned off; enable them to avoid a deadlock if all</span></span><br><span class="line"> <span class="comment">// 最近运行的进程可能已经关闭了中断；为了避免所有进程都在等待而导致的死锁，需要开启它们</span></span><br><span class="line"> <span class="comment">// processes are waiting.</span></span><br><span class="line"> intr_on();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">   acquire(&amp;p-&gt;lock);</span><br><span class="line">   <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">     <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">     <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">     <span class="comment">// 切换到选中的进程。进程的任务是在释放其锁，然后在跳转回这里之前重新获取锁</span></span><br><span class="line">     <span class="comment">// before jumping back to us.</span></span><br><span class="line">     p-&gt;state = RUNNING;</span><br><span class="line">     c-&gt;proc = p;</span><br><span class="line">     swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Process is done running for now.</span></span><br><span class="line">     <span class="comment">// 进程现在已完成运行。在返回之前，它应该已经改变了其 p-&gt;state（进程状态）</span></span><br><span class="line">     <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">     c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   release(&amp;p-&gt;lock);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>补充说明（不在翻译内容中）：</p>
</li>
<li><p>根据 xv6 的源代码，xv6 中只有两处调用 switch：</p>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;scheduler);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    swtch(&amp;c-&gt;scheduler, &amp;p-&gt;context);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可以看出这里没有两个用户进程之间的直接切换，只有用户进程和调度器线程之间的切换</strong>：xv6 中要主动让出 cpu 的进程都是通过调用 exit&#x2F;sleep&#x2F;yield，间接调用 sched，从而实现切换到调度器线程，再由调度器线程选出并切换到一个 runnable</li>
</ul>
<h2 id="Code-Scheduling-调度"><a href="#Code-Scheduling-调度" class="headerlink" title="Code: Scheduling 调度"></a>Code: Scheduling 调度</h2><ul>
<li><p>上一节研究了 <strong>swtch</strong> 的底层细节，现在我们把 <strong>swtch</strong> 作为一个给定的条件，研究从一个进程的内核线程通过调度器切换到另一个进程</p>
<ul>
<li><p>调度器以 CPU 特殊线程（每个 CPU 各一个）的形式存在，线程运行 <strong>scheduler</strong> 函数。这个函数负责选择下一步运行哪个进程</p>
</li>
<li><p>一个想要放弃 CPU 的进程，必须获取自己的进程锁 <strong>p-&gt;lock</strong>，释放它所持有的其他锁，更新自己的状态（<strong>p-&gt;state</strong>），然后调用 <strong>sched</strong>。<strong>yield</strong> (kernel&#x2F;proc.c:515) 遵循这个规则，我们稍后要研究的 <strong>sleep</strong> 和 <strong>exit</strong> 也同样遵循这个规则。<strong>sched</strong> 对这些条件进行仔细检查 (kernel&#x2F;proc.c:499-504)，然后再检查这些条件的含义：既然锁被持有，就应该禁用中断。最后，<strong>sched</strong> 调用 <strong>swtch</strong> 将当前上下文保存在 p-&gt;context 中，并切换到 cpu-&gt;scheduler 中 <strong>scheduler</strong> 的上下文。swtch 在 <strong>scheduler</strong> 堆栈上返回，<strong>scheduler</strong> 继续 for 循环，找到一个要运行的进程，切换到它，然后循环重复</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> intena;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!holding(&amp;p-&gt;lock))	<span class="comment">// 此时必须持有进程锁</span></span><br><span class="line"> panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)	<span class="comment">// push_off()仅有一层，说明acquire只被调用一次，没有其他进程争抢这把锁</span></span><br><span class="line"> panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;state == RUNNING)	<span class="comment">// 当前进程的状态不能是running</span></span><br><span class="line"> panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(intr_get())			<span class="comment">// 中断必须是关闭的</span></span><br><span class="line"> panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">intena = mycpu()-&gt;intena;	<span class="comment">// 获得新线程的中断状态(其实这里是调度器的中断状态，也就是中断打开)</span></span><br><span class="line">swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">mycpu()-&gt;intena = intena; <span class="comment">// 保存调度器的中断状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>我们刚刚看到 xv6 在调用 <strong>swtch</strong> 的过程中持有 <strong>p-&gt;lock</strong>：<strong>swtch</strong> 的调用者必须已经持有锁，并把锁的控制权移交给切换到的代码。这种约定对于锁来说是不寻常的；一般来说获得锁的线程也要负责释放锁，这样才容易保证正确性。对于上下文切换来说，有必要打破这个约定，因为 <strong>p-&gt;lock</strong> 保护了进程的状态和 <strong>context</strong> 字段上的 <strong>不变量（invariant）</strong>，而这些不变量在 <strong>swtch</strong> 执行时是不正确的。如果 <strong>p-&gt;lock</strong> 在 <strong>swtch</strong> 过程中不被持有，可能会出现问题的一个情况：在 <strong>yield</strong> 将其状态设置为 <strong>RUNNABLE</strong> 之后，但在 <strong>swtch</strong> 切换到新的栈之前，其他 CPU 可能会运行这个进程。结果就是两个 CPU 运行在同一个栈上，这显然是错误的</p>
</li>
<li><p>一个内核线程在 <strong>sched</strong> 中放弃它的 CPU，并且切换到 <strong>scheduler</strong> 的同一个位置，而 <strong>scheduler</strong>（几乎）总是切换到之前调用 <strong>sched</strong> 的某个内核线程。因此，如果把 xv6 切换线程的行号打印出来，就会观察到下面的结果：(kernel&#x2F;proc.c:475)，(kernel&#x2F;proc.c:509)，(kernel&#x2F;proc.c:475)，(kernel&#x2F;proc.c:509)，等等</p>
<ul>
<li>在两个线程之间发生这种样式化切换的程序有时被称为 <strong>协程（coroutine）</strong>；在这个例子中，<strong>sched</strong> 和 <strong>scheduler</strong> 是彼此的 <strong>coroutines</strong></li>
</ul>
</li>
<li><p>有一种情况是调度器对 <strong>swtch</strong> 的调用没有以 <strong>sched</strong> 结束（意思是没有回到之前进程调用 sched 结束的位置）。当一个新进程第一次被调度时，它从 <strong>forkret</strong> 开始（kernel&#x2F;proc.c:527）。<strong>forkret</strong> 的存在是为了释放 <strong>p-&gt;lock</strong>；否则，新进程需要从 <strong>usertrapret</strong> 开始</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A fork child&#x27;s very first scheduling by scheduler()</span></span><br><span class="line"><span class="comment">// will swtch to forkret.</span></span><br><span class="line"><span class="comment">// scheduler()对一个fork子进程的第一次调度将会swtch到forkret</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Still holding p-&gt;lock from scheduler. 仍然持有来自调度器的进程锁</span></span><br><span class="line">release(&amp;myproc()-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (first) &#123;</span><br><span class="line"> <span class="comment">// File system initialization must be run in the context of a</span></span><br><span class="line"> <span class="comment">// regular process (e.g., because it calls sleep), and thus cannot</span></span><br><span class="line"> <span class="comment">// be run from main().</span></span><br><span class="line"> <span class="comment">// 文件系统初始化必须在常规进程的上下文中运行（例如，因为它调用了sleep），因此不能从main()函数中运行</span></span><br><span class="line"> fsinit(ROOTDEV);</span><br><span class="line"></span><br><span class="line"> first = <span class="number">0</span>; <span class="comment">// first为静态局部变量，所以fsinit只能执行一次</span></span><br><span class="line"> <span class="comment">// ensure other cores see first=0. 确保其他核心看到 first=0</span></span><br><span class="line"> __sync_synchronize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>scheduler(kernel&#x2F;proc.c:457)</strong> 运行了一个简单的循环：找到一个可以运行进程，运行它，直到它让出 CPU，一直重复。调度器在进程表上循环寻找一个可运行的进程，即 p-&gt;state &#x3D;&#x3D; RUNNABLE 的进程。一旦找到这样的进程，它就会设置 CPU 当前进程变量 c-&gt;proc 指向该进程，将该进程标记为 RUNNING，然后调用 <strong>swtch</strong> 开始运行它 (kernel&#x2F;proc.c:470- 475)</p>
</li>
<li><p>你可以这样理解调度代码结构，它执行一组关于进程的不变量，并且每当这些不变量不正确时，就持有 <strong>p-&gt;lock</strong></p>
<ul>
<li>一个不变量是，如果一个进程正在运行，那么定时中断导致的 yield 必须能够安全的让他让出 cpu；这意味着 CPU 寄存器必须持有该进程的寄存器值（即 <strong>swtch</strong> 没有将它们移到上下文中），并且 <strong>c-&gt;proc</strong> 必须指向该进程</li>
<li>另一个不变量是，如果一个进程是 <strong>RUNNABLE</strong> 的，那么对于一个空闲的 CPU 调度器来说，运行它必须是安全的；这意味<ul>
<li>（1）<strong>p-&gt;context</strong> 必须拥有进程的寄存器（即它们实际上并不在真实的寄存器中，swtch 将它们移动到上下文中）   </li>
<li>（2）没有 CPU 在进程的内核栈上执行 </li>
<li>（3）也没有 CPU 的 c-&gt;proc 指向该进程。请注意，当 p-&gt;lock 被持有时，这些属性往往不正确</li>
</ul>
</li>
</ul>
</li>
<li><p>维护上述不变量是 xv6 经常在一个线程中获取 <strong>p-&gt;lock</strong>，然后在另一个线程中释放它的原因（例如在 <strong>yield</strong> 中获取，在 <strong>schedululer</strong> 中释放）</p>
<ul>
<li>一旦 <strong>yield</strong> 开始修改一个正在运行的进程的状态，使其成为 <strong>RUNNABLE</strong>，锁必须一直保持，直到不变量被恢复：最早正确的释放点是在调度器（运行在自己的堆栈上）清除 <strong>c-&gt;proc</strong> 之后</li>
<li>同样，一旦调度器开始将一个 <strong>RUNNABLE</strong> 进程转换为 <strong>RUNNING</strong>，锁就不能被释放，直到内核线程完成运行（在 <strong>swtch</strong> 之后，例如在 <strong>yield</strong> 中）</li>
</ul>
</li>
<li><p><strong>p-&gt;lock</strong> 也保护其他的东西：<strong>exit</strong> 和 <strong>wait</strong> 之间的相互作用，避免丢失唤醒的机制（见第 7.5 节），以及避免避免退出进程和读写其状态的其他进程之间的竞争（例如，<strong>exit</strong> 系统调用查看 <strong>p-&gt;pid</strong> 并设置 **p-&gt;killed (kernel&#x2F;proc.c:611)**。值得思考的是，是否可以将 <strong>p-&gt;lock</strong> 的不同功能拆分开来，这样既清晰，也可能提高性能</p>
</li>
</ul>
<h2 id="Code-mycpu-and-myproc"><a href="#Code-mycpu-and-myproc" class="headerlink" title="Code: mycpu and myproc"></a>Code: mycpu and myproc</h2><ul>
<li><p>xv6 经常需要一个指向当前进程 <strong>proc</strong> 的指针。在单核处理器上，可以用一个全局变量指向当前的 <strong>proc</strong>。这在多核机器上是行不通的，因为每个核都执行不同的进程。解决这个问题的方法是利用每个核都有自己的一组寄存器的事实；我们可以使用其中的一个寄存器来帮助查找每个核的信息</p>
</li>
<li><p>xv6 为每个 CPU 维护了一个 <strong>cpu</strong> 结构体 (kernel&#x2F;proc.h:22)，它记录了当前在该 CPU 上运行的进程 (如果有的话)，为 CPU 的调度线程保存的寄存器，以及管理中断禁用所需的嵌套自旋锁的计数</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line"><span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line"><span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>函数 <strong>mycpu</strong> (kernel&#x2F;proc.c:60) 返回一个指向当前 CPU 结构体 <strong>cpu</strong> 的指针。RISC-V 对 CPU 进行编号，给每个 CPU 一个 <strong>hartid</strong>。xv6 确保每个 CPU 的 <strong>hartid</strong> 在内核中被存储在该 CPU 的 <strong>tp</strong> 寄存器中。这使得 <strong>mycpu</strong> 可以使用 <strong>tp</strong> 对 <strong>cpu</strong> 结构体的数组进行索引，从而找到正确的 cpu</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return this CPU&#x27;s cpu struct.</span></span><br><span class="line"><span class="comment">// Interrupts must be disabled.</span></span><br><span class="line"><span class="keyword">struct</span> cpu*</span><br><span class="line"><span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id = cpuid();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[id];</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Must be called with interrupts disabled,</span></span><br><span class="line"><span class="comment">// to prevent race with process being moved</span></span><br><span class="line"><span class="comment">// to a different CPU.</span></span><br><span class="line"><span class="comment">// 必须在禁用中断的情况下调用，以防止进程被移动到不同CPU的竞态条件</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cpuid</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id = r_tp();</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>确保一个 CPU 的 <strong>tp</strong> 始终保持 CPU 的 hartid 是有一点复杂的</p>
<ul>
<li><p><strong>mstart</strong> 在 CPU 启动的早期设置 <strong>tp</strong> 寄存器，此时 CPU 处于机器模式 (kernel&#x2F;start.c:46)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line"><span class="type">int</span> id = r_mhartid();</span><br><span class="line">w_tp(id);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>usertrapret</strong> 将 <strong>tp</strong> 寄存器保存在 trampoline 页中，因为用户进程可能会修改 tp 寄存器。最后，当从用户空间进入内核时，<strong>uservec</strong> 会恢复保存的 tp（trapframe 中的 tp 加载到 tp 寄存器）(kernel&#x2F;trampoline.S:70)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">		# ...</span><br><span class="line">     # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">     ld tp, 32(a0)</span><br><span class="line">   	# ...</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>编译器保证永远不使用 tp 寄存器。如果 RISC-V 允许 xv6 直接读取当前的 hartid 会更方便，但这只允许在机器模式下读取，而不允许在管理模式下读取</p>
</li>
</ul>
</li>
<li><p>cpuid 和 mycpu 的返回值很容易错：如果定时器中断，导致线程让出 CPU，然后转移到不同的 CPU 上，之前返回的值将不再正确。为了避免这个问题，xv6 要求调用者禁用中断，只有在使用完返回的 cpu 结构后才启用中断。(即为了避免这个问题，调用 cpuid 和 mycpu 时，需要禁用中断)</p>
</li>
<li><p><strong>myproc</strong> (kernel&#x2F;proc.c:68) 函数返回当前 CPU 上运行的进程的 <strong>proc</strong> 指针。<strong>myproc</strong> 禁用中断，调用 <strong>mycpu</strong>，从 <strong>struct</strong> <strong>cpu</strong> 中获取当前进程指针 (<strong>c-&gt;proc</strong>)，然后启用中断。即使启用了中断，<strong>myproc</strong> 的返回值也可以安全使用：如果定时器中断将调用进程移到了另一个的 CPU 上，它的 <strong>proc</strong> 结构指针将保持不变</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the current struct proc *, or zero if none.</span></span><br><span class="line"><span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">push_off();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">pop_off();</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Sleep-and-wakeup"><a href="#Sleep-and-wakeup" class="headerlink" title="Sleep and wakeup"></a>Sleep and wakeup</h2><ul>
<li><p>调度和锁有助于让一个进程对另一个进程的不可见，但到目前为止，我们还没有帮助进程进行交互的抽象。人们发明了许多机制来解决这个问题</p>
<ul>
<li>xv6 使用了一种叫做睡眠和唤醒的机制，它允许一个进程睡眠并等待事件，另一个进程在该事件发生后将其唤醒</li>
<li>睡眠和唤醒通常被称为 <strong>序列协调（sequence coordination）</strong> 或 <strong>条件同步（conditional synchronization）</strong> 机制</li>
</ul>
</li>
<li><p>为了说明这一点，让我们考虑一个叫做 <strong>信号量（semaphore）</strong>[4] 的同步机制，它协调生产者和消费者</p>
<ul>
<li>信号量维护一个计数并提供两个操作。V 操作（针对生产者）增加计数。P 操作（针对消费者）等待，直到计数非零，然后将其递减并返回</li>
<li>如果只有一个生产者线程和一个消费者线程，而且它们在不同的 CPU 上执行，编译器也没有太过激进的优化，那么这个实现是正确的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count += <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面的实现是代价很大。如果生产者很少生产，消费者将把大部分时间花在 while 循环中，希望得到一个非零的计数</p>
<ul>
<li>消费者的 CPU 可以通过反复 <strong>轮询(polling)</strong> <strong>s-&gt;count</strong> 可以找到比 <strong>忙碌等待(busy waiting)</strong> 更有效的工作</li>
<li>避免 <strong>忙碌等待</strong> 需要一种方法，让消费者让出 CPU，只有在 <strong>V</strong> 增加计数后才恢复</li>
</ul>
</li>
<li><p>这里是朝着这个方向迈出的一步，虽然他不能完全解决这个问题。让我们想象一对调用，<strong>sleep</strong> 和 <strong>wakeup</strong>，其工作原理如下</p>
<ul>
<li><strong>Sleep(chan)</strong> 睡眠 <strong>chan</strong> 上，<strong>chan</strong> 可以为任意值，称为 <strong>等待通道(wait channel)<strong>。</strong>Sleep</strong> 使调用进程进入睡眠状态，释放 CPU 进行其他工作</li>
<li><strong>Wakeup(chan)</strong> 唤醒所有在 <strong>chan</strong> 上 <strong>sleep</strong> 的进程（如果有的话），使它们的 <strong>sleep</strong> 调用返回。如果没有进程在 <strong>chan</strong> 上等待，则 <strong>wakeup</strong> 不做任何事情</li>
<li>我们修改信号量实现，以使用 <strong>sleep</strong> 和 <strong>wakeup</strong>（修改处用注释标注）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count += <span class="number">1</span>;</span><br><span class="line">  wakeup(s);			<span class="comment">// 修改</span></span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    sleep(s);			<span class="comment">// 修改</span></span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>P 现在放弃 CPU 而不是自旋，这是一个不错的改进。然而，事实证明，像这样设计 <strong>sleep</strong> 和 <strong>wakeup</strong> 并不是一件容易的事，因为它会遇到所谓的丢失唤醒问题</p>
<ul>
<li>假设执行 P 的 <strong>s-&gt;count &#x3D;&#x3D; 0</strong> 这一行时。当 P 在 <strong>sleep</strong> 之前，V 在另一个 CPU 上运行：它将 <strong>s-&gt;count</strong> 改为非零，并调用 <strong>wakeup</strong>，<strong>wakeup</strong> 发现没有进程在睡眠，因此什么也不做。现在 P 继续执行：它调用 <strong>sleep</strong> 并进入睡眠状态。这就造成了一个问题：P 正在 <strong>sleep</strong>，等待一个已经发生的 V 调用。除非我们运气好，生产者再次调用 V，否则消费者将永远等待，即使计数是非零</li>
</ul>
</li>
<li><p>这个问题的根源在于，在错误的时刻运行的 V 违反了 P 只在 <code>s-&gt;count==0</code> 时休眠的不变量。保护这个不变量的一个不正确的方法是将锁获取（修改用注释标注）移动到 P 中，这样它对计数的检查和对 sleep 的调用是原子的：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	acquire(&amp;s-&gt;lock);</span><br><span class="line">	s-&gt;count += <span class="number">1</span>;</span><br><span class="line">	wakeup(s);</span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	acquire(&amp;s-&gt;lock);		<span class="comment">// 修改</span></span><br><span class="line">	<span class="keyword">while</span>(s-&gt;count == <span class="number">0</span>)</span><br><span class="line">		sleep(s);</span><br><span class="line">	s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>人们可能希望这个版本的 P 能够避免丢失的唤醒，因为锁会阻止 V 在 <strong>s-&gt;count &#x3D;&#x3D; 0</strong> 和 sleep 之间执行。它做到了这一点，但它也会死锁。P 在 <strong>sleep</strong> 时保持着锁，所以 V 将永远阻塞在等待锁的过程中</p>
</li>
<li><p>我们将通过改变 <strong>sleep</strong> 的接口来修正前面的方案：调用者必须将 <strong>条件锁(condition lock)</strong> 传递给 <strong>sleep</strong>，这样在调用进程被标记为 <strong>SLEEPING</strong> 并在 chan 上等待后，它就可以释放锁。锁将强制并发的 V 等待直到 P 将自己置于 <strong>SLEEPING</strong> 状态，这样 <strong>wakeup</strong> 就会发现 <strong>SLEEPING</strong> 的消费者并将其唤醒。一旦消费者再次被唤醒，<strong>sleep</strong> 就会重新获得锁，然后再返回。我们新的正确的睡眠&#x2F;唤醒方案是可用的，如下所示（修改用注释标注）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	acquire(&amp;s-&gt;lock);</span><br><span class="line">	<span class="keyword">while</span>(s-&gt;count == <span class="number">0</span>)</span><br><span class="line">		sleep(s, &amp;s-&gt;lock);	<span class="comment">// 修改</span></span><br><span class="line">	s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>P 持有 <strong>s-&gt;lock</strong> 会阻止了 V 在 P 检查 <strong>c-&gt;count</strong> 和调用 <strong>sleep</strong> 之间试图唤醒它。但是，请注意，我们需要 <strong>sleep</strong> 来原子地释放 <strong>s-&gt;lock</strong> 并使消费者进程进入 <strong>SLEEPING</strong> 状态</li>
</ul>
<h2 id="Code-Sleep-and-wakeup"><a href="#Code-Sleep-and-wakeup" class="headerlink" title="Code: Sleep and wakeup"></a>Code: Sleep and wakeup</h2><ul>
<li><p>让我们看看 <strong>sleep (kernel&#x2F;proc.c:548)</strong> 和 <strong>wakeup (kernel&#x2F;proc.c:582)</strong> 的实现。其基本思想是让 <strong>sleep</strong> 将当前进程标记为 <strong>SLEEPING</strong>，然后调用 <strong>sched</strong> 让出 <strong>CPU</strong>；<strong>wakeup</strong> 则寻找给定的 <strong>等待通道</strong> 上睡眠的进程，并将其标记为 <strong>RUNNABLE</strong></p>
<ul>
<li><strong>sleep</strong> 和 <strong>wakeup</strong> 的调用者可以使用任何方便的数字作为 <strong>channel</strong>。xv6 经常使用参与等待的内核数据结构的地址</li>
</ul>
</li>
<li><p><strong>Sleep</strong> 首先获取 **p-&gt;lock (kernel&#x2F;proc.c:559)**。现在进入睡眠状态的进程同时持有 <strong>p-&gt;lock</strong> 和 <strong>lk</strong>。在调用者 (在本例中为 P) 中，持有 <strong>lk</strong> 是必要的：它保证了没有其他进程 (在本例中，运行 V 的进程) 可以调用 **wakeup(chan)**。现在 <strong>sleep</strong> 持有 <strong>p-&gt;lock</strong>，释放 <strong>lk</strong> 是安全的：其他进程可能会调用 **wakeup(chan)**，但 <strong>wakeup</strong> 会等待获得 <strong>p-&gt;lock</strong>，因此会等到 <strong>sleep</strong> 将进程状态设置为 <strong>SLEEPING</strong>，使 <strong>wakeup</strong> 不会错过 <strong>sleep</strong> 的进程</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Atomically release lock and sleep on chan. 原子的释放锁并睡眠在chan上</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened. 获得锁当被唤醒时</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to 必须获得进程锁是为了改变当前进程的状态和调用sched(放弃CPU)</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be  一旦我们拥有进程锁，我们可以保证不会错过任何唤醒</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),  唤醒需要进程锁</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.  所以现在释放lk锁是安全的</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">  release(lk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep. 进入睡眠</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up. 清理</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock. 重新获得初始的锁</span></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  acquire(lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>有一个复杂情况：如果 <strong>lk</strong> 和 <strong>p-&gt;lock</strong> 是同一个锁，如果 <strong>sleep</strong> 仍试图获取 <strong>p-&gt;lock</strong>，就会和自己死锁。但是如果调用 <strong>sleep</strong> 的进程已经持有 <strong>p-&gt;lock</strong>，那么它就不需要再做任何事情来避免错过一个并发的 <strong>wakeup</strong>。这样的情况发生在，<strong>wait (kernel&#x2F;proc.c:582)</strong> 调用 <strong>sleep</strong> 并持有 <strong>p-&gt;lock</strong> 时（没看懂）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exit the current process.  Does not return.</span></span><br><span class="line"><span class="comment">// An exited process remains in the zombie state</span></span><br><span class="line"><span class="comment">// until its parent calls wait().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for a child process to exit and return its pid.</span></span><br><span class="line"><span class="comment">// Return -1 if this process has no children.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">wait</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pp</span>;</span></span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(pp = proc; pp &lt; &amp;proc[NPROC]; pp++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(pp-&gt;parent == p)&#123;</span><br><span class="line">        <span class="comment">// make sure the child isn&#x27;t still in exit() or swtch().</span></span><br><span class="line">        acquire(&amp;pp-&gt;lock);</span><br><span class="line"></span><br><span class="line">        havekids = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pp-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          <span class="comment">// Found one.</span></span><br><span class="line">          pid = pp-&gt;pid;</span><br><span class="line">          <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;pp-&gt;xstate,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(pp-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            release(&amp;pp-&gt;lock);</span><br><span class="line">            release(&amp;wait_lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          freeproc(pp);</span><br><span class="line">          release(&amp;pp-&gt;lock);</span><br><span class="line">          release(&amp;wait_lock);</span><br><span class="line">          <span class="keyword">return</span> pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;pp-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don&#x27;t have any children.</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || killed(p))&#123;</span><br><span class="line">      release(&amp;wait_lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Wait for a child to exit.</span></span><br><span class="line">    sleep(p, &amp;wait_lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>现在 <strong>sleep</strong> 持有 <strong>p-&gt;lock</strong>，而没有其他的锁，它可以通过记录它睡眠的 <strong>channel</strong>，将进程状态设置 <strong>SLEEPING</strong>，并调用 <strong>sched</strong> (kernel&#x2F;proc.c:564-567) 来使进程进入睡眠状态。稍后我们就会明白为什么在进程被标记为 <strong>SLEEPING</strong> 之前，<strong>p-&gt;lock</strong> 不会被释放（由调度器）</p>
</li>
<li><p>在某些时候，一个进程将获取条件锁（V 操作会先获得条件锁 lk，再调用 wakeup），设置睡眠等待的条件，并调用 <strong>wakeup(chan)<strong>。重要的是，</strong>wakeup</strong> 是在持有条件锁<a href="#ftn2">[2]</a>的情况下被调用的</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan. 唤醒所有在chan上睡眠的进程</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.  必须在没有任何进程锁时才能被调用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p != myproc())&#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>Wakeup</strong> 循环浏览进程表<strong>（kernel&#x2F;proc.c:582）</strong>。它获取每个被检查的进程的 <strong>p-&gt;lock</strong>，因为它可能会修改该进程的状态，也因为 <strong>p-&gt;sleep</strong> （这里应该是 p-&gt;lock 吧）确保 <strong>sleep</strong> 和 <strong>wakeup</strong> 不会相互错过。当 <strong>wakeup</strong> 发现一个进程处于状态为 <strong>SLEEPING</strong> 并有一个匹配的 <strong>chan</strong> 时，它就会将该进程的状态改为 <strong>RUNNABLE</strong>。下一次调度器运行时，就会看到这个进程已经准备好运行了</li>
</ul>
</li>
<li><p>为什么 <strong>sleep</strong> 和 <strong>wakeup</strong> 的锁规则能保证睡眠的进程不会错过 <strong>wakeup</strong>？<strong>sleep</strong> 进程从检查条件之前到标记为 <strong>SLEEPING</strong> 之后的这段时间里，持有条件锁或它自己的 <strong>p-&gt;lock</strong> 或两者都持有。调用 <strong>wakeup</strong> 的进程在 <strong>wakeup</strong> 的循环中持有这两个锁。因此，唤醒者要么在消费者检查条件之前使条件为真；要么唤醒者的 <strong>wakeup</strong> 在消费者被标记为 <strong>SLEEPING</strong> 之后检查它。 无论怎样，<strong>wakeup</strong> 就会看到这个睡眠的进程，并将其唤醒（除非有其他事情先将其唤醒）</p>
</li>
<li><p>有时会出现多个进程在同一个 <strong>channel</strong> 上睡眠的情况；例如，有多个进程从管道中读取数据。调用一次 <strong>wakeup</strong> 就会把它们全部唤醒。其中一个进程将首先运行，并获得 <strong>sleep</strong> 参数传递的锁，（就管道而言）读取数据都会在管道中等待。其他进程会发现，尽管被唤醒了，但没有数据可读。从他们的角度来看，唤醒是 “虚假的“，他们必须再次睡眠。出于这个原因，<strong>sleep</strong> 总是在一个检查条件的循环中被调用</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	acquire(&amp;s-&gt;lock);</span><br><span class="line">	<span class="keyword">while</span>(s-&gt;count == <span class="number">0</span>)</span><br><span class="line">		sleep(s, &amp;s-&gt;lock);	</span><br><span class="line">	s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果两次使用 <strong>sleep&#x2F;wakeup</strong> 不小心选择了同一个通道，也不会有害：它们会看到虚假的唤醒，上面提到的循环允许发生这种情况。<strong>sleep</strong>&#x2F;<strong>wakeup</strong> 的魅力很大程度上在于它既是轻量级的（不需要创建特殊的数据结构来充当睡眠通道），又提供了一层间接性（调用者不需要知道他们正在与哪个具体的进程交互）</p>
</li>
</ul>
<h2 id="Code-Pipes"><a href="#Code-Pipes" class="headerlink" title="Code: Pipes"></a>Code: Pipes</h2><ul>
<li><p>一个使用 <strong>sleep</strong> 和 <strong>wakeup</strong> 来同步生产者和消费者的更复杂的例子是 xv6 的管道实现。我们在第 1 章看到了管道的接口：写入管道一端的字节被复制到内核缓冲区，然后可以从管道的另一端读取。未来的章节将研究管道如何支持文件描述符，但我们现在来看一下 <strong>pipewrite</strong> 和 <strong>piperead</strong> 的实现吧</p>
</li>
<li><p>每个管道由一个结构体 <strong>pipe</strong> 表示，它包含一个锁和一个数据缓冲区。<strong>nread</strong> 和 <strong>nwrite</strong> 两个字段统计从缓冲区读取和写入的字节总数。缓冲区呈环形：<strong>buf[PIPESIZE-1]</strong> 之后写入的下一个字节是 **buf[0]**。计数不呈环形。这个约定使得实现可以区分满缓冲区 (<strong>nwrite &#x3D;&#x3D; nread+PIPESIZE</strong>) 和空缓冲区 (<strong>nwrite &#x3D;&#x3D; nread</strong>)，但这意味着对缓冲区的索引必须使用 **buf[nread % PIPESIZE]**，而不是使用 <strong>buf[nread]</strong> (<strong>nwrite</strong> 也是如此)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">  uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">  uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">  <span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">  <span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>假设对 <strong>piperead</strong> 和 <strong>pipewrite</strong> 的调用同时发生在两个不同的 CPU 上</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipewrite</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;readopen == <span class="number">0</span> || killed(pr))&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123; <span class="comment">//DOC: pipewrite-full</span></span><br><span class="line">      wakeup(&amp;pi-&gt;nread);</span><br><span class="line">      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">char</span> ch;</span><br><span class="line">      <span class="keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;pi-&gt;nread);</span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>Pipewrite</strong> <strong>(kernel&#x2F;pipe.c:77)</strong> 首先获取管道的锁，它保护了计数、数据和相关的不变式。然后，<strong>Piperead</strong> <strong>(kernel&#x2F;pipe.c:103)</strong> 也试图获取这个锁，但是不会获取成功。它在 <strong>acquire(kernel&#x2F;spinlock.c:22)</strong> （acquire 是自旋锁）中循环，等待锁的到来</li>
<li>当 <strong>piperead</strong> 等待时，<strong>pipewrite</strong> 会循环写，依次将每个字节添加到管道中 (kernel&#x2F;pipe.c:95)。在这个循环中，可能会发生缓冲区被填满的情况 (kernel&#x2F;pipe.c:85)。在这种情况下，<strong>pipewrite</strong> 调用 <strong>wakeup</strong> 来提醒所有睡眠中的 reader 有数据在缓冲区中等待，然后在 <strong>&amp;pi-&gt;nwrite</strong> 上 <strong>sleep</strong>，等待 reader 从缓冲区中取出一些字节。<strong>Sleep</strong> 函数内会释放 <strong>pi-&gt;lock</strong>，然后 <strong>pipwrite</strong> 进程睡眠</li>
</ul>
</li>
<li><p>现在 <strong>pi-&gt;lock</strong> 可用了，<strong>piperead</strong> 设法获取它并进入它的临界区：它发现 <strong>pi-&gt;nread !&#x3D; pi-&gt;nwrite (kernel&#x2F;pipe.c:110)</strong>  (<strong>pipewrite</strong> 进入睡眠状态是由于 <strong>pi-&gt;nwrite &#x3D;&#x3D; pi-&gt;nread+PIPESIZE (kernel&#x2F;pipe.c:85)</strong>)，所以它进入 for 循环，将数据从管道中复制出来 <strong>(kernel&#x2F;pipe.c:117)<strong>，并按复制的字节数增加 <strong>nread</strong>。现在又可写了，所以 <strong>piperead</strong> 在返回之前调用 <strong>wakeup (kernel&#x2F;pipe.c:124)</strong> 来唤醒在睡眠的 writer。</strong>Wakeup</strong> 找到一个在 <strong>&amp;pi-&gt;nwrite</strong> 上睡眠的进程，这个进程正在运行 <strong>pipewrite</strong>，但在缓冲区填满时停止了。它将该进程标记为 <strong>RUNNABLE</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">piperead</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="comment">// 只有缓冲区空且有人想写的时候，才会睡眠以等待写进程唤醒</span></span><br><span class="line">  <span class="keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="comment">//DOC: pipe-empty</span></span><br><span class="line">    <span class="keyword">if</span>(killed(pr))&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="comment">//DOC: piperead-sleep	</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">//DOC: piperead-copy</span></span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];</span><br><span class="line">    <span class="keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;pi-&gt;nwrite);  <span class="comment">//DOC: piperead-wakeup</span></span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>管道代码对 reader 和 writer 分别使用不同的睡眠 <strong>channel</strong>（<strong>pi-&gt;nread</strong> 和 <strong>pi-&gt;nwrite</strong>）；这可能会使系统在有多个 reader 和 writer 等待同一个管道的情况下更有效率（如果使用相同的条件变量，满的时候写进程可能唤醒另一个写进程）。管道代码在循环内 sleep，检查 sleep 条件；如果有多个 reader 和 writer，除了第一个被唤醒的进程外，其他进程都会看到条件仍然是假的，然后再次睡眠</p>
</li>
</ul>
<h2 id="Code-Wait-exit-and-kill"><a href="#Code-Wait-exit-and-kill" class="headerlink" title="Code: Wait, exit, and kill"></a>Code: Wait, exit, and kill</h2><ul>
<li><p><strong>sleep</strong> 和 <strong>wakeup</strong> 可以用于许多种需要等待的情况。在第 1 章中介绍的一个有趣的例子是，一个子进程的 <strong>exit</strong> 和其父进程的 <strong>wait</strong> 之间的交互</p>
<ul>
<li>在子进程退出的时候，父进程可能已经在 <strong>wait</strong> 中睡眠了，也可能在做别的事情；在后一种情况下，后续的 <strong>wait</strong> 调用必须观察子进程的退出，也许是在它调用 <strong>exit</strong> 之后很久。xv6 在 <strong>wait</strong> 观察到子进程退出之前，记录子进程退出的方式是让 <strong>exit</strong> 将调用进程设置为 <strong>ZOMBIE</strong> 状态，在那里停留，直到父进程的 <strong>wait</strong> 注意到它，将子进程的状态改为 <strong>UNUSED</strong>，然后复制子进程的退出状态，并将子进程的进程 ID 返回给父进程</li>
<li>如果父进程比子进程先退出，父进程就把子进程交给 <strong>init</strong> 进程，而 <strong>init</strong> 进程则循环的调用 <strong>wait</strong>；这样每个子进程都有一个 “父进程” 来清理</li>
<li>主要的实现挑战是父进程和子进程的 <strong>wait</strong> 和 <strong>exit</strong>，以及 <strong>exit</strong> 和 <strong>exit</strong> 之间可能出现竞争和死锁的情况</li>
</ul>
</li>
<li><p><strong>Wait</strong> 使用 <strong>调用进程</strong> 的 <strong>p-&gt;lock</strong> 作为条件锁（这里其实就是一个全局锁 wait_lock，可能由于 xv6 版本的原因，2023 版和之前并不相同），以避免唤醒丢失，它在开始时获取该锁<strong>（kernel&#x2F;proc.c:398）</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helps ensure that wakeups of wait()ing 有助于确保等待（wait）中的父进程（或线程）的唤醒操作不会丢失</span></span><br><span class="line"><span class="comment">// parents are not lost. helps obey the 有助于在使用 p-&gt;parent 时遵守内存模型</span></span><br><span class="line"><span class="comment">// memory model when using p-&gt;parent.</span></span><br><span class="line"><span class="comment">// must be acquired before any p-&gt;lock. 必须在获取任何 p-&gt;lock 之前获取它</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">wait_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for a child process to exit and return its pid.</span></span><br><span class="line"><span class="comment">// Return -1 if this process has no children.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">wait</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pp</span>;</span></span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(pp = proc; pp &lt; &amp;proc[NPROC]; pp++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(pp-&gt;parent == p)&#123;</span><br><span class="line">        <span class="comment">// make sure the child isn&#x27;t still in exit() or swtch().</span></span><br><span class="line">        acquire(&amp;pp-&gt;lock);</span><br><span class="line"></span><br><span class="line">        havekids = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pp-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          <span class="comment">// Found one.</span></span><br><span class="line">          pid = pp-&gt;pid;</span><br><span class="line">          <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;pp-&gt;xstate,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(pp-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            release(&amp;pp-&gt;lock);</span><br><span class="line">            release(&amp;wait_lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          freeproc(pp);</span><br><span class="line">          release(&amp;pp-&gt;lock);</span><br><span class="line">          release(&amp;wait_lock);</span><br><span class="line">          <span class="keyword">return</span> pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;pp-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don&#x27;t have any children.</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || killed(p))&#123;</span><br><span class="line">      release(&amp;wait_lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Wait for a child to exit.</span></span><br><span class="line">    sleep(p, &amp;wait_lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>然后它扫描进程表。如果它发现一个处于 <strong>ZOMBIE</strong> 状态的子进程，它释放这个子进程的资源和它的 <strong>proc</strong> 结构，将子进程的退出状态复制到提供给 <strong>wait</strong> 的地址 (如果它不是 0)，并返回子进程的 ID</li>
<li>如果 <strong>wait</strong> 找到了子进程但没有一个退出，它调用 <strong>sleep</strong> 等待其中一个子进程退出 **(kernel&#x2F;proc.c:445)**，然后再次扫描。这里，在 <strong>sleep</strong> 中释放的条件锁是等待进程的 <strong>p-&gt;lock</strong>，也就是上面提到的特殊情况</li>
<li>请注意，<strong>wait</strong> 经常持有两个锁；它在试图获取任何子锁之前，会先获取自己的锁；因此 xv6 的所有锁都必须遵守相同的锁顺序（父进程的锁，然后是子进程的锁），以避免死锁</li>
</ul>
</li>
<li><p><strong>Wait</strong> 会查看每个进程的 <strong>np-&gt;parent</strong> 来寻找它的子进程。它使用 <strong>np-&gt;parent</strong> 而不持有 <strong>np-&gt;lock</strong>，这违反了共享变量必须受锁保护的通常规则。但是 <strong>np</strong> 有可能是当前进程的祖先，在这种情况下，获取 <strong>np-&gt;lock</strong> 可能会导致死锁，因为这违反了上面提到的顺序。在这种情况下，在没有锁的情况下检查 <strong>np-&gt;parent</strong> 似乎是安全的；一个进程的父进程字段只有 “父亲“ 改变，所以如果 <strong>np-&gt;parent&#x3D;&#x3D;p</strong> 为真，除非当前进程改变它，否则该值就不会改变</p>
</li>
<li><p><strong>Exit (kernel&#x2F;proc.c:333)</strong> 记录退出状态，释放一些资源，将所有子进程交给 <strong>init</strong> 进程，在父进程处于等待状态时唤醒它，将 <strong>调用进程</strong> 标记为 <strong>zombie</strong>，并永久放弃 CPU</p>
<ul>
<li>最后的序列有点棘手。退出的进程必须持有父进程的锁（这里为全局锁 wait_lock），同时将自己状态设置为 <strong>ZOMBIE</strong> 并唤醒父进程，因为父进程的锁是条件锁，可以防止在等待中丢失 <strong>wakeup</strong>。子进程也必须持有自己的 <strong>p-&gt;lock</strong>，否则父进程可能会看到它的状态为 <strong>ZOMBIE</strong>，并在它还在运行时释放它</li>
<li>锁的获取顺序对避免死锁很重要：因为 <strong>wait</strong> 在子锁之前获取父锁，所以 <strong>exit</strong> 必须使用相同的顺序</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exit the current process.  Does not return.</span></span><br><span class="line"><span class="comment">// An exited process remains in the zombie state</span></span><br><span class="line"><span class="comment">// until its parent calls wait().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == initproc)</span><br><span class="line">    panic(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Close all open files.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[fd])&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> p-&gt;ofile[fd];</span><br><span class="line">      fileclose(f);</span><br><span class="line">      p-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  iput(p-&gt;cwd);</span><br><span class="line">  end_op();</span><br><span class="line">  p-&gt;cwd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give any children to init.</span></span><br><span class="line">  reparent(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parent might be sleeping in wait().</span></span><br><span class="line">  wakeup(p-&gt;parent);</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  p-&gt;xstate = status;</span><br><span class="line">  p-&gt;state = ZOMBIE;</span><br><span class="line"></span><br><span class="line">  release(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Jump into the scheduler, never to return.</span></span><br><span class="line">  sched();</span><br><span class="line">  panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass p&#x27;s abandoned children to init.</span></span><br><span class="line"><span class="comment">// Caller must hold wait_lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">reparent</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(pp = proc; pp &lt; &amp;proc[NPROC]; pp++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pp-&gt;parent == p)&#123;</span><br><span class="line">      pp-&gt;parent = initproc;</span><br><span class="line">      wakeup(initproc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Exit</strong> 调用了一个专门的唤醒函数 <strong>wakeup1</strong>，它只唤醒父函数，而且只有父进程在 <strong>wait</strong> 中睡眠的情况下才会去唤醒它**(kernel&#x2F;proc.c:598)**</p>
<ul>
<li>在将自己的状态设置为 <strong>ZOMBIE</strong> 之前，唤醒父进程可能看起来并不正确，但这是安全的：尽管 <strong>wakeup1</strong> 可能会导致父进程运行，但 <strong>wait</strong> 中的循环不能检查子进程，直到子进程的 <strong>p-&gt;lock</strong> 被调度器释放为止，所以 <strong>wait</strong> 不能查看退出的进程，直到 <strong>exit</strong> 将其状态设置为 <strong>ZOMBIE</strong> 之后 <strong>(kernel&#x2F;proc.c:386)</strong></li>
<li>（由于版本原因，在 2023 版中，wakeup 将父进程的状态设置为 RUNNABLE 后，被调度返回到 sleep 时，会尝试获取 wait_lock，所以只有在子进程设置好状态且释放 wait_lock 后，父进程才能重新回到 wait 循环中。当然，后边提到的调度释放子进程的 p-&gt;lock 也是一个保障）</li>
<li>所以 exit 做的就是释放一些资源，并设置为僵尸状态（不可以运行），等待父进程的 wait 释放它的其他资源，这是因为子进程调用 exit 时，它还在运行，所以它并不能直接释放一些关键资源，比如堆栈，只能等待父进程在 wait 中释放</li>
<li>下文将要提到的 kill 也是如此，它可能正在做一些重要操作，更新一些重要的数据结构，不能只更新一半就被终止，所以 kill 也不能直接摧毁一个进程，它能做的也仅仅是设置一个 flag，等待关键操作完成后返回到 trap，trap 中发现 flag 并调用 exit，最终由它的父进程的 wait 释放关键资源</li>
</ul>
</li>
<li><p><strong>exit</strong> 允许一个进程自行终止，而 <strong>kill（kernel&#x2F;proc.c:611）</strong> 则允许一个进程请求另一个进程终止</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kill the process with the given pid. 杀死具有给定pid的进程</span></span><br><span class="line"><span class="comment">// The victim won&#x27;t exit until it tries to return 受害者进程不会立即退出，直到它尝试返回到用户空间</span></span><br><span class="line"><span class="comment">// to user space (see usertrap() in trap.c). </span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid == pid)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING)&#123;</span><br><span class="line">        <span class="comment">// Wake process from sleep().</span></span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>如果让 <strong>kill</strong> 直接摧毁进程，那就太复杂了，因为相应进程可能在另一个 CPU 上执行，也许正处于更新内核数据结构的敏感序列中</p>
</li>
<li><p>因此，kill 的作用很小：它只是设置进程的 <strong>p-&gt;killed</strong>，如果它在 <strong>sleep</strong>，则 <strong>wakeup</strong> 它（在 2023 版本中，会直接设置 RUNNABLE 状态）。最终，进程会进入或离开内核，这时如果 <strong>p-&gt;killed</strong> 被设置，<strong>usertrap</strong> 中的代码会调用 <strong>exit</strong>。如果进程在用户空间运行，它将很快通过进行系统调用或因为定时器（或其他设备）中断而进入内核</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">    <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>如果进程处于睡眠状态，<strong>kill</strong> 调用 <strong>wakeup</strong> 会使进程从睡眠中返回。这是潜在的危险，因为正在等待的条件可能不为真。然而，xv6 对 <strong>sleep</strong> 的调用总是被包裹在一个 <strong>while</strong> 循环中，在 <strong>sleep</strong> 返回后重新检测条件</p>
<ul>
<li>一些对 <strong>sleep</strong> 的调用也会在循环中检测 <strong>p-&gt;killed</strong>，如果设置了 <strong>p-&gt;killed</strong>，则离开当前活动。只有当这种离开是正确的时候才会这样做。例如，管道读写代码如果设置了 <strong>killed</strong> 标志就会返回；最终代码会返回到 <strong>trap</strong>，<strong>trap</strong> 会再次检查标志并退出</li>
</ul>
</li>
<li><p>一些 xv6 <strong>sleep</strong> 循环没有检查 <strong>p-&gt;killed</strong>，因为代码处于多步骤系统调用的中间，而这个调用应该是原子的。virtio 驱动 <strong>(kernel&#x2F;virtio_disk.c:242)</strong> 就是一个例子：它没有检查 <strong>p-&gt;killed</strong>，因为磁盘操作可能是一系列写操作中的一个，而这些写操作都是为了让文件系统处于一个正确的状态而需要的。一个在等待磁盘 I&#x2F;O 时被杀死的进程不会退出，直到它完成当前的系统调用和 <strong>usertrap</strong> 看到 <strong>killed</strong> 的标志</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">virtio_disk_rw</span><span class="params">(<span class="keyword">struct</span> buf *b, <span class="type">int</span> write)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Wait for virtio_disk_intr() to say request has finished.</span></span><br><span class="line">  <span class="keyword">while</span>(b-&gt;disk == <span class="number">1</span>) &#123;</span><br><span class="line">    sleep(b, &amp;disk.vdisk_lock);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<ul>
<li>所以它的意思是：一个进程可能 sleep 等待磁盘 I&#x2F;O，这个操作是必须的，所以这时 kill 即使设置了 flag 并且唤醒这个 sleep，这个进程也不能退出，回到 trap，所以这类 xv6 sleep 循环中是没有 p-&gt;killed 检查的，因为它们不想退出，而是当完成必须的所有磁盘 I&#x2F;O 后再退出</li>
</ul>
</li>
</ul>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><ul>
<li><p>xv6 调度器实现了一个简单的调度策略，它依次运行每个进程。这种策略被称为 <strong>轮询调度(round robin)</strong></p>
<ul>
<li>真正的操作系统实现了更复杂的策略，例如，允许进程有优先级。这个策略是，一个可运行的高优先级进程将被调度器优先于一个可运行的低优先级进程</li>
<li>这些策略可能会很快变得复杂，因为经常有相互竞争的目标：例如，操作者可能还想保证公平性和高吞吐量</li>
<li>此外，复杂的策略可能会导致不尽人意的交互，如 <strong>优先级倒置(priority inversion)</strong> 和 **护航现象(convoys)**。当低优先级和高优先级进程共享一个锁时，就会发生优先级倒置，当低优先级进程获得锁时，就会阻止高优先级进程的进展。当许多高优先级进程都在等待一个获得共享锁的低优先级进程时，就会形成一个长长的等待进程的车队；一旦护航现象形成，就会持续很长时间</li>
<li>为了避免这类问题，在复杂的调度器中需要额外的机制</li>
</ul>
</li>
<li><p><strong>sleep</strong> 和 <strong>wakeup</strong> 是一种简单有效的同步方法，但还有很多其他的方法。在所有这些方法中，第一个挑战是避免我们在本章开头看到的丢失唤醒问题</p>
<ul>
<li>最初的 Unix 内核的 <strong>sleep</strong> 只是禁用了中断，这已经足够了，因为 Unix 运行在单 CPU 系统上。因为 xv6 运行在多处理器上，所以它增加了一个显式的 <strong>sleep</strong> 锁。FreeBSD 的 <strong>msleep</strong> 采用了同样的方法。Plan 9 的 <strong>sleep</strong> 使用了一个回调函数，它在进入睡眠前保持调度锁的情况下运行；这个函数的作用是在最后一刻检查 <strong>sleep</strong> 情况，以避免 <strong>wakeup</strong> 丢失。Linux 内核的 <strong>sleep</strong> 使用一个显式的进程队列，称为等待队列，而不是等待通道；队列有自己的内部锁</li>
</ul>
</li>
<li><p>在 <strong>wakeup</strong> 过程中扫描整个进程链表，寻找相匹配的 <strong>chan</strong> 的进程，效率很低。一个更好的解决方案是用一个数据结构代替 <strong>sleep</strong> 和 <strong>wakeup</strong> 中的 <strong>chan</strong>，该结构上存放着 <strong>sleep</strong> 的进程列表，比如 Linux 的等待队列</p>
<ul>
<li>Plan 9 的 <strong>sleep</strong> 和 <strong>wakeup</strong> 将该结构称为 rendezvous point 或 Rendez。许多线程库将同一个结构称为条件变量；在这种情况下，sleep 和 wakeup 的操作被称为 <strong>wait</strong> 和 <strong>signal</strong></li>
<li>所有这些机制都有相同的机制：睡眠条件被睡眠过程中原子地释放的锁保护</li>
</ul>
</li>
<li><p><strong>wakeup</strong> 唤醒了所有在某个特定 <strong>channel</strong> 上等待的进程，可能很多进程都在等待这个特定 <strong>channel</strong>。操作系统会调度所有这些进程，它们会争相检查睡眠条件。以这种方式行事的进程有时被称为 <strong>惊群效应（thundering herd）</strong>，最好避免这种情况。大多数条件变量都有两个唤醒的基元：信号（signal），唤醒一个进程；广播（broadcast），唤醒所有等待的进程</p>
</li>
<li><p>信号量通常用于同步。count 通常对应于类似于管道缓冲区中可用的字节数或一个进程拥有的僵尸子进程的数量。使用显式计数作为抽象的一部分，可以避免丢失 <strong>wakeup</strong> 的问题：有一个显式的计数，说明已经发生的唤醒次数。该计数还避免了 “虚假的” 唤醒和 <strong>惊群效应</strong> 问题</p>
</li>
<li><p>终止进程和清理进程在 xv6 中引入了很多复杂性。在大多数操作系统中，它甚至更加复杂，因为，假设被杀进程可能 <strong>trap</strong> 在内核中睡眠，而解除它的堆栈需要很多仔细的编程。许多操作系统使用显式的异常处理机制来解除堆栈，比如 <strong>longjmp</strong><a href="#ftn3">[3]</a>。此外，还有其他一些事件可以导致一个睡眠进程被唤醒，即使它正在等待的事件还没有发生。例如，当一个 Unix 进程处于睡眠状态时，另一个进程可能会向它发送一个 <strong>signal</strong>。在这种情况下，该进程将从中断的系统调用中返回，返回值为 -1，错误代码设置为 <strong>EINTR</strong>。应用程序可以检查这些值并决定做什么。xv6 不支持信号，也就不会出现这种复杂性</p>
</li>
<li><p>xv6 对 <strong>kill</strong> 的支持并不完全令人满意：有些 <strong>sleep</strong> 循环可能应该检查 <strong>p-&gt;killed</strong>。一个相关的问题是，即使是检查 <strong>p-&gt;killed</strong> 的 <strong>sleep</strong> 循环，在 <strong>sleep</strong> 和 <strong>kill</strong> 之间也会有一个竞争；<strong>kill</strong> 可能会设置 <strong>p-&gt;killed</strong>，并试图唤醒被杀进程，唤醒时刻发生在循环检查 <strong>p-&gt;killed</strong> 之后， 但在它调用 <strong>sleep</strong> 之前，就会发生。如果这个问题发生了，被杀进程不会注意到 <strong>p-&gt;killed</strong>，直到它所等待的条件发生。这可能会晚很多（例如，当 virtio 驱动返回一个被杀进程正在等待的磁盘块时），也可能永远不会发生（例如，如果被杀进程正在等待来自控制台的输入，但用户没有键入任何输入）</p>
</li>
<li><p>真正的操作系统会在常数时间内用显式的空闲列表来寻找空闲的进程，而不是在 allocproc 中进行线性时间的搜索；xv6 为了简单起见，使用了线性扫描的方式</p>
</li>
</ul>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li>Sleep 必须检查 lk !&#x3D; &amp; p-&gt;lock 以避免死锁 **(kernel&#x2F;proc.c:558-561)**。假设一种特殊情况通过将</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">     acquire(&amp;p-&gt;lock);</span><br><span class="line">     release(lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">release(lk);</span><br><span class="line">acquire(&amp;p-&gt;lock);</span><br></pre></td></tr></table></figure>

<p>这样会破坏 sleep 吗，怎样破坏</p>
<ol start="2">
<li><p>大部分进程退出时，资源清理可以通过 <strong>exit</strong> 或 <strong>wait</strong> 来完成。事实证明，关闭打开的文件一定要在<strong>exit</strong>中进行。为什么？答案和管道有关</p>
</li>
<li><p>在 xv6 中实现信号量而不使用 <strong>sleep</strong> 和 <strong>wakeup</strong> (但可以使用 <strong>spin</strong> <strong>locks</strong>)。在 xv6 中用信号量替换 <strong>sleep</strong> 和 <strong>wakeup</strong> 的使用。判断结果</p>
</li>
<li><p>修正上面提到的 <strong>kill</strong> 和 <strong>sleep</strong> 之间的竞争，使得发生在被杀进程睡眠循环检查 p-&gt;killed 之后，在它调用 sleep 之前的 kill 会使得被杀进程放弃当前系统调用</p>
</li>
<li><p>设计一个方案，让每一个睡眠循环都检查 <strong>p-&gt;killed</strong>，这样，在 <strong>virtio</strong> 驱动中的进程如果被其他进程杀死，就可以从 <strong>while</strong> 循环中快速返回</p>
</li>
<li><p>修改 xv6，当从一个进程的内核线程切换到另一个进程时，只使用一次上下文切换，而不是先切换到调度线程，再切换到另一个进程。使用一次上下文切换，产生的线程需要自己选择下一个线程，并调用 <strong>swtch</strong>。面临的挑战将是如何防止多个内核意外执行同一个线程；如何正确地进行锁定；以及如何避免死锁</p>
</li>
<li><p>修改 xv6 的调度器，当没有进程可运行时，使用 RISC-V <strong>WFI</strong>（等待中断）指令。尽量保证只要有可运行的进程等待运行，就不会有核心通过 WFI 进行暂停</p>
</li>
<li><p>锁 <strong>p-&gt;lock</strong> 保护了很多不变式，当看到某段被 <strong>p-&gt;lock</strong> 保护的 xv6 代码时，可能很难弄清楚保护了那个不变式。通过将 <strong>p-&gt;lock</strong> 拆分成几个锁，设计一个更简洁的方案</p>
</li>
</ol>
<hr>
<ol>
<li><p><a name="ftn1"></a>ra寄存器: 函数 return 地址</p>
</li>
<li><p><a name="ftn2"></a>严格地说，只是在 <strong>acquire</strong> 之后 <strong>wakeup</strong> 就足够了(也就是说，可以在 <strong>release</strong> 之后调用 <strong>wakeup</strong>)</p>
</li>
<li><p><a name="ftn3"></a>一种异常处理方式，可以去 google 下</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/6-s081/" rel="tag"># 6.s081</a>
              <a href="/tags/xv6/" rel="tag"># xv6</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/06/22/xv6-book-chapter-6/" rel="prev" title="xv6 book chapter 6">
      <i class="fa fa-chevron-left"></i> xv6 book chapter 6
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/07/01/6-S081-Lab6/" rel="next" title="Lab Multithreading">
      Lab Multithreading <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Multiplexing-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">Multiplexing 多路复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Context-switching-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">1.2.</span> <span class="nav-text">Code: Context switching 上下文切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Scheduling-%E8%B0%83%E5%BA%A6"><span class="nav-number">1.3.</span> <span class="nav-text">Code: Scheduling 调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-mycpu-and-myproc"><span class="nav-number">1.4.</span> <span class="nav-text">Code: mycpu and myproc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sleep-and-wakeup"><span class="nav-number">1.5.</span> <span class="nav-text">Sleep and wakeup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Sleep-and-wakeup"><span class="nav-number">1.6.</span> <span class="nav-text">Code: Sleep and wakeup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Pipes"><span class="nav-number">1.7.</span> <span class="nav-text">Code: Pipes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Wait-exit-and-kill"><span class="nav-number">1.8.</span> <span class="nav-text">Code: Wait, exit, and kill</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world"><span class="nav-number">1.9.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercises"><span class="nav-number">1.10.</span> <span class="nav-text">Exercises</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
