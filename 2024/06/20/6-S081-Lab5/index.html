<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="注意事项 Lab Guidance：Lab: Copy-on-Write Fork for xv6 (mit.edu)  虚拟内存提供了一种程度的间接性：内核可以通过将 PTE 标记为无效或只读来拦截内存引用，从而导致页面错误，并且可以通过修改 PTE 来更改地址的含义  计算机系统中有句谚语：任何系统问题都可以通过间接层来解决  在开始前，输入：git fetch &amp;&amp; git">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab Copy on-write">
<meta property="og:url" content="http://yiweiboi.github.io/2024/06/20/6-S081-Lab5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="注意事项 Lab Guidance：Lab: Copy-on-Write Fork for xv6 (mit.edu)  虚拟内存提供了一种程度的间接性：内核可以通过将 PTE 标记为无效或只读来拦截内存引用，从而导致页面错误，并且可以通过修改 PTE 来更改地址的含义  计算机系统中有句谚语：任何系统问题都可以通过间接层来解决  在开始前，输入：git fetch &amp;&amp; git">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yiweiboi.github.io/2024/06/20/6-S081-Lab5/image-20240622211042467.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/06/20/6-S081-Lab5/image-20240622221123530.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/06/20/6-S081-Lab5/image-20240622230114645.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/06/20/6-S081-Lab5/image-20240622230857574.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/06/20/6-S081-Lab5/image-20240622231107743.png">
<meta property="article:published_time" content="2024-06-20T08:39:25.000Z">
<meta property="article:modified_time" content="2024-06-22T15:13:11.212Z">
<meta property="article:author" content="yiweiBoi">
<meta property="article:tag" content="6.s081">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yiweiboi.github.io/2024/06/20/6-S081-Lab5/image-20240622211042467.png">

<link rel="canonical" href="http://yiweiboi.github.io/2024/06/20/6-S081-Lab5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Lab Copy on-write | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/20/6-S081-Lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Lab Copy on-write
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-20 16:39:25" itemprop="dateCreated datePublished" datetime="2024-06-20T16:39:25+08:00">2024-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-22 23:13:11" itemprop="dateModified" datetime="2024-06-22T23:13:11+08:00">2024-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>Lab Guidance：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2023/labs/cow.html">Lab: Copy-on-Write Fork for xv6 (mit.edu)</a></p>
</li>
<li><p>虚拟内存提供了一种程度的间接性：内核可以通过将 PTE 标记为无效或只读来拦截内存引用，从而导致页面错误，并且可以通过修改 PTE 来更改地址的含义</p>
</li>
<li><p>计算机系统中有句谚语：任何系统问题都可以通过间接层来解决</p>
</li>
<li><p>在开始前，输入：<code>git fetch &amp;&amp; git checkout cow &amp;&amp; make clean</code> 来切换到 cow 分支</p>
</li>
</ul>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ul>
<li>xv6 中的 <code>fork()</code> 系统调用将父进程的所有用户空间内存复制到子进程中，如果父进程很大，复制可以需要很长时间，更糟糕的是：子进程中，<code>fork()</code> 后面通常是 <code>exec()</code>，它丢弃了复制的内存，通常不使用大部分内存</li>
<li>另一方面，如果父进程和子进程使用一个复制页面，并且他们中的一个或两个都写它，复制确实是需要的</li>
</ul>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li>你实现写时复制（COW）<code>fork()</code> 的目标是推迟分配和复制物理内存页面，直到真正需要副本</li>
<li>COW <code>fork()</code> 仅为子进程创建一个页表，用户内存的 PTE 指向父级物理页面。COW <code>fork()</code> 将父进程和子进程中的所有用户 PTE 标记为只读。当任一进程尝试写这些 COW 页面之一时，CPU 将强制出现页面错误。内核页面错误处理程序检测此情况，为发生错误的进程分配一个物理内存页面，将原始页面复制到新页面，并修改发生错误进程中的相关 PTE 以引用新页面，PTE 标记为可写。当页面错误处理程序返回时，用户进程将能够写页面的副本了。</li>
<li>COW <code>fork()</code> 使释放实现用户内存的物理页面变得有些棘手。给定的物理页面可以被多个进程的页表引用，并且只有在最后一个引用消失时才应释放。在像 xv6 这样的简单内核中，这种记录相当简单明了，但在真正的内核中，这可能很难正确</li>
</ul>
<h1 id="Implement-copy-on-write-fork"><a href="#Implement-copy-on-write-fork" class="headerlink" title="Implement copy-on-write fork"></a>Implement copy-on-write fork</h1><ul>
<li><p>你的任务是在 xv6 内核中实现写时复制 <code>fork()</code>。如果你修改后的内核成功执行了 <code>cowtest</code> 和 <code>usertests</code>，则通过</p>
</li>
<li><p>这是一个合理的 attack 计划</p>
<ul>
<li>修改 <code>uvmcopy()</code> 以将父进程的物理页面映射到子进程，而不是分配的新的页面。对于设置了 PTE_W 的页面，在子进程和父进程的 PTE 中清除 PTE_W</li>
<li>修改 <code>usertrap()</code> 以识别页面错误。当最初的可写入 COW 页面上发生页面错误时，使用 <code>kalloc()</code> 分配一个新页面，将旧页面复制到新页面，并在设置 PTE_W 的 PTE 中设置新页面。最初只读的页面（没有 PTE_W，如文本段中的页面）应保持只读状态，并在父进程和子进程之间共享；试图写此类页面的进程应该被终止</li>
<li>确保每个物理页面在最后一次 PTE 引用消失时释放——但不是之前。做到这一点的一个好方法是为每个物理页面保留引用该页面的 “引用计数”。当 <code>kalloc()</code> 分配页面时，将页面的引用计数设置为 1。当 <code>fork()</code> 导致共享页面时，增加页面的引用计数，每次任何进程将页面从其页面表中删除时，都会减少页面的引用计数。<code>kfree()</code> 仅当其引用计数为零时，才将页面放回到空闲链表中。将这些计数保留在固定大小的整数数组中是可以的。你必须制定一个如何索引数组以及如何选择其大小的方案。例如，你可以将页面的物理地址除以 4096 对数组进行索引，并通过 <code>kalloc.c</code> 中的 <code>kinit()</code> 为数组提供等于空闲链表中页面的最高物理地址的大小。随意修改 <code>kalloc.c</code>（例如，<code>kalloc()</code> 和 <code>kfree()</code>）以保持引用计数</li>
<li>修改 <code>copyout()</code>，以便在遇到 COW 页面时使用与页面错误系统的方案</li>
</ul>
</li>
<li><p>一些提示</p>
<ul>
<li>对于每个 PTE，有一种记录它是否是 COW 映射的方法可能是有用的。你可以使用 RISC-V 中的 RSW（保留给软件）位</li>
<li><code>usertests</code> 探索了 <code>cowtest</code> 不测试的场景，所以不要忘记检查所有的测试是否通过</li>
<li>对页表标志有用的一些宏定义在 <code>kernel/riscv.h</code> 的末尾</li>
<li>如果发生 COW 页面错误，并且没有可用的内存，则应该终止进程</li>
</ul>
</li>
</ul>
<img src="/2024/06/20/6-S081-Lab5/image-20240622211042467.png" class="" title="image-20240622211042467">

<ul>
<li>在 <code>kernel/riscv.h</code> 中添加 <code>PTE_COW</code> 来标记这是一个 COW 页面</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L &lt;&lt; 4) <span class="comment">// user can access</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8) <span class="comment">// COW</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/vm.c</code> 中，修改 <code>uvmcopy()</code> 将父进程的物理内存映射到子进程的页表中，需要注意的是：<ul>
<li>只有 PTE 拥有 PTE_W 时才消除 PTE_W，添加 PTE_COW。PTE 没有 PTE_W 时有两种情况，第一种是已经是 COW 页面了，第二种是只读页面</li>
<li>在将可写页面设置为 COW 页面时有一个逻辑上的细节。当一个 PTE 拥有 PTE_W 时，将父进程的 PTE  消除 PTE_W，添加 PTE_COW，之后子进程 <code>(mappages(new, i, PGSIZE, pa, flags)</code> 映射时，由于父进程 PTE 的 <code>flags</code> 已经更新，所以子进程的相关页面也是 COW 页面了。不仅更新了父进程的可写页面为 COW 页面，之后子进程的相关也是 COW 页面了</li>
<li>映射成功后，通过 <code>add_refcount(pa)</code> （之后讨论方法的具体实现及细节）增加对应页面的引用计数</li>
<li>发生错误 <code>goto err</code> 时，调用了 <code>uvmunmap(new, 0, i / PGSIZE, 1)</code>，第四个参数为 1 表示取消映射且 <code>kfree()</code> 映射的物理内存，这也是与引用计数相关的细节，之后再讨论</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given a parent process&#x27;s page table, copy 给定一个父进程的页表，复制其内存到子进程的页表中</span></span><br><span class="line"><span class="comment">// its memory into a child&#x27;s page table.</span></span><br><span class="line"><span class="comment">// Copies both the page table and the 复制页表和物理内存</span></span><br><span class="line"><span class="comment">// physical memory.</span></span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure. 成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="comment">// frees any allocated pages on failure. 如果失败，释放任何已分配的页面</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_W) != <span class="number">0</span>) &#123;</span><br><span class="line">      *pte |= PTE_COW;</span><br><span class="line">      *pte &amp;= (~PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span> (mappages(new, i, PGSIZE, pa, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: mappages error&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    add_refcount(pa);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err:</span><br><span class="line">    uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 <code>copyout()</code> 和发生页面错误时 <code>usertrap()</code> 的处理方案相同，所以创建一个方法来解决，需要注意的是：<ul>
<li><code>va &gt; MAXVA</code> 中的 <code>MAXVA</code> 真的值得注意，不要写成 <code>MAXARG</code>（因为它，我重新写了整个实验！）</li>
<li>如果 PTE 没有 PTE_W，也没有 PTE_COW 时，说明它是一个最初的只读页面，不能写。此时 <code>usertrap()</code> 会终止写一个只读页面而造成 page fault 的进程；<code>copyout()</code> 也是一样（<code>usertests</code> 的 <code>copyout</code> 测试了它，由于这个条件没写，Debug 很久，又重新写了一次实验！！）</li>
<li>如果 PTE 没有 PTE_W，或者没有 PTE_COW，此时 PTE 是一个最初的可写页面。最后 PTE 就只能是 COW 页面了</li>
<li>如果 COW 页面的引用计数为 1，那么添加 PTE_W，消除 PTE_COW，重新变为最初的可写页面</li>
<li><code>(mappages(pagetable, PGROUNDDOWN(va), PGSIZE, pa1, flags)</code> 失败时需要 <code>kfree()</code>，当然也和引用计数有关</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">handler_COW</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa0, pa1, flags;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pte == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_U) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pa0 = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_COW) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_W) != <span class="number">0</span> || (*pte &amp; PTE_COW) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> pa0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_refcount(pa0) == <span class="number">1</span>) &#123;</span><br><span class="line">    *pte &amp;= (~PTE_COW);</span><br><span class="line">    *pte |= PTE_W;</span><br><span class="line">    <span class="keyword">return</span> pa0;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (get_refcount(pa0) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    panic(<span class="string">&quot;handle_COW: refcount &lt;= 0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((pa1 = (uint64)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  flags = PTE_FLAGS(*pte);</span><br><span class="line">  flags |= PTE_W;</span><br><span class="line">  flags &amp;= (~PTE_COW);</span><br><span class="line">  memmove((<span class="type">void</span> *)pa1, (<span class="type">void</span> *)pa0, PGSIZE);</span><br><span class="line">  uvmunmap(pagetable, PGROUNDDOWN(va), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, PGROUNDDOWN(va), PGSIZE, pa1, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *)pa1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pa1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/vm.c</code> 中，修改 <code>copyout()</code>，在遇到 COW 页面时采用上述方案</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user. 从内核复制到用户空间</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table. 复制len字节从src到给定的页表中的虚拟地址dstva</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.  返回0表示成功，-1表示失败</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="comment">// printf(&quot;here &quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    </span><br><span class="line">    pa0 = handler_COW(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/defs.h</code> 中添加 <code>handler_COW</code> 以便在 <code>usertrap()</code> 中调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm.c</span></span><br><span class="line">uint64          <span class="title function_">handler_COW</span><span class="params">(<span class="type">pagetable_t</span> pagatable, uint64 va)</span>;</span><br></pre></td></tr></table></figure>

<style>.rcjqldjjhyjn{zoom: 67%;}</style><img src="/2024/06/20/6-S081-Lab5/image-20240622221123530.png" class="rcjqldjjhyjn" alt="image-20240622221123530">

<ul>
<li><code>kernel/trap.c</code> 中，修改 <code>usertrap()</code> 处理由于写 COW 页面而造成的 page fault。如果写一个只读页面，立即终止这个进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">    <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span>(handler_COW(p-&gt;pagetable, va) == <span class="number">0</span>)&#123;  </span><br><span class="line">      setkilled(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">      setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/kalloc.c</code> 中创建相关结构体和方法，实现引用计数，需要注意的是：<ul>
<li>由于记录引用计数的数组属于临界资源，所以需要锁来实现互斥访问</li>
<li>由于 <code>refcount</code> 结构体变量是全局变量，所以引用计数数组中所有元素初始值为 0</li>
<li><code>PHYSTOP</code> 是物理内存地址的最大值，<code>KERNBASE</code> 是物理内存地址的最小值，在 <code>kernel/memlayout.h</code> 中定义</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[(PHYSTOP - KERNBASE) / PGSIZE];</span><br><span class="line">&#125; refcount;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_refcount</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || pa &gt;= PHYSTOP) &#123;</span><br><span class="line">    panic(<span class="string">&quot;add_refcount: index error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint64 ret;</span><br><span class="line">  pa = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  ret = ++refcount.<span class="built_in">array</span>[pa];</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_refcount</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || pa &gt;= PHYSTOP) &#123;</span><br><span class="line">    panic(<span class="string">&quot;sub_refcount: index error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pa = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  ret = --refcount.<span class="built_in">array</span>[pa];</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_refcount</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || pa &gt;= PHYSTOP) &#123;</span><br><span class="line">    panic(<span class="string">&quot;get_refcount: index error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pa = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  ret = refcount.<span class="built_in">array</span>[pa];</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kinit()</code> 初始化锁（好像并不需要，因为锁的初始值就是 0）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;refcount.lock, <span class="string">&quot;refcount&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kfree()</code>，每次调用 <code>kfree()</code> 时都会减少引用计数，只有引用计数为 0 时才真正释放物理内存，需要注意的是：<ul>
<li>经过之前的修改，每个进程在将页面从页表中删除时，都会调用 <code>kfree()</code> 释放映射的物理内存，因此最终在 <code>kfree()</code> 中减少引用计数是合理的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sub_refcount((uint64)pa) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>kalloc()</code> 在分配页面时，将引用计数设置为 1，需要注意的是：<ul>
<li>只有分配成功时才设置引用计数，由于引用计数初始值为 0，加一后为 1</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r) &#123;</span><br><span class="line">    add_refcount((uint64)r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>freerange()</code>，一个回马枪，需要注意的是：<ul>
<li><code>kinit()</code> 调用了 <code>freerange()</code>，<code>freerange()</code> 对每个物理页面调用了 <code>kfree()</code> 将其添加到空闲链表</li>
<li>由于引用计数初始值都为 0，减一后不等于 0 会导致无法添加，加一保证了页面可以添加到空闲链表</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE) &#123;</span><br><span class="line">    add_refcount((uint64)p);</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>kernel/defs.h</code> 中添加相关函数原型，以便在其他文件中调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="type">int</span>             <span class="title function_">add_refcount</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">sub_refcount</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">get_refcount</span><span class="params">(uint64 pa)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><strong>make clean &amp;&amp; make qemu &amp;&amp; cowtest &amp;&amp; usertests</strong></li>
</ul>
<img src="/2024/06/20/6-S081-Lab5/image-20240622230114645.png" class="" title="image-20240622230114645">

<img src="/2024/06/20/6-S081-Lab5/image-20240622230857574.png" class="" title="image-20240622230857574">

<ul>
<li><strong>make grade</strong></li>
</ul>
<img src="/2024/06/20/6-S081-Lab5/image-20240622231107743.png" class="" title="image-20240622231107743">

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/121418548">MIT 6.S081] Lab 6: Copy-on-Write Fork for xv6_xv6 lab cow-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16170379.html">MIT6.S081-Lab5 COW 2021Fall] - duile - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://ttzytt.com/2022/07/xv6_lab6_record/index.html">MIT 6.s081] Xv6 Lab6 COW 实验记录 | tzyt的博客 (ttzytt.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.expoli.tech/articles/2023/07/25/[MIT-6.s081]-Lab:-Copy-on-Write-Fork-for-xv6-experiment-record#d40c70a00c7e45e59250f5f9d4c99297">MIT 6.s081] Lab: Copy-on-Write Fork for xv6 实验记录 | 糖醋鱼的小破站 (expoli.tech)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/644779152">MIT 6.828 LAB 5 COW 代码与debug - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cstardust.github.io/2022/11/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab6-cow/">操作系统-xv6-lab6-cow | 不落辰 (cstardust.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/traver/p/15778370.html">MIT 6.S081 操作系统 LAB6:Copy-on-Write - traver - 博客园 (cnblogs.com)</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/6-s081/" rel="tag"># 6.s081</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/06/19/xv6-book-chapter-5/" rel="prev" title="xv6 book chapter 5">
      <i class="fa fa-chevron-left"></i> xv6 book chapter 5
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/06/22/xv6-book-chapter-6/" rel="next" title="xv6 book chapter 6">
      xv6 book chapter 6 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Implement-copy-on-write-fork"><span class="nav-number">4.</span> <span class="nav-text">Implement copy-on-write fork</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Test"><span class="nav-number">5.</span> <span class="nav-text">Test</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#References"><span class="nav-number">6.</span> <span class="nav-text">References</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
