<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="陷阱和系统调用 有三种事件会导致 CPU 搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码  一种情况是 系统调用，当用户程序执行 ecall 指令要求内核为其做某事时 另一种情况是 异常：一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址 第三种情况是设备 中断，当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时   本书使用 trap 作为这些情况的">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6 book chapter 4">
<meta property="og:url" content="http://yiweiboi.github.io/2024/06/05/xv6-book-chapter-4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="陷阱和系统调用 有三种事件会导致 CPU 搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码  一种情况是 系统调用，当用户程序执行 ecall 指令要求内核为其做某事时 另一种情况是 异常：一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址 第三种情况是设备 中断，当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时   本书使用 trap 作为这些情况的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-06-05T12:02:43.000Z">
<meta property="article:modified_time" content="2024-06-22T10:36:46.832Z">
<meta property="article:author" content="yiweiBoi">
<meta property="article:tag" content="6.s081">
<meta property="article:tag" content="xv6 book">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yiweiboi.github.io/2024/06/05/xv6-book-chapter-4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>xv6 book chapter 4 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/06/05/xv6-book-chapter-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          xv6 book chapter 4
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-05 20:02:43" itemprop="dateCreated datePublished" datetime="2024-06-05T20:02:43+08:00">2024-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-22 18:36:46" itemprop="dateModified" datetime="2024-06-22T18:36:46+08:00">2024-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h1><ul>
<li><p>有三种事件会导致 CPU 搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码</p>
<ul>
<li>一种情况是 <strong>系统调用</strong>，当用户程序执行 <strong>ecall</strong> 指令要求内核为其做某事时</li>
<li>另一种情况是 <strong>异常</strong>：一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址</li>
<li>第三种情况是设备 <strong>中断</strong>，当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时</li>
</ul>
</li>
<li><p>本书使用 <strong>trap</strong> 作为这些情况的通用术语</p>
<ul>
<li>通常，代码在执行时发生 trap，之后都会被恢复，而且不需要意识到发生了什么特殊的事情</li>
<li>也就是说，我们通常希望 trap 是透明的；这一点对于中断来说尤其重要，被中断的代码通常不会意识到会发生 trap</li>
<li>通常的顺序是：trap 迫使控制权转移到内核；内核保存寄存器和其他状态，以便恢复执行；内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；内核恢复保存的状态，并从 trap 中返回；代码从原来的地方恢复执行</li>
</ul>
</li>
<li><p>xv6 内核会处理所有的 trap</p>
<ul>
<li>这对于系统调用来说是很自然的</li>
<li>这对中断来说也是合理的，因为隔离要求用户进程不能直接使用设备，而且只有内核才有设备处理所需的状态</li>
<li>这对异常处理来说也是合理的，因为 xv6 响应所有来自用户空间的异常，并杀死该违规程序</li>
</ul>
</li>
<li><p>xv6 trap 处理分为四个阶段：</p>
<ul>
<li>RISC-V CPU 采取的硬件行为，为内核 C 代码准备的汇编入口，处理 trap 的 C 处理程序，以及系统调用或设备驱动服务</li>
<li>虽然三种 trap 类型之间的共性表明，内核可以用单一的代码入口处理所有的 trap，但事实证明，为三种不同的情况，即来自用户空间的 trap、来自内核空间的 trap 和定时器中断，设置单独的汇编入口和 C trap 处理程序会更方便的</li>
</ul>
</li>
</ul>
<h2 id="RISC-V-trap-machinery-RISC-V-陷阱处理机制"><a href="#RISC-V-trap-machinery-RISC-V-陷阱处理机制" class="headerlink" title="RISC-V trap machinery RISC-V 陷阱处理机制"></a>RISC-V trap machinery RISC-V 陷阱处理机制</h2><ul>
<li><p>每个 RISC-V CPU 都有一组控制寄存器，内核写入这些寄存器来告诉 CPU 如何处理 trap，内核可以通过读取这些寄存器来发现已经发生的 trap</p>
<ul>
<li>RISC-V 文档包含了完整的叙述[1]</li>
<li><code>riscv.h</code>（kernel&#x2F;riscv.h:1）包含了 xv6 使用的定义。这里是最重要的寄存器的概述</li>
</ul>
<ul>
<li><p><code>stvec</code>：内核在这里写下 trap 处理程序的地址；RISC-V 跳转到这里来处理 trap</p>
</li>
<li><p><code>sepc</code>：当 trap 发生时，RISC-V 会将程序计数器保存在这里（因为 <code>PC</code> 会被 <code>stvec</code> 覆盖）</p>
<ul>
<li><code>sret</code>（从 trap 中返回）指令将 <code>sepc</code> 复制到 <code>pc</code> 中。内核可以写 <code>sepc</code> 来控制 <code>sret</code> 的返回到哪里</li>
</ul>
</li>
<li><p><code>scause</code>：RISC -V 在这里放了一个数字，描述了 trap 的原因</p>
</li>
<li><p><code>sscratch</code>：内核在这里放置了一个值，在 trap 处理程序开始时可以方便地使用</p>
</li>
<li><p><code>sstatus</code>：<code>sstatus</code> 中的 <strong>SIE</strong> 位控制设备中断是否被启用，如果内核清除 <strong>SIE</strong>，RISC-V 将推迟设备中断，直到内核设置 <strong>SIE</strong></p>
<ul>
<li><strong>SPP</strong> 位表示 trap 是来自用户模式还是 supervisor 模式，并控制 <code>sret</code> 返回到什么模式</li>
</ul>
</li>
</ul>
</li>
<li><p>上述寄存器与在特权态模式下处理的 trap 有关，在用户模式下不能读或写</p>
<ul>
<li>对于机器模式下处理的 trap，有一组等效的控制寄存器；xv6 只在定时器中断的特殊情况下使用它们</li>
</ul>
</li>
<li><p>多核芯片上的每个 CPU 都有自己的一组这些寄存器，而且在任何时候都可能有多个 CPU 在处理一个 trap</p>
</li>
<li><p>当需要执行 trap 时，RISC-V 硬件对所有的 trap 类型（除定时器中断外）进行以下操作：</p>
<ul>
<li><p>如果该 trap 是设备中断，且 <code>sstatus</code> <strong>SIE</strong> 位为 0，则不执行以下任何操作</p>
</li>
<li><p>通过清除 SIE 来禁用中断</p>
</li>
<li><p>复制 <code>pc</code> 到 <code>sepc</code></p>
</li>
<li><p>将当前模式（用户态或特权态）保存在 <code>sstatus</code> 的 <strong>SPP</strong> 位</p>
</li>
<li><p>在 <code>scause</code> 设置该次 trap 的原因</p>
</li>
<li><p>将模式转换为特权态</p>
</li>
<li><p>将 <code>stvec</code> 复制到 <code>pc</code></p>
</li>
<li><p>从新的 <code>pc</code> 开始执行</p>
</li>
</ul>
</li>
<li><p>注意，CPU 不会切换到内核页表，不会切换到内核中的栈，也不会保存 pc 以外的任何寄存器</p>
<ul>
<li>内核软件必须执行这些任务</li>
<li>CPU 在 trap 期间做很少的工作的一个原因是为了给软件提供灵活性，例如，一些操作系统在某些情况下不需要页表切换，这可以提高性能</li>
</ul>
</li>
<li><p>你可能会想 CPU 的 trap 处理流程是否可以进一步简化</p>
<ul>
<li>例如，假设 CPU 没有切换程序计数器（pc）</li>
<li>那么 trap 可以切换到监督者模式时，还在运行用户指令。这些用户指令可以打破用户空间&#x2F;内核空间的隔离，例如通过修改 <code>satp</code> 寄存器指向一个允许访问所有物理内存的页表</li>
<li>因此，CPU 必须切换到内核指定的指令地址，即 <code>stvec</code></li>
</ul>
</li>
</ul>
<blockquote>
<p> 在进入 trampoline.S 之前，ecall 指令做了三件事情：</p>
<p> 保存用户 pc，将权限提升到内核模式，更改 pc 为 trampoline.S 的起始地址并跳转到 trampoline.S</p>
</blockquote>
<h2 id="Traps-from-user-space-来自用户空间的陷阱"><a href="#Traps-from-user-space-来自用户空间的陷阱" class="headerlink" title="Traps from user space 来自用户空间的陷阱"></a>Traps from user space 来自用户空间的陷阱</h2><ul>
<li><p>在用户空间执行时，如果用户程序进行了系统调用（<code>ecall</code> 指令），或者做了一些非法的事情，或者设备中断，都可能发生 trap</p>
<ul>
<li>来自用户空间的 trap 的处理路径是 <code>uservec</code>（kernel&#x2F;trampoline.S:16），然后是 <code>usertrap</code>（kernel&#x2F;trap.c:37）；返回时是<code>usertrapret</code>（kernel&#x2F;trap.c:90），然后是 <code>userret</code>（kernel&#x2F;trampoline.S:16）。</li>
</ul>
</li>
<li><p>来自用户代码的 trap 比来自内核的 trap 更具挑战性，因为 <code>satp</code> 指向的用户页表并不映射内核，而且栈指针可能包含一个无效甚至恶意的值</p>
</li>
<li><p>因为 RISC-V 硬件在 trap 过程中不切换页表，所以用户页表必须包含 <code>uservec</code> 的映射，即 <code>stvec</code> 指向的 trap 处理程序地址</p>
<ul>
<li><code>uservec</code> 必须切换 <code>satp</code>，使其指向内核页表；为了在切换后继续执行指令，<code>uservec</code> 必须被映射到内核页表与用户页表相同的地址</li>
</ul>
</li>
<li><p>xv6 用一个包含 <code>uservec</code> 的 trampoline 页来满足这些条件</p>
<ul>
<li>xv6 在内核页表和每个用户页表中的同一个虚拟地址上映射了 trampoline 页</li>
<li>这个虚拟地址就是 <code>TRAMPOLINE</code>（如我们在图 2.3 和图 3.3 中看到的）</li>
<li><code>trampoline.S</code> 中包含 trampoline 的内容，（执行用户代码时）<code>stvec</code> 设置为 <code>uservec</code>（kernel&#x2F;trampoline.S:16）。</li>
</ul>
</li>
<li><p>当 <code>uservec</code> 启动时，所有 32 个寄存器都包含被中断的代码所拥有的值</p>
<ul>
<li>但是 <code>uservec</code> 需要能够修改一些寄存器，以便设置 <code>satp</code> 和生成保存寄存器的地址</li>
<li>RISC-V 通过 <code>sscratch</code> 寄存器提供了帮助</li>
<li><code>uservec</code> 开始时的 <code>csrrw</code> 指令将 <code>a0</code> 和 <code>sscratch</code> 的内容互换</li>
<li>现在用户代码的 <code>a0</code> 被保存了；<code>uservec</code> 有一个寄存器（<code>a0</code>）可以使用；<code>a0</code> 包含了内核之前放在 <code>sscratch</code> 中的值。</li>
</ul>
</li>
<li><p><code>uservec</code> 的下一个任务是保存用户寄存器</p>
<ul>
<li><p>在进入用户空间之前，内核先设置 <code>sscratch</code> 指向该进程的 <code>trapframe</code>，这个 <code>trapframe</code> 可以保存所有用户寄存器（kernel&#x2F;proc.h:44）</p>
</li>
<li><p>因为 <code>satp</code> 仍然是指用户页表，所以 <code>uservec</code> 需要将 <code>trapframe</code> 映射到用户地址空间中</p>
</li>
<li><p>当创建每个进程时，xv6 为进程的 <code>trapframe</code> 分配一页内存，并将它映射在用户虚拟地址 <code>TRAPFRAME</code>，也就是 <code>TRAMPOLINE</code> 的下面</p>
</li>
<li><p>进程的 <code>p-&gt;trapframe</code> 也指向 <code>trapframe</code>，不过是指向它的物理地址[<a href="#_ftn1">1]</a>，这样内核可以通过内核页表来使用它</p>
</li>
</ul>
</li>
<li><p>因此，在交换 <code>a0</code> 和 <code>sscratch</code> 后，<code>a0</code> 将指向当前进程的 <code>trapframe</code></p>
<ul>
<li><code>uservec</code> 将在 <code>trapframe</code> 保存全部的寄存器，包括从 <code>sscratch</code> 读取的 <code>a0</code></li>
</ul>
</li>
<li><p><code>trapframe</code> 包含指向当前进程的内核栈、当前 CPU 的 hartid、<code>usertrap</code> 的地址和内核页表的地址的指针，<code>uservec</code> 将这些值设置到相应的寄存器中，并将 <code>satp</code> 切换到内核页表和刷新 TLB，然后调用 <code>usertrap</code></p>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">     # trap.c sets stvec to point here, so	trap.c设置的stvec指向这里</span><br><span class="line">     # traps from user space start here,		所以来自用户空间的陷阱从这里开始</span><br><span class="line">     # in supervisor mode, but with a		在监督者模式，但是有一个用户页表</span><br><span class="line">     # user page table.</span><br><span class="line">     #</span><br><span class="line"></span><br><span class="line">     # save user a0 in sscratch so			保存用户a0到sscratch以便a0可以被使用去到达TRAPFRAME</span><br><span class="line">     # a0 can be used to get at TRAPFRAME.</span><br><span class="line">     csrw sscratch, a0</span><br><span class="line"></span><br><span class="line">		# trap frame 陷阱帧，用于保存当前进程的重要信息</span><br><span class="line">     # each process has a separate p-&gt;trapframe memory area,	每个进程都有一个独立的p-&gt;trapframe内存区域</span><br><span class="line">     # but it&#x27;s mapped to the same virtual address			但是被映射到相同的虚拟地址</span><br><span class="line">     # (TRAPFRAME) in every process&#x27;s user page table.		（TRAPFRAME）在每个进程的用户页表中</span><br><span class="line">     li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">     # save the user registers in TRAPFRAME		保存用户寄存器在TRAPFRAME</span><br><span class="line">     sd ra, 40(a0)</span><br><span class="line">     sd sp, 48(a0)</span><br><span class="line">     sd gp, 56(a0)</span><br><span class="line">     sd tp, 64(a0)</span><br><span class="line">     sd t0, 72(a0)</span><br><span class="line">     sd t1, 80(a0)</span><br><span class="line">     sd t2, 88(a0)</span><br><span class="line">     sd s0, 96(a0)</span><br><span class="line">     sd s1, 104(a0)</span><br><span class="line">     sd a1, 120(a0)</span><br><span class="line">     sd a2, 128(a0)</span><br><span class="line">     sd a3, 136(a0)</span><br><span class="line">     sd a4, 144(a0)</span><br><span class="line">     sd a5, 152(a0)</span><br><span class="line">     sd a6, 160(a0)</span><br><span class="line">     sd a7, 168(a0)</span><br><span class="line">     sd s2, 176(a0)</span><br><span class="line">     sd s3, 184(a0)</span><br><span class="line">     sd s4, 192(a0)</span><br><span class="line">     sd s5, 200(a0)</span><br><span class="line">     sd s6, 208(a0)</span><br><span class="line">     sd s7, 216(a0)</span><br><span class="line">     sd s8, 224(a0)</span><br><span class="line">     sd s9, 232(a0)</span><br><span class="line">     sd s10, 240(a0)</span><br><span class="line">     sd s11, 248(a0)</span><br><span class="line">     sd t3, 256(a0)</span><br><span class="line">     sd t4, 264(a0)</span><br><span class="line">     sd t5, 272(a0)</span><br><span class="line">     sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# save the user a0 in p-&gt;trapframe-&gt;a0	保存用户a0在p-&gt;trapframe-&gt;a0</span><br><span class="line">     csrr t0, sscratch</span><br><span class="line">     sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">     # initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">     # 从 p-&gt;trapframe-&gt;kernel_sp 初始化内核栈指针</span><br><span class="line">     ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">     # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid </span><br><span class="line">     ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">     # load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap	初始化usertrap()的地址</span><br><span class="line">     ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">     # fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.	</span><br><span class="line">     # 从 p-&gt;trapframe-&gt;kernel_satp 获取内核页表地址</span><br><span class="line">     ld t1, 0(a0)</span><br><span class="line"></span><br><span class="line">     # wait for any previous memory operations to complete, so that</span><br><span class="line">     # they use the user page table.</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">     # install the kernel page table.	切换到内核页表</span><br><span class="line">     csrw satp, t1</span><br><span class="line"></span><br><span class="line">     # flush now-stale user entries from the TLB. 刷新TLB</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">     # jump to usertrap(), which does not return	跳转到usertrap()</span><br><span class="line">     jr t0</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">truct trapframe &#123;</span><br><span class="line"><span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table	</span></span><br><span class="line"><span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line"><span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line"><span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line"><span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line"><span class="comment">/*  40 */</span> uint64 ra;			  <span class="comment">// 上面这些与内核有关的寄存器在usertrapret返回到trampoline.S之前已经被设置</span></span><br><span class="line"><span class="comment">/*  48 */</span> uint64 sp;			  <span class="comment">// 需要注意的是：用户的a0和trapframe中的a0是不一样的</span></span><br><span class="line"><span class="comment">/*  56 */</span> uint64 gp;			  <span class="comment">// trapframe中的a0会被系统调用的返回值覆盖，返回到用户空间之前有被交换到a0</span></span><br><span class="line"><span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line"><span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line"><span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line"><span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line"><span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line"><span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line"><span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line"><span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line"><span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line"><span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line"><span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line"><span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line"><span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line"><span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line"><span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line"><span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line"><span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line"><span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line"><span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line"><span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line"><span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line"><span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line"><span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line"><span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line"><span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line"><span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line"><span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line"><span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>usertrap</code> 的作用是确定 trap 的原因，处理它，然后返回（kernel&#x2F; trap.c:37）</p>
<ul>
<li>如上所述，它首先改变 <code>stvec</code>，这样在内核中发生的 trap 将由 <code>kernelvec</code> 处理</li>
<li>它保存了 <code>sepc</code>（用户PC），这也是因为 <code>usertrap</code> 中可能会有一个进程切换，导致 <code>sepc</code> 被覆盖</li>
<li>如果 trap 是系统调用，<code>syscall</code> 会处理它；如果是设备中断，<code>devintr</code> 会处理；否则就是异常，内核会杀死故障进程</li>
<li><code>usertrap</code> 会把用户 <code>pc</code> 加 4，因为 RISC-V 在执行系统调用时，会留下指向 <code>ecall</code> 指令的程序指针<a href="#ftn2">[2]</a></li>
<li>在退出时，<code>usertrap</code> 检查进程是否已经被杀死或应该让出 CPU（如果这个 trap 是一个定时器中断）</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.  </span></span><br><span class="line"><span class="comment">// 处理一个来自用户空间的中断，异常，或系统调用</span></span><br><span class="line"><span class="comment">// called from trampoline.S   来自于trampoline.S的调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// send interrupts and exceptions to kerneltrap(), </span></span><br><span class="line"><span class="comment">// 因为我们现在处于内核中，将中断和异常发送到 kerneltrap() 函数处理</span></span><br><span class="line"><span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">w_stvec((uint64)kernelvec);	</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// save user program counter. 保存用户的程序计数器</span></span><br><span class="line">p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line"> <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(killed(p))</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// sepc points to the ecall instruction,  spec 指向ecall指令，但我们想要返回下一条指令</span></span><br><span class="line"> <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line"> p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// an interrupt will change sepc, scause, and sstatus, </span></span><br><span class="line"> <span class="comment">// 中断会改变 sepc、scause 和 sstatus 寄存器的值，所以只有在处理完这些寄存器之后，我们才启用中断</span></span><br><span class="line"> <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line"> intr_on(); <span class="comment">// 所以中断打开仅在处理syscall()时，从用户空间触发的中断是不允许嵌套的</span></span><br><span class="line"></span><br><span class="line"> syscall();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line"> <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line"> setkilled(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(killed(p))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line"> yield();</span><br><span class="line"></span><br><span class="line">usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>回到用户空间的第一步是调用 <code>usertrapret</code>（kernel&#x2F;trap.c:90）</p>
<ul>
<li><p>这个函数设置 RISC-V 控制寄存器，为以后用户空间 trap 做准备</p>
</li>
<li><p>这包括改变 <code>stvec</code> 来引用 <code>uservec</code>，准备 <code>uservec</code> 所依赖的 <code>trapframe</code> 字段，并将 <code>sepc</code> 设置为先前保存的用户程序计数器</p>
</li>
<li><p>最后，<code>usertrapret</code> 在用户页表和内核页表中映射的 trampoline 页上调用 <code>userret</code>，因为 <code>userret</code> 中的汇编代码会切换页表。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space 返回到用户空间</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// we&#x27;re about to switch the destination of traps from      </span></span><br><span class="line"><span class="comment">// 我们即将把陷阱（trap）的目的地从 kerneltrap() 切换到 usertrap()</span></span><br><span class="line"><span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until </span></span><br><span class="line"><span class="comment">// 所以在回到用户空间之前，先关闭中断直到返回到用户空间</span></span><br><span class="line"><span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">intr_off();</span><br><span class="line"></span><br><span class="line"><span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S </span></span><br><span class="line"><span class="comment">// 在trampoline.S中发送系统调用，中断，异常给uservec</span></span><br><span class="line">uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">w_stvec(trampoline_uservec);	<span class="comment">// 所以这里是在设置stvec为trampoline中的uservec，为下一次trap做准备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set up trapframe values that uservec will need when  </span></span><br><span class="line"><span class="comment">// 设置uservec将会需要的trapframe的值，当进程下一次陷入到内核中时</span></span><br><span class="line"><span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set up the registers that trampoline.S&#x27;s sret will use </span></span><br><span class="line"><span class="comment">// 设置寄存器，trampoline.S的sret将会使用去返回到用户空间</span></span><br><span class="line"><span class="comment">// to get to user space.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set S Previous Privilege mode to User. 模式置为用户模式，其实是设置返回到用户空间时的模式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode	这里设置返回后为用户模式</span></span><br><span class="line">x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode	且打开中断在用户模式中</span></span><br><span class="line">w_sstatus(x);	<span class="comment">// 是更新相关寄存器操作吗</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set S Exception Program Counter to the saved user pc. 设置sepc寄存器为epc，也就是epc+4</span></span><br><span class="line">w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tell trampoline.S the user page table to switch to.  告诉trampoline.S需要转换的用户页表</span></span><br><span class="line">uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line"><span class="comment">// 跳转到 trampoline.S 中的 userret，它位于内存顶部</span></span><br><span class="line"><span class="comment">// switches to the user page table, restores user registers, 用于切换到用户页表，恢复用户寄存器</span></span><br><span class="line"><span class="comment">// and switches to user mode with sret. 并使用 sret 指令切换到用户模式</span></span><br><span class="line">uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>usertrapret</code> 对 <code>userret</code> 的调用传递了参数 <code>a0</code>，<code>a1</code>， <code>a0</code> 指向 <code>TRAPFRAME</code>，<code>a1</code> 指向用户进程页表（kernel&#x2F;trampoline.S:88），<code>userret</code> 将 <code>satp</code> 切换到进程的用户页表</p>
<blockquote>
<p>可能由于版本不同了吧，这里只有一个参数，且 a0 指向的是用户进程页表</p>
</blockquote>
<ul>
<li>回想一下，用户页表同时映射了 trampoline 页和 <code>TRAPFRAME</code>，但没有映射内核的其他内容</li>
<li>同样，事实上，在用户页表和内核页表中，trampoline 页被映射在相同的虚拟地址上，这也是允许 <code>uservec</code> 在改变 <code>satp</code> 后继续执行的原因</li>
<li><code>userret</code> 将 <code>trapframe</code> 中保存的用户 <code>a0</code> 复制到 <code>sscratch</code> 中，为以后与 <code>TRAPFRAME</code> 交换做准备</li>
<li>从这时开始，<code>userret</code> 能使用的数据只有寄存器内容和 <code>trapframe</code> 的内容</li>
<li>接下来 <code>userret</code> 从 trapframe 中恢复保存的用户寄存器，对 <code>a0</code> 和 <code>sscratch</code> 做最后的交换，恢复用户 <code>a0</code> 并保存<code>TRAPFRAME</code>，为下一次 trap 做准备，并使用 <code>sret</code> 返回用户空间</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">userret:</span><br><span class="line">     # userret(pagetable)</span><br><span class="line">     # called by usertrapret() in trap.c to	被trap.c中的usertrapret()调用从内核返回到用户空间</span><br><span class="line">     # switch from kernel to user.</span><br><span class="line">     # a0: user page table, for satp.	</span><br><span class="line"></span><br><span class="line">     # switch to the user page table.</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line">     csrw satp, a0				# 好像被简化了，和之前的版本不一样，之前返回两个参数a0是trapframe，a1才是satp</span><br><span class="line">     sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">     li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">     # restore all but a0 from TRAPFRAME</span><br><span class="line">     ld ra, 40(a0)</span><br><span class="line">     ld sp, 48(a0)</span><br><span class="line">     ld gp, 56(a0)</span><br><span class="line">     ld tp, 64(a0)</span><br><span class="line">     ld t0, 72(a0)</span><br><span class="line">     ld t1, 80(a0)</span><br><span class="line">     ld t2, 88(a0)</span><br><span class="line">     ld s0, 96(a0)</span><br><span class="line">     ld s1, 104(a0)</span><br><span class="line">     ld a1, 120(a0)</span><br><span class="line">     ld a2, 128(a0)</span><br><span class="line">     ld a3, 136(a0)</span><br><span class="line">     ld a4, 144(a0)</span><br><span class="line">     ld a5, 152(a0)</span><br><span class="line">     ld a6, 160(a0)</span><br><span class="line">     ld a7, 168(a0)</span><br><span class="line">     ld s2, 176(a0)</span><br><span class="line">     ld s3, 184(a0)</span><br><span class="line">     ld s4, 192(a0)</span><br><span class="line">     ld s5, 200(a0)</span><br><span class="line">     ld s6, 208(a0)</span><br><span class="line">     ld s7, 216(a0)</span><br><span class="line">     ld s8, 224(a0)</span><br><span class="line">     ld s9, 232(a0)</span><br><span class="line">     ld s10, 240(a0)</span><br><span class="line">     ld s11, 248(a0)</span><br><span class="line">     ld t3, 256(a0)</span><br><span class="line">     ld t4, 264(a0)</span><br><span class="line">     ld t5, 272(a0)</span><br><span class="line">     ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0</span><br><span class="line">     ld a0, 112(a0)</span><br><span class="line"></span><br><span class="line">     # return to user mode and user pc.</span><br><span class="line">     # usertrapret() set up sstatus and sepc.</span><br><span class="line">     sret</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Code-Calling-system-calls-调用系统调用"><a href="#Code-Calling-system-calls-调用系统调用" class="headerlink" title="Code: Calling system calls 调用系统调用"></a>Code: Calling system calls 调用系统调用</h2><ul>
<li>第 2 章以 <code>initcode.S</code> 调用 <code>exec</code> 系统调用结束（user&#x2F;initcode.S:11）<ul>
<li>让我们来看看用户调用是如何在内核中实现 <code>exec</code> 系统调用的</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  la a0, init</span><br><span class="line">  la a1, argv</span><br><span class="line">     li a7, SYS_exec</span><br><span class="line">     ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">  li a7, SYS_exit</span><br><span class="line">  ecall</span><br><span class="line">     jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">.string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">.long init</span><br><span class="line">.long 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>用户代码将 <code>exec</code> 的参数放在寄存器 <code>a0</code> 和 <code>a1</code> 中，并将系统调用号放在 <code>a7</code> 中。系统调用号与函数指针表 <code>syscalls</code> 数组（kernel&#x2F;syscall.c:108）中的项匹配<ul>
<li><code>ecall</code> 指令进入内核，执行 <code>uservec</code>、<code>usertrap</code>，然后执行 <code>syscall</code>，就像我们上面看到的那样</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An array mapping syscall numbers from syscall.h</span></span><br><span class="line"><span class="comment">// to the function that handles the system call.</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>syscall</code>（kernel&#x2F;syscall.c:133）从 trapframe 中的 <code>a7</code> 中得到系统调用号，并其作为索引在 <code>syscalls</code> 查找相应函数<ul>
<li>对于第一个系统调用 <code>exec</code>，<code>a7</code> 将为 <code>SYS_exec</code>（kernel&#x2F;syscall.h:8），这会让 <code>syscall</code> 调用 <code>exec</code> 的实现函数 <code>sys_exec</code></li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">num = p-&gt;trapframe-&gt;a7;</span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line"><span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line"><span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line"> p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">        p-&gt;pid, p-&gt;name, num);</span><br><span class="line"> p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>当系统调用函数返回时，<code>syscall</code> 将其返回值记录在 <code>p-&gt;trapframe-&gt;a0</code> 中<ul>
<li>用户空间的 <code>exec()</code> 将会返回该值，因为 RISC-V 上的 C 调用通常将返回值放在 <code>a0</code> 中</li>
<li>系统调用返回负数表示错误，0 或正数表示成功</li>
<li>如果系统调用号无效，<code>syscall</code> 会打印错误并返回 -1</li>
</ul>
</li>
</ul>
<h2 id="Code-System-call-arguments-系统调用参数"><a href="#Code-System-call-arguments-系统调用参数" class="headerlink" title="Code: System call arguments 系统调用参数"></a>Code: System call arguments 系统调用参数</h2><ul>
<li>内核的系统调用实现需要找到用户代码传递的参数<ul>
<li>因为用户代码调用系统调用的包装函数，参数首先会存放在寄存器中，这是 C 语言存放参数的惯例位置</li>
<li>内核 trap 代码将用户寄存器保存到当前进程的 trap frame 中，内核代码可以在那里找到它们</li>
<li>函数 <code>argint</code>、<code>argaddr</code> 和 <code>argfd</code> 从 trap frame 中以整数、指针或文件描述符的形式检索第 n 个系统调用参数</li>
<li>它们都调用 <code>argraw</code> 来获取保存的用户寄存器（kernel&#x2F;syscall.c:35）</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="keyword">switch</span> (n) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"> <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">&#125;</span><br><span class="line">panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>一些系统调用传递指针作为参数，而内核必须使用这些指针来读取或写入用户内存</p>
<ul>
<li>例如，<code>exec</code> 系统调用会向内核传递一个指向用户空间中的字符串的指针数组</li>
<li>这些指针带来了两个挑战</li>
<li>首先，用户程序可能是错误的或恶意的，可能会传递给内核一个无效的指针或一个旨在欺骗内核访问内核内存而不是用户内存的指针</li>
<li>第二，xv6 内核页表映射与用户页表映射不一样，所以内核不能使用普通指令从用户提供的地址加载或存储</li>
</ul>
</li>
<li><p>内核实现了安全地将数据复制到用户提供的地址或从用户提供的地址复制数据的函数</p>
<ul>
<li>例如 <code>fetchstr</code>（kernel&#x2F;syscall.c:25）</li>
<li>文件系统调用，如 <code>exec</code>，使用 <code>fetchstr</code> 从用户空间中检索字符串文件名参数</li>
<li><code>fetchstr</code> 调用 <code>copyinstr</code> 来做这些困难的工作</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nul-terminated string at addr from the current process.</span></span><br><span class="line"><span class="comment">// 在当前进程中的addr处，获得以null结尾的字符串</span></span><br><span class="line"><span class="comment">// Returns length of string, not including nul, or -1 for error.</span></span><br><span class="line"><span class="comment">// 返回字符串的长度，不包括null，-1表示error</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fetchstr</span><span class="params">(uint64 addr, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="keyword">if</span>(copyinstr(p-&gt;pagetable, buf, addr, max) &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>copyinstr</code>（kernel&#x2F;vm.c:406）将用户页表 <code>pagetable</code> 中的虚拟地址 <code>srcva</code> 复制到 <code>dst</code>，需指定最大复制字节数<ul>
<li>它使用 <code>walkaddr</code>（调用 <code>walk</code> 函数）在软件中模拟分页硬件的操作，以确定 <code>srcva</code> 的物理地址 <code>pa0</code></li>
<li><code>walkaddr</code>（kernel&#x2F;vm.c:109）检查用户提供的虚拟地址是否是进程用户地址空间的一部分，所以程序不能欺骗内核读取其他内存</li>
<li>类似的函数 <code>copyout</code>，可以将数据从内核复制到用户提供的地址</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.	复制以null结尾的字符串从用户空间到内核</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,	</span></span><br><span class="line"><span class="comment">// 复制字节从srcva虚拟地址到dst，在一个给定的页表中</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.	知道遇到 /0 或已经达到max</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.	返回0表示成功，-1</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 n, va0, pa0;</span><br><span class="line"><span class="type">int</span> got_null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">va0 = PGROUNDDOWN(srcva); <span class="comment">// #define PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1)) 作用是将srcva页对齐</span></span><br><span class="line">pa0 = walkaddr(pagetable, va0);</span><br><span class="line"><span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">n = PGSIZE - (srcva - va0);	<span class="comment">// 可以保证每次都处理一个页</span></span><br><span class="line"><span class="keyword">if</span>(n &gt; max)</span><br><span class="line">n = max;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *) (pa0 + (srcva - va0));`<span class="comment">// 得到srcva对应的物理地址</span></span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;	</span><br><span class="line"><span class="keyword">if</span>(*p == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">  *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  got_null = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  *dst = *p;</span><br><span class="line">&#125;</span><br><span class="line">--n;</span><br><span class="line">--max;</span><br><span class="line">p++;</span><br><span class="line">dst++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srcva = va0 + PGSIZE; <span class="comment">// 更新 srcva</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(got_null)&#123;	<span class="comment">// 检查是否遇到了/0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up a virtual address, return the physical address, 查找一个虚拟地址，返回物理地址</span></span><br><span class="line"><span class="comment">// or 0 if not mapped.	返回0表示没有映射</span></span><br><span class="line"><span class="comment">// Can only be used to look up user pages.	仅可以用于查找用户页面</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line">uint64 pa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pa = PTE2PA(*pte);</span><br><span class="line"><span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.  从内核复制到用户空间</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table. </span></span><br><span class="line"><span class="comment">// 从 src 复制 len 字节到给定页表中的虚拟地址 dstva</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.  成功时返回 0，错误时返回 -1</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 n, va0, pa0;</span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">va0 = PGROUNDDOWN(dstva);	<span class="comment">// 页对齐，不大于dstva且是PGSIZE的倍数</span></span><br><span class="line"><span class="keyword">if</span>(va0 &gt;= MAXVA)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> ||</span><br><span class="line"> (*pte &amp; PTE_W) == <span class="number">0</span>) <span class="comment">// pte没有找到 || 不是有效的 || 用户不可访问 || 不可写</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">pa0 = PTE2PA(*pte);	<span class="comment">// 这里是合理的，因为我们已经保证了va0是页对齐的了</span></span><br><span class="line">n = PGSIZE - (dstva - va0);	<span class="comment">// 保证每次处理一页</span></span><br><span class="line"><span class="keyword">if</span>(n &gt; len)</span><br><span class="line">n = len;</span><br><span class="line">memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);	<span class="comment">// 从src复制n个字节到dstva对应的物理地址</span></span><br><span class="line"></span><br><span class="line">len -= n;	<span class="comment">// 更新</span></span><br><span class="line">src += n;</span><br><span class="line">dstva = va0 + PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Traps-from-kernel-space-从内核空间触发的陷阱"><a href="#Traps-from-kernel-space-从内核空间触发的陷阱" class="headerlink" title="Traps from kernel space 从内核空间触发的陷阱"></a>Traps from kernel space 从内核空间触发的陷阱</h2><ul>
<li><p>xv6 根据用户还是内核代码正在执行，对 CPU 陷阱寄存器的配置略有不同行为</p>
<ul>
<li>当内核在 CPU 上执行时，内核将 <code>stvec</code> 指向 <code>kernelvec</code> 上的汇编代码（kernel&#x2F;kernelvec.S:10）</li>
<li>由于 xv6 已经在内核中，<code>kernelvec</code> 可以使用 <code>satp</code>，将其设置为内核页表，以及引用有效内核的堆栈指针</li>
<li><code>kernelvec</code> 保存所有寄存器，以便中断的代码最后可以在没有中断的情况下恢复</li>
</ul>
</li>
<li><p><code>kernelvec</code> 将寄存器保存在中断内核线程的堆栈上，因为寄存器值属于该线程，这是合理的</p>
<ul>
<li>如果 trap 导致切换到另一个线程—在这种情况下，trap 将实际返回到新线程的栈上，将中断线程保存的寄存器安全地保留在其堆栈上</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">kernelvec:</span><br><span class="line">     # make room to save registers.</span><br><span class="line">     addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">     # save the registers.</span><br><span class="line">     sd ra, 0(sp)</span><br><span class="line">     sd sp, 8(sp)</span><br><span class="line">     sd gp, 16(sp)</span><br><span class="line">     sd tp, 24(sp)</span><br><span class="line">     sd t0, 32(sp)</span><br><span class="line">     sd t1, 40(sp)</span><br><span class="line">     sd t2, 48(sp)</span><br><span class="line">     sd s0, 56(sp)</span><br><span class="line">     sd s1, 64(sp)</span><br><span class="line">     sd a0, 72(sp)</span><br><span class="line">     sd a1, 80(sp)</span><br><span class="line">     sd a2, 88(sp)</span><br><span class="line">     sd a3, 96(sp)</span><br><span class="line">     sd a4, 104(sp)</span><br><span class="line">     sd a5, 112(sp)</span><br><span class="line">     sd a6, 120(sp)</span><br><span class="line">     sd a7, 128(sp)</span><br><span class="line">     sd s2, 136(sp)</span><br><span class="line">     sd s3, 144(sp)</span><br><span class="line">     sd s4, 152(sp)</span><br><span class="line">     sd s5, 160(sp)</span><br><span class="line">     sd s6, 168(sp)</span><br><span class="line">     sd s7, 176(sp)</span><br><span class="line">     sd s8, 184(sp)</span><br><span class="line">     sd s9, 192(sp)</span><br><span class="line">     sd s10, 200(sp)</span><br><span class="line">     sd s11, 208(sp)</span><br><span class="line">     sd t3, 216(sp)</span><br><span class="line">     sd t4, 224(sp)</span><br><span class="line">     sd t5, 232(sp)</span><br><span class="line">     sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">     # call the C trap handler in trap.c</span><br><span class="line">     call kerneltrap</span><br><span class="line"></span><br><span class="line">     # restore registers.</span><br><span class="line">     ld ra, 0(sp)</span><br><span class="line">     ld sp, 8(sp)</span><br><span class="line">     ld gp, 16(sp)</span><br><span class="line">     # not tp (contains hartid), in case we moved CPUs</span><br><span class="line">     ld t0, 32(sp)</span><br><span class="line">     ld t1, 40(sp)</span><br><span class="line">     ld t2, 48(sp)</span><br><span class="line">     ld s0, 56(sp)</span><br><span class="line">     ld s1, 64(sp)</span><br><span class="line">     ld a0, 72(sp)</span><br><span class="line">     ld a1, 80(sp)</span><br><span class="line">     ld a2, 88(sp)</span><br><span class="line">     ld a3, 96(sp)</span><br><span class="line">     ld a4, 104(sp)</span><br><span class="line">     ld a5, 112(sp)</span><br><span class="line">     ld a6, 120(sp)</span><br><span class="line">     ld a7, 128(sp)</span><br><span class="line">     ld s2, 136(sp)</span><br><span class="line">     ld s3, 144(sp)</span><br><span class="line">     ld s4, 152(sp)</span><br><span class="line">     ld s5, 160(sp)</span><br><span class="line">     ld s6, 168(sp)</span><br><span class="line">     ld s7, 176(sp)</span><br><span class="line">     ld s8, 184(sp)</span><br><span class="line">     ld s9, 192(sp)</span><br><span class="line">     ld s10, 200(sp)</span><br><span class="line">     ld s11, 208(sp)</span><br><span class="line">     ld t3, 216(sp)</span><br><span class="line">     ld t4, 224(sp)</span><br><span class="line">     ld t5, 232(sp)</span><br><span class="line">     ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">     addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">     # return to whatever we were doing in the kernel.</span><br><span class="line">     sret</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>kernelvec</code> 在保存寄存器后跳转到 <code>kerneltrap</code>（kernel&#x2F;trap.c:134）</p>
<ul>
<li><code>kerneltrap</code> 是为两种类型的陷阱准备的：设备中断和异常	</li>
<li>它调用 <code>devintr</code>（kernel&#x2F;trap.c:177）来检查和处理前者</li>
<li>如果 trap 不是设备中断，那么它必须是异常，如果它发生在 xv6 内核中，则一定是一个致命错误；内核调用 <code>panic</code> 并停止执行</li>
</ul>
</li>
<li><p>如果由于计时器中断而调用了 <code>kerneltrap</code>，并且进程的内核线程正在运行（而不是调度程序线程），<code>kerneltrap</code> 调用 <code>yield</code> 让出 CPU，允许其他线程运行</p>
<ul>
<li>在某个时刻，其中一个线程将退出，并让我们的线程及其 <code>kerneltrap</code> 恢复</li>
<li>第 7 章解释了线程让出 CPU 控制权</li>
</ul>
</li>
<li><p>当 <code>kerneltrap</code> 的工作完成时，它需要返回到被中断的代码</p>
<ul>
<li>因为 <code>yield</code> 可能破坏保存的 <code>sepc</code> 和在 <code>sstatus</code> 中保存的之前的模式</li>
<li><code>kerneltrap</code> 在启动时保存它们。它现在恢复那些控制寄存器并返回到 <code>kernelvec</code>（kernel&#x2F;kernelvec.S:48）</li>
<li><code>kernelvec</code> 从堆栈恢复保存的寄存器并执行 <code>sret</code>，<code>sret</code> 将 <code>sepc</code> 复制到 <code>pc</code> 并恢复中断的内核代码</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,  </span></span><br><span class="line"><span class="comment">// 中断和异常从内核代码产生时，会通过 kernelvec 到达</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is. 无论当前的内核栈是什么</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">uint64 sepc = r_sepc(); <span class="comment">// 保存一些可能被修改的寄存器</span></span><br><span class="line">uint64 sstatus = r_sstatus();</span><br><span class="line">uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)  <span class="comment">// 如果是来自于用户模式，那太糟糕了</span></span><br><span class="line"> panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);  <span class="comment">// 此时中断不能打开</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;	<span class="comment">// 如果不是设备中断，只能是异常了</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line"> panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.  放弃CPU如果这是一个时钟中断</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line"> yield();</span><br><span class="line"></span><br><span class="line"><span class="comment">// the yield() may have caused some traps to occur, yield()可能造成一些陷阱的发生</span></span><br><span class="line"><span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction. </span></span><br><span class="line"><span class="comment">// 恢复陷阱寄存器以供kernelvec.S中的spec指令使用</span></span><br><span class="line">w_sepc(sepc);</span><br><span class="line">w_sstatus(sstatus);	<span class="comment">// 恢复这些可能被修改的寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>可以思考一下，如果因为时间中断，<code>kerneltrap</code> 调用了 <code>yield</code>，trap return 是如何发生的</p>
</li>
<li><p>当 CPU 从用户空间进入内核时，xv6 将 CPU 的 <code>stvec</code> 设置为 <code>kernelvec</code>；可以在 <code>usertrap</code>（kernel&#x2F;trap.c:29）中看到这一点</p>
<ul>
<li>内核运行但 <code>stvec</code> 被设置为 <code>uservec</code> 时，这期间有一个时间窗口，在这个窗口期，禁用设备中断是至关重要的</li>
<li>幸运的是，RISC-V 总是在开始使用 trap 时禁用中断，xv6 在设置 <code>stvec</code> 之前不会再次启用它们</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果不知道去哪里找到想要的函数，<code>kernel/defs.h</code> 是一个很好的选择</p>
</blockquote>
<h2 id="Page-fault-exceptions-缺页异常"><a href="#Page-fault-exceptions-缺页异常" class="headerlink" title="Page-fault exceptions 缺页异常"></a>Page-fault exceptions 缺页异常</h2><ul>
<li><p>xv6 对异常的响应是相当固定：如果一个异常发生在用户空间，内核就会杀死故障进程</p>
<ul>
<li>如果一个异常发生在内核中，内核就会 <strong>panic</strong>。真正的操作系统通常会以更有趣的方式进行响应</li>
</ul>
</li>
<li><p>举个例子，许多内核使用页面故障来实现 <strong>写时复制（copy-on-write，cow）fork</strong></p>
<ul>
<li>要解释写时复制 fork，可以想一想 xv6 的 <code>fork</code>，在第 3 章中介绍过</li>
<li><code>fork</code> 通过调用 <code>uvmcopy</code>（kernel&#x2F;vm.c:309）为子进程分配物理内存，并将父进程的内存复制到子程序中，使子进程拥有与父进程相同的内存内容</li>
<li>如果子进程和父进程能够共享父进程的物理内存，效率会更高。然而，直接实现这种方法是行不通的，因为父进程和子进程对共享栈和堆的写入会中断彼此的执行</li>
</ul>
</li>
<li><p>通过使用写时复制 fork，可以让父进程和子进程安全地共享物理内存，通过页面故障来实现</p>
<ul>
<li>当 CPU 不能将虚拟地址翻译成物理地址时，CPU 会产生一个页面故障异常（page-fault exception）</li>
<li>RISC-V 有三种不同的页故障：load 页故障（当加载指令不能翻译其虚拟地址时）、stote 页故障（当存储指令不能翻译其虚拟地址时）和指令页故障（当指令的地址不能翻译时）</li>
<li><code>scause</code> 寄存器中的值表示页面故障的类型，<code>stval</code> 寄存器中包含无法翻译的地址</li>
</ul>
</li>
<li><p><strong>COW</strong> fork 中的基本设计是父进程和子进程最初共享所有的物理页面，但将它们映射设置为只读</p>
<ul>
<li>因此，当子进程或父进程执行 store 指令时，RISC-V CPU 会引发一个页面故障异常</li>
<li>作为对这个异常的响应，内核会拷贝一份包含故障地址的页。然后将一个副本的读&#x2F;写映射在子进程地址空间，另一个副本的读&#x2F;写映射在父进程地址空间</li>
<li>更新页表后，内核在引起故障的指令处恢复故障处理</li>
<li>因为内核已经更新了相关的 PTE，允许写入，所以现在故障指令将正常执行</li>
</ul>
</li>
<li><p>这个 COW 设计对 <code>fork</code> 很有效，因为往往子程序在 fork 后立即调用 exec，用新的地址空间替换其地址空间</p>
<ul>
<li>在这种常见的情况下，子程序只会遇到一些页面故障，而内核可以避免进行完整的复制</li>
<li>此外，COW fork 是透明的：不需要对应用程序进行修改，应用程序就能受益</li>
</ul>
</li>
<li><p>页表和页故障的结合，将会有更多种有趣的可能性的应用</p>
<ul>
<li>另一个被广泛使用的特性叫做 **懒分配 (lazy allocation)**，它有两个部分</li>
<li>首先，当一个应用程序调用 <code>sbrk</code> 时，内核会增长地址空间，但在页表中把新的地址标记为无效</li>
<li>第二，当这些新地址中的一个出现页面故障时，内核分配物理内存并将其映射到页表中</li>
<li>由于应用程序经常要求获得比他们需要的更多的内存，所以懒分配是一个胜利：内核只在应用程序实际使用时才分配内存</li>
<li>像 COW fork 一样，内核可以对应用程序透明地实现这个功能</li>
</ul>
</li>
<li><p>另一个被广泛使用的利用页面故障的功能是从 <strong>磁盘上分页(paging from disk)</strong></p>
<ul>
<li>如果应用程序需要的内存超过了可用的物理 RAM，内核可以交换出一些页：将它们写入一个存储设备，比如磁盘，并将其 PTE 标记为无效</li>
<li>如果一个应用程序读取或写入一个被换出到磁盘的页，CPU 将遇到一个页面故障。内核就可以检查故障地址</li>
<li>如果该地址属于磁盘上的页面，内核就会分配一个物理内存的页面，从磁盘上读取页面到该内存，更新 PTE 为有效并引用该内存，然后恢复应用程序</li>
<li>为了给该页腾出空间，内核可能要交换另一个页</li>
<li>这个特性不需要对应用程序进行任何修改，如果应用程序具有引用的位置性（即它们在任何时候都只使用其内存的一个子集），这个特性就能很好地发挥作用</li>
</ul>
</li>
<li><p>其他结合分页和分页错误异常的功能包括自动扩展堆栈和内存映射文件</p>
</li>
</ul>
<h2 id="Real-world-现实情况"><a href="#Real-world-现实情况" class="headerlink" title="Real world 现实情况"></a>Real world 现实情况</h2><ul>
<li>如果将内核内存映射到每个进程的用户页表中（使用适当的 PTE 权限标志），就不需要特殊的 trampoline 页了<ul>
<li>这也将消除从用户空间 trap 进入内核时对页表切换的需求</li>
<li>这也可以让内核中的系统调用实现利用当前进程的用户内存被映射的优势，让内核代码直接去间接引用（对地址取值）用户指针</li>
<li>许多操作系统已经使用这些想法来提高效率</li>
<li>xv6 没有实现这些想法，以减少由于无意使用用户指针而导致内核出现安全漏洞的机会，并减少一些复杂性，以确保用户和内核虚拟地址不重叠</li>
</ul>
</li>
</ul>
<h2 id="Exercises-练习"><a href="#Exercises-练习" class="headerlink" title="Exercises 练习"></a>Exercises 练习</h2><ul>
<li><p>函数 <code>copyin</code> 和 <code>copyinstr</code> 在软件中 walk 用户页表。设置内核页表，使内核拥有用户程序的内存映射，<code>copyin</code> 和 <code>copyinstr</code> 可以使用 <code>memcpy</code> 将系统调用参数复制到内核空间，依靠硬件来完成页表的 walk</p>
</li>
<li><p>实现内存的懒分配</p>
</li>
<li><p>实现写时复制 fork</p>
</li>
</ul>
<hr>
<ol>
<li><p><a name="ftn1"></a>内核中物理地址和虚拟地址时直接映射的，所以可以在启用分页时，通过物理地址访问。</p>
</li>
<li><p><a name="ftn2"></a>执行系统调用时，进程的pc会指向ecall指令，这里需要加4清除，因为进程栈的地址空间是从高到低。</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/6-s081/" rel="tag"># 6.s081</a>
              <a href="/tags/xv6-book/" rel="tag"># xv6 book</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/06/03/6-S081-Lab3/" rel="prev" title="Lab Page tables">
      <i class="fa fa-chevron-left"></i> Lab Page tables
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/06/13/6-S081-Lab4/" rel="next" title="Lab Traps">
      Lab Traps <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">陷阱和系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RISC-V-trap-machinery-RISC-V-%E9%99%B7%E9%98%B1%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.</span> <span class="nav-text">RISC-V trap machinery RISC-V 陷阱处理机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traps-from-user-space-%E6%9D%A5%E8%87%AA%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-number">1.2.</span> <span class="nav-text">Traps from user space 来自用户空间的陷阱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Calling-system-calls-%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">Code: Calling system calls 调用系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-System-call-arguments-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">Code: System call arguments 系统调用参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traps-from-kernel-space-%E4%BB%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E8%A7%A6%E5%8F%91%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-number">1.5.</span> <span class="nav-text">Traps from kernel space 从内核空间触发的陷阱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-fault-exceptions-%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8"><span class="nav-number">1.6.</span> <span class="nav-text">Page-fault exceptions 缺页异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world-%E7%8E%B0%E5%AE%9E%E6%83%85%E5%86%B5"><span class="nav-number">1.7.</span> <span class="nav-text">Real world 现实情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercises-%E7%BB%83%E4%B9%A0"><span class="nav-number">1.8.</span> <span class="nav-text">Exercises 练习</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
