<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="12 动态内存 我们的程序之前使用的都是静态内存和栈内存，静态内存（static）和栈内存都是由编译器自动创建和销毁的 每个程序还拥有一个内存池，被称为 自由空间 或 堆 ，程序用堆来存储 动态分配 的对象（程序运行时分配的对象） 动态对象不再使用时，必须显示的销毁它们  12.1 动态内存和智能指针 new：在冬天太内存中为对象分配空间并返回一个指向该对象的指针  delete：接受一个动态对象">
<meta property="og:type" content="article">
<meta property="og:title" content="C++Primer-12-动态内存">
<meta property="og:url" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="12 动态内存 我们的程序之前使用的都是静态内存和栈内存，静态内存（static）和栈内存都是由编译器自动创建和销毁的 每个程序还拥有一个内存池，被称为 自由空间 或 堆 ，程序用堆来存储 动态分配 的对象（程序运行时分配的对象） 动态对象不再使用时，必须显示的销毁它们  12.1 动态内存和智能指针 new：在冬天太内存中为对象分配空间并返回一个指向该对象的指针  delete：接受一个动态对象">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129153819459.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129153958953.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129154234812.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129154439313.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129154659474.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129155212609.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129155818718.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129155826819.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129160237194.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129161515970.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129161654333.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129161811465.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129162456162.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129162627102.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129162852836.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129163806576.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129164120773.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129165601535.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129165815575.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129165922694.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170206001.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170216568.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170430745.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170440765.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170450208.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171136503.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171504149.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171514132.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171852797.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129173708453.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129174136618.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129174145963.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129174350617.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180236825.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180308421.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180334373.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180806421.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180840084.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129181057275.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129181610928.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129202140397.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129202226704.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129202355424.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129205243652.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129205359868.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129205910027.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129210001004.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129210353845.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129210504615.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211032929.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211222606.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211336894.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211608651.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214150987.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214125266.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214541210.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214849723.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214932308.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129215107537.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129215620978.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129215643466.png">
<meta property="article:published_time" content="2024-01-29T07:22:21.000Z">
<meta property="article:modified_time" content="2024-01-29T14:00:02.994Z">
<meta property="article:author" content="yiweiBoi">
<meta property="article:tag" content="C++Primer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129153819459.png">

<link rel="canonical" href="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++Primer-12-动态内存 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++Primer-12-动态内存
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-29 15:22:21 / 修改时间：22:00:02" itemprop="dateCreated datePublished" datetime="2024-01-29T15:22:21+08:00">2024-01-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="12-动态内存"><a href="#12-动态内存" class="headerlink" title="12 动态内存"></a>12 动态内存</h1><blockquote>
<p>我们的程序之前使用的都是静态内存和栈内存，静态内存（static）和栈内存都是由编译器自动创建和销毁的</p>
<p>每个程序还拥有一个内存池，被称为 <strong>自由空间 或 堆</strong> ，程序用堆来存储 <strong>动态分配</strong> 的对象（程序运行时分配的对象）</p>
<p>动态对象不再使用时，必须显示的销毁它们</p>
</blockquote>
<h2 id="12-1-动态内存和智能指针"><a href="#12-1-动态内存和智能指针" class="headerlink" title="12.1 动态内存和智能指针"></a>12.1 动态内存和智能指针</h2><ul>
<li><p><strong>new</strong>：在冬天太内存中为对象分配空间并返回一个指向该对象的指针</p>
</li>
<li><p><strong>delete</strong>：接受一个动态对象指针，销毁该对象，释放与之关联的内存</p>
<blockquote>
<p>有时我们会忘记释放内存，造成内存泄漏</p>
<p>有时在尚有指针引用内存的情况下我们就释放它们，会产生引用非法内存的指针</p>
</blockquote>
</li>
<li><p>为了更容易、更安全的使用动态内存，标准库提供了 <strong>智能指针</strong></p>
<ul>
<li><strong>shared_ptr</strong>：允许多个指针同时指向同一个对象</li>
<li><strong>unique_ptr</strong>：独占所指向的对象</li>
<li><strong>weak_ptr</strong>：伴随类，是一种弱引用，指向 <strong>shared_ptr</strong> 所管理的对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>这两种智能指针的区别在于管理底层指针的方式不同，且这三种类型都定义在头文件 <strong>memory</strong> 种</p>
</blockquote>
<h3 id="12-1-1-shared-ptr-类"><a href="#12-1-1-shared-ptr-类" class="headerlink" title="12.1.1 shared_ptr 类"></a>12.1.1 shared_ptr 类</h3><ul>
<li>类似的，智能指针也是 <strong>模板</strong> ，因此创建一个智能指针时，必须提供指针可以指向的类型</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129153819459.png" class="" title="image-20240129153819459">

<blockquote>
<p>默认初始化的增长保存着一个空指针</p>
</blockquote>
<ul>
<li>与不同指针类似，解引用一个智能指针返回它指向的对象</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129153958953.png" class="" title="image-20240129153958953">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129154234812.png" class="" title="image-20240129154234812">

<h4 id="make-shared-函数"><a href="#make-shared-函数" class="headerlink" title="make_shared 函数"></a>make_shared 函数</h4><ul>
<li>最安全的分配和使用动态内存的方法是调用一个名为 <strong>make_shared</strong> 的标准库函数<ul>
<li>此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 <strong>shared_ptr</strong></li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129154439313.png" class="" title="image-20240129154439313">

<ul>
<li>make_shared 用其参数来构造给定类型的对象，如果不传递任何参数，对象就会进行值初始化</li>
<li>我们也可以用 <strong>auto</strong> 定义一个对象来保存 make_shared 的结果</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129154659474.png" class="" title="image-20240129154659474">

<h4 id="shared-ptr-的拷贝和赋值"><a href="#shared-ptr-的拷贝和赋值" class="headerlink" title="shared_ptr 的拷贝和赋值"></a>shared_ptr 的拷贝和赋值</h4><ul>
<li>当进项拷贝和赋值操作时，每个 shared_ptr 都会记录有多少个其他 shared_ptr 指向相同的对象<ul>
<li>即每个 shared_ptr 都有一个关联的计数器，通常称为 <strong>计数引用</strong></li>
<li>拷贝一个 shared_ptr（值传递、返回），计数器会增加</li>
<li>销毁一个 shared_ptr（局部对象离开作用域），计数器会递减</li>
<li>一旦一个 shared_ptr 的计数器变为 <strong>0</strong> ，它会自动释放自己所管理的对象</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129155212609.png" class="" title="image-20240129155212609">

<h4 id="shared-ptr-自动销毁所管理的对象"><a href="#shared-ptr-自动销毁所管理的对象" class="headerlink" title="shared_ptr 自动销毁所管理的对象"></a>shared_ptr 自动销毁所管理的对象</h4><ul>
<li>shared_ptr 类会自动销毁此对象，是通过 <strong>析构函数</strong> 所实现的，析构函数会递减它所指向的对象的引用计数，如果计数变为 0，就销毁对象，释放它占用的空间</li>
</ul>
<h4 id="shared-ptr-还会自动释放相关联的内存"><a href="#shared-ptr-还会自动释放相关联的内存" class="headerlink" title="shared_ptr 还会自动释放相关联的内存"></a>shared_ptr 还会自动释放相关联的内存</h4><ul>
<li>动态内对象不再被使用时，shared_ptr 类会自动释放动态对象，这一特性使得动态内存的使用变得容易</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129155818718.png" class="" title="image-20240129155818718">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129155826819.png" class="" title="image-20240129155826819">

<ul>
<li><p>保证 shared_ptr 在无用之后不再被保留非常重要，如果忘记销毁程序不再需要的 shared_ptr，程序仍然会正确执行，但会浪费空间</p>
<blockquote>
<p>比如在 vector 中，shared_ptr 被放在容器里，重排容器后，某些元素不再需要，我们应该确保使用 erase 删除那些不再需要的 shared_ptr 元素</p>
</blockquote>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129160237194.png" class="" title="image-20240129160237194">

<h4 id="使用了动态生存期的资源的类的原因"><a href="#使用了动态生存期的资源的类的原因" class="headerlink" title="使用了动态生存期的资源的类的原因"></a>使用了动态生存期的资源的类的原因</h4><ul>
<li>程序不知道自己需要使用多少对象（使用容器解决）</li>
<li>程序不知道所需对象的准确类型（使用模板解决）</li>
<li>程序需要在多个对象间共享数据（使用 shared_ptr 解决）</li>
</ul>
<blockquote>
<p>使用动态内存的一个常见原因是允许多个对象共享相同的状态</p>
</blockquote>
<h3 id="12-1-2-直接管理内存"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2 直接管理内存"></a>12.1.2 直接管理内存</h3><ul>
<li>相对于智能指针，直接管理内存的类不能依赖于对象的拷贝、赋值和销毁操作的任何默认定义</li>
</ul>
<h4 id="使用-new-动态分配和初始化对象"><a href="#使用-new-动态分配和初始化对象" class="headerlink" title="使用 new 动态分配和初始化对象"></a>使用 new 动态分配和初始化对象</h4><ul>
<li>在自由空间分配的内存都是无名的，因此 <strong>new</strong> 无法为其分配的对象命名，而是返回一个指向该对象的指针、</li>
<li>默认情况下，动态分配的对象都是默认初始化的，这意味着：<ul>
<li>内置类型或组合类型的对象的值将会是 <strong>未定义</strong> 的</li>
<li>类类型对象将用默认构造函数进行初始化</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129161515970.png" class="" title="image-20240129161515970">

<ul>
<li>我们也可以使用 <strong>直接初始化</strong> 的方式来初始化一个动态分配的对象（圆括号、初始化列表）</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129161654333.png" class="" title="image-20240129161654333">

<ul>
<li>也可以对动态分配的对象进行 <strong>值初始化</strong>（在类型名后加空括号即可）</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129161811465.png" class="" title="image-20240129161811465">

<blockquote>
<p>值初始化 和 默认初始化 对内置类型有很大差别，值初始化的内置类型有着良好定义的值</p>
<p>而对于类类型来说就没有意义了，它们总是通过默认构造函数来初始化，而对于类中的内置类型成员，如果未在类内被初始化，则它们的值也是未定义的</p>
</blockquote>
<ul>
<li>对于一个括号包围的初始化器，可以使用 <strong>auto</strong> 来从初始化器推断我们想要分配的对象的类型，但仅当括号中仅有 <strong>单一</strong> 的初始化器时才可以使用 auto</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129162456162.png" class="" title="image-20240129162456162">

<h4 id="动态分配的-const-对象"><a href="#动态分配的-const-对象" class="headerlink" title="动态分配的 const 对象"></a>动态分配的 const 对象</h4><ul>
<li>类似的，一个动态分配的 const 对象必须进行初始化，且由于分配的对象是 const 的，new 返回的指针是一个指向 const 的指针</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129162627102.png" class="" title="image-20240129162627102">

<h4 id="内存耗尽"><a href="#内存耗尽" class="headerlink" title="内存耗尽"></a>内存耗尽</h4><ul>
<li>当一个程序用光它所有可用的内存，new 表达式就会失败，默认情况下，会抛出一个类型为 <strong>bad_alloc</strong> 的异常，我们可以改变使用 new 的方式来阻止它抛出异常</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129162852836.png" class="" title="image-20240129162852836">

<ul>
<li>上方这种形式的 new 称为 <strong>定位 new</strong>，我们传递给它一个标准库定义的名为 <strong>nothrow</strong> 的对象，意图是告诉它不能抛出异常，如果这种形式的 new 不能分配所需内存，它会返回一个 <strong>空指针</strong></li>
</ul>
<h4 id="释放动态内存"><a href="#释放动态内存" class="headerlink" title="释放动态内存"></a>释放动态内存</h4><ul>
<li><strong>delete</strong> 表达式接受一个指针，指向我们想要释放的对象</li>
<li>和 new 类似，delete 表达式执行两个步骤：销毁给定对象，释放对应的内存</li>
</ul>
<h4 id="指针值和-delete"><a href="#指针值和-delete" class="headerlink" title="指针值和 delete"></a>指针值和 delete</h4><ul>
<li>传递给 delete 的指针必须指向 <strong>动态分配的内存</strong>，或者是一个 <strong>空指针</strong></li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129163806576.png" class="" title="image-20240129163806576">

<blockquote>
<p>通常情况下，编译器不能分辨一个真正指向的 静态 还是 动态 分配的对象</p>
<p>类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放</p>
<p>对于这些 delete 表达式，大多数编译器通过，尽管它们是错误的</p>
</blockquote>
<ul>
<li>一个 const 对象的值不能被改变，但它本身可以被销毁</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129164120773.png" class="" title="image-20240129164120773">

<h4 id="动态对象的生存期直到被释放时为止"><a href="#动态对象的生存期直到被释放时为止" class="headerlink" title="动态对象的生存期直到被释放时为止"></a>动态对象的生存期直到被释放时为止</h4><ul>
<li>由 shared_ptr 管理的内存在最后一个 shared_ptr 销毁时会被自动释放</li>
<li>而对于通过内置指针类型来管理的动态对象，直到被 <strong>显示释放</strong> 之前它都是存在的（因此调用者必须记得释放内存）</li>
</ul>
<h4 id="使用-new-和-delete-管理动态内存的三个常见问题"><a href="#使用-new-和-delete-管理动态内存的三个常见问题" class="headerlink" title="使用 new 和 delete 管理动态内存的三个常见问题"></a>使用 new 和 delete 管理动态内存的三个常见问题</h4><ul>
<li><p>忘记 delete 内存，导致 <strong>内存泄漏</strong> 问题， 查找困难</p>
</li>
<li><p>使用已经释放的对象</p>
</li>
<li><p>同一块内存释放两次</p>
<blockquote>
<p>坚持只使用智能指针，就可以避免所有这些问题</p>
</blockquote>
</li>
</ul>
<h4 id="delete-之后重置指针值"><a href="#delete-之后重置指针值" class="headerlink" title="delete 之后重置指针值"></a>delete 之后重置指针值</h4><ul>
<li>当我们 delete 一个指针后，指针值就变为无效了，即 <strong>空悬指针</strong>，指向一块曾经保存数据对象但现在已经无效的内存的指针</li>
<li>我们可以在 delete 之后将 <strong>nullptr</strong> 赋予指针来避免使用空悬指针</li>
</ul>
<h4 id="这只是提供了有限的保护"><a href="#这只是提供了有限的保护" class="headerlink" title="这只是提供了有限的保护"></a>这只是提供了有限的保护</h4><ul>
<li>delete 之后重置指针值的方法只是对这个指针有效，对于其他任何仍然指向（已释放）内存的指针是没有用的</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129165601535.png" class="" title="image-20240129165601535">

<h3 id="12-1-3-shared-ptr-和-new-结合使用"><a href="#12-1-3-shared-ptr-和-new-结合使用" class="headerlink" title="12.1.3 shared_ptr 和 new 结合使用"></a>12.1.3 shared_ptr 和 new 结合使用</h3><ul>
<li>我们还可以使用 new 返回的指针来初始化智能指针</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129165815575.png" class="" title="image-20240129165815575">

<ul>
<li>我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129165922694.png" class="" title="image-20240129165922694">

<blockquote>
<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用 delete 释放它所关联的对象</p>
<p>我们也可以智能指针绑定到一个指向其他资源的指针上，但必须提供自己的操作来替代 delete</p>
</blockquote>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170206001.png" class="" title="image-20240129170206001">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170216568.png" class="" title="image-20240129170216568">

<h4 id="不要混合使用普通指针和智能指针"><a href="#不要混合使用普通指针和智能指针" class="headerlink" title="不要混合使用普通指针和智能指针"></a>不要混合使用普通指针和智能指针</h4><img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170430745.png" class="" title="image-20240129170430745">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170440765.png" class="" title="image-20240129170440765">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129170450208.png" class="" title="image-20240129170450208">

<ul>
<li>一旦我们将一个 shared_ptr 绑定到一个普通指针时，我们就将内存的管理责任交给这个 shared_ptr，我们就不应该再使用内置指针来访问 shared_ptr 所指向的内存了</li>
</ul>
<blockquote>
<p>使用内置指针来访问智能指针所负责的对象是很危险的，因为我们不知道对象何时被销毁</p>
</blockquote>
<h4 id="不要使用-get-初始化另一个智能指针或为智能指针赋值"><a href="#不要使用-get-初始化另一个智能指针或为智能指针赋值" class="headerlink" title="不要使用 get 初始化另一个智能指针或为智能指针赋值"></a>不要使用 get 初始化另一个智能指针或为智能指针赋值</h4><ul>
<li><p>智能指针类型的 get 函数，返回一个内置指针，指向智能指针管理的对象</p>
<ul>
<li>该函数是为 我们需要向不能使用智能指针的代码传递一个内置指针 而设计的</li>
<li>使用 get 返回的指针的代码不能 delete 此指针</li>
</ul>
</li>
<li><p>而将另一个智能指针也绑定到 get 返回的指针上是错误的（即使编译器不会给出错误信息）</p>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171136503.png" class="" title="image-20240129171136503">

<h4 id="其他-shared-ptr-操作"><a href="#其他-shared-ptr-操作" class="headerlink" title="其他 shared_ptr 操作"></a>其他 shared_ptr 操作</h4><ul>
<li>我们可以用 <strong>reset</strong> 将一个新的指针赋予一个 shared_ptr <ul>
<li>和赋值类似，reset 会更新引用计数，如果需要的话，会释放原来所指对象（计数为 0 时）</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171504149.png" class="" title="image-20240129171504149">

<ul>
<li>reset 常与 unique 一起使用，来控制多个 shared_ptr 共享的对象</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171514132.png" class="" title="image-20240129171514132">

<h3 id="12-1-4-智能指针和异常"><a href="#12-1-4-智能指针和异常" class="headerlink" title="12.1.4 智能指针和异常"></a>12.1.4 智能指针和异常</h3><ul>
<li>如果使用智能指针，即使程序块过早结束，智能指针类也能确保内存不再需要时将其释放</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129171852797.png" class="" title="image-20240129171852797">

<ul>
<li>与之相对的，当发生异常时，我们直接管理的内存是不会自动释放的，即如果在 new 和 delete 之间发生异常，且异常未在当前函数中被捕获，则内存就永远不会被释放</li>
</ul>
<h4 id="智能指针和哑类"><a href="#智能指针和哑类" class="headerlink" title="智能指针和哑类"></a>智能指针和哑类</h4><ul>
<li>所有标准库在内的很多 C++ 类都定义了析构函数，但部署所有类都是这样良好定义的，特别是那些为 C 和 C++ 两种语言设计的类，通常要求用户显示的释放所有使用的任何资源</li>
<li>程序员忘记释放资源、在资源分配和释放之间发生了异常时，程序常常会发生资源泄漏</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129173708453.png" class="" title="image-20240129173708453">

<ul>
<li>可以使用 shared_ptr 来保证资源的正确释放</li>
</ul>
<h4 id="使用我们自己的释放操作"><a href="#使用我们自己的释放操作" class="headerlink" title="使用我们自己的释放操作"></a>使用我们自己的释放操作</h4><ul>
<li>默认情况下，shared_ptr 假定它指向的是动态内存，因此一个 shared_ptr 销毁时，默认对它管理的指针进行 delete 操作</li>
<li>我们可以定义一个 <strong>删除器（函数）</strong> 来代替 delete</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129174136618.png" class="" title="image-20240129174136618">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129174145963.png" class="" title="image-20240129174145963">

<ul>
<li>当指针被销毁时（即使发生异常也可会被销毁），调用的是我们自定义的函数，而不是 delete</li>
</ul>
<h4 id="智能指针陷阱"><a href="#智能指针陷阱" class="headerlink" title="智能指针陷阱"></a>智能指针陷阱</h4><img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129174350617.png" class="" title="image-20240129174350617">

<h3 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h3><ul>
<li>某个时刻一个 unique_ptr 只能指向一个给定对象，当 unique_ptr 被销毁时，它所指向的对象也被销毁</li>
<li>当我们定义一个 unique_ptr 时，需要将器绑定到一个 new 返回的指针上，初始化 unique_ptr 必须采用 <strong>直接初始化的形式</strong></li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180236825.png" class="" title="image-20240129180236825">

<ul>
<li>unique_ptr 不支持普通的拷贝和辅助操作</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180308421.png" class="" title="image-20240129180308421">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180334373.png" class="" title="image-20240129180334373">

<ul>
<li><p><strong>release</strong> 成员返回 unique_ptr 当前保存的指针并将其置为空</p>
<ul>
<li><p>release 会切断 unique_ptr 和它原来管理的对象间的联系，返回的指针常用来初始化另一个智能指针或给另一个智能指针赋值</p>
</li>
<li><p>如果我们不用另一个智能指针来保存 release 返回的指针，则我们的程序需要负责资源的释放</p>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180806421.png" class="" title="image-20240129180806421"></li>
</ul>
</li>
<li><p><strong>reset</strong> 成员接受一个可选的指针参数，令 unique_ptr 重新指向给定的指针，如果 unique_ptr 不为空，释放原来指向对象</p>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129180840084.png" class="" title="image-20240129180840084">

<h4 id="传递-unique-ptr-参数和返回-unique-ptr"><a href="#传递-unique-ptr-参数和返回-unique-ptr" class="headerlink" title="传递 unique_ptr 参数和返回 unique_ptr"></a>传递 unique_ptr 参数和返回 unique_ptr</h4><ul>
<li>不能拷贝 unique_ptr 有一个例外：可以拷贝或赋值一个将要被销毁的 unique_ptr</li>
<li>编译器知道要返回的对象是将要被销毁的，编译器会执行一种特殊的 拷贝</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129181057275.png" class="" title="image-20240129181057275">

<blockquote>
<p>标准库较早的版本包含了一个名为 auto_ptr 的类，它有 unique_ptr 的部分功能</p>
<p>特别的，我们不能容器中保存 auto_ptr，也不能从函数中返回 auto_ptr</p>
<p>编写程序时应该使用 unique_ptr，而不是 auto_ptr</p>
</blockquote>
<h4 id="向-unique-ptr-传递删除器"><a href="#向-unique-ptr-传递删除器" class="headerlink" title="向 unique_ptr 传递删除器"></a>向 unique_ptr 传递删除器</h4><ul>
<li>类似的，默认情况下，unique_ptr 也使用 delete 释放它所指向的对象</li>
<li>和 shared_ptr 不同的是，重载一个 unique_ptr 的删除器时，我们必须在尖括号中提供删除器的类型，且在创建或 reset 一个这种 unique_ptr 类型的对象时，必须提供一个指定类型的可调用对象（删除器）</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129181610928.png" class="" title="image-20240129181610928">

<h3 id="12-1-6-weak-ptr"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr</h3><ul>
<li>weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向由一个 shared_ptr 管理的对象<ul>
<li>它不会改变所绑定的 shared_ptr 的引用计数</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129202140397.png" class="" title="image-20240129202140397">

<ul>
<li>当我们创建一个 weak_ptr 时，要用一个 shared_ptr 来初始化它</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129202226704.png" class="" title="image-20240129202226704">

<ul>
<li>由于对象可能不存在，我们不能使用 weak_ptr 直接访问对象，而必须使用 lock 函数<ul>
<li>如果对象存在，lock 返回一个指向共享对象的 shared_ptr</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129202355424.png" class="" title="image-20240129202355424">

<ul>
<li>通过使用 weak_ptr，不会影响一个给定的 shared_ptr 的生存周期，但可以阻止用户访问一个可能不再存在的对象</li>
</ul>
<h2 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h2><blockquote>
<p>为了支持这种需求，C++ 语言和标准库提供了两种一次分配一个对象数组的方法</p>
<p>C++ 语言定义了另一种 new 表达式语法，可以分配并初始化一个对象数组</p>
<p>标准库中包含一个名为 <strong>allocator</strong> 的类，允许我们将分配和初始化分离，使用 allocator 通常会提供更好的性能和更灵活的内存管理能力</p>
</blockquote>
<h3 id="12-2-1-new-和数组"><a href="#12-2-1-new-和数组" class="headerlink" title="12.2.1 new 和数组"></a>12.2.1 new 和数组</h3><ul>
<li>为了让 new 分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129205243652.png" class="" title="image-20240129205243652">

<blockquote>
<p>方括号中的大小必须是整型，但不必是常量</p>
</blockquote>
<ul>
<li>也可以使用一个表示数组类型的类型别名来分配一个数组</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129205359868.png" class="" title="image-20240129205359868">

<h4 id="分配一个数组会得到一个元素类型的指针"><a href="#分配一个数组会得到一个元素类型的指针" class="headerlink" title="分配一个数组会得到一个元素类型的指针"></a>分配一个数组会得到一个元素类型的指针</h4><blockquote>
<p>虽然我们通常称 new T[ ] 分配的内存为 <strong>动态数组</strong>，但这种叫法有一定的误导性</p>
</blockquote>
<ul>
<li>当用 new 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针<ul>
<li>由于得到的并不是一个数组类型，因此不能对动态数组调用 <strong>begin 和 end</strong>（这些函数使用数组的维度）</li>
<li>也不能使用 <strong>范围 for</strong> 语句来处理动态数组中的元素</li>
</ul>
</li>
</ul>
<h4 id="初始化动态分配对象的数组"><a href="#初始化动态分配对象的数组" class="headerlink" title="初始化动态分配对象的数组"></a>初始化动态分配对象的数组</h4><ul>
<li>默认情况下，new 分配的对象无论是单个分配还是数组中的，都是默认初始化</li>
<li>可以通过在大小后跟一对空括号来进行值初始化</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129205910027.png" class="" title="image-20240129205910027">

<ul>
<li>还可以提供一个元素初始化器的花括号列表进行初始化</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129210001004.png" class="" title="image-20240129210001004">

<blockquote>
<p>如果初始化器数目大于元素数目，则 new 表达式失败，不会分配任何内存，抛出一个类型为 bad_array_new_length 的异常</p>
</blockquote>
<h4 id="动态分配一个空数组是合法的"><a href="#动态分配一个空数组是合法的" class="headerlink" title="动态分配一个空数组是合法的"></a>动态分配一个空数组是合法的</h4><ul>
<li>当我们用 new 分配一个大小为 0 的数组时，new 返回一个合法的非空指针，此指针与 new 返回的其他任何指针都不同<ul>
<li>此指针就像尾后指针一样，我们可以像使用尾后指针一样使用它，不能解引用</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129210353845.png" class="" title="image-20240129210353845">

<h4 id="释放动态数组"><a href="#释放动态数组" class="headerlink" title="释放动态数组"></a>释放动态数组</h4><ul>
<li>为了释放动态数组，我们使用一种特殊形式的 delete，在指针前加上一个空方括号</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129210504615.png" class="" title="image-20240129210504615">

<ul>
<li>数组中的元素是按照逆序来进行销毁的</li>
<li>当释放一个指向数组的指针时，方括号是必须的，它指示编译器此指针指向一个对象数组的第一个元素</li>
</ul>
<blockquote>
<p>delete 一个数组忘记加方括号，或者 delete 一个单一对象的指针时使用了方括号，编译器可能不会给出警告</p>
</blockquote>
<h4 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h4><ul>
<li>为了用一个 <strong>unique_ptr</strong> 管理动态数组，我们必须在对象类型后面跟一对空方括号</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211032929.png" class="" title="image-20240129211032929">

<ul>
<li>当一个 unique_ptr 指向一个数组时，我们不能使用 <strong>点和箭头</strong> 成员运算符，我们可以使用 <strong>下标</strong> 运算符来访问数组中的元素</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211222606.png" class="" title="image-20240129211222606">

<ul>
<li>shared_ptr 并不直接支持管理动态数组，如果希望使用 shared_ptr 管理一个动态数组，必须提供自定义的删除器<ul>
<li>因为默认情况下使用 delete，会造成错误</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211336894.png" class="" title="image-20240129211336894">

<ul>
<li>且 shared_ptr 未定义下标运算符，且智能指针不支持指针算术运算，为了访问数组中的元素，必须通过 get 获取一个内置指针</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129211608651.png" class="" title="image-20240129211608651">

<h3 id="12-2-2-allocator-类"><a href="#12-2-2-allocator-类" class="headerlink" title="12.2.2 allocator 类"></a>12.2.2 allocator 类</h3><ul>
<li>new 有一些灵活性上的局限，它将内存分配和对象构造组合在了一起<ul>
<li>一般情况下，将内存分配和对象构造组合在一起可能导致不必要的浪费</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214150987.png" class="" title="image-20240129214150987">

<blockquote>
<p>new 表达式分配并初始化了 n 个 string，但我们可能并不需要 n 个 string，且对于每个使用到的元素，都被赋值了两次，一次默认初始化，一次赋值</p>
<p>更重要的是，对于没有默认构造函数的类就不能动态分配数组</p>
</blockquote>
<h4 id="allocator-类"><a href="#allocator-类" class="headerlink" title="allocator 类"></a>allocator 类</h4><ul>
<li>它帮助我们将内存分配和对象构造分离开来，提供了一种类型感知的内存分配方法，<strong>它分配的内存是原始的、未构造的</strong></li>
<li>allocator 也是一个模板，定义时必须指明它可以分配的对象类型</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214125266.png" class="" title="image-20240129214125266">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214541210.png" class="" title="image-20240129214541210">

<h4 id="allocator-分配未构造的内存"><a href="#allocator-分配未构造的内存" class="headerlink" title="allocator 分配未构造的内存"></a>allocator 分配未构造的内存</h4><ul>
<li><strong>allocate</strong> 函数分配的内存是未构造的</li>
<li><strong>construct</strong> 函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素，额外参数用来初始化构造的对象</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214849723.png" class="" title="image-20240129214849723">

<ul>
<li>还未构造对象的情况下就使用原始内存是错误的、未定义的</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129214932308.png" class="" title="image-20240129214932308">

<ul>
<li><p>当我们用完对象后，必须对每个构造的原始调用 <strong>destory</strong> 来销毁它们</p>
<ul>
<li><p>destory 函数接受一个真正，对指向的对象执行析构函数</p>
<blockquote>
<p>我们只能对真正构造了的元素进行 destory 操作</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129215107537.png" class="" title="image-20240129215107537">

<ul>
<li>一旦一个元素被销毁后，就可以重新使用这部分内存来保存其他对象，也可以将其归还给系统<ul>
<li>释放内存通过调用 <strong>deallocate</strong> 来完成</li>
<li>传递给 deallocate 的指针不能为空，且它必须指向由 allocate 分配的内存</li>
<li>且传递给 deallocate 的大小参数必须与调用 allocate 分配内存时提供的大小参数一样</li>
</ul>
</li>
</ul>
<h4 id="拷贝和填充未初始化内存的算法"><a href="#拷贝和填充未初始化内存的算法" class="headerlink" title="拷贝和填充未初始化内存的算法"></a>拷贝和填充未初始化内存的算法</h4><ul>
<li>标准库还为 allocator 类定义了两个伴随算法，可以在未初始化内存中创建对象</li>
</ul>
<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129215620978.png" class="" title="image-20240129215620978">

<img src="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/image-20240129215643466.png" class="" title="image-20240129215643466">

<ul>
<li>类似 copy，uninitialized_copy 返回一个指针，指向最后一个构造的元素之后的位置</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-Primer/" rel="tag"># C++Primer</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/" rel="prev" title="C++Primer-10-泛型算法">
      <i class="fa fa-chevron-left"></i> C++Primer-10-泛型算法
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/01/31/LeetCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/" rel="next" title="LeetCode-232-用栈实现队列">
      LeetCode-232-用栈实现队列 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="nav-number">1.</span> <span class="nav-text">12 动态内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.1.</span> <span class="nav-text">12.1 动态内存和智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-1-shared-ptr-%E7%B1%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">12.1.1 shared_ptr 类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#make-shared-%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">make_shared 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared-ptr-%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">shared_ptr 的拷贝和赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared-ptr-%E8%87%AA%E5%8A%A8%E9%94%80%E6%AF%81%E6%89%80%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">shared_ptr 自动销毁所管理的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared-ptr-%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">shared_ptr 还会自动释放相关联的内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%86%E5%8A%A8%E6%80%81%E7%94%9F%E5%AD%98%E6%9C%9F%E7%9A%84%E8%B5%84%E6%BA%90%E7%9A%84%E7%B1%BB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">使用了动态生存期的资源的类的原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-2-%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-number">1.1.2.</span> <span class="nav-text">12.1.2 直接管理内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-new-%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">使用 new 动态分配和初始化对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84-const-%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">动态分配的 const 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%80%97%E5%B0%BD"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">内存耗尽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">释放动态内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%80%BC%E5%92%8C-delete"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">指针值和 delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%AD%98%E6%9C%9F%E7%9B%B4%E5%88%B0%E8%A2%AB%E9%87%8A%E6%94%BE%E6%97%B6%E4%B8%BA%E6%AD%A2"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">动态对象的生存期直到被释放时为止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-new-%E5%92%8C-delete-%E7%AE%A1%E7%90%86%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">使用 new 和 delete 管理动态内存的三个常见问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete-%E4%B9%8B%E5%90%8E%E9%87%8D%E7%BD%AE%E6%8C%87%E9%92%88%E5%80%BC"><span class="nav-number">1.1.2.8.</span> <span class="nav-text">delete 之后重置指针值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%99%E5%8F%AA%E6%98%AF%E6%8F%90%E4%BE%9B%E4%BA%86%E6%9C%89%E9%99%90%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="nav-number">1.1.2.9.</span> <span class="nav-text">这只是提供了有限的保护</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-3-shared-ptr-%E5%92%8C-new-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">12.1.3 shared_ptr 和 new 结合使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">不要混合使用普通指针和智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-get-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%88%96%E4%B8%BA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">不要使用 get 初始化另一个智能指针或为智能指针赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-shared-ptr-%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">其他 shared_ptr 操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">1.1.4.</span> <span class="nav-text">12.1.4 智能指针和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%93%91%E7%B1%BB"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">智能指针和哑类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%9A%84%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">使用我们自己的释放操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E9%99%B7%E9%98%B1"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">智能指针陷阱</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-5-unique-ptr"><span class="nav-number">1.1.5.</span> <span class="nav-text">12.1.5 unique_ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92-unique-ptr-%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E-unique-ptr"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">传递 unique_ptr 参数和返回 unique_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91-unique-ptr-%E4%BC%A0%E9%80%92%E5%88%A0%E9%99%A4%E5%99%A8"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">向 unique_ptr 传递删除器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-6-weak-ptr"><span class="nav-number">1.1.6.</span> <span class="nav-text">12.1.6 weak_ptr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.</span> <span class="nav-text">12.2 动态数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-1-new-%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">12.2.1 new 和数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%BC%9A%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">分配一个数组会得到一个元素类型的指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">初始化动态分配对象的数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%88%E6%B3%95%E7%9A%84"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">动态分配一个空数组是合法的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">释放动态数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">智能指针和动态数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-2-allocator-%E7%B1%BB"><span class="nav-number">1.2.2.</span> <span class="nav-text">12.2.2 allocator 类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#allocator-%E7%B1%BB"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">allocator 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#allocator-%E5%88%86%E9%85%8D%E6%9C%AA%E6%9E%84%E9%80%A0%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">allocator 分配未构造的内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%A1%AB%E5%85%85%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">拷贝和填充未初始化内存的算法</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
