<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="10 泛型算法 顺序容器只定义了很少的操作，用户可能还做一些其他很有用的操作，标准库并未给每个容器都定义成员函数来实现它们，而是定义了一组 泛型算法 算法 是因为它们实现了一些经典算法的公共接口，泛型 是因为它们可以用于不同类型的元素和多种容器类型  10.1 概述 大多数算法都定义在头文件 algorithm 中，标准库还在头文件 numeric 中定义了一组数值泛型算法 一般情况下，算法并不直">
<meta property="og:type" content="article">
<meta property="og:title" content="C++Primer-10-泛型算法">
<meta property="og:url" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="10 泛型算法 顺序容器只定义了很少的操作，用户可能还做一些其他很有用的操作，标准库并未给每个容器都定义成员函数来实现它们，而是定义了一组 泛型算法 算法 是因为它们实现了一些经典算法的公共接口，泛型 是因为它们可以用于不同类型的元素和多种容器类型  10.1 概述 大多数算法都定义在头文件 algorithm 中，标准库还在头文件 numeric 中定义了一组数值泛型算法 一般情况下，算法并不直">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095429785.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120094024649.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095507828.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095532562.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095605020.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100204810.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100247186.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100846520.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101225937.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101333789.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102044011.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102109934.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101657896.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102131214.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103050597.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103100877.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103241249.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104014949.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104347020.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104423846.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104841160.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104849527.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105305781.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105456109.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105640375.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120110529067.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120110557764.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111417949.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111540565.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111722099.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112046142.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112131621.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112507534.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112604726.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112650976.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113047932.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113624892.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113636991.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113749208.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113802747.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114153398.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114144721.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114316937.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114514241.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114718943.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120130709219.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120130721421.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131257862.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131310063.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131627364.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131643099.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131739797.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132315074.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132346862.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132509140.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132700171.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132900248.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133138976.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133645835.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133654972.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120134322779.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120134619601.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120135823274.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120135944553.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120140323390.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120140501206.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141052933.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141402297.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141621469.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141735652.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141924398.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141934406.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120142111787.png">
<meta property="article:published_time" content="2024-01-20T01:13:45.000Z">
<meta property="article:modified_time" content="2024-01-20T09:46:24.844Z">
<meta property="article:author" content="yiweiBoi">
<meta property="article:tag" content="C++Primer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095429785.png">

<link rel="canonical" href="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++Primer-10-泛型算法 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++Primer-10-泛型算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-20 09:13:45 / 修改时间：17:46:24" itemprop="dateCreated datePublished" datetime="2024-01-20T09:13:45+08:00">2024-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="10-泛型算法"><a href="#10-泛型算法" class="headerlink" title="10 泛型算法"></a>10 泛型算法</h1><blockquote>
<p>顺序容器只定义了很少的操作，用户可能还做一些其他很有用的操作，标准库并未给每个容器都定义成员函数来实现它们，而是定义了一组 <strong>泛型算法</strong></p>
<p><strong>算法</strong> 是因为它们实现了一些经典算法的公共接口，<strong>泛型</strong> 是因为它们可以用于不同类型的元素和多种容器类型</p>
</blockquote>
<h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><blockquote>
<p>大多数算法都定义在头文件 <strong>algorithm</strong> 中，标准库还在头文件 <strong>numeric</strong> 中定义了一组数值泛型算法</p>
<p>一般情况下，算法并不直接操作容器，而是遍历由两个迭代器指定的一个容器范围来进行操作</p>
</blockquote>
<h4 id="迭代器令算法不依赖于容器"><a href="#迭代器令算法不依赖于容器" class="headerlink" title="迭代器令算法不依赖于容器"></a>迭代器令算法不依赖于容器</h4><ul>
<li><strong>find</strong> 算法的前两个参数表示元素范围的迭代器，第三个参数是一个值，返回第一个指向等于给定值的元素的迭代器<ul>
<li>如果没有匹配，则 find 返回第二个参数表示搜索失败，所以我们可以比较返回值和第二个参数判断是否成功</li>
<li>完成算法中的这些步骤都不依赖于容器所保存的元素类型</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095429785.png" class="" title="image-20240120095429785">

<h4 id="但算法依赖于元素类型的操作"><a href="#但算法依赖于元素类型的操作" class="headerlink" title="但算法依赖于元素类型的操作"></a>但算法依赖于元素类型的操作</h4><ul>
<li>虽然迭代器的使用令算法不依赖容器类型，但大多数算法都使用了一个或多个元素类型上的操作</li>
</ul>
<blockquote>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器上，执行迭代器的操作</p>
<p>这个特性带来了一个非常必要的编程假定：算法永远不会改变底层容器的大小</p>
</blockquote>
<h2 id="10-2-初始泛型算法"><a href="#10-2-初始泛型算法" class="headerlink" title="10.2 初始泛型算法"></a>10.2 初始泛型算法</h2><blockquote>
<p>除了少数例外，标准库算法都对一个范围内的元素进行操作，这个元素范围称为 <strong>输入范围</strong></p>
<p>虽然大多数算法遍历输入范围的方式类似，但它们使用范围中元素的方式不同</p>
</blockquote>
<h3 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法</h3><ul>
<li><p>只读取输入范围的元素，而不改变元素</p>
</li>
<li><p>find 就是一种只读算法，另一个只读算法是 <strong>accumulate</strong>，定义在头文件 numeric 中</p>
<ul>
<li><p>接受三个参数，前两个指出需要 <strong>求和</strong> 的范围，第三个参数是和的初始值</p>
<blockquote>
<p>accumulate 的第三个参数的类型决定了函数中使用哪个加法运算符及返回值的类型</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120094024649.png" class="" title="image-20240120094024649">

<blockquote>
<p>对于只读算法，通常最好使用 cbegin 和 cend</p>
</blockquote>
<h4 id="操作两个序列的算法"><a href="#操作两个序列的算法" class="headerlink" title="操作两个序列的算法"></a>操作两个序列的算法</h4><ul>
<li><p>另一个只读算法是 <strong>equal</strong>，用于确定两个序列算法保存相同的值</p>
<ul>
<li><p>接受三个迭代器，前两个表示输入范围，第三个表示第二个序列的首元素</p>
</li>
<li><p>它将第一个序列中每个元素于第二个序列中对应元素进行比较，都相等返回 true，否则返回 false</p>
<blockquote>
<p>equal 基于一个非常重要的 <strong>假设</strong>：第二个序列至少于第一个序列一样长</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095507828.png" class="" title="image-20240120095507828">

<blockquote>
<p>那些只接受一个单一迭代器表示第二个序列的算法，都假定第二个序列至少于第一个序列一样长</p>
</blockquote>
<h3 id="10-2-2-写容器元素的算法"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a>10.2.2 写容器元素的算法</h3><ul>
<li><p>这类算法要求原序列大小至少不小于我们要求算法写入的元素数目（因此它们最多写入和给定序列一样多的元素）</p>
</li>
<li><p><strong>fill</strong> 算法接受一对迭代器参数表示范围，还接受一个值作为第三个参数，将给定值赋予输入序列中的每个元素</p>
<blockquote>
<p>因此 fill 算法很安全，只要确保传递了一个有效的输入序列</p>
</blockquote>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095532562.png" class="" title="image-20240120095532562">

<h4 id="算法不检查写操作"><a href="#算法不检查写操作" class="headerlink" title="算法不检查写操作"></a>算法不检查写操作</h4><ul>
<li><p>一些算法只接受一个迭代器来指出一个单独的目的位置</p>
</li>
<li><p><strong>fill_n</strong> 函数接受一个单迭代器、一个计数器和一个值，它将给定值赋予迭代器指向的元素开始的指定个元素</p>
<blockquote>
<p>full_n 假定：dest 指向一个元素，而从 dest 开始的序列至少包含 n 个元素</p>
</blockquote>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120095605020.png" class="" title="image-20240120095605020">

<blockquote>
<p>一个很容易犯的 <strong>错误</strong> 就是：在一个空容器上调用 fill_n</p>
<p>向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素</p>
</blockquote>
<h4 id="介绍-back-inserter"><a href="#介绍-back-inserter" class="headerlink" title="介绍 back_inserter"></a>介绍 back_inserter</h4><ul>
<li><p>一种保证算法有足够空间来容纳输入数据的方法是使用 <strong>插入迭代器</strong></p>
<ul>
<li>一般情况下，我们通过一个迭代器向容器赋值时，值被赋予迭代器指向的元素</li>
<li>而当我们通过一个插入迭代器赋值时，一个值相等的新元素被添加到容器中</li>
</ul>
</li>
<li><p><strong>back_inserter</strong> 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器</p>
<ul>
<li>当我们通过它赋值时，赋值运算符会调用 <strong>push_back</strong> 将一个给定值元素加入容器</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100204810.png" class="" title="image-20240120100204810">

<ul>
<li>我们通常将插入迭代器作为算法的 <strong>目的位置</strong> 来使用</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100247186.png" class="" title="image-20240120100247186">

<h4 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h4><ul>
<li>拷贝算法也是向 目的位置迭代器 指向的输入序列 中的元素 写入数据的算法<ul>
<li>接受三个迭代器，前两个表示输入范围，第三个表示目的序列的起始位置</li>
<li>将输入范围中的元素拷贝到目的序列中</li>
<li>因此，目的序列至少包含于输入序列一样多的元素</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120100846520.png" class="" title="image-20240120100846520">

<ul>
<li><p>很多算法都提供了 <strong>拷贝版本</strong>，它们不会改变原序列，而是创建一个新的序列保存这些结果</p>
<ul>
<li><p><strong>replace</strong> 接受 4 个参数，前两个是输入序列，后两个一个是要搜索的值，一个是要替换的新值</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101225937.png" class="" title="image-20240120101225937">
</li>
<li><p><strong>replace_copy</strong> 接受额外的一个迭代器参数，指出调整后序列的保存位置</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101333789.png" class="" title="image-20240120101333789"></li>
</ul>
</li>
</ul>
<h3 id="10-2-3-重排容器元素的算法"><a href="#10-2-3-重排容器元素的算法" class="headerlink" title="10.2.3 重排容器元素的算法"></a>10.2.3 重排容器元素的算法</h3><ul>
<li><strong>sort</strong> 算法是利用元素类型的 <strong>&lt; 运算符</strong> 来实现排序的</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102044011.png" class="" title="image-20240120102044011">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102109934.png" class="" title="image-20240120102109934">

<blockquote>
<p>算法并不能执行容器操作，所以使用 vector 的 erase 来完成真正的删除操作</p>
</blockquote>
<h4 id="消除重复元素"><a href="#消除重复元素" class="headerlink" title="消除重复元素"></a>消除重复元素</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120101657896.png" class="" title="image-20240120101657896">

<h4 id="使用-unique"><a href="#使用-unique" class="headerlink" title="使用 unique"></a>使用 unique</h4><ul>
<li><strong>unique</strong> 算法重排输入序列，将相邻的重复项 <strong>“消除”</strong>，并返回一个指向不重复范围末尾的迭代器</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120102131214.png" class="" title="image-20240120102131214">

<h4 id="使用容器操作删除元素"><a href="#使用容器操作删除元素" class="headerlink" title="使用容器操作删除元素"></a>使用容器操作删除元素</h4><h2 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h2><blockquote>
<p>很多算法都会比较输入序列，默认情况下，这类算法使用元素类型的 <strong>&lt; 或 &#x3D;&#x3D; 运算符</strong> 完成比较</p>
<p>标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符</p>
</blockquote>
<h3 id="10-3-1-向算法传递函数"><a href="#10-3-1-向算法传递函数" class="headerlink" title="10.3.1 向算法传递函数"></a>10.3.1 向算法传递函数</h3><ul>
<li><strong>sort</strong> 的第二个版本，接受一个额外的参数，此参数是一个 <strong>谓词</strong></li>
</ul>
<h4 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h4><ul>
<li>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值，谓词又分为两类：<ul>
<li><strong>一元谓词</strong> 只能接受一个参数，<strong>二元谓词</strong> 有两个参数</li>
<li>接受谓词参数的算法，对输入序列中的元素调用谓词，因此元素类型必须能转换为谓词的参数类型</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103050597.png" class="" title="image-20240120103050597">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103100877.png" class="" title="image-20240120103100877">

<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><ul>
<li><strong>stable_sort</strong> 算法，这种 <strong>稳定</strong> 排序算法维持相等元素的原有顺序</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120103241249.png" class="" title="image-20240120103241249">

<blockquote>
<p>通常情况下，我们不关心有序序列中相等元素的相对顺序，但在这个例子中，我们将 <strong>相等</strong> 定义为了 <strong>具有相同长度</strong></p>
</blockquote>
<h3 id="10-3-2-lambda-表达式"><a href="#10-3-2-lambda-表达式" class="headerlink" title="10.3.2 lambda 表达式"></a>10.3.2 lambda 表达式</h3><h4 id="介绍-lambda"><a href="#介绍-lambda" class="headerlink" title="介绍 lambda"></a>介绍 lambda</h4><ul>
<li><p>我们可以向一个算法传递任何类别的 <strong>可调用对象</strong>，对于一个对象或一个表达式，如果可以对其使用 <strong>（）调用运算符</strong>，则称它为可调用的</p>
</li>
<li><p>可调用对象有 4 种：函数、函数指针、重载了函数调用运算符的类、<strong>lambda 表达式</strong></p>
</li>
<li><p>一个 lambda 表达式表示一个可调用的代码单元</p>
<ul>
<li><p>具有一个返回类型，一个参数列表、一个函数体</p>
</li>
<li><p>与函数不同的是，lambda 可以定义在函数内部，形式如下：</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104014949.png" class="" title="image-20240120104014949">

<ul>
<li><strong>capture list（捕获列表）</strong>是一个 lambda 所在函数种定义的局部遍历的列表（通常为空）</li>
<li><strong>return type、parameter list 和 function body</strong> 分别表示返回类型、参数类别和函数体</li>
<li>不同的是，lambda 必须使用尾置返回来指定返回类型</li>
</ul>
</li>
</ul>
</li>
<li><p>我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104347020.png" class="" title="image-20240120104347020">

<blockquote>
<p>lambda 中忽略括号和参数列表等价于指定一个空参数列表</p>
<p>如果忽略返回类型，则 lambda 根据函数体中的代码推断出返回类型</p>
<p>如果函数体只是一个 return 语句，返回类型可以推测，否则忽略返回类型的话，返回类型为 void</p>
</blockquote>
<ul>
<li>lambda 的调用方式和普通函数一样，都使用调用运算符</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104423846.png" class="" title="image-20240120104423846">

<h4 id="向-lambda-传递参数"><a href="#向-lambda-传递参数" class="headerlink" title="向 lambda 传递参数"></a>向 lambda 传递参数</h4><ul>
<li>lambda 不能有默认参数，因此 lambda 的调用的实参数目永远与形参数目相等</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104841160.png" class="" title="image-20240120104841160">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120104849527.png" class="" title="image-20240120104849527">

<h4 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h4><ul>
<li>lambda 通过将局部遍历包含在其捕获列表中来指出将会使用这些变量</li>
</ul>
<h4 id="调用-find-if"><a href="#调用-find-if" class="headerlink" title="调用 find_if"></a>调用 find_if</h4><ul>
<li><strong>find_if</strong> 算法可以查找第一个具有特定大小的元素<ul>
<li>接受三个参数，前两个参数表示输入范围，第三个参数是一个谓词，且是一个一元谓词</li>
<li>返回第一个使用谓词返回非 0 值的元素，如果不存在则返回尾迭代器</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105305781.png" class="" title="image-20240120105305781">

<h4 id="for-each-算法"><a href="#for-each-算法" class="headerlink" title="for_each 算法"></a>for_each 算法</h4><ul>
<li>接受三个参数，前两个为输入范围，第三个为一个可调用对象，对输入序列中的每个元素调用此对象</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105456109.png" class="" title="image-20240120105456109">

<blockquote>
<p>捕获列表只用于局部非 static 变量，lambda 可以直接使用局部 static 变量和它所在函数之外声明的名字</p>
</blockquote>
<h4 id="完整的-biggies"><a href="#完整的-biggies" class="headerlink" title="完整的 biggies"></a>完整的 biggies</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120105640375.png" class="" title="image-20240120105640375">

<h3 id="10-3-3-lambda-捕获与返回"><a href="#10-3-3-lambda-捕获与返回" class="headerlink" title="10.3.3 lambda 捕获与返回"></a>10.3.3 lambda 捕获与返回</h3><ul>
<li>当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名的）类类型</li>
<li>当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象（未命名对象）<ul>
<li>默认情况下，从 lambda 生成的类都包含一个对应 lambda 所捕获的变量的数据成员</li>
</ul>
</li>
</ul>
<h4 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h4><ul>
<li>变量的捕获方式可以是值或引用<ul>
<li>采用值捕获的前提是变量可以拷贝，被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120110529067.png" class="" title="image-20240120110529067">

<h4 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120110557764.png" class="" title="image-20240120110557764">

<ul>
<li>如果我们采用引用的方式捕获变量，就必须保证被引用的对象在 lambda 这些的时候是存在的</li>
<li>lambda 捕获的是局部变量，这些变量在函数结束后就不复存在了</li>
<li>如果函数返回一个 lambda，则该 lambda 不能包含引用捕获</li>
</ul>
<blockquote>
<p>一般来说，我们应该尽量减少捕获的数据量，如果可能的话，应该避免捕获指针或引用</p>
</blockquote>
<h4 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h4><ul>
<li>可以让编译器根据 lambda 体中的代码来推断我们要使用那些变量<ul>
<li>在捕获列表中写 **&amp; 或 &#x3D;**，&amp; 告诉编译器采用捕获引用方式，&#x3D; 则表采用值捕获方式</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111417949.png" class="" title="image-20240120111417949">

<ul>
<li>也可以混合使用隐式捕获和显示捕获</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111540565.png" class="" title="image-20240120111540565">

<blockquote>
<p>混合使用隐式捕获和显示捕获时，捕获列表中的第一个元素必须是一个 &amp; 或 &#x3D;，且显示捕获的变量必须使用与隐式捕获不同的方式</p>
</blockquote>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120111722099.png" class="" title="image-20240120111722099">

<h4 id="可变-lambda"><a href="#可变-lambda" class="headerlink" title="可变 lambda"></a>可变 lambda</h4><ul>
<li>默认情况下，一个值拷贝的变量，lambda 不会改变其值</li>
<li>如果我们希望改变一个捕获的变量的值，就必须在参数列表首加上关键字 <strong>mutable</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112046142.png" class="" title="image-20240120112046142">

<ul>
<li>一个引用捕获的变量算法可以修改则依赖于指向的是一个 const 还是 非 const</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112131621.png" class="" title="image-20240120112131621">

<h4 id="指定-lambda-返回类型"><a href="#指定-lambda-返回类型" class="headerlink" title="指定 lambda 返回类型"></a>指定 lambda 返回类型</h4><ul>
<li><p><strong>transform</strong> 函数接受三个迭代器和一个可调用对象，前两个迭代器表示输入序列，第三个迭代器表示目的位置</p>
<ul>
<li>算法对输入序列中每个元素调用可调用对象，结果写入到目的位置</li>
</ul>
</li>
<li><p>lambda 体只包含一个 return 语句时，可以隐式推断出返回类型</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112507534.png" class="" title="image-20240120112507534">

<ul>
<li>如果 lambda 体包含 return 之外的任何语句，则编译器假定此 lambda 返回 <strong>void</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112604726.png" class="" title="image-20240120112604726">

<ul>
<li>当我们需要为一个 lambda 定义返回类型时，必须使用 <strong>尾置返回类型</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120112650976.png" class="" title="image-20240120112650976">

<h3 id="10-3-4-参数绑定"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a>10.3.4 参数绑定</h3><blockquote>
<p>在那种只有一两个地方使用的简单操作，lambda 表达式是最有用的</p>
<p>如果需要在很多地方使用，或一个操作需要很多语句才能完成，通常使用函数更好</p>
<p>对于捕获局部变量的 lambda，用函数替换它就不是那么容易了</p>
</blockquote>
<h4 id="标准库-bind-函数"><a href="#标准库-bind-函数" class="headerlink" title="标准库 bind 函数"></a>标准库 bind 函数</h4><ul>
<li><p>可以将 <strong>bind</strong> 看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来 <strong>“适应”</strong> 原对象的参数列表</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113047932.png" class="" title="image-20240120113047932">

<ul>
<li><strong>newCallable</strong> 是一个可调用对象，<strong>arg_list</strong> 是一个参数列表，对应给定的 <strong>callable（旧的可调用对象）</strong> 的参数</li>
<li><strong>arg_list</strong> 中的参数可能包含 <strong>_n</strong> 这样的名字，n 为一个整数，称为 <strong>占位符</strong>，表示 newCallable 的参数<ul>
<li><strong>_1</strong> 为 newCallable 的第一个参数，**_2** 为第二个参数……</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113624892.png" class="" title="image-20240120113624892">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113636991.png" class="" title="image-20240120113636991">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113749208.png" class="" title="image-20240120113749208">

<ul>
<li>对 find_if 使用</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120113802747.png" class="" title="image-20240120113802747">

<h4 id="使用-placeholders-名字"><a href="#使用-placeholders-名字" class="headerlink" title="使用 placeholders 名字"></a>使用 placeholders 名字</h4><ul>
<li><p><strong>_n</strong> 这样的名字都定义在一个名为 <strong>placeholders</strong> 的命名空间中，这个命名空间本身就定义在 <strong>std</strong> 命名空间</p>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114153398.png" class="" title="image-20240120114153398">
</li>
<li><p>我们可以使用如下声明，说明希望所有来自 <strong>namespace_name</strong> 的名字都可以在我们的程序中直接使用</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114144721.png" class="" title="image-20240120114144721">

<h4 id="bind-的参数"><a href="#bind-的参数" class="headerlink" title="bind 的参数"></a>bind 的参数</h4><ul>
<li>可以用 bind 绑定给定可调用对象中的参数或重新安排其顺序</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114316937.png" class="" title="image-20240120114316937">

<ul>
<li>此时 g 的第一个参数被传递给 f 的最后一个参数，g 的第二个参数被传递给 f 的第三个参数</li>
</ul>
<h4 id="用-bind-重排参数顺序"><a href="#用-bind-重排参数顺序" class="headerlink" title="用 bind 重排参数顺序"></a>用 bind 重排参数顺序</h4><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114514241.png" class="" title="image-20240120114514241">

<h4 id="绑定引用参数"><a href="#绑定引用参数" class="headerlink" title="绑定引用参数"></a>绑定引用参数</h4><ul>
<li>默认情况下，bind 的那些不是占位符的参数被拷贝到 bind 返回的可调用函数中</li>
<li>如果必须传递给 bind 一个对象而不是拷贝它，就必须使用 <strong>ref</strong> 函数（比如 ostream）</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120114718943.png" class="" title="image-20240120114718943">

<ul>
<li><strong>cref</strong> 函数生成一个保存 const 引用的类</li>
</ul>
<h2 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器</h2><ul>
<li>除了在每个容器中定义的迭代器外，标志库在头文件 <strong>iterator</strong> 中还定义了额外几种迭代器</li>
<li><strong>插入迭代器</strong>：这些迭代器绑定到一个容器上，可以用来向容器中插入元素</li>
<li><strong>流迭代器</strong>：这些迭代器被绑定到输入或输出流上，可以用来遍历所关联的 IO 流</li>
<li><strong>反向迭代器</strong>：这些迭代器向后而不是向前移动（除了 forward_list 外的标准库都有反向迭代器）</li>
<li><strong>移动迭代器</strong>：这些专用的迭代器不是拷贝其中的元素，而是移动它们</li>
</ul>
<h3 id="10-4-1-插入迭代器"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a>10.4.1 插入迭代器</h3><ul>
<li>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，可以实现向给定容器添加元素</li>
<li>通过一个插入迭代器赋值时，该迭代器会调用容器操作来向给定容器的指定位置插入一个元素</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120130709219.png" class="" title="image-20240120130709219">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120130721421.png" class="" title="image-20240120130721421">

<h3 id="10-4-2-iostream-迭代器"><a href="#10-4-2-iostream-迭代器" class="headerlink" title="10.4.2 iostream 迭代器"></a>10.4.2 iostream 迭代器</h3><ul>
<li>虽然 iostream 类型不是容器，但标准库定义了可用于这些 IO 类型对象的迭代器</li>
<li><strong>istream_iterator</strong> 读取输入流，<strong>ostream_iterator</strong> 向一个输出流写数据</li>
<li>这些迭代器将给定的流当作一个特定类型的元素序列来处理</li>
</ul>
<h4 id="istream-iterator-操作"><a href="#istream-iterator-操作" class="headerlink" title="istream_iterator 操作"></a>istream_iterator 操作</h4><ul>
<li><p>创建一个流迭代器时，必须指定迭代器要读写的对象的类型</p>
<ul>
<li>一个 istream_iterator 使用 <strong>&gt;&gt;</strong> 来读取流，因此它读取的类型必须定义了 &gt;&gt; 输出运算符</li>
</ul>
</li>
<li><p>默认初始化迭代器时，会创建一个可以当作 <strong>尾后值</strong> 使用的迭代器</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131257862.png" class="" title="image-20240120131257862">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131310063.png" class="" title="image-20240120131310063">

<blockquote>
<p>对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到 IO 错误，迭代器的值就与尾后迭代器相等</p>
</blockquote>
<ul>
<li>我们以如下的方式构造 vector，从 cin 中读取数据，知道遇到文件尾或遇到一个不是 int 数据为止</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131627364.png" class="" title="image-20240120131627364">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131643099.png" class="" title="image-20240120131643099">

<h4 id="使用算法操作流迭代器"><a href="#使用算法操作流迭代器" class="headerlink" title="使用算法操作流迭代器"></a>使用算法操作流迭代器</h4><ul>
<li>通过一对 istream_iterator 来调用 accumulate：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120131739797.png" class="" title="image-20240120131739797">

<h4 id="istream-iterator-允许使用懒惰求值"><a href="#istream-iterator-允许使用懒惰求值" class="headerlink" title="istream_iterator 允许使用懒惰求值"></a>istream_iterator 允许使用懒惰求值</h4><ul>
<li>当一个 istream_iterator 绑定到一个流时，标准库并不保证马上从流读取数据，可能直到我们使用迭代器时才真正读取</li>
</ul>
<h4 id="ostream-iterator-操作"><a href="#ostream-iterator-操作" class="headerlink" title="ostream_iterator 操作"></a>ostream_iterator 操作</h4><ul>
<li><p>我们可以对任何具有 <strong>&lt;&lt; 输出运算符</strong> 的类型定义 ostream_iterator</p>
<ul>
<li>创建时，我们也可以提供（可选的）第二参数，它是一个 C 风格的字符串，在输出每个元素后都会打印此字符串</li>
</ul>
</li>
<li><p>必须将 ostream_iterator 绑定到一个指定的流，不允许空的或表示尾后位置的 ostream_iterator</p>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132315074.png" class="" title="image-20240120132315074">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132346862.png" class="" title="image-20240120132346862">

<ul>
<li>当我们向 ostream_iterator 赋值时，可以忽略解引用和递增运算符，因为实际上它们什么也不做</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132509140.png" class="" title="image-20240120132509140">

<blockquote>
<p>但更推荐写上解引用和递增运算符，因为这样对读者来说更清晰，也更易修改</p>
</blockquote>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132700171.png" class="" title="image-20240120132700171">

<h4 id="使用流迭代器处理类类型"><a href="#使用流迭代器处理类类型" class="headerlink" title="使用流迭代器处理类类型"></a>使用流迭代器处理类类型</h4><ul>
<li>我们可以为任何定义了 <strong>&gt;&gt; 输入运算符</strong> 的类型创建 istream_iterator 对象，对定义有 <strong>&lt;&lt; 输出运算符</strong> 的类型创建 ostream_iterator 对象</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120132900248.png" class="" title="image-20240120132900248">

<h3 id="10-4-3-反向迭代器"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a>10.4.3 反向迭代器</h3><ul>
<li>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器，递增及递减操作的含义颠倒过来</li>
<li>除了 **forward_list **之外的其他容器都支持反向迭代器，我们可以通过调用 rbegin、rend、crbegin、crend 函数来获得反向迭代器</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133138976.png" class="" title="image-20240120133138976">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133645835.png" class="" title="image-20240120133645835">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120133654972.png" class="" title="image-20240120133654972">

<h4 id="反向迭代器需要递减运算符"><a href="#反向迭代器需要递减运算符" class="headerlink" title="反向迭代器需要递减运算符"></a>反向迭代器需要递减运算符</h4><ul>
<li>我们只能从既支持 ++ 也支持 - - 的迭代器来定义反向迭代器<ul>
<li><strong>流迭代器</strong> 不支持递减迭代器，而除了 forward_list 外，标准库容器上的其他迭代器都都既支持递增也支持递减运算符</li>
</ul>
</li>
</ul>
<h4 id="反向迭代器和其他迭代器之间的关系"><a href="#反向迭代器和其他迭代器之间的关系" class="headerlink" title="反向迭代器和其他迭代器之间的关系"></a>反向迭代器和其他迭代器之间的关系</h4><ul>
<li><p>调用反向迭代器（reverse_iterator）的 <strong>base</strong> 成员函数完成从一个反向迭代器转换为普通迭代器</p>
<blockquote>
<p>反向迭代器转换为普通迭代器后，指向不同的元素</p>
</blockquote>
</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120134322779.png" class="" title="image-20240120134322779">

<blockquote>
<p>反向迭代器和普通迭代器都反映了左闭合区间的特性，**[ line.crbegin( )，rcomma ），[ rcomma.base( )，line.cend( ) ）**</p>
</blockquote>
<h2 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构</h2><ul>
<li>算法所要求的迭代器操作可分为 5 个 <strong>迭代器类别</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120134619601.png" class="" title="image-20240120134619601">

<h3 id="10-5-1-5-类迭代器"><a href="#10-5-1-5-类迭代器" class="headerlink" title="10.5.1 5 类迭代器"></a>10.5.1 5 类迭代器</h3><ul>
<li>一个高层类别的迭代器支持低层类别迭代器的所有操作，而向算法传递一个哪里更差的迭代器会产生错误</li>
</ul>
<h4 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h4><ul>
<li>可以读取序列中的元素，一个输入迭代器必须支持：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120135823274.png" class="" title="image-20240120135823274">

<blockquote>
<p>输入迭代器只能用于单遍扫描算法</p>
</blockquote>
<h4 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h4><ul>
<li>只写而不读元素，输出迭代器必须支持：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120135944553.png" class="" title="image-20240120135944553">

<blockquote>
<p>我们只能向一个输出迭代器赋值一次，输出迭代器也只能用于单遍扫描算法</p>
<p>用作目的位置的迭代器通常是输出迭代器</p>
</blockquote>
<h4 id="向前迭代器"><a href="#向前迭代器" class="headerlink" title="向前迭代器"></a>向前迭代器</h4><ul>
<li>可以读写元素，这类迭代器只能在序列中沿一个方向移动</li>
<li>可以多次读写同一个元素，因此可以使用向前迭代器的算法对序列进行多次扫描</li>
</ul>
<h4 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h4><ul>
<li>提供在常量时间内访问序列中任意元素的哪里，支持双向迭代器的所有功能，还支持：</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120140323390.png" class="" title="image-20240120140323390">

<blockquote>
<p>sort 就要求随机访问迭代器，array、deque、vector、string 的迭代器都是随机访问迭代器，用于访问内置数组的指针也是</p>
</blockquote>
<h3 id="10-5-2-算法形参模式"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a>10.5.2 算法形参模式</h3><img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120140501206.png" class="" title="image-20240120140501206">

<ul>
<li><strong>alg</strong> 是算法的名字，<strong>beg 和 end</strong> 表示算法所操作的输入范围（几乎所有算法都接受一个输入范围）</li>
<li><strong>dest 和 beg2、end2</strong> 都是迭代器参数，分别表示目的位置和第二个范围的角色</li>
<li><strong>other args</strong> 表示其他额外的非迭代器参数，一些算法还接受它们</li>
</ul>
<h4 id="接受单个目标迭代器的算法"><a href="#接受单个目标迭代器的算法" class="headerlink" title="接受单个目标迭代器的算法"></a>接受单个目标迭代器的算法</h4><ul>
<li>蕴含一个编程假定，且通常 dest 被绑定到一个插入迭代器</li>
</ul>
<h4 id="接受第二个输入序列的算法"><a href="#接受第二个输入序列的算法" class="headerlink" title="接受第二个输入序列的算法"></a>接受第二个输入序列的算法</h4><ul>
<li>蕴含一个编程假定：从 beg2 开始的范围与 beg 和 end 所表示的范围至少一样大</li>
</ul>
<h3 id="10-5-3-算法命名规范"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a>10.5.3 算法命名规范</h3><h4 id="一些算法使用重载形式传递一个谓词"><a href="#一些算法使用重载形式传递一个谓词" class="headerlink" title="一些算法使用重载形式传递一个谓词"></a>一些算法使用重载形式传递一个谓词</h4><ul>
<li>接受谓词参数替换 &lt; 或 &#x3D;&#x3D; 运算符的算法，以及那些不接受额外参数的算法，通常是重载函数</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141052933.png" class="" title="image-20240120141052933">

<h4 id="if-版本的算法"><a href="#if-版本的算法" class="headerlink" title="_if 版本的算法"></a>_if 版本的算法</h4><ul>
<li>接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词替代元素值，都附加有 <strong>_if</strong> 前缀</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141402297.png" class="" title="image-20240120141402297">

<h4 id="区分拷贝元素的版本和不拷贝的版本"><a href="#区分拷贝元素的版本和不拷贝的版本" class="headerlink" title="区分拷贝元素的版本和不拷贝的版本"></a>区分拷贝元素的版本和不拷贝的版本</h4><ul>
<li>默认情况下，重排元素的算法将重排后的元素写到给定的输入序列中，它们还提供了一个拷贝版本，将元素写到一个指定的输出目的位置，都在名字后边附加一个 <strong>_copy</strong></li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141621469.png" class="" title="image-20240120141621469">

<ul>
<li>一些算法同时提供了 _copy 和 _if 版本</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141735652.png" class="" title="image-20240120141735652">

<h2 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法</h2><ul>
<li>特别的，<strong>链式类型 list 和 forward_list</strong> 定义了几个成员函数形式的算法，这些链表版本的算法的性能比对应的通用版本好得多</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141924398.png" class="" title="image-20240120141924398">

<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120141934406.png" class="" title="image-20240120141934406">

<blockquote>
<p>对于 list 和 forward_list 应该优先使用成员函数版本的算法，而不是通用版本算法</p>
</blockquote>
<h4 id="spilce-成员"><a href="#spilce-成员" class="headerlink" title="spilce 成员"></a>spilce 成员</h4><ul>
<li>此算法是链表数据结构所特有的，不需要通用版本</li>
</ul>
<img src="/2024/01/20/10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/image-20240120142111787.png" class="" title="image-20240120142111787">

<h4 id="链表特有的操作会改变容器"><a href="#链表特有的操作会改变容器" class="headerlink" title="链表特有的操作会改变容器"></a>链表特有的操作会改变容器</h4><ul>
<li>多数链表特有的算法都与其通用版本相似，但不完全相同</li>
<li>链表特有的版本与通用版本的一个至关重要的的区别是 <strong>链表版本会改变底层的容器</strong></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-Primer/" rel="tag"># C++Primer</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/01/19/9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" rel="prev" title="C++Primer-9-顺序容器">
      <i class="fa fa-chevron-left"></i> C++Primer-9-顺序容器
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/01/29/12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" rel="next" title="C++Primer-12-动态内存">
      C++Primer-12-动态内存 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">10 泛型算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">10.1 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%A4%E7%AE%97%E6%B3%95%E4%B8%8D%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%AE%B9%E5%99%A8"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">迭代器令算法不依赖于容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%86%E7%AE%97%E6%B3%95%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">但算法依赖于元素类型的操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-%E5%88%9D%E5%A7%8B%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">10.2 初始泛型算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-1-%E5%8F%AA%E8%AF%BB%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">10.2.1 只读算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E4%B8%A4%E4%B8%AA%E5%BA%8F%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">操作两个序列的算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-2-%E5%86%99%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">10.2.2 写容器元素的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%B8%8D%E6%A3%80%E6%9F%A5%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">算法不检查写操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-back-inserter"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">介绍 back_inserter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">拷贝算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-3-%E9%87%8D%E6%8E%92%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.3.</span> <span class="nav-text">10.2.3 重排容器元素的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">消除重复元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-unique"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">使用 unique</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">使用容器操作删除元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.</span> <span class="nav-text">10.3 定制操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-1-%E5%90%91%E7%AE%97%E6%B3%95%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">10.3.1 向算法传递函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%93%E8%AF%8D"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">谓词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">排序算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-2-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text">10.3.2 lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-lambda"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">介绍 lambda</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91-lambda-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">向 lambda 传递参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">使用捕获列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-find-if"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">调用 find_if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-each-%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">for_each 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84-biggies"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">完整的 biggies</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-3-lambda-%E6%8D%95%E8%8E%B7%E4%B8%8E%E8%BF%94%E5%9B%9E"><span class="nav-number">1.3.3.</span> <span class="nav-text">10.3.3 lambda 捕获与返回</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E6%8D%95%E8%8E%B7"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">值捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%8D%95%E8%8E%B7"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">引用捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E6%8D%95%E8%8E%B7"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">隐式捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98-lambda"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">可变 lambda</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A-lambda-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">指定 lambda 返回类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-4-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-number">1.3.4.</span> <span class="nav-text">10.3.4 参数绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93-bind-%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">标准库 bind 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-placeholders-%E5%90%8D%E5%AD%97"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">使用 placeholders 名字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind-%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">bind 的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8-bind-%E9%87%8D%E6%8E%92%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">用 bind 重排参数顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.4.5.</span> <span class="nav-text">绑定引用参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.4.</span> <span class="nav-text">10.4 再探迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-1-%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">10.4.1 插入迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-2-iostream-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">10.4.2 iostream 迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#istream-iterator-%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">istream_iterator 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E6%93%8D%E4%BD%9C%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">使用算法操作流迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#istream-iterator-%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8%E6%87%92%E6%83%B0%E6%B1%82%E5%80%BC"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">istream_iterator 允许使用懒惰求值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ostream-iterator-%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">ostream_iterator 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%84%E7%90%86%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">使用流迭代器处理类类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-3-%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.4.3.</span> <span class="nav-text">10.4.3 反向迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%9C%80%E8%A6%81%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">反向迭代器需要递减运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%85%B6%E4%BB%96%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">反向迭代器和其他迭代器之间的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-5-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">10.5 泛型算法结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-1-5-%E7%B1%BB%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.5.1.</span> <span class="nav-text">10.5.1 5 类迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">输入迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">输出迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E5%89%8D%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">向前迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">随机访问迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-2-%E7%AE%97%E6%B3%95%E5%BD%A2%E5%8F%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">10.5.2 算法形参模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%97%E5%8D%95%E4%B8%AA%E7%9B%AE%E6%A0%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">接受单个目标迭代器的算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%97%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%BE%93%E5%85%A5%E5%BA%8F%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">接受第二个输入序列的算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-3-%E7%AE%97%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">1.5.3.</span> <span class="nav-text">10.5.3 算法命名规范</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E4%BD%BF%E7%94%A8%E9%87%8D%E8%BD%BD%E5%BD%A2%E5%BC%8F%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E8%B0%93%E8%AF%8D"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">一些算法使用重载形式传递一个谓词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#if-%E7%89%88%E6%9C%AC%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">_if 版本的算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%86%E6%8B%B7%E8%B4%9D%E5%85%83%E7%B4%A0%E7%9A%84%E7%89%88%E6%9C%AC%E5%92%8C%E4%B8%8D%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">区分拷贝元素的版本和不拷贝的版本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-6-%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">10.6 特定容器算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#spilce-%E6%88%90%E5%91%98"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">spilce 成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%89%B9%E6%9C%89%E7%9A%84%E6%93%8D%E4%BD%9C%E4%BC%9A%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8"><span class="nav-number">1.6.0.2.</span> <span class="nav-text">链表特有的操作会改变容器</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
