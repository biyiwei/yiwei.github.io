<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiweiboi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="文件系统 文件系统的目的是组织和存储数据。文件系统通常支持用户和应用程序之间的数据共享，以及支持持久性，以便数据在重启后仍然可用  xv6 文件系统提供了类 Unix 的文件、目录和路径名（见第 1 章），并将其数据存储在 virtio 磁盘上以实现持久化（见第 4 章）。该文件系统解决了几个挑战：  文件系统需要磁盘上的数据结构来表示命名目录和文件的树，记录保存每个文件内容的块的身份，并记录磁盘">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6 book chapter 8">
<meta property="og:url" content="http://yiweiboi.github.io/2024/07/09/xv6-book-chapter-8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="文件系统 文件系统的目的是组织和存储数据。文件系统通常支持用户和应用程序之间的数据共享，以及支持持久性，以便数据在重启后仍然可用  xv6 文件系统提供了类 Unix 的文件、目录和路径名（见第 1 章），并将其数据存储在 virtio 磁盘上以实现持久化（见第 4 章）。该文件系统解决了几个挑战：  文件系统需要磁盘上的数据结构来表示命名目录和文件的树，记录保存每个文件内容的块的身份，并记录磁盘">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yiweiboi.github.io/2024/07/09/xv6-book-chapter-8/Figure-8.1-17206131871324.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/07/09/xv6-book-chapter-8/Figure-8.2-17206131871325.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/07/09/xv6-book-chapter-8/image-20240711123126129.png">
<meta property="og:image" content="http://yiweiboi.github.io/2024/07/09/xv6-book-chapter-8/Figure-8.3-17206131871326.png">
<meta property="article:published_time" content="2024-07-09T12:43:15.000Z">
<meta property="article:modified_time" content="2024-07-11T04:31:45.495Z">
<meta property="article:author" content="yiweiBoi">
<meta property="article:tag" content="6.s081">
<meta property="article:tag" content="xv6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yiweiboi.github.io/2024/07/09/xv6-book-chapter-8/Figure-8.1-17206131871324.png">

<link rel="canonical" href="http://yiweiboi.github.io/2024/07/09/xv6-book-chapter-8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>xv6 book chapter 8 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiweiboi.github.io/2024/07/09/xv6-book-chapter-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiweiBoi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          xv6 book chapter 8
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-09 20:43:15" itemprop="dateCreated datePublished" datetime="2024-07-09T20:43:15+08:00">2024-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-11 12:31:45" itemprop="dateModified" datetime="2024-07-11T12:31:45+08:00">2024-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><ul>
<li><p>文件系统的目的是组织和存储数据。文件系统通常支持用户和应用程序之间的数据共享，以及支持持久性，以便数据在重启后仍然可用</p>
</li>
<li><p>xv6 文件系统提供了类 Unix 的文件、目录和路径名（见第 1 章），并将其数据存储在 virtio 磁盘上以实现持久化（见第 4 章）。该文件系统解决了几个挑战：</p>
<ul>
<li><p>文件系统需要磁盘上的数据结构来表示命名目录和文件的树，记录保存每个文件内容的块的身份，并记录磁盘上哪些区域是空闲的</p>
</li>
<li><p>文件系统必须支持崩溃恢复。也就是说，如果发生崩溃（如电源故障），文件系统必须在重新启动后仍能正常工作。风险在于，崩溃可能会中断更新序列，并在磁盘上留下不一致的数据结构（例如，一个块既在文件中使用，又被标记为空闲）</p>
</li>
<li><p>不同的进程可能并发在文件系统上运行，所以文件系统代码必须协调维护每一个临界区</p>
</li>
<li><p>访问磁盘的速度比访问内存的速度要慢几个数量级，所以文件系统必须在内存维护一个缓冲区，用于缓存常用块</p>
</li>
</ul>
</li>
<li><p>本章剩下的部分将解释 xv6 如何解决这些问题</p>
</li>
</ul>
<h2 id="Overview-概述"><a href="#Overview-概述" class="headerlink" title="Overview 概述"></a>Overview 概述</h2><img src="/2024/07/09/xv6-book-chapter-8/Figure-8.1-17206131871324.png" class="" title="Figure-8.1">

<ul>
<li>xv6 文件系统的实现分为七层，如图 8.1 所示<ul>
<li>disk 层在 virtio 磁盘上读写块</li>
<li>Buffer cache 缓存磁盘块，并同步访问它们，确保一个块只能同时被内核中的一个进程访问</li>
<li>日志层允许上层通过事务更新多个磁盘块，并确保在崩溃时，磁盘块是原子更新的（即全部更新或不更新）</li>
<li>inode 层将一个文件都表示为一个 <strong>inode</strong>，每个文件包含一个唯一的 i-number 和一些存放文件数据的块</li>
<li>目录层将实现了一种特殊的 <strong>inode</strong>，被称为目录，其包含一个目录项序列，每个目录项由文件名称和 i-number 组成</li>
<li>路径名层提供了层次化的路径名，如 &#x2F;<strong>usr&#x2F;rtm&#x2F;xv6&#x2F;fs.c</strong>，可以用递归查找解析他们</li>
<li>文件描述符层用文件系统接口抽象了许多 Unix 资源（如管道、设备、文件等），使程序员的生产力得到大大的提高</li>
</ul>
</li>
</ul>
<img src="/2024/07/09/xv6-book-chapter-8/Figure-8.2-17206131871325.png" class="" title="Figure-8.2">

<img src="/2024/07/09/xv6-book-chapter-8/image-20240711123126129.png" class="" title="image-20240711123126129">

<ul>
<li><p>文件系统必须安排好磁盘存储 inode 和内容块的位置。为此，xv6 将磁盘分为几个部分，如图 8.2 所示</p>
<ul>
<li><p>文件系统不使用块 0（它存放 boot sector）</p>
</li>
<li><p>第 1 块称为 <strong>superblock</strong>，它包含了文件系统的元数据（以块为单位的文件系统大小、数据块的数量、inode 的数量和日志中的块数）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Disk layout:</span></span><br><span class="line"><span class="comment">// [ boot block | super block | log | inode blocks |</span></span><br><span class="line"><span class="comment">//                                          free bit map | data blocks]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mkfs computes the super block and builds an initial file system. The</span></span><br><span class="line"><span class="comment">// super block describes the disk layout:</span></span><br><span class="line"><span class="comment">// 磁盘布局：  </span></span><br><span class="line"><span class="comment">// [引导块 | 超级块 | 日志 | inode 块 |  </span></span><br><span class="line"><span class="comment">//                                          空闲位图 | 数据块]  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// mkfs 工具计算超级块并构建初始文件系统。  </span></span><br><span class="line"><span class="comment">// 超级块描述了磁盘的布局：  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> &#123;</span></span><br><span class="line">uint magic;        <span class="comment">// Must be FSMAGIC 必须为FSMAGIC，用于验证文件系统的魔数</span></span><br><span class="line">uint size;         <span class="comment">// Size of file system image (blocks) 文件系统映像的大小（以块为单位）</span></span><br><span class="line">uint nblocks;      <span class="comment">// Number of data blocks 数据块的数量</span></span><br><span class="line">uint ninodes;      <span class="comment">// Number of inodes. inode的数量</span></span><br><span class="line">uint nlog;         <span class="comment">// Number of log blocks 日志块的数量</span></span><br><span class="line">uint logstart;     <span class="comment">// Block number of first log block 第一个日志块的块号 </span></span><br><span class="line">uint inodestart;   <span class="comment">// Block number of first inode block 第一个inode块的块号</span></span><br><span class="line">uint bmapstart;    <span class="comment">// Block number of first free map block 第一个空闲位图块的块号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>从块 2 开始存放着日志</p>
</li>
<li><p>日志之后是 inodes，每个块会包含多个 inode</p>
</li>
<li><p>在这些块之后是 **位图块(bitmap)**，记录哪些数据块在使用</p>
</li>
<li><p>其余的块是数据块，每个数据块要么在 bitmap 块中标记为空闲，要么持有文件或目录的内容</p>
</li>
<li><p>超级块由一个单独的程序 <strong>mkfs</strong> 写入，它建立了一个初始文件系统</p>
</li>
</ul>
</li>
<li><p>本章的其余部分将讨论每一层，从 buffer 缓存开始。从讨论中我们将看到如何选择合适的低层抽象，来方便更高层的设计</p>
</li>
</ul>
<h2 id="Buffer-cache-layer"><a href="#Buffer-cache-layer" class="headerlink" title="Buffer cache layer"></a>Buffer cache layer</h2><ul>
<li><p>buffer 缓存有两项工作。(1) 同步访问磁盘块，以确保磁盘块在内存中只有一个 buffer 缓存，并且一次只有一个内核线程能使用该 buffer 缓存；(2) 缓存使用较多的块，这样它们就不需要从慢速磁盘中重新读取。代码见 <strong>bio.c</strong></p>
</li>
<li><p>buffer 缓存的主要接口包括 <strong>bread</strong> 和 <strong>bwrite</strong>，bread 返回一个在内存中可以读取和修改的块副本 <strong>buf</strong>，<strong>bwrite</strong> 将修改后的 buffer 写到磁盘上相应的块</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a locked buf with the contents of the indicated block. 返回一个包含指定块内容的已锁定缓冲区</span></span><br><span class="line"><span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">b = bget(dev, blockno);</span><br><span class="line"><span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line"> virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line"> b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked. 将b的内容写入磁盘，必须持有锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line"> panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>内核线程在使用完一个 buffer 后，必须通过调用 <strong>brelse</strong> 释放它</li>
<li>buffer 缓存为每个 buffer 的都设有 sleep-lock，以确保每次只有一个线程使用 buffer（从而使用相应的磁盘块）</li>
<li><strong>bread</strong> 返回的 buffer 会被锁定，而 <strong>brelse</strong> 释放锁</li>
</ul>
</li>
<li><p>我们再来看看 buffer 缓存。buffer 缓存有固定数量的 buffer 来存放磁盘块，这意味着如果文件系统需要一个尚未被缓存的块，buffer 缓存必须回收一个当前存放其他块的 buffer。buffer 缓存为新块寻找最近使用最少的 buffer（lru 机制）。因为最近使用最少的 buffer 是最不可能被再次使用的 buffer</p>
</li>
</ul>
<h2 id="Code-Buffer-cache"><a href="#Code-Buffer-cache" class="headerlink" title="Code: Buffer cache"></a>Code: Buffer cache</h2><ul>
<li><p>buffer 缓存是一个由 buffer 组成的双端链表。由函数 <strong>binit</strong> 用静态数组 <strong>buf</strong> 初始化这个链表，<strong>binit</strong> 在启动时由 <strong>main</strong> (kernel&#x2F;main.c:27) 调用。访问 buffer 缓存是通过链表，而不是 <strong>buf</strong> 数组</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBUF (MAXOPBLOCKS*3)   <span class="comment">// size of disk block cache</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Linked list of all buffers, through prev/next.  通过 prev/next 指针链接所有缓冲区，形成一个链表</span></span><br><span class="line"><span class="comment">// Sorted by how recently the buffer was used. 根据缓冲区最近被使用的时间进行排序</span></span><br><span class="line"><span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line"><span class="comment">// head.next 指向最近被使用的缓冲区，head.prev 指向最久未被使用的缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create linked list of buffers 创建缓冲区的链表(很好的创建双向环形链表的方式)</span></span><br><span class="line">bcache.head.prev = &amp;bcache.head;</span><br><span class="line">bcache.head.next = &amp;bcache.head;</span><br><span class="line"><span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">b-&gt;next = bcache.head.next;</span><br><span class="line">b-&gt;prev = &amp;bcache.head;</span><br><span class="line">initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">bcache.head.next-&gt;prev = b;</span><br><span class="line">bcache.head.next = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>buffer 有两个与之相关的状态字段。字段 <strong>valid</strong> 表示是否包含该块的副本（是否从磁盘读取了数据）。字段 <strong>disk</strong> 表示缓冲区的内容已经被修改需要被重新写入磁盘</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line"><span class="type">int</span> valid;   <span class="comment">// has data been read from disk? 已经从磁盘读取数据了吗</span></span><br><span class="line"><span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">uint dev;</span><br><span class="line">uint blockno;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">uint refcnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>bget</strong> (kernel&#x2F;bio.c:59) 扫描 buffer 链表，寻找给定设备号和扇区号来查找缓冲区 (kernel&#x2F;bio.c:65-73)。如果存在，<strong>bget</strong> 就会获取该 buffer 的 sleep-lock。然后 <strong>bget</strong> 返回被锁定的 buffer</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev. 在 buf 缓存中查找设备 dev 上的数据块</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer. 如果没有找到，则分配一个缓冲区</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer. 在任何一种情况下，都返回已加锁的缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is the block already cached? 数据块是否已经被缓存</span></span><br><span class="line"><span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line"> <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">   b-&gt;refcnt++;</span><br><span class="line">   release(&amp;bcache.lock);</span><br><span class="line">   acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not cached. 没有被缓存</span></span><br><span class="line"><span class="comment">// Recycle the least recently used (LRU) unused buffer. 回收最近最少使用（LRU）的未使用缓冲区</span></span><br><span class="line"><span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line"> <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">   b-&gt;dev = dev;</span><br><span class="line">   b-&gt;blockno = blockno;</span><br><span class="line">   b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">   b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">   release(&amp;bcache.lock);</span><br><span class="line">   acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果给定的扇区没有缓存的 buffer，<strong>bget</strong> 必须生成一个，可能会使用一个存放不同扇区的 buffer，它再次扫描 buffer 链表，寻找没有被使用的 buffer(<strong>b-&gt;refcnt &#x3D; 0</strong>)；任何这样的 buffer 都可以使用。bget 修改 buffer 元数据，记录新的设备号和扇区号，并获得其 sleep-lock。请注意，<strong>b-&gt;valid &#x3D; 0</strong> 可以确保 bread 从磁盘读取块数据，而不是错误地使用 buffer 之前的内容</p>
</li>
<li><p>请注意，每个磁盘扇区最多只能有一个 buffer，以确保写操作对读取者可见，也因为文件系统需要使用 buffer 上的锁来进行同步。<strong>bget</strong> 通过从第一次循环检查块是否被缓存，第二次循环来生成一个相应的 buffer（通过设置 <strong>dev</strong>、<strong>blockno</strong> 和 <strong>refcnt</strong>），在进行这两步操作时，需要一直持有 <strong>bache.lock</strong> 。持有 <strong>bache.lock</strong> 会保证上面两个循环在整体上是原子的</p>
</li>
<li><p><strong>bget</strong> 在 <strong>bcache.lock</strong> 保护的临界区之外获取 buffer 的 sleep-lock 是安全的，因为非零的 <strong>b-&gt;refcnt</strong> 可以防止缓冲区被重新用于不同的磁盘块（只要保证我们获得了正确的磁盘块对应的缓冲区，假如此时有一个中断导致磁盘块对应缓冲区中的内容被修改，都是被允许的）。sleep-lock 保护的是块的缓冲内容的读写，而 bcache.lock 保护被缓存块的信息</p>
</li>
<li><p>如果所有 buffer 都在使用，那么太多的进程同时在执行文件相关的系统调用，bget 就会 <strong>panic</strong>。一个更好的处理方式可能是睡眠，直到有 buffer 空闲，尽管这时有可能出现死锁</p>
</li>
<li><p>一旦 <strong>bread</strong> 读取了磁盘内容（如果需要的话）并将缓冲区返回给它的调用者，调用者就独占该 buffer，可以读取或写入数据。如果调用者修改了 buffer，它必须在释放 buffer 之前调用 <strong>bwrite</strong> 将修改后的数据写入磁盘。<strong>bwrite</strong> (kernel&#x2F;bio.c:107) 调用 <strong>virtio_disk_rw</strong> 与磁盘硬件交互</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked. 将b的内容写入磁盘，必须持有锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line"> panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>当调用者处理完一个 buffer 后，必须调用 <strong>brelse</strong> 来释放它。(<strong>brelse</strong> 这个名字是 <strong>b-release</strong> 的缩写，虽然很神秘，但值得学习，它起源于 Unix，在 BSD、Linux 和 Solaris 中也有使用。) </p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release a locked buffer. 释放一个已锁定的缓冲区</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list. 将其移动到最近使用列表的头部</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line"> panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">acquire(&amp;bcache.lock);</span><br><span class="line">b-&gt;refcnt--;</span><br><span class="line"><span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123; <span class="comment">// refcnt==0代表它很可能将会被LRU替换,所以移至链表头来延迟替换,同时加速再次使用时的查找</span></span><br><span class="line"> <span class="comment">// no one is waiting for it.</span></span><br><span class="line"> b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line"> b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line"> b-&gt;next = bcache.head.next;</span><br><span class="line"> b-&gt;prev = &amp;bcache.head;</span><br><span class="line"> bcache.head.next-&gt;prev = b;</span><br><span class="line"> bcache.head.next = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>brelse</strong> (kernel&#x2F;bio.c:117) 释放 sleep-lock，并将该 buffer 移动到链表的头部 (kernel&#x2F;bio.c:128-133)。移动 buffer 会使链表按照 buffer 最近使用的时间（最近释放）排序，链表中的第一个 buffer 是最近使用的，最后一个是最早使用的</li>
<li><strong>bget</strong> 中的两个循环利用了这一点，在最坏的情况下，获取已缓存 buffer 的扫描必须处理整个链表，由于数据局部性，先检查最近使用的缓冲区（从 <strong>bcache.head</strong> 开始，通过 <strong>next</strong> 指针）将减少扫描时间。扫描选取可使用 buffer 的方法是通过从后向前扫描（通过 <strong>prev</strong> 指针）选取最近使用最少的缓冲区</li>
</ul>
</li>
</ul>
<h2 id="Logging-layer"><a href="#Logging-layer" class="headerlink" title="Logging layer"></a>Logging layer</h2><ul>
<li><p>文件系统设计中最有趣的问题之一是崩溃恢复。这个问题的出现是因为许多文件系统操作涉及到对磁盘的多次写入，如果只执行了部分写操作，然后发生崩溃可能会使磁盘上的文件系统处于不一致的状态。例如，假设在文件截断（将文件的长度设置为零并释放其内容块）时发生崩溃。根据磁盘写入的顺序，可能会留下一个引用空闲内容块的inode，也可能会留下一个已分配但没有被引用的内容块</p>
</li>
<li><p>后面的这种情况相对来说好一点，但是如果一个 inode 指向被释放的块，很可能在重启后造成严重的问题。重启后，内核可能会将该块分配给另一个文件，现在我们有两个不同的文件无意中指向了同一个块。如果 xv6 支持多用户，这种情况可能是一个安全问题，因为旧文件的所有者能够读写新文件，即使该文件被另一个用户所拥有</p>
</li>
<li><p>xv6 通过简单的日志系统来解决文件系统操作过程中崩溃带来的问题。xv6 的系统调用不直接写磁盘上的文件系统数据结构。相反，它将写入的数据记录在磁盘上的日志中。一旦系统调用记录了全部的写入数据，它就会在磁盘上写一个特殊的提交记录，表明该日志包含了一个完整的操作。这时，系统调用就会将日志中的写入数据写到磁盘上相应的位置。在执行完成后，系统调用将磁盘上的日志清除</p>
</li>
<li><p>如果系统崩溃并重启，文件系统会在启动过程中恢复自己。如果日志被标记为包含一个完整的操作，那么恢复代码就会将写入的内容复制到它们在磁盘文件系统中的相应位置。如果日志未被标记为包含完整的操作，则恢复代码将忽略并清除该日志</p>
</li>
<li><p>为什么 xv6 的日志系统可以解决文件系统操作过程中的崩溃问题？如果崩溃发生在操作提交之前，那么磁盘上的日志将不会被标记为完成，恢复代码将忽略它，磁盘的状态就像操作根本没有开始一样。如果崩溃发生在操作提交之后，那么恢复代码会重新执行写操作，可能会重复执行之前的写操作。不管是哪种情况，日志都会使写与崩溃为原子的，即恢复后，所有操作的写入内容，要么都在磁盘上，要么都不在</p>
</li>
</ul>
<h2 id="Log-design"><a href="#Log-design" class="headerlink" title="Log design"></a>Log design</h2><ul>
<li><p>日志贮存在一个固定位置，由 <strong>superblock</strong> 指定。它由一个 header 块组成，后面是一连串的更新块副本（日志块）。header 块包含一个扇区号数组，其中的每个扇区号都对应一个日志块<a href="#ftn1">[1]</a>，header 还包含日志块的数量。磁盘上 header 块中的数量要么为零，表示日志中没有事务，要么为非零，表示日志中包含一个完整的提交事务，并有指定数量的日志块。xv6 在事务提交时会修改  header 块，将日志块复制到文件系统后，会将数量设为零。因此，一个事务中途的崩溃将导致日志 header 块中的计数为零；提交后的崩溃的计数为非零</p>
</li>
<li><p>为了应对崩溃，每个系统调用都包含一个原子写序列。为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写操作累积到一个事务中。因此，一次提交可能涉及多个完整系统调用的写入。为了避免一个系统调用被分裂到不同的事务中，只有在没有文件系统相关的系统调用正在进行时，日志系统才会提交</p>
</li>
<li><p>将几个事务一起提交的方法被称为组提交（group commit）。组提交可以减少磁盘操作的次数，因为它将提交的固定成本分摊在了多个操作上。组提交可以让文件系统同时执行更多的并发写，也可以让磁盘在一次磁盘轮转中把它们全部写入。xv6 的 virtio 驱动不支持这种批处理，但 xv6 的文件系统实现了这种方式</p>
</li>
<li><p>xv6 在磁盘上划出固定的空间来存放日志。在一个事务中，系统调用所写的块总数必须适应这个空间的大小。这将导致两个后果：</p>
<ul>
<li>1、系统调用写入的日志大小必须小于日志空间的大小。这对大多数系统调用来说都不是问题，但有两个系统调用可能会写很多块，<strong>write</strong> 和 <strong>unlink</strong>。大文件的 write 可能会写很多数据块和 bitmap 块，以及一个 inode 块；取消链接一个大文件可能会写很多 bitmap 块和一个 inode。xv6 的 <strong>write</strong> 系统调用将大的写操作分解成多个小的写操作，以适应在日志空间的大小，而 <strong>unlink</strong> 不会引起问题，因为 xv6 文件系统只使用一个位图块</li>
<li>2、日志空间有限的另一个后果是，日志系统只会在确定了系统调用的写操作可以适应剩余日志空间之后，才会开始执行该系统调用</li>
</ul>
</li>
</ul>
<h2 id="Code-logging"><a href="#Code-logging" class="headerlink" title="Code: logging"></a>Code: logging</h2><ul>
<li>系统调用中一般用法如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">...</span><br><span class="line">bp = bread(...);</span><br><span class="line">bp-&gt;data[...] = ...;</span><br><span class="line">log_write(bp);</span><br><span class="line">...</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>begin_op</strong> (kernel&#x2F;log.c:126) 会一直等到日志系统没有 commiting，并且有足够的日志空间来容纳这次调用的写。<strong>log.outstanding</strong> 统计当前系统调用的数量，可以通过 <strong>log.outstanding</strong> 乘以 <strong>MAXOPBLOCKS</strong> 来计算已使用的日志空间。自增 <strong>log.outstanding</strong> 既能预留空间，又能防止该系统调用期间进行提交。该代码假设每次系统调用最多写入 <strong>MAXOPBLOCKS</strong> 个块</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple logging that allows concurrent FS system calls. 简单的日志系统，允许并发的文件系统调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A log transaction contains the updates of multiple FS system </span></span><br><span class="line"><span class="comment">// calls. The logging system only commits when there are</span></span><br><span class="line"><span class="comment">// no FS system calls active. Thus there is never</span></span><br><span class="line"><span class="comment">// any reasoning required about whether a commit might</span></span><br><span class="line"><span class="comment">// write an uncommitted system call&#x27;s updates to disk.</span></span><br><span class="line"><span class="comment">// 一个日志事务包含多个文件系统（FS）系统调用的更新</span></span><br><span class="line"><span class="comment">// 日志系统只在没有活跃的FS系统调用时提交</span></span><br><span class="line"><span class="comment">// 因此，永远不需要考虑一个提交操作是否可能会将未提交的系统调用的更新写入磁盘</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A system call should call begin_op()/end_op() to mark</span></span><br><span class="line"><span class="comment">// its start and end. Usually begin_op() just increments</span></span><br><span class="line"><span class="comment">// the count of in-progress FS system calls and returns.</span></span><br><span class="line"><span class="comment">// But if it thinks the log is close to running out, it</span></span><br><span class="line"><span class="comment">// sleeps until the last outstanding end_op() commits.</span></span><br><span class="line"><span class="comment">// 一个系统调用应该通过调用begin_op()/end_op()来标记其开始和结束</span></span><br><span class="line"><span class="comment">// 通常，begin_op()只是增加正在进行的FS系统调用的计数并返回</span></span><br><span class="line"><span class="comment">// 但是，如果它认为日志即将用尽，它会等待直到最后一个未完成的end_op()提交</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The log is a physical re-do log containing disk blocks. 日志是一个物理重做日志，包含磁盘块</span></span><br><span class="line"><span class="comment">// The on-disk log format: 磁盘上的日志格式</span></span><br><span class="line"><span class="comment">//   header block, containing block #s for block A, B, C, ... 头部块，包含块A、B、C等的块号</span></span><br><span class="line"><span class="comment">//   block A 块A</span></span><br><span class="line"><span class="comment">//   block B 块B</span></span><br><span class="line"><span class="comment">//   block C 块C</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">// Log appends are synchronous. 日志追加是同步的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Contents of the header block, used for both the on-disk header block</span></span><br><span class="line"><span class="comment">// and to keep track in memory of logged block# before commit.</span></span><br><span class="line"><span class="comment">// 头部块的内容，既用于磁盘上的头部块，也用于在内存中跟踪提交前记录的块号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> start;	<span class="comment">// 日志块开始的块号</span></span><br><span class="line">  <span class="type">int</span> size;		<span class="comment">// 日志块数量</span></span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// how many FS sys calls are executing. 有多少文件系统（FS）系统调用正在执行</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// in commit(), please wait. 在提交（commit）过程中，请稍候</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXOPBLOCKS  10  <span class="comment">// max # of blocks any FS op writes</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// called at the start of each FS system call. 在每个文件系统（FS）系统调用开始时被调用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">begin_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;</span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">// this op might exhaust log space; wait for commit. 这个操作可能会耗尽日志空间；等待提交</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>log_write</strong> (kernel&#x2F;log.c:214) 是 <strong>bwrite</strong> 的代理。它将扇区号记录在内存中，在磁盘上的日志中使用一个槽，并自增 <strong>buffer.refcnt</strong> 防止该 <strong>buffer</strong> 被重用。在提交之前，块必须留在缓存中，即该缓存的副本是修改的唯一记录；在提交之后才能将其写入磁盘上的位置；该次修改必须对其他读可见。 注意，当一个块在一个事务中被多次写入时，他们在日志中的槽是相同的。这种优化通常被称为 <strong>absorption</strong> (吸收)。例如，在一个事务中，包含多个文件的多个 inode 的磁盘块被写多次，这是常见的情况。通过将几次磁盘写 <strong>吸收</strong> 为一次，文件系统可以节省日志空间，并且可以获得更好的性能，因为只有一份磁盘块的副本必须写入磁盘</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOGSIZE (MAXOPBLOCKS*3) <span class="comment">// max data blocks in on-disk log</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller has modified b-&gt;data and is done with the buffer. </span></span><br><span class="line"><span class="comment">// 调用者已经修改了b-&gt;data，并且完成了对缓冲区的操作</span></span><br><span class="line"><span class="comment">// Record the block number and pin in the cache by increasing refcnt. </span></span><br><span class="line"><span class="comment">// 通过增加refcnt（引用计数）来在缓存中记录块号和固定（锁定）该块</span></span><br><span class="line"><span class="comment">// commit()/write_log() will do the disk write. commit()/write_log()将会执行磁盘写入操作</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// log_write() replaces bwrite(); a typical use is: log_write()替换了bwrite(); 一个典型的使用场景是</span></span><br><span class="line"><span class="comment">//   bp = bread(...)</span></span><br><span class="line"><span class="comment">//   modify bp-&gt;data[]</span></span><br><span class="line"><span class="comment">//   log_write(bp)</span></span><br><span class="line"><span class="comment">//   brelse(bp)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">log_write</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorption 日志吸收</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno; <span class="comment">// 如果没有匹配项，此时i==log.ln.n，记录一个新块号</span></span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log? 增加一个新的块到日志</span></span><br><span class="line">    bpin(b);</span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>end_op</strong> (kernel&#x2F;log.c:146) 首先递减 <strong>log.outstanding</strong>。如果计数为零，则通过调用 <strong>commit()</strong> 来提交当前事务</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the end of each FS system call. 在每个文件系统（FS）系统调用的末尾被调用</span></span><br><span class="line"><span class="comment">// commits if this was the last outstanding operation. 如果这是最后一个挂起的操作，则提交更改</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// begin_op() may be waiting for log space, begin_op() 可能正在等待日志空间</span></span><br><span class="line">    <span class="comment">// and decrementing log.outstanding has decreased </span></span><br><span class="line">    <span class="comment">// 并且减少 log.outstanding 的值已经降低了预留空间的数量</span></span><br><span class="line">    <span class="comment">// the amount of reserved space.</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    <span class="comment">// call commit w/o holding locks, since not allowed </span></span><br><span class="line">    <span class="comment">// 调用提交操作时不持有锁，因为不允许在持有锁的情况下进入睡眠状态</span></span><br><span class="line">    <span class="comment">// to sleep with locks.</span></span><br><span class="line">    commit();</span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log 将缓存中修改过的数据块写入日志</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit 将头部信息写入磁盘——实际提交</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations 现在，将写入操作安装到原始位置</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log 从日志中擦除事务信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy modified blocks from cache to log.  将缓存中修改过的数据块复制到日志中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block 读日志块到缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block （这个修改块已经在缓存中了）</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">    brelse(from);</span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked. 将b的内容写入磁盘，必须持有锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write in-memory log header to disk. 将内存中的日志头部信息写入磁盘</span></span><br><span class="line"><span class="comment">// This is the true point at which the 这是当前事务真正提交的时刻</span></span><br><span class="line"><span class="comment">// current transaction commits.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data); <span class="comment">// 所以第一个日志块的addr部分是日志头</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf); <span class="comment">// 只有完全更新了buf后才会write到磁盘，所以不会出现log.lh.n更新了，但log.lh.block[i]没有更新</span></span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy committed blocks from log to their home location </span></span><br><span class="line"><span class="comment">// 将已提交的数据块从日志复制到它们的主位置（或原始位置）</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">install_trans</span><span class="params">(<span class="type">int</span> recovering)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// read log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// read dst</span></span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="comment">// copy block to dst</span></span><br><span class="line">    bwrite(dbuf);  <span class="comment">// write dst to disk</span></span><br><span class="line">    <span class="keyword">if</span>(recovering == <span class="number">0</span>)</span><br><span class="line">      bunpin(dbuf);</span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bunpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Commit</strong> 分为四个阶段：</p>
<ul>
<li>1、<strong>write_log()</strong> (kernel&#x2F;log.c:178) 将事务中修改的每个块从 buffer 缓存中复制到磁盘上的日志槽中</li>
<li>2、 <strong>write_head()</strong> (kernel&#x2F;log.c:102) 将 header 块写到磁盘上，就表明已提交，为提交点，写完日志后的崩溃，会导致在重启后重新执行日志</li>
<li>3、<strong>install_trans</strong> (kernel&#x2F;log.c:69) 从日志中读取每个块，并将其写到文件系统中对应的位置</li>
<li>4、最后修改日志块计数为 0，并写入日志空间的 header 部分。这必须在下一个事务开始之前修改，这样崩溃就不会导致重启后的恢复使用这次的 header 和下次的日志块</li>
</ul>
</li>
<li><p><strong>recover_from_log</strong> (kernel&#x2F;log.c:116) 是在 <strong>initlog</strong> (kernel&#x2F;log.c:55) 中调用的，而 <strong>initlog</strong> 是在第一个用户进程运行 (kernel&#x2F;proc.c:539) 之前, 由 <strong>fsinit</strong>(kernel&#x2F;fs.c:42) 调用的。它读取日志头，如果日志头显示日志中包含一个已提交的事务，则会像 <strong>end_op</strong> 那样执行日志</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ROOTDEV 1 	<span class="comment">// device number of file system root disk</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A fork child&#x27;s very first scheduling by scheduler() </span></span><br><span class="line"><span class="comment">// 当调度器（scheduler）首次调度一个由fork创建的子进程时，它将切换到forkret函数执行</span></span><br><span class="line"><span class="comment">// will swtch to forkret.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Still holding p-&gt;lock from scheduler.</span></span><br><span class="line">  release(&amp;myproc()-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    <span class="comment">// File system initialization must be run in the context of a</span></span><br><span class="line">    <span class="comment">// regular process (e.g., because it calls sleep), and thus cannot</span></span><br><span class="line">    <span class="comment">// be run from main().</span></span><br><span class="line">    <span class="comment">// 文件系统的初始化必须在常规进程的上下文中运行(例如,因为它调用了sleep函数),因此不能从main()函数中直接运行</span></span><br><span class="line">    <span class="comment">// 由于文件系统的初始化可能涉及到一些需要等待或延迟,这些操作不能在程序的主入口点（即main()函数）中直接执行</span></span><br><span class="line">    <span class="comment">// 因为main()函数通常期望立即返回，以允许程序继续执行其他任务或结束</span></span><br><span class="line">    fsinit(ROOTDEV);</span><br><span class="line"></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ensure other cores(核心) see first=0.</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init fs</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fsinit</span><span class="params">(<span class="type">int</span> dev)</span> &#123;</span><br><span class="line">  readsb(dev, &amp;sb); <span class="comment">// sb is superblock</span></span><br><span class="line">  <span class="keyword">if</span>(sb.magic != FSMAGIC)</span><br><span class="line">    panic(<span class="string">&quot;invalid file system&quot;</span>);</span><br><span class="line">  initlog(dev, &amp;sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the super block.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">readsb</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  bp = bread(dev, <span class="number">1</span>);	<span class="comment">// 磁盘的第一个块</span></span><br><span class="line">  memmove(sb, bp-&gt;data, <span class="keyword">sizeof</span>(*sb)); <span class="comment">// 磁盘第一个块的addr部分就是superblock</span></span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlog</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> logheader) &gt;= BSIZE)</span><br><span class="line">    panic(<span class="string">&quot;initlog: too big logheader&quot;</span>);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;<span class="built_in">log</span>.lock, <span class="string">&quot;log&quot;</span>);</span><br><span class="line">  <span class="built_in">log</span>.start = sb-&gt;logstart;</span><br><span class="line">  <span class="built_in">log</span>.size = sb-&gt;nlog; <span class="comment">// sb-&gt;nlog是日志块的数量</span></span><br><span class="line">  <span class="built_in">log</span>.dev = dev;</span><br><span class="line">  recover_from_log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  read_head();</span><br><span class="line">  install_trans(<span class="number">1</span>); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  write_head(); <span class="comment">// clear the log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the log header from disk into the in-memory log header</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">read_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">lh</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">log</span>.lh.n = lh-&gt;n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="built_in">log</span>.lh.block[i] = lh-&gt;block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>一个使用了日志的例子是 filewrite (kernel&#x2F;file.c:135)。这个事务看起来像这样：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">ilock(f-&gt;ip);</span><br><span class="line">r = writei(f-&gt;ip, ...);</span><br><span class="line">iunlock(f-&gt;ip);</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段代码被包裹在一个循环中，它将大的写分解成每次只有几个扇区的单独事务，以避免溢出日志空间。调用 <strong>writei</strong> 写入许多块作为这个事务的一部分：文件的 inode，一个或多个 bitmap 块，以及一些数据块</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write to file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">ret = pipewrite(f-&gt;pipe, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line"><span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">ret = devsw[f-&gt;major].write(<span class="number">1</span>, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line"><span class="comment">// write a few blocks at a time to avoid exceeding </span></span><br><span class="line"><span class="comment">// 一次写入几个块以避免超过日志事务的最大大小，这包括i节点、间接块、分配块,以及对于非对齐写入的2个额外块</span></span><br><span class="line"><span class="comment">// the maximum log transaction size, including</span></span><br><span class="line"><span class="comment">// i-node, indirect block, allocation blocks,</span></span><br><span class="line"><span class="comment">// and 2 blocks of slop for non-aligned writes.</span></span><br><span class="line"><span class="comment">// this really belongs lower down, since writei() </span></span><br><span class="line"><span class="comment">// 这实际上应该放在更低层，因为writei()可能正在写入像控制台这样的设备</span></span><br><span class="line"><span class="comment">// might be writing a device like the console.</span></span><br><span class="line"><span class="comment">// -1-1-2代表可能写的块inode-间接块-bitmap-?(也有可能是因为(10-3)/2=3.5,额外-1取整),/2是给logblock预留空间</span></span><br><span class="line"><span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE; </span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line"><span class="type">int</span> n1 = n - i;</span><br><span class="line"><span class="keyword">if</span>(n1 &gt; max) <span class="comment">// 每次最多写入max字节</span></span><br><span class="line">  n1 = max;</span><br><span class="line"></span><br><span class="line">begin_op();</span><br><span class="line">ilock(f-&gt;ip);</span><br><span class="line"><span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">  f-&gt;off += r;</span><br><span class="line">iunlock(f-&gt;ip);</span><br><span class="line">end_op();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r != n1)&#123;</span><br><span class="line">  <span class="comment">// error from writei</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">i += r;</span><br><span class="line">&#125;</span><br><span class="line">ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">panic(<span class="string">&quot;filewrite&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Code-Block-allocator"><a href="#Code-Block-allocator" class="headerlink" title="Code: Block allocator"></a>Code: Block allocator</h2><ul>
<li><p>文件和目录存储在磁盘块中，必须从空闲池中分配，xv6 的块分配器在磁盘上维护一个 bitmap，每个块对应一个位。0 表示对应的块是空闲的，1 表示正在使用中。程序 mkfs 设置引导扇区、超级块、日志块、inode 块和位图块对应的位。</p>
</li>
<li><p>块分配器提供了两个函数：<strong>balloc</strong> 申请一个新的磁盘块，<strong>bfree</strong> 释放一个块</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 1024  <span class="comment">// block size</span></span></span><br><span class="line"><span class="comment">// Bitmap bits per block</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPB           (BSIZE*8)</span></span><br><span class="line"><span class="comment">// Block of free map containing bit for block b 包含数据块b的比特的空闲映射块</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BBLOCK(b, sb) ((b)/BPB + sb.bmapstart)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a zeroed disk block. 分配一个已清零的磁盘块</span></span><br><span class="line"><span class="comment">// returns 0 if out of disk space. 如果磁盘空间不足，则返回0</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">balloc</span><span class="params">(uint dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> b, bi, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">bp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(b = <span class="number">0</span>; b &lt; sb.size; b += BPB)&#123;</span><br><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line"><span class="keyword">for</span>(bi = <span class="number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123; <span class="comment">// 一个bitmap块可以确定8*1024个块是否空闲</span></span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>); <span class="comment">// 确定到位</span></span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)&#123;  <span class="comment">// Is block free? 确定到字节</span></span><br><span class="line">    bp-&gt;data[bi/<span class="number">8</span>] |= m;  <span class="comment">// Mark block in use.</span></span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">  bzero(dev, b + bi);</span><br><span class="line">  <span class="keyword">return</span> b + bi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">brelse(bp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;balloc: out of blocks\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>balloc</strong> (kernel&#x2F;fs.c:71) 会有一个循环遍历每一个块，从块 0 开始，直到 <strong>sb.size</strong>，即文件系统中的块数</li>
<li>它寻找一个位为 0 的空闲块。如果 <strong>balloc</strong> 找到了这样一个块，它就会更新 bitmap 并返回该块</li>
<li>为了提高效率，这个循环被分成两部分。外循环读取 bitmap 的一个块，内循环检查块中的所有 BPB 位。如果两个进程同时试图分配一个块，可能会发生竞争，但 buffer 缓存只允许块同时被一个进程访问，这就避免了这种情况的发生</li>
</ul>
</li>
<li><p><strong>bfree</strong> (kernel&#x2F;fs.c:90) 找到相应的 bitmap 块并清除相应的位。<strong>bread</strong> 和 <strong>brelse</strong> 暗含的独占性避免了显式锁定</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a disk block. 释放一个磁盘块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"><span class="type">int</span> bi, m;</span><br><span class="line"></span><br><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">bi = b % BPB;	</span><br><span class="line">m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">log_write(bp);</span><br><span class="line">brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>与本章其余部分描述的大部分代码一样，<strong>balloc</strong> 和 <strong>bfree</strong> 必须在事务中被调用</p>
</li>
</ul>
<h2 id="Inode-layer"><a href="#Inode-layer" class="headerlink" title="Inode layer"></a>Inode layer</h2><ul>
<li><p>术语 inode 有两种相关的含义。1、指的是磁盘上的数据结构，其中包含了文件的大小和数据块号的列表；2、指的是内存中的 inode，它包含了磁盘上 inode 的副本以及内核中需要的其他信息</p>
</li>
<li><p>磁盘上的 inode 被放置在磁盘的一个连续区域。每一个 inode 的大小都是一样的，所以，给定一个数字 n，很容易找到磁盘上的第 n 个 inode。事实上，这个数字 n，被称为 inode 号或 i-number，在实现中就是通过这个识别 inode 的</p>
</li>
<li><p>结构体 <strong>dinode</strong>(kernel&#x2F;fs.h:32) 定义了磁盘上的 inode</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line"><span class="type">short</span> type;           <span class="comment">// File type 文件类型</span></span><br><span class="line"><span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only) 主设备号（仅对T_DEVICE类型有效）</span></span><br><span class="line"><span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only) 次设备号（仅对T_DEVICE类型有效）</span></span><br><span class="line"><span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system 在文件系统中链接到此inode的链接数</span></span><br><span class="line">uint size;            <span class="comment">// Size of file (bytes) 文件大小（字节）</span></span><br><span class="line">uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses 数据块地址数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>type</strong> 字段区分了文件、目录和特殊文件（设备）。type 为 0 表示该 inode 是空闲的</li>
<li><strong>nlink</strong> 字段统计引用这个 inode 的目录项的数量，当引用数为 0 时就释放磁盘上的 inode 及其数据块</li>
<li><strong>size</strong> 字段记录了文件中内容的字节数</li>
<li><strong>addrs</strong> 数组记录了持有文件内容的磁盘块的块号</li>
</ul>
</li>
<li><p>内核将在使用的 inode 保存在内存中；结构体 <strong>inode</strong> (kernel&#x2F;file.h:17) 是磁盘 <strong>dinode</strong> 的拷贝。内核只在有指针指向 inode 才会储存</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in-memory copy of an inode 内存中inode的复制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">uint dev;           <span class="comment">// Device number 设备号</span></span><br><span class="line">uint inum;          <span class="comment">// Inode number indoe号</span></span><br><span class="line"><span class="type">int</span> ref;            <span class="comment">// Reference count  引用计数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here 保护这里以下的所有内容</span></span><br><span class="line"><span class="type">int</span> valid;          <span class="comment">// inode has been read from disk? indoe已经从磁盘中读出了吗</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> type;         <span class="comment">// copy of disk inode 磁盘inode的复制</span></span><br><span class="line"><span class="type">short</span> major;</span><br><span class="line"><span class="type">short</span> minor;</span><br><span class="line"><span class="type">short</span> nlink;</span><br><span class="line">uint size;</span><br><span class="line">uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>ref</strong> 字段为指向 inode 的指针的数量，如果引用数量减少到零，内核就会从内存中丢弃这个 inode</li>
<li><strong>iget</strong> 和 <strong>iput</strong> 函数引用和释放 inode，并修改引用计数。指向 inode 的指针可以来自文件描述符，当前工作目录，以及短暂的内核代码，如 <strong>exec</strong></li>
</ul>
</li>
<li><p>在 xv6 的 inode 代码中，有四种锁或类似锁的机制</p>
<ul>
<li><strong>icache.lock</strong> 保证了一个 inode 在缓存只有一个副本，以及缓存 inode 的 <strong>ref</strong> 字段计数正确</li>
<li>每个内存中的 inode 都有一个包含 sleep-lock 的锁字段，它保证了可以独占访问 inode 的其他字段（如文件长度）以及 inode 的文件或目录内容块的。一个 inode 的 <strong>ref</strong> 如果大于 0，则会使系统将该 inode 保留在缓存中，而不会重用该 inode</li>
<li>最后，每个 inode 都包含一个 <strong>nlink</strong> 字段 (在磁盘上，缓存时会复制到内存中)，该字段统计链接该 inode 的目录项的数量；如果一个 inode 的链接数大于零，xv6 不会释放它</li>
</ul>
</li>
<li><p><strong>iget()</strong> 返回的 <strong>inode</strong> 指针在调用 iput() 之前都是有效的；inode 不会被删除，指针所引用的内存也不会被另一个 inode 重新使用</p>
<ul>
<li><strong>iget()</strong> 提供了对 inode 的非独占性访问，因此可以有许多指针指向同一个 inode</li>
<li>文件系统代码中的许多部分都依赖于 <strong>iget()</strong> 的这种行为，既是为了保持对 inode 的长期引用 (如打开的文件和当前目录)，也是为了防止竞争，同时避免在操作多个 inode 的代码中出现死锁 (如路径名查找)</li>
</ul>
</li>
<li><p>inode 缓存只缓存被指针指向的 inode。它的主要工作其实是同步多个进程的访问，缓存是次要的。如果一个 inode 被频繁使用，如果不被 inode 缓存保存，buffer 缓存可能会把它保存在内存中。inode 缓存是 <strong>write-through</strong> 的，这意味着缓存的 inode 被修改，就必须立即用 <strong>iupdate</strong> 把它写入磁盘</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">inode</span>[<span class="title">NINODE</span>];</span></span><br><span class="line">&#125; itable;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Code-Inodes"><a href="#Code-Inodes" class="headerlink" title="Code: Inodes"></a>Code: Inodes</h2><ul>
<li><p>要创建一个新的 inode (例如，当创建一个文件时)，xv6 会调用 **ialloc **(kernel&#x2F;fs.c:196)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inodes per block. 一个块多少个indoe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPB           (BSIZE / sizeof(struct dinode))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Block containing inode i 包含inode i的块（i/IPB 确定inode i 位于块偏移量)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate an inode on device dev. 在设备 dev 上分配一个inode</span></span><br><span class="line"><span class="comment">// Mark it as allocated by  giving it type type. 通过赋予它类型 type 来标记为已分配</span></span><br><span class="line"><span class="comment">// Returns an unlocked but allocated and referenced inode, 返回一个未加锁但已分配且被引用的inode</span></span><br><span class="line"><span class="comment">// or NULL if there is no free inode. 如果没有空闲的inode，则返回NULL</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">ialloc</span><span class="params">(uint dev, <span class="type">short</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> inum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line"> bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line"> dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB; <span class="comment">// 确定inodes块中inum inode的位置</span></span><br><span class="line"> <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// a free inode</span></span><br><span class="line">   <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));</span><br><span class="line">   dip-&gt;type = type;</span><br><span class="line">   log_write(bp);   <span class="comment">// mark it allocated on the disk 在磁盘上标记它为已分配</span></span><br><span class="line">   brelse(bp);</span><br><span class="line">   <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line"> &#125;</span><br><span class="line"> brelse(bp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ialloc: no inodes\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>ialloc</strong> 类似于 <strong>balloc</strong>：它遍历磁盘上的  inode ，寻找一个被标记为空闲的 inode</li>
<li>当它找到后，它会修改该 inode 的 <strong>type</strong> 字段来使用它，最后调用 <strong>iget</strong> (kernel&#x2F;fs.c:210) 来从 inode 缓存中返回一个条目</li>
<li>由于一次只能有一个进程持有对 <strong>bp:ialloc</strong> 的引用，所以可以确保其他进程不会同时看到 inode 是可用的并使用它</li>
</ul>
</li>
<li><p><strong>Iget</strong> (kernel&#x2F;fs.c:243) 在 inode 缓存中寻找一个带有所需设备号和 inode 号码的 active 条目 (ip-&gt;ref &gt; 0)。如果它找到了，它就返回一个新的对该 inode 的引用 (kernel&#x2F;fs.c:252-256)。当 <strong>iget</strong> 扫描时，它会记录第一个空槽的位置 (kernel&#x2F;fs.c:257- 258)，当它需要分配一个缓存条目时，它会使用这个空槽</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the inode with number inum on device dev </span></span><br><span class="line"><span class="comment">// 在设备dev上找到编号为inum的inode，并返回其内存中的副本</span></span><br><span class="line"><span class="comment">// and return the in-memory copy. Does not lock 此操作不会锁定inode，也不会从磁盘读取它</span></span><br><span class="line"><span class="comment">// the inode and does not read it from disk.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">iget</span><span class="params">(uint dev, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is the inode already in the table?</span></span><br><span class="line">empty = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ip = &amp;itable.inode[<span class="number">0</span>]; ip &lt; &amp;itable.inode[NINODE]; ip++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">   ip-&gt;ref++;</span><br><span class="line">   release(&amp;itable.lock);</span><br><span class="line">   <span class="keyword">return</span> ip;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// Remember empty slot.</span></span><br><span class="line">   empty = ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recycle an inode entry. 回收一个inode条目</span></span><br><span class="line"><span class="keyword">if</span>(empty == <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;iget: no inodes&quot;</span>);</span><br><span class="line"></span><br><span class="line">ip = empty;</span><br><span class="line">ip-&gt;dev = dev;</span><br><span class="line">ip-&gt;inum = inum;</span><br><span class="line">ip-&gt;ref = <span class="number">1</span>;</span><br><span class="line">ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">release(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>在读写 inode 的元数据或内容之前，代码必须使用 <strong>ilock</strong> 锁定它。<strong>Ilock</strong>(kernel&#x2F;fs.c:289) 使用 sleep-lock 来锁定。一旦 <strong>ilock</strong> 锁定了 inode，它就会根据自己的需要从磁盘（更有可能是 buffer 缓存）读取 inode。函数 <strong>iunlock</strong> (kernel&#x2F;fs.c:317) 释放睡眠锁，这会唤醒正在等待该睡眠锁的进程</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock the given inode. 锁定给定的inode</span></span><br><span class="line"><span class="comment">// Reads the inode from disk if necessary. 如果需要，则从磁盘读取inode</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ilock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line"> panic(<span class="string">&quot;ilock&quot;</span>);</span><br><span class="line"></span><br><span class="line">acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line"> bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line"> dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line"> ip-&gt;type = dip-&gt;type;</span><br><span class="line"> ip-&gt;major = dip-&gt;major;</span><br><span class="line"> ip-&gt;minor = dip-&gt;minor;</span><br><span class="line"> ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line"> ip-&gt;size = dip-&gt;size;</span><br><span class="line"> memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line"> brelse(bp);</span><br><span class="line"> ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)</span><br><span class="line">   panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock the given inode. 解锁给定的inode</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iunlock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ip == <span class="number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line"> panic(<span class="string">&quot;iunlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Iput</strong> (kernel&#x2F;fs.c:333) 通过递减引用次数 (kernel&#x2F;fs.c:356) 释放指向 inode 的指针。如果递减后的引用数为 0，inode 缓存就会释放掉该 inode 在 inode 缓存中的槽位，该槽位就可以被其他 inode 使用</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Drop a reference to an in-memory inode. 释放对内存中inode的引用</span></span><br><span class="line"><span class="comment">// If that was the last reference, the inode table entry can </span></span><br><span class="line"><span class="comment">// 如果这是最后一个引用，那么inode表项可以被回收</span></span><br><span class="line"><span class="comment">// be recycled.</span></span><br><span class="line"><span class="comment">// If that was the last reference and the inode has no links </span></span><br><span class="line"><span class="comment">// 如果这是最后一个引用，并且inode没有任何链接指向它，则在磁盘上释放inode（及其内容）</span></span><br><span class="line"><span class="comment">// to it, free the inode (and its content) on disk.</span></span><br><span class="line"><span class="comment">// All calls to iput() must be inside a transaction in  </span></span><br><span class="line"><span class="comment">// 所有对iput()的调用都必须在事务内部进行,以防需要释放inode</span></span><br><span class="line"><span class="comment">// case it has to free the inode.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;ref == <span class="number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line"> <span class="comment">// inode has no links and no other references: truncate and free. </span></span><br><span class="line"> <span class="comment">// inode没有任何链接和其他引用：截断并释放</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// ip-&gt;ref == 1 means no other process can have ip locked, </span></span><br><span class="line"> <span class="comment">// ip-&gt;ref == 1 意味着没有其他进程可以锁定ip</span></span><br><span class="line"> <span class="comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span></span><br><span class="line"> <span class="comment">// 因此这个acquiresleep()调用不会阻塞（或导致死锁）</span></span><br><span class="line"> acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line"> release(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line"> itrunc(ip);</span><br><span class="line"> ip-&gt;type = <span class="number">0</span>;	<span class="comment">// 配合iupdate将磁盘上的inode标记为空闲</span></span><br><span class="line"> iupdate(ip);</span><br><span class="line"> ip-&gt;valid = <span class="number">0</span>;	<span class="comment">// 表示inode缓存空闲</span></span><br><span class="line"></span><br><span class="line"> releasesleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line"> acquire(&amp;itable.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ip-&gt;ref--;</span><br><span class="line">release(&amp;itable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果 <strong>iput</strong> 发现没有指针指向该 inode，并且没有任何目录项链接该 inode（不在任何目录中出现），那么该 inode 和它的数据块必须被释放。<strong>Iput</strong> 调用 <strong>itrunc</strong> 将文件截断为零字节，释放数据块；将 inode 类型设置为 0（未分配）；并将 inode 写入磁盘（kernel&#x2F;fs.c:338）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents). 截断inode（丢弃内容）</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">uint *a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">   bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">   ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line"> bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line"> a = (uint*)bp-&gt;data;</span><br><span class="line"> <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(a[j])</span><br><span class="line">     bfree(ip-&gt;dev, a[j]);</span><br><span class="line"> &#125;</span><br><span class="line"> brelse(bp);</span><br><span class="line"> bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line"> ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">iupdate(ip);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free a disk block. 释放一个磁盘块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"><span class="type">int</span> bi, m;</span><br><span class="line"></span><br><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">bi = b % BPB;	</span><br><span class="line">m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line"> panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">log_write(bp);</span><br><span class="line">brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>iput</strong> 在释放 inode 的锁定协议是值得我们仔细研究</p>
<ul>
<li><p>一个危险是，一个并发线程可能会在 <strong>ilock</strong> 中等待使用这个 inode (例如，读取一个文件或列出一个目录)，但它没有意识到该 inode 可能被释放掉了。这种情况是不会发生，因为该 inode 的没有被目录项链接且 <strong>ip-&gt;ref</strong> 为 1，那么系统调用是没有这个指针的（如果有，<strong>ip-&gt;ref</strong> 应该为 2）。这一个引用是调用 iput 的线程所拥有的。的确，<strong>iput</strong> 会在其 <strong>icache.lock</strong> 锁定的临界区之外检查引用数是否为 1，但此时已知链接数为 0，所以没有线程会尝试获取新的引用</p>
</li>
<li><p>另一个主要的危险是，并发调用 <strong>ialloc</strong> 可能会使 <strong>iput</strong> 返回一个正在被释放的 inode。这种情况发生在 <strong>iupdate</strong> 写磁盘时 <strong>ip-&gt;type&#x3D;0</strong>。这种竞争是正常的，分配 inode 的线程会等待获取 inode 的睡眠锁，然后再读取或写入 inode，但此时 <strong>iput</strong> 就结束了（意思是：ialloc 可能返回一个正在释放磁盘块的 inode，但如果想要读写该 inode，就需要调用 ilock 获取 sleep-lock，但 ilock 此时正在被 iput 获取，ilock 获得锁后 iput 就结束了）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a modified in-memory inode to disk. 将修改后的内存中的inode复制到磁盘上</span></span><br><span class="line"><span class="comment">// Must be called after every change to an ip-&gt;xxx field </span></span><br><span class="line"><span class="comment">// 在对存储在磁盘上的ip-&gt;xxx字段进行任何更改后，必须调用此函数</span></span><br><span class="line"><span class="comment">// that lives on disk. </span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iupdate</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">dip-&gt;type = ip-&gt;type;</span><br><span class="line">dip-&gt;major = ip-&gt;major;</span><br><span class="line">dip-&gt;minor = ip-&gt;minor;</span><br><span class="line">dip-&gt;nlink = ip-&gt;nlink;</span><br><span class="line">dip-&gt;size = ip-&gt;size;</span><br><span class="line">memmove(dip-&gt;addrs, ip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">log_write(bp);</span><br><span class="line">brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p><strong>iput()</strong> 会写磁盘。这意味着任何使用文件系统的系统调用都会写磁盘，因为系统调用可能是最后一个对文件有引用的调用。甚至像 read() 这样看似只读的调用，最终也可能会调用 iput()。这又意味着，即使是只读的系统调用，如果使用了文件系统，也必须用事务来包装</p>
</li>
<li><p>崩溃发生在 <strong>iput()</strong> 中是相当棘手的。当文件的链接数降到零时，<strong>iput()</strong> 不会立即截断一个文件，因为一些进程可能仍然在内存中持有对 inode 的引用：一个进程可能仍然在对文件进行读写，因为它成功地打开了 inode。但是，如果崩溃发生在该文件的最后一个文件描述符释放时，那么该文件将被标记为已在磁盘上分配，但没有目录项指向它</p>
</li>
<li><p>文件系统处理这种情况的方法有两种。简单的解决方法是，是在重启后的恢复时，文件系统会扫描整个文件系统，寻找那些被标记为已分配的文件，但没有指向它们的目录项。如果有这样的文件存在，那么就可以释放这些文件</p>
</li>
<li><p>第二种解决方案不需要扫描文件系统。在这个解决方案中，文件系统在磁盘上（例如，在 <strong>superblock</strong> 中）记录链接数为 0 但引用数不为 0 的文件的 inode 的 inumber。如果文件系统在其引用计数达到 0 时删除该文件 。当文件的引用数为 0 时，文件系统会删除该文件，同时它更新磁盘上的列表，从列表（记录链接数为 0 但引用数不为 0 的 inode）中删除该 inode。恢复时，文件系统会释放列表中的任何文件</p>
</li>
<li><p>xv6 没有实现这两种解决方案，这意味着 inode 可能会在磁盘上被标记分配，即使它们不再使用。这意味着随着时间的推移，xv6 可能会面临磁盘空间耗尽的风险</p>
</li>
</ul>
<h2 id="Code-Inode-content"><a href="#Code-Inode-content" class="headerlink" title="Code: Inode content"></a>Code: Inode content</h2> <img src="/2024/07/09/xv6-book-chapter-8/Figure-8.3-17206131871326.png" class="" title="Figure-8.3">

<ul>
<li><p>磁盘上的 <strong>inode</strong>，即 <strong>dinode</strong> 结构体，包含一个 size 和一个块号数组（见图 8.3）</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line"><span class="type">short</span> type;           <span class="comment">// File type 文件类型</span></span><br><span class="line"><span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only) 主设备号（仅对T_DEVICE类型有效）</span></span><br><span class="line"><span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only) 次设备号（仅对T_DEVICE类型有效）</span></span><br><span class="line"><span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system 在文件系统中链接到此inode的链接数</span></span><br><span class="line">uint size;            <span class="comment">// Size of file (bytes) 文件大小（字节）</span></span><br><span class="line">uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses 数据块地址数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>inode</strong> 数据可以在 <strong>dinode</strong> 的 <strong>addrs</strong> 数组中找到。开始的 <strong>NDIRECT</strong> 个数据块列在数组中的前 <strong>NDIRECT</strong> 个条目中，这些块被称为 <strong>直接块</strong>。接下来的 <strong>NINDIRECT</strong> 个数据块并没有列在 <strong>inode</strong> 中，而是列在叫做 <strong>间接块</strong> 的数据块中。<strong>addrs</strong> 数组中的最后一个条目给出了放置间接块的地址。因此，一个文件的前 <strong>12</strong> <strong>kB</strong> ( <strong>NDIRECT x BSIZE</strong>) 字节可以从 <strong>inode</strong> 中列出的块中加载，而接下来的 <strong>256</strong> <strong>kB</strong> ( <strong>NINDIRECT x BSIZE</strong>) 字节只能在查阅间接块后才能取出。对于磁盘这是一种不错的表示方式，但对客户机就有点复杂了</li>
<li>函数 <strong>bmap</strong> 包装了这种表示方式使得高层次的函数，如 <strong>readi</strong> 和 <strong>writei</strong> 可以更好的使用。<strong>Bmap</strong> 返回 inode <strong>ip</strong> 的第 <strong>bn</strong> 个数据块的磁盘块号。如果 <strong>ip</strong> 没有第 <strong>bn</strong> 个的数据块，<strong>bmap</strong> 就会分配一个</li>
</ul>
</li>
<li><p>函数 <strong>bmap</strong> (kernel&#x2F;fs.c:378) 从简单的情况开始：最前面的 <strong>NDIRECT</strong> 个块储存在 inode (kernel&#x2F;fs.c:383-387) 中，接下来的 <strong>NINDIRECT</strong> 个块放置在 <strong>ip-&gt;addrs[NDIRECT]</strong> 指向的的 <strong>间接块</strong> 中。<strong>bmap</strong> 读取间接块 (kernel&#x2F;fs.c:394)，然后从块内的正确的位置读取一个块号 (kernel&#x2F;fs.c:395)。如果块号超过了 <strong>NDIRECT+NINDIRECT</strong>，<strong>bmap</strong> 就会 <strong>panic</strong>；<strong>writei</strong> 会检查并防止这种情况(kernel&#x2F;fs.c:490)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip. 返回inode ip中第n个块的磁盘块地址</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.  如果不存在这样的块，则bmap分配一个新的块</span></span><br><span class="line"><span class="comment">// returns 0 if out of disk space. 如果磁盘空间不足，则返回0</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">uint addr, *a;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line"> <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">   addr = balloc(ip-&gt;dev);</span><br><span class="line">   <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   ip-&gt;addrs[bn] = addr;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line">bn -= NDIRECT;  <span class="comment">// 说明是间接块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line"> <span class="comment">// Load indirect block, allocating if necessary. 加载间接块，如果必要则进行分配</span></span><br><span class="line"> <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)&#123;</span><br><span class="line">   addr = balloc(ip-&gt;dev);</span><br><span class="line">   <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   ip-&gt;addrs[NDIRECT] = addr;</span><br><span class="line"> &#125;</span><br><span class="line"> bp = bread(ip-&gt;dev, addr);</span><br><span class="line"> a = (uint*)bp-&gt;data;</span><br><span class="line"> <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">   addr = balloc(ip-&gt;dev);</span><br><span class="line">   <span class="keyword">if</span>(addr)&#123;</span><br><span class="line">     a[bn] = addr;</span><br><span class="line">     log_write(bp);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> brelse(bp);</span><br><span class="line"> <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>bmap</strong> 根据需要分配块。<strong>ip-&gt;addrs[bn]</strong> 或间接条目为 0 时表示没有块。当 <strong>bmap</strong> 遇到 0 时，它会用新的块号来代替 0 (kernel&#x2F;fs.c:384-385) (kernel&#x2F;fs.c:392-393)</p>
</li>
<li><p><strong>itrunc</strong> 释放文件的块，将 inode 的大小重置为零。<strong>Itrunc</strong> (kernel&#x2F;fs.c:410) 首先释放 <strong>直接块</strong> (kernel&#x2F;fs.c:416-421)，然后释放 <strong>间接块</strong> 中指向的块 (kernel&#x2F;fs.c:426- 429)，最后释放 <strong>间接块</strong> 本身 (kernel&#x2F;fs.c:431-432)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents). 截断inode（丢弃内容）</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">uint *a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">   bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">   ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line"> bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line"> a = (uint*)bp-&gt;data;</span><br><span class="line"> <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(a[j])</span><br><span class="line">     bfree(ip-&gt;dev, a[j]);</span><br><span class="line"> &#125;</span><br><span class="line"> brelse(bp);</span><br><span class="line"> bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line"> ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>bmap 使得 readi 和 writei 可以很容易地获取一个 inode 的数据。Readi (kernel&#x2F;fs.c:456) 首先要确定偏移量和计数没有超过文件末端。从文件超出末尾开始的读会返回一个错误 (kernel&#x2F;fs.c:461-462)，而从文件末尾开始或读取过程中超出末尾的读会不会返回错误，只是返回的字节数会少于请求的字节数 (kernel&#x2F;fs.c:463-464)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read data from inode. 从inode读取数据</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="comment">// If user_dst==1, then dst is a user virtual address; 如果user_dst==1，则dst是一个用户虚拟地址</span></span><br><span class="line"><span class="comment">// otherwise, dst is a kernel address. 否则，dst是一个内核地址</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">readi</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">uint tot, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(off + n &gt; ip-&gt;size)</span><br><span class="line"> n = ip-&gt;size - off;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;</span><br><span class="line"> uint addr = bmap(ip, off/BSIZE); <span class="comment">// off/BSIZE表示第几个块</span></span><br><span class="line"> <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> bp = bread(ip-&gt;dev, addr);</span><br><span class="line"> <span class="comment">// 所以可以知道readi是从文件off偏移开始读取n个字节</span></span><br><span class="line"> m = min(n - tot, BSIZE - off%BSIZE);  <span class="comment">// 如果读取字节数大于一个块，则经过一轮循环后off是块大小的整数倍</span></span><br><span class="line"> <span class="keyword">if</span>(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="number">-1</span>) &#123; <span class="comment">//将磁盘块中的内容读到dst</span></span><br><span class="line">   brelse(bp);</span><br><span class="line">   tot = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> brelse(bp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>主循环会把文件中的每一个块的数据复制到 <strong>dst</strong> 中 (kernel&#x2F;fs.c:466-474)。<strong>writei</strong> (kernel&#x2F;fs.c:483) 与 <strong>readi</strong> 相同，但有三个不同：（1）、从文件末尾开始或越过文件末尾的写入会使文件增长，但不会超过文件的最大长度 (kernel&#x2F;fs.c:490-491)；（2）、循环将数据复制到缓冲区而不是 <strong>out</strong> (kernel&#x2F;fs.c:36)；（3）、如果写使文件增长了，<strong>writi</strong> 必须更新它的大小 (kernel&#x2F;fs.c:504-511)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write data to inode. 向inode写入数据</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="comment">// If user_src==1, then src is a user virtual address; 如果user_src==1，则src是一个用户虚拟地址</span></span><br><span class="line"><span class="comment">// otherwise, src is a kernel address. 否则，src是一个内核地址</span></span><br><span class="line"><span class="comment">// Returns the number of bytes successfully written. 返回成功写入的字节数</span></span><br><span class="line"><span class="comment">// If the return value is less than the requested n, 如果返回值小于请求写入的n个字节</span></span><br><span class="line"><span class="comment">// there was an error of some kind. 则表明发生了某种错误</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">writei</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_src, uint64 src, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">uint tot, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(off + n &gt; MAXFILE*BSIZE)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;</span><br><span class="line"> uint addr = bmap(ip, off/BSIZE);</span><br><span class="line"> <span class="keyword">if</span>(addr == <span class="number">0</span>)	<span class="comment">// 所以在off符合条件的情况下，发送错误的原因为磁盘空间不足</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> bp = bread(ip-&gt;dev, addr);</span><br><span class="line"> m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line"> <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">   brelse(bp);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> log_write(bp);</span><br><span class="line"> brelse(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(off &gt; ip-&gt;size)</span><br><span class="line"> ip-&gt;size = off;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write the i-node back to disk even if the size didn&#x27;t change </span></span><br><span class="line"><span class="comment">// 即使文件大小没有改变，也将i-node（索引节点）写回磁盘</span></span><br><span class="line"><span class="comment">// because the loop above might have called bmap() and added a new </span></span><br><span class="line"><span class="comment">// 因为上面的循环可能已经调用了bmap()并向ip-&gt;addrs[]中添加了一个新的块</span></span><br><span class="line"><span class="comment">// block to ip-&gt;addrs[].</span></span><br><span class="line">iupdate(ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>readi</strong> 和 <strong>writei</strong> 开始都会检查 <strong>ip-&gt;type &#x3D;&#x3D; T_DEV</strong>。这种情况处理的是数据不在文件系统中的特殊设备；我们将在文件描述符层中再讨论这种情况</p>
</li>
<li><p>函数 <strong>stati</strong> (kernel&#x2F;fs.c:442) 将 inode 元数据复制到 <strong>stat</strong> 结构体中，通过 <strong>stat</strong> 系统调用暴露给用户程序</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"><span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">uint ino;    <span class="comment">// Inode number</span></span><br><span class="line"><span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line"><span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy stat information from inode. 从inode复制状态信息</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock. 调用者必须持有ip-&gt;lock锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">stati</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="keyword">struct</span> stat *st)</span></span><br><span class="line">&#123;</span><br><span class="line">st-&gt;dev = ip-&gt;dev;</span><br><span class="line">st-&gt;ino = ip-&gt;inum;</span><br><span class="line">st-&gt;type = ip-&gt;type;</span><br><span class="line">st-&gt;nlink = ip-&gt;nlink;</span><br><span class="line">st-&gt;size = ip-&gt;size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Code-directory-layer"><a href="#Code-directory-layer" class="headerlink" title="Code: directory layer"></a>Code: directory layer</h2><ul>
<li><p>目录的实现机制和文件很类似。它的 <strong>inode</strong> 类型是 <strong>T_DIR</strong>，它的数据是一个目录项的序列。每个条目是一个结构体 <strong>dirent</strong> (kernel&#x2F;fs.h:56)，它包含一个名称和一个 inode 号。名称最多包含 <strong>DIRSIZ</strong> (14) 个字符，较短的名称以 <strong>NULL</strong> (0) 结束。inode 号为 0 的目录项是空闲的</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="comment">// 目录是一个文件,它包含一系列的dirent结构体（确实很特殊，是inode，a含的一系列dirent在addr指向的块中）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">ushort inum;</span><br><span class="line"><span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>函数 <strong>dirlookup</strong> (kernel&#x2F;fs.c:527) 在一个目录中搜索一个带有给定名称的条目</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">namecmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *t)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strncmp</span>(s, t, DIRSIZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look for a directory entry in a directory.  在目录中查找一个目录项</span></span><br><span class="line"><span class="comment">// If found, set *poff to byte offset of entry.  如果找到，将目录项的字节偏移量设置到*poff中</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">dirlookup</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint *poff)</span></span><br><span class="line">&#123;</span><br><span class="line">uint off, inum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dp-&gt;type != T_DIR)</span><br><span class="line"> panic(<span class="string">&quot;dirlookup not DIR&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line"> <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">   panic(<span class="string">&quot;dirlookup read&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line"> <span class="keyword">if</span>(namecmp(name, de.name) == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="comment">// entry matches path element 条目与路径元素匹配</span></span><br><span class="line">   <span class="keyword">if</span>(poff)</span><br><span class="line">     *poff = off;</span><br><span class="line">   inum = de.inum;</span><br><span class="line">   <span class="keyword">return</span> iget(dp-&gt;dev, inum);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>如果找到了，它返回一个指向相应未上锁的 inode 的指针，并将 <strong>poff</strong> 设置为目录中条目的字节偏移量，以便调用者想要编辑它</li>
<li>如果 dirlookup 找到一个对应名称的条目，则更新 *poff，并返回一个通过 iget 获得的未被锁定的 inode。Dirlookup 是 iget 返回未锁定的 inode 的原因</li>
<li>调用者已经锁定了 dp，所以如果查找的是 <strong>“.”</strong> ，当前目录的别名，在返回之前试图锁定 inode，就会试图重新锁定 dp 而死锁。(还有更复杂的死锁情况，涉及到多个进程和 <strong>“..”</strong>，父目录的别名；<strong>“.”</strong> 不是唯一的问题。) 调用者可以先解锁 dp，然后再锁定 ip，保证一次只持有一个锁</li>
</ul>
</li>
<li><p>函数 <strong>dirlink</strong> (kernel&#x2F;fs.c:554) 会在当前目录 dp 中创建一个新的目录项，通过给定的名称和 inode 号</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write a new directory entry (name, inum) into the directory dp. </span></span><br><span class="line"><span class="comment">// 在目录 dp 中写入一个新的目录项（名称，inum）</span></span><br><span class="line"><span class="comment">// Returns 0 on success, -1 on failure (e.g. out of disk blocks).</span></span><br><span class="line"><span class="comment">// 成功时返回0,失败时返回-1 (例如,磁盘块不足)</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dirlink</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> off;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that name is not present. 检查名称是否不存在</span></span><br><span class="line"><span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123; <span class="comment">// 返回非0表示名称存在</span></span><br><span class="line"> iput(ip);	<span class="comment">// 减少ip引用</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look for an empty dirent. 寻找一个空的条目项</span></span><br><span class="line"><span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line"> <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">   panic(<span class="string">&quot;dirlink read&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">de.inum = inum;</span><br><span class="line"><span class="comment">// 如果一直都没有找到dirent，此时off==dp-&gt;size(也就是dp末尾)，那么writei会在末尾创建一个新的dirent</span></span><br><span class="line"><span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de)) </span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>如果名称已经存在，dirlink 将返回一个错误 (kernel&#x2F;fs.c:560- 564)</li>
<li>主循环读取目录项，寻找一个未使用的条目。当它找到一个时，它会提前跳出循环  (kernel&#x2F;fs.c:538-539)，并将 <strong>off</strong> 设置为该可用条目的偏移量。否则，循环结束时，将 <strong>off</strong> 设置为 <strong>dp-&gt;size</strong>。不管是哪种方式，<strong>dirlink</strong> 都会在偏移量 <strong>off</strong> 的位置添加一个新的条目到目录中 (kernel&#x2F;fs.c:574-577)</li>
</ul>
</li>
</ul>
<h2 id="Code-Path-names"><a href="#Code-Path-names" class="headerlink" title="Code: Path names"></a>Code: Path names</h2><ul>
<li><p>查找路径名会对每一个节点调用一次 <strong>dirlookup</strong>。Namei (kernel&#x2F;fs.c:661) 解析路径并返回相应的 inode。函数 <strong>nameiparent</strong> 是 <strong>namei</strong> 的一个变种：它返回相应 inode 的父目录 inode，并将最后一个元素复制到 <strong>name</strong> 中。这两个函数都通过调用 <strong>namex</strong> 来实现</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> name[DIRSIZ];</span><br><span class="line"><span class="keyword">return</span> namex(path, <span class="number">0</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> namex(path, <span class="number">1</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Namex</strong> (kernel&#x2F;fs.c:626) 首先确定路径解析从哪里开始。如果路径以斜线开头，则从根目录开始解析；否则，从当前目录开始解析 (kernel&#x2F;fs.c:630-633)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ROOTINO  1   <span class="comment">// root i-number</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOTDEV 1    <span class="comment">// device number of file system root disk</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look up and return the inode for a path name. 根据路径名查找并返回对应的inode（索引节点）</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final </span></span><br><span class="line"><span class="comment">// 如果parent参数不为0，则返回该路径的父目录的inode，并将路径中的最后一个元素复制到name中</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes. </span></span><br><span class="line"><span class="comment">// 其中name必须有足够的空间来存储DIRSIZ个字节的数据</span></span><br><span class="line"><span class="comment">// Must be called inside a transaction since it calls iput(). </span></span><br><span class="line"><span class="comment">// 因为该函数调用了iput()（释放inode或进行其他与inode相关的清理操作），所以它必须在事务（transaction）的上下文中被调用</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"> ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123; <span class="comment">// 这里应该name已经为path中当前父目录inode需要查找的name了</span></span><br><span class="line"> ilock(ip);</span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">   iunlockput(ip);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">   <span class="comment">// Stop one level early.</span></span><br><span class="line">   iunlock(ip);</span><br><span class="line">   <span class="keyword">return</span> ip;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">   iunlockput(ip);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> iunlockput(ip);</span><br><span class="line"> ip = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nameiparent)&#123; <span class="comment">// 能走到这里说明没有进行一轮循环</span></span><br><span class="line"> iput(ip);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>然后它使用 <strong>skipelem</strong> 来遍历路径中的每个元素 (kernel&#x2F;fs.c:635)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy the next path element from path into name. 从path中复制下一个路径元素到name中</span></span><br><span class="line"><span class="comment">// Return a pointer to the element following the copied one. 返回指向已复制元素之后的元素的指针</span></span><br><span class="line"><span class="comment">// The returned path has no leading slashes, 返回的路径没有前导斜杠</span></span><br><span class="line"><span class="comment">// so the caller can check *path==&#x27;\0&#x27; to see if the name is the last one. </span></span><br><span class="line"><span class="comment">// 因此调用者可以检查*path==&#x27;\0&#x27;来查看name是否是最后一个</span></span><br><span class="line"><span class="comment">// If no name to remove, return 0. 如果没有要移除的名称，则返回0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a/bb/c&quot;, name) = &quot;bb/c&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;///a//bb&quot;, name) = &quot;bb&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a&quot;, name) = &quot;&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;&quot;, name) = skipelem(&quot;////&quot;, name) = 0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>*</span><br><span class="line"><span class="title function_">skipelem</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *s;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"> path++;</span><br><span class="line"><span class="keyword">if</span>(*path == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">s = path;</span><br><span class="line"><span class="keyword">while</span>(*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="number">0</span>) <span class="comment">// 直到path=&#x27;/0&#x27;或path==&#x27;/&#x27;</span></span><br><span class="line"> path++;</span><br><span class="line">len = path - s;</span><br><span class="line"><span class="keyword">if</span>(len &gt;= DIRSIZ)</span><br><span class="line"> memmove(name, s, DIRSIZ);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"> memmove(name, s, len);</span><br><span class="line"> name[len] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"> path++;</span><br><span class="line"><span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>循环的每次迭代都必须在当前 inode <strong>ip</strong> 中查找 <strong>name</strong></p>
</li>
<li><p>迭代的开始是锁定 <strong>ip</strong> 并检查它是否是一个目录。如果不是，查找就会失败 (kernel&#x2F;fs.c:636-640)。(锁定 <strong>ip</strong> 是必要的，不是因为 <strong>ip-&gt;type</strong> 可能会改变，而是因为在 <strong>ilock</strong> 运行之前，不能保证 ip-&gt;type 已经从磁盘载入)</p>
</li>
<li><p>如果调用的是 <strong>nameiparent</strong>，而且这是最后一个路径元素，按照之前 <strong>nameiparent</strong> 的定义，循环应该提前停止，最后一个路径元素已经被复制到 name 中，所以 <strong>namex</strong> 只需要返回解锁的 ip (kernel&#x2F;fs.c:641-645)</p>
</li>
<li><p>最后，循环使用 <strong>dirlookup</strong> 查找路径元素，并通过设置 <strong>ip</strong> &#x3D; <strong>next</strong> 为下一次迭代做准备 (kernel&#x2F;fs.c:646-651)</p>
</li>
<li><p>当循环遍历完路径元素时，它返回 <strong>ip</strong></p>
</li>
</ul>
</li>
<li><p><strong>namex</strong> 可能需要很长的时间来完成：它可能会涉及几个磁盘操作，通过遍历路径名得到的目录的 inode 和目录块（如果它们不在 buffer 缓存中）。xv6 经过精心设计，如果一个内核线程对 <strong>namex</strong> 的调用阻塞在磁盘 I&#x2F;O 上，另一个内核线程查找不同的路径名可以同时进行。<strong>namex</strong> 分别锁定路径中的每个目录，这样不同目录的查找就可以并行进行</p>
</li>
<li><p>这种并发性带来了一些挑战。例如，当一个内核线程在查找一个路径名时，另一个内核线程可能正在取消链接一个目录，这会改变目录数。一个潜在的风险是，可能一个查找线程正在搜索的目录可能已经被另一个内核线程删除了，而它的块已经被另一个目录或文件重用了</p>
</li>
<li><p>xv6 避免了这种竞争。例如，在 <strong>namex</strong> 中执行 <strong>dirlookup</strong> 时，查找线程会持有目录的锁，<strong>dirlookup</strong> 返回一个使用 <strong>iget</strong> 获得的 inode。<strong>iget</strong> 会增加 inode 的引用次数。只有从 <strong>dirlookup</strong> 收到 inode 后，<strong>namex</strong> 才会释放目录上的锁。现在另一个线程可能会从目录中取消链接 inode，但 xv6 还不会删除 inode，因为 inode 的引用数仍然大于零</p>
</li>
<li><p>另一个风险是死锁。例如，当查找 <strong>“. “</strong> 时，next 指向的 inode 与 <strong>ip</strong> 相同。在释放对 <strong>ip</strong> 的锁之前锁定 next 会导致死锁。为了避免这种死锁，<strong>namex</strong> 在获得对 next 的锁之前就会解锁目录。这里我们再次看到为什么 <strong>iget</strong> 和 <strong>ilock</strong> 之间的分离是很重要的（如果 iget 直接返回加锁的 inode 的话，我们根本没有机会释放锁，在获得锁，可能造成死锁）</p>
</li>
</ul>
<h2 id="File-descriptor-layer"><a href="#File-descriptor-layer" class="headerlink" title="File descriptor layer"></a>File descriptor layer</h2><ul>
<li><p>Unix 接口很酷的一点是：Unix 中的大部分资源都是以文件的形式来表示的。包括控制台、管道等设备，当然还有真实的文件。文件描述符层就是实现这种统一性的一层</p>
</li>
<li><p>xv6 给每个进程提供了自己的打开文件表，或者说文件描述符表，就像我们在第一章中看到的那样。每个打开的文件由一个结构体 <strong>file</strong> (kernel&#x2F;file.h:1) 表示，它包装 inode 或管道，也包含一个 I&#x2F;O 偏移量</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line"><span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line"><span class="type">char</span> readable;</span><br><span class="line"><span class="type">char</span> writable;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line"><span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>每次调用 <strong>open</strong> 都会创建一个新的打开文件（一个新的结构体 file），如果多个进程独立打开同一个文件，那么不同的 <strong>file</strong> 实例会有不同的 I&#x2F;O 偏移量</li>
<li>另一方面，一个打开的文件（同一个结构文件）可以在一个进程的文件表中出现多次，也可以在多个进程的文件表中出现。如果一个进程使用 <strong>open</strong> 打开文件，然后使用 <strong>dup</strong> 创建别名，或者使用 <strong>fork</strong> 与子进程共享文件，就会出现这种情况</li>
<li>引用计数可以跟踪特定打开文件的引用数量</li>
<li>一个文件的打开方式可以为读，写，或者读写。通过 <strong>readable</strong> 和 <strong>writable</strong> 来指明</li>
</ul>
</li>
<li><p>系统中所有打开的文件都保存在一个全局文件表中，即 <strong>ftable</strong>。文件表的功能有: 分配文件 (<strong>filealloc</strong>)、创建重复引用 (<strong>fileup</strong>)、释放引用 (<strong>fileclose</strong>)、读写数据 (<strong>fileeread</strong> 和 <strong>filewrite</strong>)</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>前三个函数应该比较熟悉了，就不过多的讨论</p>
<ul>
<li><p><strong>Filealloc</strong> (kernel&#x2F;file.c:30) 扫描文件表，寻找一个未引用的文件 (f-&gt;ref &#x3D;&#x3D; 0)，并返回一个新的引用</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filealloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;ftable.lock);</span><br><span class="line"><span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">   f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">   release(&amp;ftable.lock);</span><br><span class="line">   <span class="keyword">return</span> f;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">release(&amp;ftable.lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>fileup</strong> (kernel&#x2F;file.c:48) 增加引用计数</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increment ref count for file f.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filedup</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;ftable.lock);</span><br><span class="line"><span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line"> panic(<span class="string">&quot;filedup&quot;</span>);</span><br><span class="line">f-&gt;ref++;</span><br><span class="line">release(&amp;ftable.lock);</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>fileclose</strong> (kernel&#x2F;file.c:60) 减少引用计数。当一个文件的引用数达到 0 时，<strong>fileclose</strong> 会根据类型释放底层的管道或 inode</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.) </span></span><br><span class="line"><span class="comment">// 关闭文件f（减少引用计数，当计数达到0时关闭文件）</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;ftable.lock);</span><br><span class="line"><span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line"> panic(<span class="string">&quot;fileclose&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> release(&amp;ftable.lock);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ff = *f;</span><br><span class="line">f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">f-&gt;type = FD_NONE;</span><br><span class="line">release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line"> pipeclose(ff.pipe, ff.writable);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line"> begin_op();</span><br><span class="line"> iput(ff.ip);</span><br><span class="line"> end_op();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>函数 <strong>filestat</strong>、<strong>fileread</strong> 和 <strong>filewrite</strong> 实现了对文件的统计、读和写操作</p>
<ul>
<li><p>filestat (kernel&#x2F;file.c:88) 只允许对 inodes 进行操作，并调用 <strong>stati</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.  获取文件f的元数据</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat. </span></span><br><span class="line"><span class="comment">// addr是一个用户虚拟地址，指向一个stat结构体</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line"> ilock(f-&gt;ip);</span><br><span class="line"> stati(f-&gt;ip, &amp;st);</span><br><span class="line"> iunlock(f-&gt;ip);</span><br><span class="line"> <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>fileread</strong> 和 <strong>filewrite</strong> 首先检查打开模式是否允许该操作，然后再调用管道或 inode 的相关实现。如果文件代表一个 inode，<strong>fileread</strong> 和 <strong>filewrite</strong> 使用 I&#x2F;O 偏移量作为本次操作的偏移量，然后前移偏移量（kernel&#x2F;file.c:122- 123）（kernel&#x2F;file.c:153-154）。pipes 没有偏移量的概念</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map major device number to device functions. 将主设备号映射到设备功能</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> &#123;</span></span><br><span class="line"><span class="type">int</span> (*read)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*write)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> <span class="title">devsw</span>[<span class="title">NDEV</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read from file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line"> r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line"> <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line"> ilock(f-&gt;ip);</span><br><span class="line"> <span class="keyword">if</span>((r = readi(f-&gt;ip, <span class="number">1</span>, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">   f-&gt;off += r;</span><br><span class="line"> iunlock(f-&gt;ip);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> panic(<span class="string">&quot;fileread&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write to file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line"> ret = pipewrite(f-&gt;pipe, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line"> <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> ret = devsw[f-&gt;major].write(<span class="number">1</span>, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line"> <span class="comment">// write a few blocks at a time to avoid exceeding </span></span><br><span class="line"> <span class="comment">// 一次写入几个块以避免超过日志事务的最大大小，这包括i节点、间接块、分配块,以及对于非对齐写入的2个额外块</span></span><br><span class="line"> <span class="comment">// the maximum log transaction size, including</span></span><br><span class="line"> <span class="comment">// i-node, indirect block, allocation blocks,</span></span><br><span class="line"> <span class="comment">// and 2 blocks of slop for non-aligned writes.</span></span><br><span class="line"> <span class="comment">// this really belongs lower down, since writei() </span></span><br><span class="line"> <span class="comment">// 这实际上应该放在更低层，因为writei()可能正在写入像控制台这样的设备</span></span><br><span class="line"> <span class="comment">// might be writing a device like the console.</span></span><br><span class="line"> <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">   <span class="type">int</span> n1 = n - i;</span><br><span class="line">   <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">     n1 = max;</span><br><span class="line"></span><br><span class="line">   begin_op();</span><br><span class="line">   ilock(f-&gt;ip);</span><br><span class="line">   <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">     f-&gt;off += r;</span><br><span class="line">   iunlock(f-&gt;ip);</span><br><span class="line">   end_op();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(r != n1)&#123;</span><br><span class="line">     <span class="comment">// error from writei</span></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   i += r;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> panic(<span class="string">&quot;filewrite&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>回想一下 inode 的函数需要调用者处理锁的相关操作（kernel&#x2F;file.c:94-96）（kernel&#x2F;file.c:121-124）（kernel&#x2F;file.c:163-166）。inode 加锁附带了一个不错的作用，那就是读写偏移量是原子式更新的，这样多个进程写一个文件时，自己写的数据就不会被其他进程所覆盖，尽管他们的写入可能最终会交错进行</p>
</li>
</ul>
</li>
</ul>
<h2 id="Code-System-calls"><a href="#Code-System-calls" class="headerlink" title="Code: System calls"></a>Code: System calls</h2><ul>
<li><p>有了更低层提供的函数，大多数系统调用的实现都是比较简单的（kernel&#x2F;sysfile.c）。有几个调用值得仔细研究一下</p>
</li>
<li><p>函数 <strong>sys_link</strong> 和 <strong>sys_unlink</strong> 可以编辑目录，创建或删除对 inodes 的引用。它们是使用事务的另一个很好的例子</p>
<ul>
<li><p><strong>sys_link</strong>  (kernel&#x2F;sysfile.c:120) 首先获取它的参数，两个字符串 <strong>old</strong> 和 <strong>new</strong> (kernel&#x2F;sysfile.c:125) 。假设 <strong>old</strong> 存在并且不是一个目录 (kernel&#x2F;sysfile.c:129-132)，<strong>sys_link</strong> 会递增它的 <strong>ip-&gt;nlink</strong> 计数。然后 <strong>sys_link</strong> 调用 <strong>nameiparent</strong> 找到 new (kernel&#x2F;sysfile.c:145) 的父目录和最终路径元素，并创建一个指向 <strong>old</strong> 的 inode 的新目录项 (kernel&#x2F;sysfile.c:148)。新的父目录必须存在，并且和现有的 inode 在同一个设备上，inode 号只在同一个磁盘上有意义。如果出现这样的错误，<strong>sys_link</strong> 必须返回并减少 <strong>ip-&gt;nlink</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the path new as a link to the same inode as old. 创建一个名为new的路径，该路径作为与old相同的inode的链接</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>, *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argstr(<span class="number">0</span>, old, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, new, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">begin_op();</span><br><span class="line"><span class="keyword">if</span>((ip = namei(old)) == <span class="number">0</span>)&#123;</span><br><span class="line"> end_op();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ilock(ip);</span><br><span class="line"><span class="keyword">if</span>(ip-&gt;type == T_DIR)&#123;</span><br><span class="line"> iunlockput(ip);</span><br><span class="line"> end_op();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ip-&gt;nlink++;</span><br><span class="line">iupdate(ip);</span><br><span class="line">iunlock(ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((dp = nameiparent(new, name)) == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">goto</span> bad;</span><br><span class="line">ilock(dp);</span><br><span class="line"><span class="keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> iunlockput(dp);</span><br><span class="line"> <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line">iunlockput(dp);</span><br><span class="line">iput(ip);</span><br><span class="line"></span><br><span class="line">end_op();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">ilock(ip);</span><br><span class="line">ip-&gt;nlink--;</span><br><span class="line">iupdate(ip);</span><br><span class="line">iunlockput(ip);</span><br><span class="line">end_op();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>事务简化了这个函数的实现，因为它需要更新多个磁盘块，但我们不必担心做这些事情的顺序。它们要么全部成功，要么都不成功。例如，如果没有事务，在创建链接之前更新 <strong>ip-&gt;nlink</strong>，会使文件系统暂时处于不安全的状态，中间的崩溃可能会造成破坏。有了事务，我们就不用担心这个问题了</p>
</li>
<li><p><strong>sys_link</strong> 为一个现有的 inode 创建一个新的名字。而函数 <strong>create</strong> (kernel&#x2F;sysfile.c:242) 为一个新的 inode 创建一个新的名字</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">create</span><span class="params">(<span class="type">char</span> *path, <span class="type">short</span> type, <span class="type">short</span> major, <span class="type">short</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">dp</span>;</span></span><br><span class="line"><span class="type">char</span> name[DIRSIZ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((dp = nameiparent(path, name)) == <span class="number">0</span>) <span class="comment">// 找父目录inode</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ilock(dp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123; <span class="comment">// 是否已经存在</span></span><br><span class="line"> iunlockput(dp);</span><br><span class="line"> ilock(ip);</span><br><span class="line"> <span class="keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE)) <span class="comment">// 是文件或设备</span></span><br><span class="line">   <span class="keyword">return</span> ip;</span><br><span class="line"> iunlockput(ip);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="number">0</span>)&#123; <span class="comment">// 不存在就创建新的inode</span></span><br><span class="line"> iunlockput(dp);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ilock(ip);</span><br><span class="line">ip-&gt;major = major;</span><br><span class="line">ip-&gt;minor = minor;</span><br><span class="line">ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">iupdate(ip);  <span class="comment">// 更新磁盘块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(type == T_DIR)&#123;  <span class="comment">// Create . and .. entries. 如果创建目录，在新的目录inode中创建. ..两个目录项</span></span><br><span class="line"> <span class="comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span></span><br><span class="line"> <span class="keyword">if</span>(dirlink(ip, <span class="string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="number">0</span> || dirlink(ip, <span class="string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>) <span class="comment">// 在父目录inode中创建name目录项</span></span><br><span class="line"> <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(type == T_DIR)&#123;</span><br><span class="line"> <span class="comment">// now that success is guaranteed:</span></span><br><span class="line"> dp-&gt;nlink++;  <span class="comment">// for &quot;..&quot;</span></span><br><span class="line"> iupdate(dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iunlockput(dp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ip;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line"><span class="comment">// something went wrong. de-allocate ip.</span></span><br><span class="line">ip-&gt;nlink = <span class="number">0</span>;</span><br><span class="line">iupdate(ip);</span><br><span class="line">iunlockput(ip);</span><br><span class="line">iunlockput(dp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>它是三个文件创建相关的系统调用的综合：使用 O_CREATE 标志的 open 创建一个新的普通文件，<strong>mkdir</strong> 创建一个新的目录，以及 mkdev 创建一个新的设备文件</li>
<li>和 <strong>sys_link</strong> 一样，<strong>create</strong> 也是通过调用 <strong>nameiparent</strong> 来获取父目录的 inode。然后调用  <strong>dirlookup</strong> 来检查名称是否已经存在 (kernel&#x2F;sysfile.c:252)</li>
<li>如果名称存在，create 的行为取决于它被用于哪个系统调用：<strong>open</strong>，<strong>mkdir</strong>，<strong>mkdev</strong> 的语义不同</li>
<li>如果 <strong>create</strong> 是由 <strong>open</strong> 使用的 (<strong>type &#x3D;&#x3D; T_FILE</strong>)，如果能根据该名字存在且为普通文件，那么打开就会成功，所以 <strong>create</strong> 也会成功 (kernel&#x2F;sysfile.c:256)。否则，就会报错（kernel&#x2F;sysfile.c:257-258）</li>
<li>如果这个名字不存在， <strong>create</strong> 就会用 <strong>ialloc</strong> 分配一个新的 inode (kernel&#x2F;sysfile.c:261)</li>
<li>如果新的 inode 是一个目录，<strong>create</strong> 会在该目录添加条目 “.” 和 “..”</li>
<li>最后，现在数据已经被正确地初始化了，<strong>create</strong> 可以把它链接到父目录中 (kernel&#x2F;sysfile.c:274)。和 <strong>sys_link</strong> 一样，create 同时拥有两个 inode 锁：<strong>ip</strong> 和 <strong>dp</strong>。没有死锁的可能性，因为 inode <strong>ip</strong> 是新分配的：系统中没有其他进程会持有 <strong>ip</strong> 的锁并尝试锁住dp</li>
</ul>
</li>
<li><p>使用 <strong>create</strong>，很容易实现 <strong>sys_open</strong>、<strong>sys_mkdir</strong> 和 <strong>sys_mknod</strong>。<strong>sys_open</strong> (kernel&#x2F;sysfile.c:287) 是其中最复杂的，因为创建一个新文件只是它做的一小部分</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file descriptor for the given file. 为给定的文件分配一个文件描述符</span></span><br><span class="line"><span class="comment">// Takes over file reference from caller on success. 如果成功，则从调用者处接管文件引用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fdalloc</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line">   p-&gt;ofile[fd] = f;</span><br><span class="line">   <span class="keyword">return</span> fd;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> path[MAXPATH];</span><br><span class="line"><span class="type">int</span> fd, omode;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">argint(<span class="number">1</span>, &amp;omode);  <span class="comment">// 取得位模式</span></span><br><span class="line"><span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span>) <span class="comment">// 路径名</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">begin_op();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(omode &amp; O_CREATE)&#123; <span class="comment">// O_CREATE打开就create</span></span><br><span class="line"> ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">   end_op();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123; <span class="comment">// 否则就去找有没有对应的inode</span></span><br><span class="line">   end_op();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ilock(ip); <span class="comment">// namei必须锁定inode</span></span><br><span class="line"> <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123; <span class="comment">// 打开的inode是目录的话，在能以只读打开</span></span><br><span class="line">   iunlockput(ip);</span><br><span class="line">   end_op();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123; <span class="comment">// 是设备的话</span></span><br><span class="line"> iunlockput(ip);</span><br><span class="line"> end_op();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123; <span class="comment">// 在文件表，描述符表中分配</span></span><br><span class="line"> <span class="keyword">if</span>(f)</span><br><span class="line">   fileclose(f);</span><br><span class="line"> iunlockput(ip);</span><br><span class="line"> end_op();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class="line"> f-&gt;type = FD_DEVICE;</span><br><span class="line"> f-&gt;major = ip-&gt;major;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> f-&gt;type = FD_INODE;</span><br><span class="line"> f-&gt;off = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">f-&gt;ip = ip;</span><br><span class="line">f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class="line">f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123; <span class="comment">// 清空文件对应磁盘块</span></span><br><span class="line"> itrunc(ip);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iunlock(ip);</span><br><span class="line">end_op();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>如果 <strong>open</strong> 的打开模式包含为 <strong>O_CREATE</strong>，它就会调用 <strong>create</strong> (kernel&#x2F;sysfile.c:301)。否则，它会调用 <strong>namei</strong> (kernel&#x2F;sysfile.c:307)</li>
<li><strong>create</strong> 会返回一个锁定的 inode，但 <strong>namei</strong> 不会，所以 <strong>sys_open</strong> 必须锁定 inode</li>
<li>这比较有一个方便的地方是目录只会以读打开，而不是写</li>
<li>假设 inode 是通过某种方式获得的，sys_open 会分配一个文件和一个文件描述符 (kernel&#x2F;sysfile.c:325)，然后设置 file 相关的字段 (kernel&#x2F;sysfile.c:337- 94 342)。注意，没有其他进程可以访问这个部分初始化的文件，因为它只在当前进程的表中</li>
</ul>
</li>
<li><p>第 7 章在我们还没有文件系统之前就研究了管道的实现。函数 <strong>sys_pipe</strong> 通过提供创建管道对的方法将管道实现与文件系统连接起来。它的参数是一个指针，该指针指向一个长度为 2 的 int 类型数组，它将在这里记录两个新的文件描述符。然后它分配管道并装入文件描述符</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 fdarray; <span class="comment">// user pointer to array of two integers 指向包含两个整数的数组的用户指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">rf</span>, *<span class="title">wf</span>;</span></span><br><span class="line"><span class="type">int</span> fd0, fd1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">argaddr(<span class="number">0</span>, &amp;fdarray);</span><br><span class="line"><span class="keyword">if</span>(pipealloc(&amp;rf, &amp;wf) &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">fd0 = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>((fd0 = fdalloc(rf)) &lt; <span class="number">0</span> || (fd1 = fdalloc(wf)) &lt; <span class="number">0</span>)&#123; <span class="comment">// 分配两个文件描述符</span></span><br><span class="line"> <span class="keyword">if</span>(fd0 &gt;= <span class="number">0</span>)</span><br><span class="line">   p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line"> fileclose(rf);</span><br><span class="line"> fileclose(wf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(copyout(p-&gt;pagetable, fdarray, (<span class="type">char</span>*)&amp;fd0, <span class="keyword">sizeof</span>(fd0)) &lt; <span class="number">0</span> ||</span><br><span class="line">  copyout(p-&gt;pagetable, fdarray+<span class="keyword">sizeof</span>(fd0), (<span class="type">char</span> *)&amp;fd1, <span class="keyword">sizeof</span>(fd1)) &lt; <span class="number">0</span>)&#123; </span><br><span class="line"> p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line"> p-&gt;ofile[fd1] = <span class="number">0</span>;</span><br><span class="line"> fileclose(rf);</span><br><span class="line"> fileclose(wf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="type">char</span> data[PIPESIZE];</span><br><span class="line">uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line"><span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line"><span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipealloc</span><span class="params">(<span class="keyword">struct</span> file **f0, <span class="keyword">struct</span> file **f1)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pi</span>;</span></span><br><span class="line"></span><br><span class="line">pi = <span class="number">0</span>;</span><br><span class="line">*f0 = *f1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((*f0 = filealloc()) == <span class="number">0</span> || (*f1 = filealloc()) == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span>((pi = (<span class="keyword">struct</span> pipe*)kalloc()) == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">goto</span> bad;</span><br><span class="line">pi-&gt;readopen = <span class="number">1</span>;</span><br><span class="line">pi-&gt;writeopen = <span class="number">1</span>;</span><br><span class="line">pi-&gt;nwrite = <span class="number">0</span>;</span><br><span class="line">pi-&gt;nread = <span class="number">0</span>;</span><br><span class="line">initlock(&amp;pi-&gt;lock, <span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">(*f0)-&gt;type = FD_PIPE;</span><br><span class="line">(*f0)-&gt;readable = <span class="number">1</span>;</span><br><span class="line">(*f0)-&gt;writable = <span class="number">0</span>;</span><br><span class="line">(*f0)-&gt;pipe = pi;</span><br><span class="line">(*f1)-&gt;type = FD_PIPE;</span><br><span class="line">(*f1)-&gt;readable = <span class="number">0</span>;</span><br><span class="line">(*f1)-&gt;writable = <span class="number">1</span>;</span><br><span class="line">(*f1)-&gt;pipe = pi;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line"><span class="keyword">if</span>(pi)</span><br><span class="line"> kfree((<span class="type">char</span>*)pi);</span><br><span class="line"><span class="keyword">if</span>(*f0)</span><br><span class="line"> fileclose(*f0);</span><br><span class="line"><span class="keyword">if</span>(*f1)</span><br><span class="line"> fileclose(*f1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><ul>
<li><p>实际操作系统中的 buffer 缓存要比 xv6 的复杂得多，但它有同样的两个目的：缓存和同步访问磁盘。xv6 的 buffer 缓存和 V6 是一样的，使用简单的最近最少使用（LRU）抛弃策略；可以实现许多更复杂的策略，每种策略都对某些情况有好处，而对其它情况没有好处。更高效的 LRU 缓存不使用链表，而使用哈希表进行查找，使用堆进行 LRU 抛弃。现代的 buffer 缓存通常与虚拟内存系统集成在一起，以支持内存映射的文件</p>
</li>
<li><p>xv6 的日志系统效率低下。提交不能与文件系统系统调用同时发生。系统会记录整个块，即使一个块中只有几个字节被改变。它执行同步的日志写入，一次写一个块，每一个块都可能需要整个磁盘旋转时间。真正的日志系统可以解决所有这些问题</p>
</li>
<li><p>日志不是提供崩溃恢复的唯一方法。早期的文件系统在重启期间使用 scavenger（例如 UNIX fsck 程序）来检查每个文件和目录以及块和 inode 空闲列表，寻找并解决不一致的地方。对于大型文件系统来说，清扫可能需要几个小时的时间，而且在某些情况下，这种方式要想获得的数据一致性，其系统调用必须是一致性的。从日志中恢复要快得多，而且在崩溃时，系统调用是原子的</p>
</li>
<li><p>xv6 使用了与早期 UNIX 相同的 inodes 和目录的基本磁盘布局；这个方案多年来仍在使用。BSD 的 UFS&#x2F;FFS 和 Linux 的 ext2&#x2F;ext3 使用基本相同的数据结构。文件系统布局中最低效的部分是目录，在每次查找过程中需要对所有磁盘块进行线性扫描。当目录只有几个磁盘块时，这是合理的，但对于有许多文件的目录来说是昂贵的。微软 Windows 的 NTFS，Mac OS X 的 HFS，以及 Solaris 的 ZFS，将目录实现为磁盘上块的平衡树。这很复杂，但可以保证目录查找的时间复杂度是对数级的</p>
</li>
<li><p>xv6 对磁盘故障的处理很朴素：如果磁盘操作失败，xv6 就会 <strong>panic</strong>。这是否合理取决于硬件：如果一个操作系统位于特殊的硬件之上，这种硬件会使用冗余来掩盖故障，也许操作系统看到故障的频率很低，以至于直接 <strong>panic</strong> 是可以的。另一方面，使用普通磁盘的操作系统应该使用更加优雅的方式来处理异常，这样一个文件中一个块的丢失就不会影响文件系统其他部分的使用</p>
</li>
<li><p>xv6 要求文件系统固定在单一磁盘设备上，而且大小不能改变。随着大型数据库和多媒体文件对存储要求越来越高，操作系统正在开发消除每个文件系统一个磁盘瓶颈的方法。基本的方法是将许多磁盘组合成一个逻辑磁盘。硬件解决方案（如 RAID）仍然是最流行的，但目前的趋势是尽可能地在软件中实现这种逻辑。这些软件实现通常允许丰富的功能，如在运行时通过快速添加或删除磁盘来增长或缩小逻辑设备。当然，一个能够快速增长或收缩的存储层需要一个能够做到同样的文件系统：xv6 使用的固定大小的 inode 块阵列在这样的环境中不能很好地工作。将磁盘管理与文件系统分离可能是最简洁的设计，但由于两者之间复杂的接口，使得有些系统，如 Sun 公司的 ZFS，将两者直接结合起来</p>
</li>
<li><p>xv6 的文件系统缺乏现代文件系统的许多其他功能，例如，它缺乏对快照和增量备份的支持</p>
</li>
<li><p>现代 Unix 系统允许用与磁盘存储相同的系统调用来访问许多种类的资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口，如 &#x2F;proc。与 xv6 在 fileread 和 filewrite 中的 if 语句，这些系统通常给每个打开的文件一个函数指针表，每个代表一个操作，调用函数指针来调用该 inode 的实现调用。网络文件系统和用户级文件系统提供了将这些调用变成网络 RPC 的函数，并在返回前等待响应</p>
</li>
</ul>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li><p>为什么 <strong>balloc</strong> 需要 <strong>panic</strong>？xv6 能恢复吗？</p>
</li>
<li><p>为什么 <strong>ialloc</strong> 需要 <strong>panic</strong>？xv6 能恢复吗？</p>
</li>
<li><p>为什么 <strong>filealloc</strong> 用完文件后不 <strong>panic</strong>？为什么这种情况比较常见，而值得处理？</p>
</li>
<li><p>假设在执行 <strong>sys_link</strong> 时，另一个进程在 <strong>iunlock(ip)</strong> 和 <strong>dirlink</strong> 之间解除链接该 <strong>ip</strong> 对应的文件。链接会被正确创建吗？为什么？</p>
</li>
<li><p><strong>create</strong> 调用了四次函数（一个 <strong>ialloc</strong>，三次 <strong>dirlink</strong>），它需要这些函数成功返回。如果任何一个不成功，<strong>create</strong> 调用就会 <strong>panic</strong>。为什么这可以接受？为什么这四个调用不能有一个失败呢？</p>
</li>
<li><p><strong>sys_chdir</strong> 在 <strong>iput(cp-&gt;cwd)</strong> 之前调用 **iunlock(ip)**，这可能会尝试锁定 <strong>cp-&gt;cwd</strong>，但将 <strong>iunlock(ip)</strong> 推迟到 <strong>iput</strong> 之后不会造成死锁。为什么不会呢？</p>
</li>
<li><p>实现 <strong>lseek</strong> 系统调用。<strong>lseek</strong> 还需要你修改 <strong>filewrite</strong>，如果 <strong>lseek</strong> 设置超过 <strong>f-&gt;ip-&gt;size</strong>，则在文件中用零来填补空缺</p>
</li>
<li><p>给 <strong>open</strong> 增加 O_TRUNC 和 O_APPEND，使 &gt; 和 &gt;&gt; 操作符在 shell 中可以使用</p>
</li>
<li><p>修改文件系统使其支持符号链接</p>
</li>
<li><p>修改文件系统使其支持命名管道</p>
</li>
<li><p>修改文件系统和 VM 使其支持 memory-map 文件（内存映射文件）</p>
</li>
</ol>
<hr>
<ol>
<li><a name="ftn1"></a>扇区号表明该日志块，应该写入的位置。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/6-s081/" rel="tag"># 6.s081</a>
              <a href="/tags/xv6/" rel="tag"># xv6</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/07/07/6-S081-Lab7/" rel="prev" title="Lab network driver">
      <i class="fa fa-chevron-left"></i> Lab network driver
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/09/02/6-S081-Lab8/" rel="next" title="Lab Lock">
      Lab Lock <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Overview-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">Overview 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-cache-layer"><span class="nav-number">1.2.</span> <span class="nav-text">Buffer cache layer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Buffer-cache"><span class="nav-number">1.3.</span> <span class="nav-text">Code: Buffer cache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Logging-layer"><span class="nav-number">1.4.</span> <span class="nav-text">Logging layer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Log-design"><span class="nav-number">1.5.</span> <span class="nav-text">Log design</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-logging"><span class="nav-number">1.6.</span> <span class="nav-text">Code: logging</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Block-allocator"><span class="nav-number">1.7.</span> <span class="nav-text">Code: Block allocator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inode-layer"><span class="nav-number">1.8.</span> <span class="nav-text">Inode layer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Inodes"><span class="nav-number">1.9.</span> <span class="nav-text">Code: Inodes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Inode-content"><span class="nav-number">1.10.</span> <span class="nav-text">Code: Inode content</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-directory-layer"><span class="nav-number">1.11.</span> <span class="nav-text">Code: directory layer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Path-names"><span class="nav-number">1.12.</span> <span class="nav-text">Code: Path names</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File-descriptor-layer"><span class="nav-number">1.13.</span> <span class="nav-text">File descriptor layer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-System-calls"><span class="nav-number">1.14.</span> <span class="nav-text">Code: System calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world"><span class="nav-number">1.15.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercises"><span class="nav-number">1.16.</span> <span class="nav-text">Exercises</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiweiBoi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiweiBoi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
